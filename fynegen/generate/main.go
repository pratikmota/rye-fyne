package main

import (
	"errors"
	"fmt"
	"go/token"
	"log"
	"os"
	"strings"
)

var fset = token.NewFileSet()

func GenerateBinding(fn *Func, indent int) (string, error) {
	var cb CodeBuilder
	cb.Indent = indent

	params := fn.Params
	if fn.Recv != nil {
		params = append([]Ident{*fn.Recv}, params...)
	}

	if len(params) > 5 {
		return "", errors.New("can only handle at most 5 parameters")
	}

	cb.Linef(`"%v": {`, FuncRyeIdent(fn))
	cb.Indent++
	cb.Linef(`Argsn: %v,`, len(params))
	cb.Linef(`Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {`)
	cb.Indent++
	for i, param := range params {
		if param.IsGoBuiltin {
			switch param.GoName {
			case "string":
				cb.Linef(`arg%vStr, ok := arg%v.(env.String)`, i, i)
				cb.Linef(`if !ok {`)
				cb.Indent++
				cb.Linef(`return evaldo.MakeArgError(ps, %v, []env.Type{env.StringType}, "%v")`, i, fn.Name.RyeName)
				cb.Indent--
				cb.Linef(`}`)
			case "float32", "float64":
				cb.Linef(`arg%vDec, ok := arg%v.(env.Decimal)`, i, i)
				cb.Linef(`if !ok {`)
				cb.Indent++
				cb.Linef(`return evaldo.MakeArgError(ps, %v, []env.Type{env.DecimalType}, "%v")`, i, fn.Name.RyeName)
				cb.Indent--
				cb.Linef(`}`)
			case "bool", "int":
				cb.Linef(`arg%vInt, ok := arg%v.(env.Integer)`, i, i)
				cb.Linef(`if !ok {`)
				cb.Indent++
				cb.Linef(`return evaldo.MakeArgError(ps, %v, []env.Type{env.IntegerType}, "%v")`, i, fn.Name.RyeName)
				cb.Indent--
				cb.Linef(`}`)
			case "error":
				cb.Linef(`arg%vErr, ok := arg%v.(env.Error)`, i, i)
				cb.Linef(`if !ok {`)
				cb.Indent++
				cb.Linef(`return evaldo.MakeArgError(ps, %v, []env.Type{env.ErrorType}, "%v")`, i, fn.Name.RyeName)
				cb.Indent--
				cb.Linef(`}`)
			default:
				return "", errors.New("unhandled builtin: " + param.GoName)
			}
		} else {
			cb.Linef(`arg%vNat, ok := arg%v.(env.Native)`, i, i)
			cb.Linef(`if !ok {`)
			cb.Indent++
			cb.Linef(`return evaldo.MakeArgError(ps, %v, []env.Type{env.NativeType}, "%v")`, i, fn.Name.RyeName)
			cb.Indent--
			cb.Linef(`}`)
			cb.Linef(`arg%vVal, ok := arg%vNat.Value.(%v)`, i, i, param.GoName)
			cb.Linef(`if !ok {`)
			cb.Indent++
			cb.Linef(`return evaldo.MakeArgError(ps, %v, []env.Type{env.NativeType}, "%v")`, i, fn.Name.RyeName)
			cb.Indent--
			cb.Linef(`}`)
		}
	}

	var args strings.Builder
	{
		start := 0
		if fn.Recv != nil {
			start = 1
		}
		for i := start; i < len(params); i++ {
			param := params[i]
			if i != start {
				args.WriteString(`, `)
			}
			if param.IsGoBuiltin {
				switch param.GoName {
				case "string":
					args.WriteString(fmt.Sprintf(`arg%vStr.Value`, i))
				case "float32":
					args.WriteString(fmt.Sprintf(`float32(arg%vDec.Value)`, i))
				case "float64":
					args.WriteString(fmt.Sprintf(`arg%vDec.Value`, i))
				case "bool":
					args.WriteString(fmt.Sprintf(`arg%vInt.Value != 0`, i))
				case "int":
					args.WriteString(fmt.Sprintf(`int(arg%vInt.Value)`, i))
				case "error":
					args.WriteString(fmt.Sprintf(`errors.New(arg%vErr.Print(*ps.Idx))`, i))
				default:
					return "", errors.New("unhandled builtin: " + param.GoName)
				}
			} else {
				expand := ""
				if param.IsEllipsis {
					expand = "..."
				}
				args.WriteString(fmt.Sprintf(`arg%vVal%v`, i, expand))
			}
		}
	}

	assign := ""
	if len(fn.Results) > 0 {
		assign = `res := `
	}
	if len(fn.Results) > 1 {
		return "", errors.New("can only handle at most one return value")
	}
	recv := ""
	if fn.Recv != nil {
		recv = `arg0Val.`
	}
	cb.Linef(`%v%v%v(%v)`, assign, recv, fn.Name.GoName, args.String())
	if len(fn.Results) > 0 {
		cb.Linef(`return *env.NewNative(ps.Idx, res, "%v")`, fn.Results[0].RyeName)
	} else {
		if fn.Recv == nil {
			cb.Linef(`return nil`)
		} else {
			cb.Linef(`return arg0Nat`)
		}
	}
	cb.Indent--
	cb.Linef(`},`)
	cb.Indent--
	cb.Linef(`},`)

	return cb.String(), nil
}

func main() {
	outFile := "../current/fynegen/builtins_fyne.go"
	srcDir := "fyne-src"

	if err := PullGitRepo(srcDir, "https://github.com/fyne-io/fyne"); err != nil {
		panic(err)
	}

	pkgs, err := ParseDirFull(fset, srcDir)
	if err != nil {
		panic(err)
	}

	var cb CodeBuilder
	cb.Linef(`//go:build b_fynegen`)
	cb.Linef(``)
	cb.Linef(`// Code generated by generator/generate. DO NOT EDIT.`)
	cb.Linef(``)
	cb.Linef(`package fynegen`)
	cb.Linef(``)
	cb.Linef(`import (`)
	cb.Indent++
	cb.Linef(`"errors"`)
	cb.Linef(`"net/url"`)
	cb.Linef(``)
	cb.Linef(`"github.com/refaktor/rye/env"`)
	cb.Linef(`"github.com/refaktor/rye/evaldo"`)
	cb.Linef(``)
	cb.Linef(`"fyne.io/fyne/v2"`)
	cb.Linef(`"fyne.io/fyne/v2/app"`)
	cb.Linef(`"fyne.io/fyne/v2/canvas"`)
	cb.Linef(`"fyne.io/fyne/v2/container"`)
	cb.Linef(`"fyne.io/fyne/v2/data/binding"`)
	cb.Linef(`"fyne.io/fyne/v2/driver/desktop"`)
	cb.Linef(`"fyne.io/fyne/v2/driver/mobile"`)
	//cb.Linef(`"fyne.io/fyne/v2/layout"`)
	cb.Linef(`"fyne.io/fyne/v2/widget"`)
	cb.Indent--
	cb.Linef(`)`)
	cb.Linef(``)

	cb.Linef(`var Builtins_fynegen = map[string]*env.Builtin{`)
	cb.Indent++

	data := NewData()
	for pkgName, pkg := range pkgs {
		if pkgName != "app" && pkgName != "fyne" && pkgName != "widget" && pkgName != "container" {
			continue
		}
		for _, f := range pkg.Files {
			if err := data.AddFile(f); err != nil {
				fmt.Println(err)
			}
		}
	}
	if err := data.ResolveInheritances(); err != nil {
		fmt.Println(err)
	}

	{
		iface := data.Interfaces["fyne.Widget"]
		fmt.Println("Interface", iface.Name)
		for _, fn := range iface.Funcs {
			fmt.Println(fn.String())
		}
	}

	boundFuncs := make(map[string]struct{})
	for _, iface := range data.Interfaces {
		for _, fn := range iface.Funcs {
			name := FuncGoIdent(fn)
			if _, exists := boundFuncs[name]; exists {
				continue
			}

			code, err := GenerateBinding(fn, cb.Indent)
			if err != nil {
				fmt.Println(err)
				continue
			}
			cb.Write(code)

			boundFuncs[name] = struct{}{}
		}
	}
	for _, fn := range data.Funcs {
		name := FuncGoIdent(fn)
		if _, exists := boundFuncs[name]; exists {
			continue
		}

		code, err := GenerateBinding(fn, cb.Indent)
		if err != nil {
			fmt.Println(err)
			continue
		}
		cb.Write(code)

		boundFuncs[name] = struct{}{}
	}

	cb.Indent--
	cb.Linef(`}`)

	if err := os.WriteFile(outFile, []byte(cb.String()), 0666); err != nil {
		panic(err)
	}
	log.Println("Wrote bindings to", outFile)
}
