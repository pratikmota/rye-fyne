package main

import (
	"errors"
	"fmt"
	"go/token"
	"log"
	"os"
	"strings"
)

var fset = token.NewFileSet()

func GenerateBinding(fn *Func, indent int) (string, error) {
	var cb CodeBuilder
	cb.Indent = indent

	params := fn.Params
	if fn.Recv != nil {
		params = append([]Ident{*fn.Recv}, params...)
	}

	if len(params) > 5 {
		return "", errors.New("can only handle at most 5 parameters")
	}

	cb.Linef(`"%v": {`, FuncRyeIdent(fn))
	cb.Indent++
	cb.Linef(`Argsn: %v,`, len(params))
	cb.Linef(`Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {`)
	cb.Indent++
	for i, param := range params {
		cb.Linef(`var arg%vVal %v`, i, param.GoName)
		if _, found := ConvRyeToGo(
			&cb,
			param,
			fmt.Sprintf(`arg%v`, i),
			fmt.Sprintf(`arg%vVal`, i),
			func(allowedTypes ...string) string {
				allowedTypesPfx := make([]string, len(allowedTypes))
				for i := range allowedTypes {
					allowedTypesPfx[i] = "env." + allowedTypes[i]
				}
				return fmt.Sprintf(
					`evaldo.MakeArgError(ps, %v, []env.Type{%v}, "%v")`,
					i,
					strings.Join(allowedTypesPfx, ", "),
					FuncRyeIdent(fn),
				)
			},
		); !found {
			return "", errors.New("unhandled type conversion (rye to go): " + param.GoName)
		}
	}

	var args strings.Builder
	{
		start := 0
		if fn.Recv != nil {
			start = 1
		}
		for i := start; i < len(params); i++ {
			param := params[i]
			if i != start {
				args.WriteString(`, `)
			}
			expand := ""
			if param.IsEllipsis {
				expand = "..."
			}
			args.WriteString(fmt.Sprintf(`arg%vVal%v`, i, expand))
		}
	}

	assign := ""
	if len(fn.Results) > 0 {
		assign = `res := `
	}
	if len(fn.Results) > 1 {
		return "", errors.New("can only handle at most one return value")
	}
	recv := ""
	if fn.Recv != nil {
		recv = `arg0Val.`
	}
	cb.Linef(`%v%v%v(%v)`, assign, recv, fn.Name.GoName, args.String())
	if len(fn.Results) > 0 {
		cb.Linef(`var resObj env.Object`)
		if _, found := ConvGoToRye(
			&cb,
			fn.Results[0],
			`res`,
			`resObj`,
			nil,
		); !found {
			return "", errors.New("unhandled type conversion (go to rye): " + fn.Results[0].GoName)
		}
		cb.Linef(`return resObj`)
	} else {
		if fn.Recv == nil {
			cb.Linef(`return nil`)
		} else {
			cb.Linef(`return arg0`)
		}
	}
	cb.Indent--
	cb.Linef(`},`)
	cb.Indent--
	cb.Linef(`},`)

	return cb.String(), nil
}

func main() {
	outFile := "../current/fynegen/builtins_fyne.go"
	srcDir := "fyne-src"

	if err := PullGitRepo(srcDir, "https://github.com/fyne-io/fyne"); err != nil {
		panic(err)
	}

	pkgs, err := ParseDirFull(fset, srcDir)
	if err != nil {
		panic(err)
	}

	var cb CodeBuilder
	cb.Linef(`//go:build b_fynegen`)
	cb.Linef(``)
	cb.Linef(`// Code generated by generator/generate. DO NOT EDIT.`)
	cb.Linef(``)
	cb.Linef(`package fynegen`)
	cb.Linef(``)
	cb.Linef(`import (`)
	cb.Indent++
	//cb.Linef(`"errors"`)
	cb.Linef(`"net/url"`)
	cb.Linef(``)
	cb.Linef(`"github.com/refaktor/rye/env"`)
	cb.Linef(`"github.com/refaktor/rye/evaldo"`)
	cb.Linef(``)
	cb.Linef(`"fyne.io/fyne/v2"`)
	cb.Linef(`"fyne.io/fyne/v2/app"`)
	cb.Linef(`"fyne.io/fyne/v2/canvas"`)
	cb.Linef(`"fyne.io/fyne/v2/container"`)
	cb.Linef(`"fyne.io/fyne/v2/data/binding"`)
	cb.Linef(`"fyne.io/fyne/v2/driver/desktop"`)
	cb.Linef(`"fyne.io/fyne/v2/driver/mobile"`)
	//cb.Linef(`"fyne.io/fyne/v2/layout"`)
	cb.Linef(`"fyne.io/fyne/v2/theme"`)
	cb.Linef(`"fyne.io/fyne/v2/widget"`)
	cb.Indent--
	cb.Linef(`)`)
	cb.Linef(``)

	cb.Linef(`func boolToInt64(x bool) int64 {`)
	cb.Indent++
	cb.Linef(`var res int64`)
	cb.Linef(`if x {`)
	cb.Indent++
	cb.Linef(`res = 1`)
	cb.Indent--
	cb.Linef(`}`)
	cb.Linef(`return res`)
	cb.Indent--
	cb.Linef(`}`)
	cb.Linef(``)

	cb.Linef(`var Builtins_fynegen = map[string]*env.Builtin{`)
	cb.Indent++

	data := NewData()
	for pkgName, pkg := range pkgs {
		if pkgName != "app" && pkgName != "fyne" && pkgName != "widget" && pkgName != "container" && pkgName != "theme" {
			continue
		}
		for _, f := range pkg.Files {
			if err := data.AddFile(f); err != nil {
				fmt.Println(err)
			}
		}
	}
	if err := data.ResolveInheritances(); err != nil {
		fmt.Println(err)
	}

	{
		iface := data.Interfaces["fyne.Widget"]
		fmt.Println("Interface", iface.Name)
		for _, fn := range iface.Funcs {
			fmt.Println(fn.String())
		}
	}

	boundFuncs := make(map[string]struct{})
	for _, iface := range data.Interfaces {
		for _, fn := range iface.Funcs {
			name := FuncGoIdent(fn)
			if _, exists := boundFuncs[name]; exists {
				continue
			}

			code, err := GenerateBinding(fn, cb.Indent)
			if err != nil {
				fmt.Println(err)
				continue
			}
			cb.Write(code)

			boundFuncs[name] = struct{}{}
		}
	}
	for _, fn := range data.Funcs {
		name := FuncGoIdent(fn)
		if _, exists := boundFuncs[name]; exists {
			continue
		}

		code, err := GenerateBinding(fn, cb.Indent)
		if err != nil {
			fmt.Println(err)
			continue
		}
		cb.Write(code)

		boundFuncs[name] = struct{}{}
	}

	cb.Indent--
	cb.Linef(`}`)

	if err := os.WriteFile(outFile, []byte(cb.String()), 0666); err != nil {
		panic(err)
	}
	log.Println("Wrote bindings to", outFile)
}
