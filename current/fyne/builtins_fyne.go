//go:build b_fyne

// Code generated by generator/generate. DO NOT EDIT.

package fyne

import (
	"errors"
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/data/binding"
	"fyne.io/fyne/v2/data/validation"
	"fyne.io/fyne/v2/dialog"
	driver_1 "fyne.io/fyne/v2/driver"
	"fyne.io/fyne/v2/driver/desktop"
	"fyne.io/fyne/v2/driver/mobile"
	"fyne.io/fyne/v2/driver/software"
	"fyne.io/fyne/v2/layout"
	"fyne.io/fyne/v2/storage"
	"fyne.io/fyne/v2/storage/repository"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/tools/playground"
	"fyne.io/fyne/v2/widget"
	"github.com/refaktor/rye/env"
	"github.com/refaktor/rye/evaldo"
	"image"
	"image/color"
	"io"
	"net/url"
	"reflect"
	"time"
)

// Force-use evaldo and env packages since tracking them would be too complicated
var _ = evaldo.BuiltinNames
var _ = env.Object(nil)

func boolToInt64(x bool) int64 {
	var res int64
	if x {
		res = 1
	}
	return res
}

var ryeStructNameLookup = map[string]string{
	"fyne.io/fyne/v2.*Animation":                     "ptr-fyne-animation",
	"fyne.io/fyne/v2.*AppMetadata":                   "ptr-fyne-app-metadata",
	"fyne.io/fyne/v2.*Container":                     "ptr-fyne-container",
	"fyne.io/fyne/v2.*Delta":                         "ptr-fyne-delta",
	"fyne.io/fyne/v2.*DragEvent":                     "ptr-fyne-drag-event",
	"fyne.io/fyne/v2.*HardwareKey":                   "ptr-fyne-hardware-key",
	"fyne.io/fyne/v2.*KeyEvent":                      "ptr-fyne-key-event",
	"fyne.io/fyne/v2.*MainMenu":                      "ptr-fyne-main-menu",
	"fyne.io/fyne/v2.*Menu":                          "ptr-fyne-menu",
	"fyne.io/fyne/v2.*MenuItem":                      "ptr-fyne-menu-item",
	"fyne.io/fyne/v2.*Notification":                  "ptr-fyne-notification",
	"fyne.io/fyne/v2.*PointEvent":                    "ptr-fyne-point-event",
	"fyne.io/fyne/v2.*Position":                      "ptr-fyne-position",
	"fyne.io/fyne/v2.*ScrollEvent":                   "ptr-fyne-scroll-event",
	"fyne.io/fyne/v2.*ShortcutCopy":                  "ptr-fyne-shortcut-copy",
	"fyne.io/fyne/v2.*ShortcutCut":                   "ptr-fyne-shortcut-cut",
	"fyne.io/fyne/v2.*ShortcutHandler":               "ptr-fyne-shortcut-handler",
	"fyne.io/fyne/v2.*ShortcutPaste":                 "ptr-fyne-shortcut-paste",
	"fyne.io/fyne/v2.*ShortcutSelectAll":             "ptr-fyne-shortcut-select-all",
	"fyne.io/fyne/v2.*Size":                          "ptr-fyne-size",
	"fyne.io/fyne/v2.*StaticResource":                "ptr-fyne-static-resource",
	"fyne.io/fyne/v2.*TextStyle":                     "ptr-fyne-text-style",
	"fyne.io/fyne/v2.Animation":                      "fyne-animation",
	"fyne.io/fyne/v2.AppMetadata":                    "fyne-app-metadata",
	"fyne.io/fyne/v2.Container":                      "fyne-container",
	"fyne.io/fyne/v2.Delta":                          "fyne-delta",
	"fyne.io/fyne/v2.DragEvent":                      "fyne-drag-event",
	"fyne.io/fyne/v2.HardwareKey":                    "fyne-hardware-key",
	"fyne.io/fyne/v2.KeyEvent":                       "fyne-key-event",
	"fyne.io/fyne/v2.MainMenu":                       "fyne-main-menu",
	"fyne.io/fyne/v2.Menu":                           "fyne-menu",
	"fyne.io/fyne/v2.MenuItem":                       "fyne-menu-item",
	"fyne.io/fyne/v2.Notification":                   "fyne-notification",
	"fyne.io/fyne/v2.PointEvent":                     "fyne-point-event",
	"fyne.io/fyne/v2.Position":                       "fyne-position",
	"fyne.io/fyne/v2.ScrollEvent":                    "fyne-scroll-event",
	"fyne.io/fyne/v2.ShortcutCopy":                   "fyne-shortcut-copy",
	"fyne.io/fyne/v2.ShortcutCut":                    "fyne-shortcut-cut",
	"fyne.io/fyne/v2.ShortcutHandler":                "fyne-shortcut-handler",
	"fyne.io/fyne/v2.ShortcutPaste":                  "fyne-shortcut-paste",
	"fyne.io/fyne/v2.ShortcutSelectAll":              "fyne-shortcut-select-all",
	"fyne.io/fyne/v2.Size":                           "fyne-size",
	"fyne.io/fyne/v2.StaticResource":                 "fyne-static-resource",
	"fyne.io/fyne/v2.TextStyle":                      "fyne-text-style",
	"fyne.io/fyne/v2/app.*SettingsSchema":            "ptr-app-settings-schema",
	"fyne.io/fyne/v2/app.SettingsSchema":             "app-settings-schema",
	"fyne.io/fyne/v2/canvas.*Circle":                 "ptr-canvas-circle",
	"fyne.io/fyne/v2/canvas.*Image":                  "ptr-canvas-image",
	"fyne.io/fyne/v2/canvas.*Line":                   "ptr-canvas-line",
	"fyne.io/fyne/v2/canvas.*LinearGradient":         "ptr-canvas-linear-gradient",
	"fyne.io/fyne/v2/canvas.*RadialGradient":         "ptr-canvas-radial-gradient",
	"fyne.io/fyne/v2/canvas.*Raster":                 "ptr-canvas-raster",
	"fyne.io/fyne/v2/canvas.*Rectangle":              "ptr-canvas-rectangle",
	"fyne.io/fyne/v2/canvas.*Text":                   "ptr-canvas-text",
	"fyne.io/fyne/v2/canvas.Circle":                  "canvas-circle",
	"fyne.io/fyne/v2/canvas.Image":                   "canvas-image",
	"fyne.io/fyne/v2/canvas.Line":                    "canvas-line",
	"fyne.io/fyne/v2/canvas.LinearGradient":          "canvas-linear-gradient",
	"fyne.io/fyne/v2/canvas.RadialGradient":          "canvas-radial-gradient",
	"fyne.io/fyne/v2/canvas.Raster":                  "canvas-raster",
	"fyne.io/fyne/v2/canvas.Rectangle":               "canvas-rectangle",
	"fyne.io/fyne/v2/canvas.Text":                    "canvas-text",
	"fyne.io/fyne/v2/container.*AppTabs":             "ptr-container-app-tabs",
	"fyne.io/fyne/v2/container.*DocTabs":             "ptr-container-doc-tabs",
	"fyne.io/fyne/v2/container.*Split":               "ptr-container-split",
	"fyne.io/fyne/v2/container.*TabItem":             "ptr-container-tab-item",
	"fyne.io/fyne/v2/container.AppTabs":              "container-app-tabs",
	"fyne.io/fyne/v2/container.DocTabs":              "container-doc-tabs",
	"fyne.io/fyne/v2/container.Split":                "container-split",
	"fyne.io/fyne/v2/container.TabItem":              "container-tab-item",
	"fyne.io/fyne/v2/dialog.*ColorPickerDialog":      "ptr-dialog-color-picker-dialog",
	"fyne.io/fyne/v2/dialog.*ConfirmDialog":          "ptr-dialog-confirm-dialog",
	"fyne.io/fyne/v2/dialog.*CustomDialog":           "ptr-dialog-custom-dialog",
	"fyne.io/fyne/v2/dialog.*EntryDialog":            "ptr-dialog-entry-dialog",
	"fyne.io/fyne/v2/dialog.*FileDialog":             "ptr-dialog-file-dialog",
	"fyne.io/fyne/v2/dialog.*FormDialog":             "ptr-dialog-form-dialog",
	"fyne.io/fyne/v2/dialog.*ProgressDialog":         "ptr-dialog-progress-dialog",
	"fyne.io/fyne/v2/dialog.*ProgressInfiniteDialog": "ptr-dialog-progress-infinite-dialog",
	"fyne.io/fyne/v2/dialog.ColorPickerDialog":       "dialog-color-picker-dialog",
	"fyne.io/fyne/v2/dialog.ConfirmDialog":           "dialog-confirm-dialog",
	"fyne.io/fyne/v2/dialog.CustomDialog":            "dialog-custom-dialog",
	"fyne.io/fyne/v2/dialog.EntryDialog":             "dialog-entry-dialog",
	"fyne.io/fyne/v2/dialog.FileDialog":              "dialog-file-dialog",
	"fyne.io/fyne/v2/dialog.FormDialog":              "dialog-form-dialog",
	"fyne.io/fyne/v2/dialog.ProgressDialog":          "dialog-progress-dialog",
	"fyne.io/fyne/v2/dialog.ProgressInfiniteDialog":  "dialog-progress-infinite-dialog",
	"fyne.io/fyne/v2/driver.*AndroidContext":         "ptr-driver-1-android-context",
	"fyne.io/fyne/v2/driver.*UnknownContext":         "ptr-driver-1-unknown-context",
	"fyne.io/fyne/v2/driver.AndroidContext":          "driver-1-android-context",
	"fyne.io/fyne/v2/driver.UnknownContext":          "driver-1-unknown-context",
	"fyne.io/fyne/v2/driver/desktop.*CustomShortcut": "ptr-desktop-custom-shortcut",
	"fyne.io/fyne/v2/driver/desktop.*MouseEvent":     "ptr-desktop-mouse-event",
	"fyne.io/fyne/v2/driver/desktop.CustomShortcut":  "desktop-custom-shortcut",
	"fyne.io/fyne/v2/driver/desktop.MouseEvent":      "desktop-mouse-event",
	"fyne.io/fyne/v2/driver/mobile.*TouchEvent":      "ptr-mobile-touch-event",
	"fyne.io/fyne/v2/driver/mobile.TouchEvent":       "mobile-touch-event",
	"fyne.io/fyne/v2/layout.*Spacer":                 "ptr-layout-spacer",
	"fyne.io/fyne/v2/layout.Spacer":                  "layout-spacer",
	"fyne.io/fyne/v2/storage.*ExtensionFileFilter":   "ptr-storage-extension-file-filter",
	"fyne.io/fyne/v2/storage.*MimeTypeFileFilter":    "ptr-storage-mime-type-file-filter",
	"fyne.io/fyne/v2/storage.ExtensionFileFilter":    "storage-extension-file-filter",
	"fyne.io/fyne/v2/storage.MimeTypeFileFilter":     "storage-mime-type-file-filter",
	"fyne.io/fyne/v2/theme.*DisabledResource":        "ptr-theme-disabled-resource",
	"fyne.io/fyne/v2/theme.*ErrorThemedResource":     "ptr-theme-error-themed-resource",
	"fyne.io/fyne/v2/theme.*InvertedThemedResource":  "ptr-theme-inverted-themed-resource",
	"fyne.io/fyne/v2/theme.*PrimaryThemedResource":   "ptr-theme-primary-themed-resource",
	"fyne.io/fyne/v2/theme.*ThemedResource":          "ptr-theme-themed-resource",
	"fyne.io/fyne/v2/theme.DisabledResource":         "theme-disabled-resource",
	"fyne.io/fyne/v2/theme.ErrorThemedResource":      "theme-error-themed-resource",
	"fyne.io/fyne/v2/theme.InvertedThemedResource":   "theme-inverted-themed-resource",
	"fyne.io/fyne/v2/theme.PrimaryThemedResource":    "theme-primary-themed-resource",
	"fyne.io/fyne/v2/theme.ThemedResource":           "theme-themed-resource",
	"fyne.io/fyne/v2/widget.*Accordion":              "ptr-widget-accordion",
	"fyne.io/fyne/v2/widget.*AccordionItem":          "ptr-widget-accordion-item",
	"fyne.io/fyne/v2/widget.*BaseWidget":             "ptr-widget-base-widget",
	"fyne.io/fyne/v2/widget.*Button":                 "ptr-widget-button",
	"fyne.io/fyne/v2/widget.*Card":                   "ptr-widget-card",
	"fyne.io/fyne/v2/widget.*Check":                  "ptr-widget-check",
	"fyne.io/fyne/v2/widget.*CheckGroup":             "ptr-widget-check-group",
	"fyne.io/fyne/v2/widget.*CustomTextGridStyle":    "ptr-widget-custom-text-grid-style",
	"fyne.io/fyne/v2/widget.*DisableableWidget":      "ptr-widget-disableable-widget",
	"fyne.io/fyne/v2/widget.*Entry":                  "ptr-widget-entry",
	"fyne.io/fyne/v2/widget.*FileIcon":               "ptr-widget-file-icon",
	"fyne.io/fyne/v2/widget.*Form":                   "ptr-widget-form",
	"fyne.io/fyne/v2/widget.*FormItem":               "ptr-widget-form-item",
	"fyne.io/fyne/v2/widget.*GridWrap":               "ptr-widget-grid-wrap",
	"fyne.io/fyne/v2/widget.*Hyperlink":              "ptr-widget-hyperlink",
	"fyne.io/fyne/v2/widget.*HyperlinkSegment":       "ptr-widget-hyperlink-segment",
	"fyne.io/fyne/v2/widget.*Icon":                   "ptr-widget-icon",
	"fyne.io/fyne/v2/widget.*ImageSegment":           "ptr-widget-image-segment",
	"fyne.io/fyne/v2/widget.*Label":                  "ptr-widget-label",
	"fyne.io/fyne/v2/widget.*List":                   "ptr-widget-list",
	"fyne.io/fyne/v2/widget.*ListSegment":            "ptr-widget-list-segment",
	"fyne.io/fyne/v2/widget.*Menu":                   "ptr-widget-menu",
	"fyne.io/fyne/v2/widget.*ParagraphSegment":       "ptr-widget-paragraph-segment",
	"fyne.io/fyne/v2/widget.*PopUp":                  "ptr-widget-pop-up",
	"fyne.io/fyne/v2/widget.*PopUpMenu":              "ptr-widget-pop-up-menu",
	"fyne.io/fyne/v2/widget.*ProgressBar":            "ptr-widget-progress-bar",
	"fyne.io/fyne/v2/widget.*ProgressBarInfinite":    "ptr-widget-progress-bar-infinite",
	"fyne.io/fyne/v2/widget.*RadioGroup":             "ptr-widget-radio-group",
	"fyne.io/fyne/v2/widget.*RichText":               "ptr-widget-rich-text",
	"fyne.io/fyne/v2/widget.*RichTextStyle":          "ptr-widget-rich-text-style",
	"fyne.io/fyne/v2/widget.*Select":                 "ptr-widget-select",
	"fyne.io/fyne/v2/widget.*SelectEntry":            "ptr-widget-select-entry",
	"fyne.io/fyne/v2/widget.*Separator":              "ptr-widget-separator",
	"fyne.io/fyne/v2/widget.*SeparatorSegment":       "ptr-widget-separator-segment",
	"fyne.io/fyne/v2/widget.*Slider":                 "ptr-widget-slider",
	"fyne.io/fyne/v2/widget.*Table":                  "ptr-widget-table",
	"fyne.io/fyne/v2/widget.*TableCellID":            "ptr-widget-table-cell-id",
	"fyne.io/fyne/v2/widget.*TextGrid":               "ptr-widget-text-grid",
	"fyne.io/fyne/v2/widget.*TextGridCell":           "ptr-widget-text-grid-cell",
	"fyne.io/fyne/v2/widget.*TextGridRow":            "ptr-widget-text-grid-row",
	"fyne.io/fyne/v2/widget.*TextSegment":            "ptr-widget-text-segment",
	"fyne.io/fyne/v2/widget.*Toolbar":                "ptr-widget-toolbar",
	"fyne.io/fyne/v2/widget.*ToolbarAction":          "ptr-widget-toolbar-action",
	"fyne.io/fyne/v2/widget.*ToolbarSeparator":       "ptr-widget-toolbar-separator",
	"fyne.io/fyne/v2/widget.*ToolbarSpacer":          "ptr-widget-toolbar-spacer",
	"fyne.io/fyne/v2/widget.*Tree":                   "ptr-widget-tree",
	"fyne.io/fyne/v2/widget.Accordion":               "widget-accordion",
	"fyne.io/fyne/v2/widget.AccordionItem":           "widget-accordion-item",
	"fyne.io/fyne/v2/widget.BaseWidget":              "widget-base-widget",
	"fyne.io/fyne/v2/widget.Button":                  "widget-button",
	"fyne.io/fyne/v2/widget.Card":                    "widget-card",
	"fyne.io/fyne/v2/widget.Check":                   "widget-check",
	"fyne.io/fyne/v2/widget.CheckGroup":              "widget-check-group",
	"fyne.io/fyne/v2/widget.CustomTextGridStyle":     "widget-custom-text-grid-style",
	"fyne.io/fyne/v2/widget.DisableableWidget":       "widget-disableable-widget",
	"fyne.io/fyne/v2/widget.Entry":                   "widget-entry",
	"fyne.io/fyne/v2/widget.FileIcon":                "widget-file-icon",
	"fyne.io/fyne/v2/widget.Form":                    "widget-form",
	"fyne.io/fyne/v2/widget.FormItem":                "widget-form-item",
	"fyne.io/fyne/v2/widget.GridWrap":                "widget-grid-wrap",
	"fyne.io/fyne/v2/widget.Hyperlink":               "widget-hyperlink",
	"fyne.io/fyne/v2/widget.HyperlinkSegment":        "widget-hyperlink-segment",
	"fyne.io/fyne/v2/widget.Icon":                    "widget-icon",
	"fyne.io/fyne/v2/widget.ImageSegment":            "widget-image-segment",
	"fyne.io/fyne/v2/widget.Label":                   "widget-label",
	"fyne.io/fyne/v2/widget.List":                    "widget-list",
	"fyne.io/fyne/v2/widget.ListSegment":             "widget-list-segment",
	"fyne.io/fyne/v2/widget.Menu":                    "widget-menu",
	"fyne.io/fyne/v2/widget.ParagraphSegment":        "widget-paragraph-segment",
	"fyne.io/fyne/v2/widget.PopUp":                   "widget-pop-up",
	"fyne.io/fyne/v2/widget.PopUpMenu":               "widget-pop-up-menu",
	"fyne.io/fyne/v2/widget.ProgressBar":             "widget-progress-bar",
	"fyne.io/fyne/v2/widget.ProgressBarInfinite":     "widget-progress-bar-infinite",
	"fyne.io/fyne/v2/widget.RadioGroup":              "widget-radio-group",
	"fyne.io/fyne/v2/widget.RichText":                "widget-rich-text",
	"fyne.io/fyne/v2/widget.RichTextStyle":           "widget-rich-text-style",
	"fyne.io/fyne/v2/widget.Select":                  "widget-select",
	"fyne.io/fyne/v2/widget.SelectEntry":             "widget-select-entry",
	"fyne.io/fyne/v2/widget.Separator":               "widget-separator",
	"fyne.io/fyne/v2/widget.SeparatorSegment":        "widget-separator-segment",
	"fyne.io/fyne/v2/widget.Slider":                  "widget-slider",
	"fyne.io/fyne/v2/widget.Table":                   "widget-table",
	"fyne.io/fyne/v2/widget.TableCellID":             "widget-table-cell-id",
	"fyne.io/fyne/v2/widget.TextGrid":                "widget-text-grid",
	"fyne.io/fyne/v2/widget.TextGridCell":            "widget-text-grid-cell",
	"fyne.io/fyne/v2/widget.TextGridRow":             "widget-text-grid-row",
	"fyne.io/fyne/v2/widget.TextSegment":             "widget-text-segment",
	"fyne.io/fyne/v2/widget.Toolbar":                 "widget-toolbar",
	"fyne.io/fyne/v2/widget.ToolbarAction":           "widget-toolbar-action",
	"fyne.io/fyne/v2/widget.ToolbarSeparator":        "widget-toolbar-separator",
	"fyne.io/fyne/v2/widget.ToolbarSpacer":           "widget-toolbar-spacer",
	"fyne.io/fyne/v2/widget.Tree":                    "widget-tree",
}

var Builtins_fyne = map[string]*env.Builtin{
	"nil": {
		Doc: "nil value for go types",
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			return *env.NewInteger(0)
		},
	},
	"app": {
		Doc:   "app.New",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := app.New()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-app")
				}
			}
			return res0Obj
		},
	},
	"app-with-id": {
		Doc:   "app.NewWithID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("app-with-id: arg 1: expected string")
			}
			res0 := app.NewWithID(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-app")
				}
			}
			return res0Obj
		},
	},
	"app-set-metadata": {
		Doc:   "app.SetMetadata",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-set-metadata: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-set-metadata: arg 1: expected native")
			}
			app.SetMetadata(arg0Val)
			return nil
		},
	},
	"app-settings-schema//cloud-config!": {
		Doc:   "Set app.SettingsSchema CloudConfig value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//cloud-config!: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//cloud-config!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudConfig = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//cloud-config!: arg 2: expected string")
			}
			return arg0
		},
	},
	"app-settings-schema//cloud-config?": {
		Doc:   "Get app.SettingsSchema CloudConfig value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//cloud-config?: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//cloud-config?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudConfig)
			return resObj
		},
	},
	"app-settings-schema//cloud-name!": {
		Doc:   "Set app.SettingsSchema CloudName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//cloud-name!: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//cloud-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//cloud-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"app-settings-schema//cloud-name?": {
		Doc:   "Get app.SettingsSchema CloudName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//cloud-name?: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//cloud-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudName)
			return resObj
		},
	},
	"app-settings-schema//disable-animations!": {
		Doc:   "Set app.SettingsSchema DisableAnimations value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//disable-animations!: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//disable-animations!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.DisableAnimations = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//disable-animations!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"app-settings-schema//disable-animations?": {
		Doc:   "Get app.SettingsSchema DisableAnimations value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//disable-animations?: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//disable-animations?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.DisableAnimations))
			return resObj
		},
	},
	"app-settings-schema//primary-color!": {
		Doc:   "Set app.SettingsSchema PrimaryColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//primary-color!: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//primary-color!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.PrimaryColor = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//primary-color!: arg 2: expected string")
			}
			return arg0
		},
	},
	"app-settings-schema//primary-color?": {
		Doc:   "Get app.SettingsSchema PrimaryColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//primary-color?: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//primary-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PrimaryColor)
			return resObj
		},
	},
	"app-settings-schema//scale!": {
		Doc:   "Set app.SettingsSchema Scale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//scale!: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//scale!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Scale = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//scale!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"app-settings-schema//scale?": {
		Doc:   "Get app.SettingsSchema Scale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//scale?: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Scale))
			return resObj
		},
	},
	"app-settings-schema//theme-name!": {
		Doc:   "Set app.SettingsSchema ThemeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//theme-name!: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//theme-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.ThemeName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//theme-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"app-settings-schema//theme-name?": {
		Doc:   "Get app.SettingsSchema ThemeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-settings-schema//theme-name?: arg 1: expected native of type app.SettingsSchema")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-settings-schema//theme-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ThemeName)
			return resObj
		},
	},
	"binding-and": {
		Doc:   "binding.And",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []binding.Bool
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]binding.Bool, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(binding.Bool)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-and: arg 1: block item: expected native of type binding.Bool")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-and: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-and: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]binding.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-and: arg 1: expected native of type []binding.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-and: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-and: arg 1: expected block, native or nil")
			}
			res0 := binding.And(arg0Val...)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-bool": {
		Doc:   "binding.BindBool",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bool: arg 1: expected native of type *bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bool: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-bool: arg 1: expected native")
			}
			res0 := binding.BindBool(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bool")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-bool-list": {
		Doc:   "binding.BindBoolList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bool-list: arg 1: expected native of type *[]bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bool-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-bool-list: arg 1: expected native")
			}
			res0 := binding.BindBoolList(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bool-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-bool-tree": {
		Doc:   "binding.BindBoolTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bool-tree: arg 1: expected native of type *map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bool-tree: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-bool-tree: arg 1: expected native")
			}
			var arg1Val *map[string]bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bool-tree: arg 2: expected native of type *map[string]bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bool-tree: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-bool-tree: arg 2: expected native")
			}
			res0 := binding.BindBoolTree(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bool-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-bytes": {
		Doc:   "binding.BindBytes",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]byte
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bytes: arg 1: expected native of type *[]byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bytes: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-bytes: arg 1: expected native")
			}
			res0 := binding.BindBytes(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bytes")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-bytes-list": {
		Doc:   "binding.BindBytesList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[][]byte
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[][]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bytes-list: arg 1: expected native of type *[][]byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bytes-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-bytes-list: arg 1: expected native")
			}
			res0 := binding.BindBytesList(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bytes-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-bytes-tree": {
		Doc:   "binding.BindBytesTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bytes-tree: arg 1: expected native of type *map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bytes-tree: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-bytes-tree: arg 1: expected native")
			}
			var arg1Val *map[string][]byte
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string][]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bytes-tree: arg 2: expected native of type *map[string][]byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-bytes-tree: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-bytes-tree: arg 2: expected native")
			}
			res0 := binding.BindBytesTree(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bytes-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-float": {
		Doc:   "binding.BindFloat",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *float64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*float64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-float: arg 1: expected native of type *float64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-float: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-float: arg 1: expected native")
			}
			res0 := binding.BindFloat(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-float")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-float-list": {
		Doc:   "binding.BindFloatList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]float64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]float64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-float-list: arg 1: expected native of type *[]float64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-float-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-float-list: arg 1: expected native")
			}
			res0 := binding.BindFloatList(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-float-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-float-tree": {
		Doc:   "binding.BindFloatTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-float-tree: arg 1: expected native of type *map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-float-tree: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-float-tree: arg 1: expected native")
			}
			var arg1Val *map[string]float64
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]float64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-float-tree: arg 2: expected native of type *map[string]float64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-float-tree: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-float-tree: arg 2: expected native")
			}
			res0 := binding.BindFloatTree(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-float-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-int": {
		Doc:   "binding.BindInt",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-int: arg 1: expected native of type *int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-int: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-int: arg 1: expected native")
			}
			res0 := binding.BindInt(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-int")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-int-list": {
		Doc:   "binding.BindIntList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-int-list: arg 1: expected native of type *[]int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-int-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-int-list: arg 1: expected native")
			}
			res0 := binding.BindIntList(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-int-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-int-tree": {
		Doc:   "binding.BindIntTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-int-tree: arg 1: expected native of type *map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-int-tree: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-int-tree: arg 1: expected native")
			}
			var arg1Val *map[string]int
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-int-tree: arg 2: expected native of type *map[string]int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-int-tree: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-int-tree: arg 2: expected native")
			}
			res0 := binding.BindIntTree(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-int-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-preference-bool": {
		Doc:   "binding.BindPreferenceBool",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bind-preference-bool: arg 1: expected string")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-preference-bool: arg 2: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-preference-bool: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-preference-bool: arg 2: expected native")
			}
			res0 := binding.BindPreferenceBool(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-preference-float": {
		Doc:   "binding.BindPreferenceFloat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bind-preference-float: arg 1: expected string")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-preference-float: arg 2: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-preference-float: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-preference-float: arg 2: expected native")
			}
			res0 := binding.BindPreferenceFloat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-float")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-preference-int": {
		Doc:   "binding.BindPreferenceInt",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bind-preference-int: arg 1: expected string")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-preference-int: arg 2: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-preference-int: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-preference-int: arg 2: expected native")
			}
			res0 := binding.BindPreferenceInt(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-int")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-preference-string": {
		Doc:   "binding.BindPreferenceString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bind-preference-string: arg 1: expected string")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-preference-string: arg 2: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-preference-string: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-preference-string: arg 2: expected native")
			}
			res0 := binding.BindPreferenceString(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-rune": {
		Doc:   "binding.BindRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-rune: arg 1: expected native of type *rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-rune: arg 1: expected native")
			}
			res0 := binding.BindRune(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-rune")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-rune-list": {
		Doc:   "binding.BindRuneList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-rune-list: arg 1: expected native of type *[]rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-rune-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-rune-list: arg 1: expected native")
			}
			res0 := binding.BindRuneList(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-rune-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-rune-tree": {
		Doc:   "binding.BindRuneTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-rune-tree: arg 1: expected native of type *map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-rune-tree: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-rune-tree: arg 1: expected native")
			}
			var arg1Val *map[string]rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-rune-tree: arg 2: expected native of type *map[string]rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-rune-tree: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-rune-tree: arg 2: expected native")
			}
			res0 := binding.BindRuneTree(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-rune-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-string": {
		Doc:   "binding.BindString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-string: arg 1: expected native of type *string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-string: arg 1: expected native")
			}
			res0 := binding.BindString(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-string")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-string-list": {
		Doc:   "binding.BindStringList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-string-list: arg 1: expected native of type *[]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-string-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-string-list: arg 1: expected native")
			}
			res0 := binding.BindStringList(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-string-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-string-tree": {
		Doc:   "binding.BindStringTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-string-tree: arg 1: expected native of type *map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-string-tree: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-string-tree: arg 1: expected native")
			}
			var arg1Val *map[string]string
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-string-tree: arg 2: expected native of type *map[string]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-string-tree: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-string-tree: arg 2: expected native")
			}
			res0 := binding.BindStringTree(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-string-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-struct": {
		Doc:   "binding.BindStruct",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val any
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-struct: arg 1: expected native of type any")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-struct: arg 1: expected native")
			}
			res0 := binding.BindStruct(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-struct")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-untyped": {
		Doc:   "binding.BindUntyped",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val any
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-untyped: arg 1: expected native of type any")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-untyped: arg 1: expected native")
			}
			res0 := binding.BindUntyped(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-untyped")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-untyped-list": {
		Doc:   "binding.BindUntypedList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]any
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-untyped-list: arg 1: expected native of type *[]any")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-untyped-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-untyped-list: arg 1: expected native")
			}
			res0 := binding.BindUntypedList(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-untyped-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-untyped-map": {
		Doc:   "binding.BindUntypedMap",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string]any
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string]any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-untyped-map: arg 1: expected native of type *map[string]any")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-untyped-map: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-untyped-map: arg 1: expected native")
			}
			res0 := binding.BindUntypedMap(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-untyped-map")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-uri": {
		Doc:   "binding.BindURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-uri: arg 1: expected native of type *fyne.URI")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-uri: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-uri: arg 1: expected native")
			}
			res0 := binding.BindURI(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-uri")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-uri-list": {
		Doc:   "binding.BindURIList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-uri-list: arg 1: expected native of type *[]fyne.URI")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-uri-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-uri-list: arg 1: expected native")
			}
			res0 := binding.BindURIList(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-uri-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bind-uri-tree": {
		Doc:   "binding.BindURITree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-uri-tree: arg 1: expected native of type *map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-uri-tree: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-uri-tree: arg 1: expected native")
			}
			var arg1Val *map[string]fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bind-uri-tree: arg 2: expected native of type *map[string]fyne.URI")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bind-uri-tree: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bind-uri-tree: arg 2: expected native")
			}
			res0 := binding.BindURITree(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-uri-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-bool-list//append": {
		Doc:   "binding.BoolList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//append: arg 1: expected native of type binding.BoolList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//append: arg 1: expected native")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//append: arg 2: expected integer")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-list//get": {
		Doc:   "binding.BoolList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//get: arg 1: expected native of type binding.BoolList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(boolToInt64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bool-list//get-value": {
		Doc:   "binding.BoolList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//get-value: arg 1: expected native of type binding.BoolList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//get-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//get-value: arg 2: expected integer")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bool-list//prepend": {
		Doc:   "binding.BoolList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//prepend: arg 1: expected native of type binding.BoolList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//prepend: arg 1: expected native")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//prepend: arg 2: expected integer")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-list//set": {
		Doc:   "binding.BoolList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//set: arg 1: expected native of type binding.BoolList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//set: arg 1: expected native")
			}
			var arg1Val []bool
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]bool, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg1Val[i] = v.Value != 0
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-bool-list//set: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//set: arg 2: expected native of type []bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//set: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-list//set-value": {
		Doc:   "binding.BoolList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//set-value: arg 1: expected native of type binding.BoolList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-list//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//set-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//set-value: arg 2: expected integer")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-list//set-value: arg 3: expected integer")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-to-string": {
		Doc:   "binding.BoolToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-to-string: arg 1: expected native of type binding.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-to-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-to-string: arg 1: expected native")
			}
			res0 := binding.BoolToString(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-bool-to-string-with-format": {
		Doc:   "binding.BoolToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-to-string-with-format: arg 1: expected native of type binding.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-to-string-with-format: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-to-string-with-format: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-to-string-with-format: arg 2: expected string")
			}
			res0 := binding.BoolToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-bool-tree//append": {
		Doc:   "binding.BoolTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//append: arg 1: expected native of type binding.BoolTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//append: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//append: arg 3: expected string")
			}
			var arg3Val bool
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//append: arg 4: expected integer")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-tree//get": {
		Doc:   "binding.BoolTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//get: arg 1: expected native of type binding.BoolTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//get: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewInteger(boolToInt64(mVal))
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"binding-bool-tree//get-value": {
		Doc:   "binding.BoolTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//get-value: arg 1: expected native of type binding.BoolTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//get-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//get-value: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bool-tree//prepend": {
		Doc:   "binding.BoolTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//prepend: arg 1: expected native of type binding.BoolTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//prepend: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//prepend: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//prepend: arg 3: expected string")
			}
			var arg3Val bool
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//prepend: arg 4: expected integer")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-tree//set": {
		Doc:   "binding.BoolTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set: arg 1: expected native of type binding.BoolTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//set: arg 1: expected native")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set: arg 2: expected block to have length of multiple of 2")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-bool-tree//set: arg 2: map key: expected string")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-bool-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bool-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-bool-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bool-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-bool-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bool-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-bool-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bool-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set: arg 2: expected native of type map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//set: arg 2: expected native, block, dict or nil")
			}
			var arg2Val map[string]bool
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set: arg 3: expected block to have length of multiple of 2")
				}
				arg2Val = make(map[string]bool, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-bool-tree//set: arg 3: map key: expected string")
					}
					var mapV bool
					if v, ok := v.Series.S[i+1].(env.Integer); ok {
						mapV = v.Value != 0
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-bool-tree//set: arg 3: map value: expected integer")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]bool, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV bool
					if v, ok := dictV.(env.Integer); ok {
						mapV = v.Value != 0
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-bool-tree//set: arg 3: map value: expected integer")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set: arg 3: expected native of type map[string]bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//set: arg 3: expected native, block, dict or nil")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-tree//set-value": {
		Doc:   "binding.BoolTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set-value: arg 1: expected native of type binding.BoolTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool-tree//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//set-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//set-value: arg 2: expected string")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool-tree//set-value: arg 3: expected integer")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool//get": {
		Doc:   "binding.Bool.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool//get: arg 1: expected native of type binding.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bool//set": {
		Doc:   "binding.Bool.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bool//set: arg 1: expected native of type binding.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bool//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bool//set: arg 1: expected native")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bool//set: arg 2: expected integer")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-list//append": {
		Doc:   "binding.BytesList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//append: arg 1: expected native of type binding.BytesList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//append: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-list//append: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-list//append: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//append: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//append: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//append: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-list//get": {
		Doc:   "binding.BytesList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//get: arg 1: expected native of type binding.BytesList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bytes-list//get-value": {
		Doc:   "binding.BytesList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//get-value: arg 1: expected native of type binding.BytesList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//get-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//get-value: arg 2: expected integer")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bytes-list//prepend": {
		Doc:   "binding.BytesList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//prepend: arg 1: expected native of type binding.BytesList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//prepend: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-list//prepend: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-list//prepend: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//prepend: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//prepend: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//prepend: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-list//set": {
		Doc:   "binding.BytesList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//set: arg 1: expected native of type binding.BytesList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//set: arg 1: expected native")
			}
			var arg1Val [][]byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([][]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Block:
						arg1Val[i] = make([]byte, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								arg1Val[i][i], ok = v.Value.(byte)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("binding-bytes-list//set: arg 2: block item: block item: expected native of type byte")
								}
							default:
								ps.FailureFlag = true
								return env.NewError("binding-bytes-list//set: arg 2: block item: block item: expected native")
							}
						}
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.([]byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-list//set: arg 2: block item: expected native of type []byte")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-list//set: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-list//set: arg 2: block item: expected block, native or nil")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([][]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//set: arg 2: expected native of type [][]byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//set: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-list//set-value": {
		Doc:   "binding.BytesList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//set-value: arg 1: expected native of type binding.BytesList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//set-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//set-value: arg 2: expected integer")
			}
			var arg2Val []byte
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg2Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-list//set-value: arg 3: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-list//set-value: arg 3: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//set-value: arg 3: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-list//set-value: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-list//set-value: arg 3: expected block, native or nil")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-tree//append": {
		Doc:   "binding.BytesTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//append: arg 1: expected native of type binding.BytesTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//append: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//append: arg 3: expected string")
			}
			var arg3Val []byte
			switch v := arg3.(type) {
			case env.Block:
				arg3Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg3Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//append: arg 4: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-tree//append: arg 4: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//append: arg 4: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//append: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//append: arg 4: expected block, native or nil")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-tree//get": {
		Doc:   "binding.BytesTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//get: arg 1: expected native of type binding.BytesTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//get: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"binding-bytes-tree//get-value": {
		Doc:   "binding.BytesTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//get-value: arg 1: expected native of type binding.BytesTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//get-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//get-value: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bytes-tree//prepend": {
		Doc:   "binding.BytesTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//prepend: arg 1: expected native of type binding.BytesTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//prepend: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//prepend: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//prepend: arg 3: expected string")
			}
			var arg3Val []byte
			switch v := arg3.(type) {
			case env.Block:
				arg3Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg3Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//prepend: arg 4: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-tree//prepend: arg 4: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//prepend: arg 4: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//prepend: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//prepend: arg 4: expected block, native or nil")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-tree//set": {
		Doc:   "binding.BytesTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set: arg 1: expected native of type binding.BytesTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//set: arg 1: expected native")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set: arg 2: expected block to have length of multiple of 2")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-bytes-tree//set: arg 2: map key: expected string")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-bytes-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-bytes-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set: arg 2: expected native of type map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//set: arg 2: expected native, block, dict or nil")
			}
			var arg2Val map[string][]byte
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set: arg 3: expected block to have length of multiple of 2")
				}
				arg2Val = make(map[string][]byte, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-bytes-tree//set: arg 3: map key: expected string")
					}
					var mapV []byte
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]byte, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								mapV[i], ok = v.Value.(byte)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("binding-bytes-tree//set: arg 3: map value: block item: expected native of type byte")
								}
							default:
								ps.FailureFlag = true
								return env.NewError("binding-bytes-tree//set: arg 3: map value: block item: expected native")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//set: arg 3: map value: expected native of type []byte")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//set: arg 3: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-tree//set: arg 3: map value: expected block, native or nil")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string][]byte, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []byte
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]byte, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								mapV[i], ok = v.Value.(byte)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("binding-bytes-tree//set: arg 3: map value: block item: expected native of type byte")
								}
							default:
								ps.FailureFlag = true
								return env.NewError("binding-bytes-tree//set: arg 3: map value: block item: expected native")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//set: arg 3: map value: expected native of type []byte")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//set: arg 3: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-tree//set: arg 3: map value: expected block, native or nil")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string][]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set: arg 3: expected native of type map[string][]byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//set: arg 3: expected native, block, dict or nil")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-tree//set-value": {
		Doc:   "binding.BytesTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set-value: arg 1: expected native of type binding.BytesTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//set-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//set-value: arg 2: expected string")
			}
			var arg2Val []byte
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg2Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes-tree//set-value: arg 3: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes-tree//set-value: arg 3: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set-value: arg 3: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes-tree//set-value: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes-tree//set-value: arg 3: expected block, native or nil")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes//get": {
		Doc:   "binding.Bytes.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bytes
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bytes)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes//get: arg 1: expected native of type binding.Bytes")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bytes//set": {
		Doc:   "binding.Bytes.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bytes
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bytes)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes//set: arg 1: expected native of type binding.Bytes")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes//set: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-bytes//set: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-bytes//set: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-bytes//set: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-bytes//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-bytes//set: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-data-item//add-listener": {
		Doc:   "binding.DataItem.AddListener",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-item//add-listener: arg 1: expected native of type binding.DataItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-item//add-listener: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-item//add-listener: arg 1: expected native")
			}
			var arg1Val binding.DataListener
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.DataListener)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-item//add-listener: arg 2: expected native of type binding.DataListener")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-item//add-listener: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-item//add-listener: arg 2: expected native")
			}
			arg0Val.AddListener(arg1Val)
			return arg0
		},
	},
	"binding-data-item//remove-listener": {
		Doc:   "binding.DataItem.RemoveListener",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-item//remove-listener: arg 1: expected native of type binding.DataItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-item//remove-listener: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-item//remove-listener: arg 1: expected native")
			}
			var arg1Val binding.DataListener
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.DataListener)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-item//remove-listener: arg 2: expected native of type binding.DataListener")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-item//remove-listener: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-item//remove-listener: arg 2: expected native")
			}
			arg0Val.RemoveListener(arg1Val)
			return arg0
		},
	},
	"binding-data-list//get-item": {
		Doc:   "binding.DataList.GetItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-list//get-item: arg 1: expected native of type binding.DataList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-list//get-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-list//get-item: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-data-list//get-item: arg 2: expected integer")
			}
			res0, res1 := arg0Val.GetItem(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-data-item")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-data-list//length": {
		Doc:   "binding.DataList.Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-list//length: arg 1: expected native of type binding.DataList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-list//length: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-list//length: arg 1: expected native")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"binding-data-listener//data-changed": {
		Doc:   "binding.DataListener.DataChanged",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataListener
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataListener)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-listener//data-changed: arg 1: expected native of type binding.DataListener")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-listener//data-changed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-listener//data-changed: arg 1: expected native")
			}
			arg0Val.DataChanged()
			return arg0
		},
	},
	"binding-data-map//get-item": {
		Doc:   "binding.DataMap.GetItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataMap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-map//get-item: arg 1: expected native of type binding.DataMap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-map//get-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-map//get-item: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-data-map//get-item: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetItem(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-data-item")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-data-map//keys": {
		Doc:   "binding.DataMap.Keys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataMap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-map//keys: arg 1: expected native of type binding.DataMap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-map//keys: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-map//keys: arg 1: expected native")
			}
			res0 := arg0Val.Keys()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"binding-data-tree//child-i-ds": {
		Doc:   "binding.DataTree.ChildIDs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-tree//child-i-ds: arg 1: expected native of type binding.DataTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-tree//child-i-ds: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-tree//child-i-ds: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-data-tree//child-i-ds: arg 2: expected string")
			}
			res0 := arg0Val.ChildIDs(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"binding-data-tree//get-item": {
		Doc:   "binding.DataTree.GetItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-data-tree//get-item: arg 1: expected native of type binding.DataTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-tree//get-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-tree//get-item: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-data-tree//get-item: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetItem(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-data-item")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-external-bool-list//reload": {
		Doc:   "binding.ExternalBoolList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBoolList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-bool-list//reload: arg 1: expected native of type binding.ExternalBoolList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-bool-list//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-bool-list//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-bool-tree//reload": {
		Doc:   "binding.ExternalBoolTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBoolTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-bool-tree//reload: arg 1: expected native of type binding.ExternalBoolTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-bool-tree//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-bool-tree//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-bool//reload": {
		Doc:   "binding.ExternalBool.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-bool//reload: arg 1: expected native of type binding.ExternalBool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-bool//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-bool//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-bytes-list//reload": {
		Doc:   "binding.ExternalBytesList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBytesList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-bytes-list//reload: arg 1: expected native of type binding.ExternalBytesList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-bytes-list//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-bytes-list//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-bytes-tree//reload": {
		Doc:   "binding.ExternalBytesTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBytesTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-bytes-tree//reload: arg 1: expected native of type binding.ExternalBytesTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-bytes-tree//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-bytes-tree//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-bytes//reload": {
		Doc:   "binding.ExternalBytes.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBytes
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBytes)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-bytes//reload: arg 1: expected native of type binding.ExternalBytes")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-bytes//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-bytes//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-float-list//reload": {
		Doc:   "binding.ExternalFloatList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalFloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalFloatList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-float-list//reload: arg 1: expected native of type binding.ExternalFloatList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-float-list//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-float-list//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-float-tree//reload": {
		Doc:   "binding.ExternalFloatTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalFloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalFloatTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-float-tree//reload: arg 1: expected native of type binding.ExternalFloatTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-float-tree//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-float-tree//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-float//reload": {
		Doc:   "binding.ExternalFloat.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalFloat
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalFloat)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-float//reload: arg 1: expected native of type binding.ExternalFloat")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-float//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-float//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-int-list//reload": {
		Doc:   "binding.ExternalIntList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalIntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalIntList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-int-list//reload: arg 1: expected native of type binding.ExternalIntList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-int-list//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-int-list//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-int-tree//reload": {
		Doc:   "binding.ExternalIntTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalIntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalIntTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-int-tree//reload: arg 1: expected native of type binding.ExternalIntTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-int-tree//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-int-tree//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-int//reload": {
		Doc:   "binding.ExternalInt.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalInt
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalInt)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-int//reload: arg 1: expected native of type binding.ExternalInt")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-int//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-int//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-rune-list//reload": {
		Doc:   "binding.ExternalRuneList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalRuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalRuneList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-rune-list//reload: arg 1: expected native of type binding.ExternalRuneList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-rune-list//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-rune-list//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-rune-tree//reload": {
		Doc:   "binding.ExternalRuneTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalRuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalRuneTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-rune-tree//reload: arg 1: expected native of type binding.ExternalRuneTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-rune-tree//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-rune-tree//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-rune//reload": {
		Doc:   "binding.ExternalRune.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalRune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalRune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-rune//reload: arg 1: expected native of type binding.ExternalRune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-rune//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-rune//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-string-list//reload": {
		Doc:   "binding.ExternalStringList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalStringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalStringList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-string-list//reload: arg 1: expected native of type binding.ExternalStringList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-string-list//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-string-list//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-string-tree//reload": {
		Doc:   "binding.ExternalStringTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalStringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalStringTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-string-tree//reload: arg 1: expected native of type binding.ExternalStringTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-string-tree//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-string-tree//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-string//reload": {
		Doc:   "binding.ExternalString.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalString
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalString)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-string//reload: arg 1: expected native of type binding.ExternalString")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-string//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-string//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-untyped-list//reload": {
		Doc:   "binding.ExternalUntypedList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalUntypedList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalUntypedList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-untyped-list//reload: arg 1: expected native of type binding.ExternalUntypedList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-untyped-list//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-untyped-list//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-untyped-map//reload": {
		Doc:   "binding.ExternalUntypedMap.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalUntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalUntypedMap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-untyped-map//reload: arg 1: expected native of type binding.ExternalUntypedMap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-untyped-map//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-untyped-map//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-untyped//reload": {
		Doc:   "binding.ExternalUntyped.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalUntyped
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalUntyped)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-untyped//reload: arg 1: expected native of type binding.ExternalUntyped")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-untyped//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-untyped//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-uri-list//reload": {
		Doc:   "binding.ExternalURIList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalURIList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalURIList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-uri-list//reload: arg 1: expected native of type binding.ExternalURIList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-uri-list//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-uri-list//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-uri-tree//reload": {
		Doc:   "binding.ExternalURITree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalURITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalURITree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-uri-tree//reload: arg 1: expected native of type binding.ExternalURITree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-uri-tree//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-uri-tree//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-uri//reload": {
		Doc:   "binding.ExternalURI.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalURI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalURI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-external-uri//reload: arg 1: expected native of type binding.ExternalURI")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-external-uri//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-external-uri//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-list//append": {
		Doc:   "binding.FloatList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//append: arg 1: expected native of type binding.FloatList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-list//append: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-list//append: arg 2: expected decimal")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-list//get": {
		Doc:   "binding.FloatList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//get: arg 1: expected native of type binding.FloatList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-list//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewDecimal(float64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-float-list//get-value": {
		Doc:   "binding.FloatList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//get-value: arg 1: expected native of type binding.FloatList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-list//get-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-list//get-value: arg 2: expected integer")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-float-list//prepend": {
		Doc:   "binding.FloatList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//prepend: arg 1: expected native of type binding.FloatList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-list//prepend: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-list//prepend: arg 2: expected decimal")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-list//set": {
		Doc:   "binding.FloatList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//set: arg 1: expected native of type binding.FloatList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-list//set: arg 1: expected native")
			}
			var arg1Val []float64
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]float64, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg1Val[i] = float64(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-float-list//set: arg 2: block item: expected decimal")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]float64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//set: arg 2: expected native of type []float64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-list//set: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-list//set-value": {
		Doc:   "binding.FloatList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//set-value: arg 1: expected native of type binding.FloatList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-list//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-list//set-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-list//set-value: arg 2: expected integer")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-list//set-value: arg 3: expected decimal")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-to-string": {
		Doc:   "binding.FloatToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-to-string: arg 1: expected native of type binding.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-to-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-to-string: arg 1: expected native")
			}
			res0 := binding.FloatToString(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-float-to-string-with-format": {
		Doc:   "binding.FloatToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-to-string-with-format: arg 1: expected native of type binding.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-to-string-with-format: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-to-string-with-format: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-to-string-with-format: arg 2: expected string")
			}
			res0 := binding.FloatToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-float-tree//append": {
		Doc:   "binding.FloatTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//append: arg 1: expected native of type binding.FloatTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//append: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//append: arg 3: expected string")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//append: arg 4: expected decimal")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-tree//get": {
		Doc:   "binding.FloatTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//get: arg 1: expected native of type binding.FloatTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//get: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewDecimal(float64(mVal))
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"binding-float-tree//get-value": {
		Doc:   "binding.FloatTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//get-value: arg 1: expected native of type binding.FloatTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//get-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//get-value: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-float-tree//prepend": {
		Doc:   "binding.FloatTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//prepend: arg 1: expected native of type binding.FloatTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//prepend: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//prepend: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//prepend: arg 3: expected string")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//prepend: arg 4: expected decimal")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-tree//set": {
		Doc:   "binding.FloatTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set: arg 1: expected native of type binding.FloatTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//set: arg 1: expected native")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set: arg 2: expected block to have length of multiple of 2")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-float-tree//set: arg 2: map key: expected string")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-float-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-float-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-float-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-float-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-float-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-float-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-float-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-float-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set: arg 2: expected native of type map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//set: arg 2: expected native, block, dict or nil")
			}
			var arg2Val map[string]float64
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set: arg 3: expected block to have length of multiple of 2")
				}
				arg2Val = make(map[string]float64, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-float-tree//set: arg 3: map key: expected string")
					}
					var mapV float64
					if v, ok := v.Series.S[i+1].(env.Decimal); ok {
						mapV = float64(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-float-tree//set: arg 3: map value: expected decimal")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]float64, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV float64
					if v, ok := dictV.(env.Decimal); ok {
						mapV = float64(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-float-tree//set: arg 3: map value: expected decimal")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]float64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set: arg 3: expected native of type map[string]float64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//set: arg 3: expected native, block, dict or nil")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-tree//set-value": {
		Doc:   "binding.FloatTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set-value: arg 1: expected native of type binding.FloatTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float-tree//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//set-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//set-value: arg 2: expected string")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float-tree//set-value: arg 3: expected decimal")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float//get": {
		Doc:   "binding.Float.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float//get: arg 1: expected native of type binding.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-float//set": {
		Doc:   "binding.Float.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-float//set: arg 1: expected native of type binding.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-float//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-float//set: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-float//set: arg 2: expected decimal")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-list//append": {
		Doc:   "binding.IntList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//append: arg 1: expected native of type binding.IntList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-list//append: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-list//append: arg 2: expected integer")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-list//get": {
		Doc:   "binding.IntList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//get: arg 1: expected native of type binding.IntList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-list//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-int-list//get-value": {
		Doc:   "binding.IntList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//get-value: arg 1: expected native of type binding.IntList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-list//get-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-list//get-value: arg 2: expected integer")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-int-list//prepend": {
		Doc:   "binding.IntList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//prepend: arg 1: expected native of type binding.IntList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-list//prepend: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-list//prepend: arg 2: expected integer")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-list//set": {
		Doc:   "binding.IntList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//set: arg 1: expected native of type binding.IntList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-list//set: arg 1: expected native")
			}
			var arg1Val []int
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg1Val[i] = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-int-list//set: arg 2: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//set: arg 2: expected native of type []int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-list//set: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-list//set-value": {
		Doc:   "binding.IntList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//set-value: arg 1: expected native of type binding.IntList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-list//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-list//set-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-list//set-value: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-list//set-value: arg 3: expected integer")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-to-string": {
		Doc:   "binding.IntToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-to-string: arg 1: expected native of type binding.Int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-to-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-to-string: arg 1: expected native")
			}
			res0 := binding.IntToString(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-int-to-string-with-format": {
		Doc:   "binding.IntToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-to-string-with-format: arg 1: expected native of type binding.Int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-to-string-with-format: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-to-string-with-format: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-to-string-with-format: arg 2: expected string")
			}
			res0 := binding.IntToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-int-tree//append": {
		Doc:   "binding.IntTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//append: arg 1: expected native of type binding.IntTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//append: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//append: arg 3: expected string")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//append: arg 4: expected integer")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-tree//get": {
		Doc:   "binding.IntTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//get: arg 1: expected native of type binding.IntTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//get: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewInteger(int64(mVal))
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"binding-int-tree//get-value": {
		Doc:   "binding.IntTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//get-value: arg 1: expected native of type binding.IntTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//get-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//get-value: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-int-tree//prepend": {
		Doc:   "binding.IntTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//prepend: arg 1: expected native of type binding.IntTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//prepend: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//prepend: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//prepend: arg 3: expected string")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//prepend: arg 4: expected integer")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-tree//set": {
		Doc:   "binding.IntTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set: arg 1: expected native of type binding.IntTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//set: arg 1: expected native")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set: arg 2: expected block to have length of multiple of 2")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-int-tree//set: arg 2: map key: expected string")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-int-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-int-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-int-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-int-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-int-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-int-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-int-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-int-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set: arg 2: expected native of type map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//set: arg 2: expected native, block, dict or nil")
			}
			var arg2Val map[string]int
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set: arg 3: expected block to have length of multiple of 2")
				}
				arg2Val = make(map[string]int, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-int-tree//set: arg 3: map key: expected string")
					}
					var mapV int
					if v, ok := v.Series.S[i+1].(env.Integer); ok {
						mapV = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-int-tree//set: arg 3: map value: expected integer")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]int, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV int
					if v, ok := dictV.(env.Integer); ok {
						mapV = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-int-tree//set: arg 3: map value: expected integer")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set: arg 3: expected native of type map[string]int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//set: arg 3: expected native, block, dict or nil")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-tree//set-value": {
		Doc:   "binding.IntTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set-value: arg 1: expected native of type binding.IntTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int-tree//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//set-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//set-value: arg 2: expected string")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int-tree//set-value: arg 3: expected integer")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int//get": {
		Doc:   "binding.Int.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int//get: arg 1: expected native of type binding.Int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-int//set": {
		Doc:   "binding.Int.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-int//set: arg 1: expected native of type binding.Int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-int//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-int//set: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-int//set: arg 2: expected integer")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool": {
		Doc:   "binding.NewBool",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBool()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
				}
			}
			return res0Obj
		},
	},
	"binding-bool-list": {
		Doc:   "binding.NewBoolList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBoolList()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bool-tree": {
		Doc:   "binding.NewBoolTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBoolTree()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-bytes": {
		Doc:   "binding.NewBytes",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBytes()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bytes")
				}
			}
			return res0Obj
		},
	},
	"binding-bytes-list": {
		Doc:   "binding.NewBytesList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBytesList()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bytes-list")
				}
			}
			return res0Obj
		},
	},
	"binding-bytes-tree": {
		Doc:   "binding.NewBytesTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBytesTree()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bytes-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-data-listener": {
		Doc:   "binding.NewDataListener",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func()
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-listener: arg 1: function has invalid number of arguments (expected 0)")
				}
				arg0Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-data-listener: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-data-listener: arg 1: expected function or nil")
			}
			res0 := binding.NewDataListener(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-data-listener")
				}
			}
			return res0Obj
		},
	},
	"binding-float": {
		Doc:   "binding.NewFloat",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewFloat()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-float")
				}
			}
			return res0Obj
		},
	},
	"binding-float-list": {
		Doc:   "binding.NewFloatList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewFloatList()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-float-list")
				}
			}
			return res0Obj
		},
	},
	"binding-float-tree": {
		Doc:   "binding.NewFloatTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewFloatTree()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-float-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-int": {
		Doc:   "binding.NewInt",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewInt()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-int")
				}
			}
			return res0Obj
		},
	},
	"binding-int-list": {
		Doc:   "binding.NewIntList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewIntList()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-int-list")
				}
			}
			return res0Obj
		},
	},
	"binding-int-tree": {
		Doc:   "binding.NewIntTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewIntTree()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-int-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-rune": {
		Doc:   "binding.NewRune",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewRune()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-rune")
				}
			}
			return res0Obj
		},
	},
	"binding-rune-list": {
		Doc:   "binding.NewRuneList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewRuneList()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-rune-list")
				}
			}
			return res0Obj
		},
	},
	"binding-rune-tree": {
		Doc:   "binding.NewRuneTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewRuneTree()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-rune-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-sprintf": {
		Doc:   "binding.NewSprintf",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-sprintf: arg 1: expected string")
			}
			var arg1Val []binding.DataItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]binding.DataItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(binding.DataItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-sprintf: arg 2: block item: expected native of type binding.DataItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-sprintf: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-sprintf: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]binding.DataItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-sprintf: arg 2: expected native of type []binding.DataItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-sprintf: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-sprintf: arg 2: expected block, native or nil")
			}
			res0 := binding.NewSprintf(arg0Val, arg1Val...)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-string": {
		Doc:   "binding.NewString",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewString()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-string-list": {
		Doc:   "binding.NewStringList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewStringList()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string-list")
				}
			}
			return res0Obj
		},
	},
	"binding-string-tree": {
		Doc:   "binding.NewStringTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewStringTree()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-untyped": {
		Doc:   "binding.NewUntyped",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewUntyped()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-untyped")
				}
			}
			return res0Obj
		},
	},
	"binding-untyped-list": {
		Doc:   "binding.NewUntypedList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewUntypedList()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-untyped-list")
				}
			}
			return res0Obj
		},
	},
	"binding-untyped-map": {
		Doc:   "binding.NewUntypedMap",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewUntypedMap()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-untyped-map")
				}
			}
			return res0Obj
		},
	},
	"binding-uri": {
		Doc:   "binding.NewURI",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewURI()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-uri")
				}
			}
			return res0Obj
		},
	},
	"binding-uri-list": {
		Doc:   "binding.NewURIList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewURIList()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-uri-list")
				}
			}
			return res0Obj
		},
	},
	"binding-uri-tree": {
		Doc:   "binding.NewURITree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewURITree()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-uri-tree")
				}
			}
			return res0Obj
		},
	},
	"binding-not": {
		Doc:   "binding.Not",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-not: arg 1: expected native of type binding.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-not: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-not: arg 1: expected native")
			}
			res0 := binding.Not(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
				}
			}
			return res0Obj
		},
	},
	"binding-or": {
		Doc:   "binding.Or",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []binding.Bool
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]binding.Bool, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(binding.Bool)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-or: arg 1: block item: expected native of type binding.Bool")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-or: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-or: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]binding.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-or: arg 1: expected native of type []binding.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-or: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-or: arg 1: expected block, native or nil")
			}
			res0 := binding.Or(arg0Val...)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
				}
			}
			return res0Obj
		},
	},
	"binding-rune-list//append": {
		Doc:   "binding.RuneList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//append: arg 1: expected native of type binding.RuneList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//append: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//append: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//append: arg 2: expected native")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-list//get": {
		Doc:   "binding.RuneList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//get: arg 1: expected native of type binding.RuneList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rune")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-rune-list//get-value": {
		Doc:   "binding.RuneList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//get-value: arg 1: expected native of type binding.RuneList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//get-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//get-value: arg 2: expected integer")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-rune-list//prepend": {
		Doc:   "binding.RuneList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//prepend: arg 1: expected native of type binding.RuneList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//prepend: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//prepend: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//prepend: arg 2: expected native")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-list//set": {
		Doc:   "binding.RuneList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//set: arg 1: expected native of type binding.RuneList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//set: arg 1: expected native")
			}
			var arg1Val []rune
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]rune, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(rune)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-rune-list//set: arg 2: block item: expected native of type rune")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-rune-list//set: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//set: arg 2: expected native of type []rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//set: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-list//set-value": {
		Doc:   "binding.RuneList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//set-value: arg 1: expected native of type binding.RuneList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//set-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//set-value: arg 2: expected integer")
			}
			var arg2Val rune
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-list//set-value: arg 3: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-list//set-value: arg 3: expected native")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-tree//append": {
		Doc:   "binding.RuneTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//append: arg 1: expected native of type binding.RuneTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//append: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//append: arg 3: expected string")
			}
			var arg3Val rune
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//append: arg 4: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//append: arg 4: expected native")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-tree//get": {
		Doc:   "binding.RuneTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//get: arg 1: expected native of type binding.RuneTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//get: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewNative(ps.Idx, mVal, "rune")
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"binding-rune-tree//get-value": {
		Doc:   "binding.RuneTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//get-value: arg 1: expected native of type binding.RuneTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//get-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//get-value: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-rune-tree//prepend": {
		Doc:   "binding.RuneTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//prepend: arg 1: expected native of type binding.RuneTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//prepend: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//prepend: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//prepend: arg 3: expected string")
			}
			var arg3Val rune
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//prepend: arg 4: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//prepend: arg 4: expected native")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-tree//set": {
		Doc:   "binding.RuneTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set: arg 1: expected native of type binding.RuneTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//set: arg 1: expected native")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set: arg 2: expected block to have length of multiple of 2")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-rune-tree//set: arg 2: map key: expected string")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-rune-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-rune-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-rune-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-rune-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-rune-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-rune-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-rune-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-rune-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set: arg 2: expected native of type map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//set: arg 2: expected native, block, dict or nil")
			}
			var arg2Val map[string]rune
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set: arg 3: expected block to have length of multiple of 2")
				}
				arg2Val = make(map[string]rune, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-rune-tree//set: arg 3: map key: expected string")
					}
					var mapV rune
					switch v := v.Series.S[i+1].(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(rune)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-rune-tree//set: arg 3: map value: expected native of type rune")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-rune-tree//set: arg 3: map value: expected native")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]rune, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV rune
					switch v := dictV.(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(rune)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-rune-tree//set: arg 3: map value: expected native of type rune")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-rune-tree//set: arg 3: map value: expected native")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set: arg 3: expected native of type map[string]rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//set: arg 3: expected native, block, dict or nil")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-tree//set-value": {
		Doc:   "binding.RuneTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set-value: arg 1: expected native of type binding.RuneTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//set-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//set-value: arg 2: expected string")
			}
			var arg2Val rune
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune-tree//set-value: arg 3: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune-tree//set-value: arg 3: expected native")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune//get": {
		Doc:   "binding.Rune.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune//get: arg 1: expected native of type binding.Rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-rune//set": {
		Doc:   "binding.Rune.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune//set: arg 1: expected native of type binding.Rune")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-rune//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune//set: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-rune//set: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-rune//set: arg 2: expected native")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-list//append": {
		Doc:   "binding.StringList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//append: arg 1: expected native of type binding.StringList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-list//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-list//append: arg 2: expected string")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-list//get": {
		Doc:   "binding.StringList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//get: arg 1: expected native of type binding.StringList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-list//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-string-list//get-value": {
		Doc:   "binding.StringList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//get-value: arg 1: expected native of type binding.StringList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-list//get-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-list//get-value: arg 2: expected integer")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-string-list//prepend": {
		Doc:   "binding.StringList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//prepend: arg 1: expected native of type binding.StringList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-list//prepend: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-list//prepend: arg 2: expected string")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-list//set": {
		Doc:   "binding.StringList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//set: arg 1: expected native of type binding.StringList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-list//set: arg 1: expected native")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-string-list//set: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//set: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-list//set: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-list//set-value": {
		Doc:   "binding.StringList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//set-value: arg 1: expected native of type binding.StringList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-list//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-list//set-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-list//set-value: arg 2: expected integer")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-list//set-value: arg 3: expected string")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-to-bool": {
		Doc:   "binding.StringToBool",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-bool: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-bool: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-to-bool: arg 1: expected native")
			}
			res0 := binding.StringToBool(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
				}
			}
			return res0Obj
		},
	},
	"binding-string-to-bool-with-format": {
		Doc:   "binding.StringToBoolWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-bool-with-format: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-bool-with-format: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-to-bool-with-format: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-to-bool-with-format: arg 2: expected string")
			}
			res0 := binding.StringToBoolWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
				}
			}
			return res0Obj
		},
	},
	"binding-string-to-float": {
		Doc:   "binding.StringToFloat",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-float: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-float: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-to-float: arg 1: expected native")
			}
			res0 := binding.StringToFloat(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-float")
				}
			}
			return res0Obj
		},
	},
	"binding-string-to-float-with-format": {
		Doc:   "binding.StringToFloatWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-float-with-format: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-float-with-format: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-to-float-with-format: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-to-float-with-format: arg 2: expected string")
			}
			res0 := binding.StringToFloatWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-float")
				}
			}
			return res0Obj
		},
	},
	"binding-string-to-int": {
		Doc:   "binding.StringToInt",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-int: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-int: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-to-int: arg 1: expected native")
			}
			res0 := binding.StringToInt(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-int")
				}
			}
			return res0Obj
		},
	},
	"binding-string-to-int-with-format": {
		Doc:   "binding.StringToIntWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-int-with-format: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-int-with-format: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-to-int-with-format: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-to-int-with-format: arg 2: expected string")
			}
			res0 := binding.StringToIntWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-int")
				}
			}
			return res0Obj
		},
	},
	"binding-string-to-string-with-format": {
		Doc:   "binding.StringToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-string-with-format: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-string-with-format: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-to-string-with-format: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-to-string-with-format: arg 2: expected string")
			}
			res0 := binding.StringToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-string-to-uri": {
		Doc:   "binding.StringToURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-uri: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-to-uri: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-to-uri: arg 1: expected native")
			}
			res0 := binding.StringToURI(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-uri")
				}
			}
			return res0Obj
		},
	},
	"binding-string-tree//append": {
		Doc:   "binding.StringTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//append: arg 1: expected native of type binding.StringTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//append: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//append: arg 3: expected string")
			}
			var arg3Val string
			if v, ok := arg3.(env.String); ok {
				arg3Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//append: arg 4: expected string")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-tree//get": {
		Doc:   "binding.StringTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//get: arg 1: expected native of type binding.StringTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//get: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewString(mVal)
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"binding-string-tree//get-value": {
		Doc:   "binding.StringTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//get-value: arg 1: expected native of type binding.StringTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//get-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//get-value: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-string-tree//prepend": {
		Doc:   "binding.StringTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//prepend: arg 1: expected native of type binding.StringTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//prepend: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//prepend: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//prepend: arg 3: expected string")
			}
			var arg3Val string
			if v, ok := arg3.(env.String); ok {
				arg3Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//prepend: arg 4: expected string")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-tree//set": {
		Doc:   "binding.StringTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set: arg 1: expected native of type binding.StringTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//set: arg 1: expected native")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set: arg 2: expected block to have length of multiple of 2")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-string-tree//set: arg 2: map key: expected string")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-string-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-string-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-string-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-string-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-string-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-string-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-string-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-string-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set: arg 2: expected native of type map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//set: arg 2: expected native, block, dict or nil")
			}
			var arg2Val map[string]string
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set: arg 3: expected block to have length of multiple of 2")
				}
				arg2Val = make(map[string]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-string-tree//set: arg 3: map key: expected string")
					}
					var mapV string
					if v, ok := v.Series.S[i+1].(env.String); ok {
						mapV = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-string-tree//set: arg 3: map value: expected string")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV string
					if v, ok := dictV.(env.String); ok {
						mapV = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-string-tree//set: arg 3: map value: expected string")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set: arg 3: expected native of type map[string]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//set: arg 3: expected native, block, dict or nil")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-tree//set-value": {
		Doc:   "binding.StringTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set-value: arg 1: expected native of type binding.StringTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string-tree//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//set-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//set-value: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string-tree//set-value: arg 3: expected string")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string//get": {
		Doc:   "binding.String.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string//get: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-string//set": {
		Doc:   "binding.String.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-string//set: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-string//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-string//set: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-string//set: arg 2: expected string")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-struct//get-value": {
		Doc:   "binding.Struct.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Struct
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Struct)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-struct//get-value: arg 1: expected native of type binding.Struct")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-struct//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-struct//get-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-struct//get-value: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "any")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-struct//reload": {
		Doc:   "binding.Struct.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Struct
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Struct)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-struct//reload: arg 1: expected native of type binding.Struct")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-struct//reload: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-struct//reload: arg 1: expected native")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-struct//set-value": {
		Doc:   "binding.Struct.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Struct
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Struct)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-struct//set-value: arg 1: expected native of type binding.Struct")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-struct//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-struct//set-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-struct//set-value: arg 2: expected string")
			}
			var arg2Val any
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-struct//set-value: arg 3: expected native of type any")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-struct//set-value: arg 3: expected native")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-untyped-list//append": {
		Doc:   "binding.UntypedList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//append: arg 1: expected native of type binding.UntypedList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//append: arg 1: expected native")
			}
			var arg1Val any
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//append: arg 2: expected native of type any")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//append: arg 2: expected native")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-untyped-list//get": {
		Doc:   "binding.UntypedList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//get: arg 1: expected native of type binding.UntypedList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "any")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-untyped-list//get-value": {
		Doc:   "binding.UntypedList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//get-value: arg 1: expected native of type binding.UntypedList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//get-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//get-value: arg 2: expected integer")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "any")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-untyped-list//prepend": {
		Doc:   "binding.UntypedList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//prepend: arg 1: expected native of type binding.UntypedList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//prepend: arg 1: expected native")
			}
			var arg1Val any
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//prepend: arg 2: expected native of type any")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//prepend: arg 2: expected native")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-untyped-list//set": {
		Doc:   "binding.UntypedList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//set: arg 1: expected native of type binding.UntypedList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//set: arg 1: expected native")
			}
			var arg1Val []any
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]any, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(any)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-untyped-list//set: arg 2: block item: expected native of type any")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-untyped-list//set: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//set: arg 2: expected native of type []any")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//set: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-untyped-list//set-value": {
		Doc:   "binding.UntypedList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//set-value: arg 1: expected native of type binding.UntypedList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//set-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//set-value: arg 2: expected integer")
			}
			var arg2Val any
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-list//set-value: arg 3: expected native of type any")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-list//set-value: arg 3: expected native")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-untyped-map//delete": {
		Doc:   "binding.UntypedMap.Delete",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedMap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//delete: arg 1: expected native of type binding.UntypedMap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//delete: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//delete: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//delete: arg 2: expected string")
			}
			arg0Val.Delete(arg1Val)
			return arg0
		},
	},
	"binding-untyped-map//get": {
		Doc:   "binding.UntypedMap.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedMap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//get: arg 1: expected native of type binding.UntypedMap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					dVal = *env.NewNative(ps.Idx, mVal, "any")
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-untyped-map//get-value": {
		Doc:   "binding.UntypedMap.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedMap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//get-value: arg 1: expected native of type binding.UntypedMap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//get-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//get-value: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "any")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-untyped-map//set": {
		Doc:   "binding.UntypedMap.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedMap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//set: arg 1: expected native of type binding.UntypedMap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//set: arg 1: expected native")
			}
			var arg1Val map[string]any
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//set: arg 2: expected block to have length of multiple of 2")
				}
				arg1Val = make(map[string]any, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-untyped-map//set: arg 2: map key: expected string")
					}
					var mapV any
					switch v := v.Series.S[i+1].(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(any)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-untyped-map//set: arg 2: map value: expected native of type any")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-untyped-map//set: arg 2: map value: expected native")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string]any, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV any
					switch v := dictV.(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(any)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-untyped-map//set: arg 2: map value: expected native of type any")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-untyped-map//set: arg 2: map value: expected native")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string]any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//set: arg 2: expected native of type map[string]any")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//set: arg 2: expected native, block, dict or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-untyped-map//set-value": {
		Doc:   "binding.UntypedMap.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedMap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//set-value: arg 1: expected native of type binding.UntypedMap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//set-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//set-value: arg 2: expected string")
			}
			var arg2Val any
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped-map//set-value: arg 3: expected native of type any")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped-map//set-value: arg 3: expected native")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-untyped//get": {
		Doc:   "binding.Untyped.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Untyped
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Untyped)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped//get: arg 1: expected native of type binding.Untyped")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "any")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-untyped//set": {
		Doc:   "binding.Untyped.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Untyped
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Untyped)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped//set: arg 1: expected native of type binding.Untyped")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-untyped//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped//set: arg 1: expected native")
			}
			var arg1Val any
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(any)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-untyped//set: arg 2: expected native of type any")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-untyped//set: arg 2: expected native")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-uri-list//append": {
		Doc:   "binding.URIList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URIList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URIList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//append: arg 1: expected native of type binding.URIList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//append: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//append: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//append: arg 2: expected native")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-uri-list//get": {
		Doc:   "binding.URIList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URIList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URIList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//get: arg 1: expected native of type binding.URIList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "fyne-uri")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-uri-list//get-value": {
		Doc:   "binding.URIList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URIList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URIList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//get-value: arg 1: expected native of type binding.URIList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//get-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//get-value: arg 2: expected integer")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-uri-list//prepend": {
		Doc:   "binding.URIList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URIList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URIList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//prepend: arg 1: expected native of type binding.URIList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//prepend: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//prepend: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//prepend: arg 2: expected native")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-uri-list//set": {
		Doc:   "binding.URIList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URIList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URIList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//set: arg 1: expected native of type binding.URIList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//set: arg 1: expected native")
			}
			var arg1Val []fyne.URI
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.URI, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.URI)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-uri-list//set: arg 2: block item: expected native of type fyne.URI")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-uri-list//set: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//set: arg 2: expected native of type []fyne.URI")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//set: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-uri-list//set-value": {
		Doc:   "binding.URIList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URIList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URIList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//set-value: arg 1: expected native of type binding.URIList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//set-value: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//set-value: arg 2: expected integer")
			}
			var arg2Val fyne.URI
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-list//set-value: arg 3: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-list//set-value: arg 3: expected native")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-uri-to-string": {
		Doc:   "binding.URIToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-to-string: arg 1: expected native of type binding.URI")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-to-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-to-string: arg 1: expected native")
			}
			res0 := binding.URIToString(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
				}
			}
			return res0Obj
		},
	},
	"binding-uri-tree//append": {
		Doc:   "binding.URITree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//append: arg 1: expected native of type binding.URITree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//append: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//append: arg 3: expected string")
			}
			var arg3Val fyne.URI
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//append: arg 4: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//append: arg 4: expected native")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-uri-tree//get": {
		Doc:   "binding.URITree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//get: arg 1: expected native of type binding.URITree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//get: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewNative(ps.Idx, mVal, "fyne-uri")
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"binding-uri-tree//get-value": {
		Doc:   "binding.URITree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//get-value: arg 1: expected native of type binding.URITree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//get-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//get-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//get-value: arg 2: expected string")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-uri-tree//prepend": {
		Doc:   "binding.URITree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//prepend: arg 1: expected native of type binding.URITree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//prepend: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//prepend: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//prepend: arg 3: expected string")
			}
			var arg3Val fyne.URI
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//prepend: arg 4: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//prepend: arg 4: expected native")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-uri-tree//set": {
		Doc:   "binding.URITree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set: arg 1: expected native of type binding.URITree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//set: arg 1: expected native")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set: arg 2: expected block to have length of multiple of 2")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-uri-tree//set: arg 2: map key: expected string")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-uri-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-uri-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-uri-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-uri-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("binding-uri-tree//set: arg 2: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-uri-tree//set: arg 2: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("binding-uri-tree//set: arg 2: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("binding-uri-tree//set: arg 2: map value: expected block, native or nil")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set: arg 2: expected native of type map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//set: arg 2: expected native, block, dict or nil")
			}
			var arg2Val map[string]fyne.URI
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set: arg 3: expected block to have length of multiple of 2")
				}
				arg2Val = make(map[string]fyne.URI, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("binding-uri-tree//set: arg 3: map key: expected string")
					}
					var mapV fyne.URI
					switch v := v.Series.S[i+1].(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(fyne.URI)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-uri-tree//set: arg 3: map value: expected native of type fyne.URI")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-uri-tree//set: arg 3: map value: expected native")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]fyne.URI, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV fyne.URI
					switch v := dictV.(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(fyne.URI)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("binding-uri-tree//set: arg 3: map value: expected native of type fyne.URI")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("binding-uri-tree//set: arg 3: map value: expected native")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set: arg 3: expected native of type map[string]fyne.URI")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//set: arg 3: expected native, block, dict or nil")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-uri-tree//set-value": {
		Doc:   "binding.URITree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set-value: arg 1: expected native of type binding.URITree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//set-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//set-value: arg 2: expected string")
			}
			var arg2Val fyne.URI
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri-tree//set-value: arg 3: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri-tree//set-value: arg 3: expected native")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-uri//get": {
		Doc:   "binding.URI.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri//get: arg 1: expected native of type binding.URI")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri//get: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri//get: arg 1: expected native")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-uri//set": {
		Doc:   "binding.URI.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri//set: arg 1: expected native of type binding.URI")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("binding-uri//set: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri//set: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("binding-uri//set: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("binding-uri//set: arg 2: expected native")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"canvas-circle//fill-color!": {
		Doc:   "Set canvas.Circle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//fill-color!: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//fill-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//fill-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//fill-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-circle//fill-color?": {
		Doc:   "Get canvas.Circle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//fill-color?: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//fill-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color-color")
			return resObj
		},
	},
	"canvas-circle//hidden!": {
		Doc:   "Set canvas.Circle Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//hidden!: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-circle//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"canvas-circle//hidden?": {
		Doc:   "Get canvas.Circle Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//hidden?: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"canvas-circle//position-1!": {
		Doc:   "Set canvas.Circle Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//position-1!: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//position-1!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//position-1!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//position-1!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-circle//position-1?": {
		Doc:   "Get canvas.Circle Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//position-1?: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//position-1?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "fyne-position")
			return resObj
		},
	},
	"canvas-circle//position-2!": {
		Doc:   "Set canvas.Circle Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//position-2!: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//position-2!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//position-2!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//position-2!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-circle//position-2?": {
		Doc:   "Get canvas.Circle Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//position-2?: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//position-2?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "fyne-position")
			return resObj
		},
	},
	"canvas-circle//stroke-color!": {
		Doc:   "Set canvas.Circle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//stroke-color!: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//stroke-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//stroke-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//stroke-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-circle//stroke-color?": {
		Doc:   "Get canvas.Circle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//stroke-color?: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//stroke-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"canvas-circle//stroke-width!": {
		Doc:   "Set canvas.Circle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//stroke-width!: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//stroke-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-circle//stroke-width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-circle//stroke-width?": {
		Doc:   "Get canvas.Circle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle//stroke-width?: arg 1: expected native of type canvas.Circle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle//stroke-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"canvas-image-fill-contain": {
		Doc:   "Get canvas.ImageFillContain value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(canvas.ImageFillContain)))
			return resObj
		},
	},
	"canvas-image-fill-original": {
		Doc:   "Get canvas.ImageFillOriginal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(canvas.ImageFillOriginal)))
			return resObj
		},
	},
	"canvas-image-fill-stretch": {
		Doc:   "Get canvas.ImageFillStretch value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(canvas.ImageFillStretch)))
			return resObj
		},
	},
	"canvas-image-scale-fastest": {
		Doc:   "Get canvas.ImageScaleFastest value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(canvas.ImageScaleFastest)))
			return resObj
		},
	},
	"canvas-image-scale-pixels": {
		Doc:   "Get canvas.ImageScalePixels value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(canvas.ImageScalePixels)))
			return resObj
		},
	},
	"canvas-image-scale-smooth": {
		Doc:   "Get canvas.ImageScaleSmooth value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(canvas.ImageScaleSmooth)))
			return resObj
		},
	},
	"canvas-image//file!": {
		Doc:   "Set canvas.Image File value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//file!: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//file!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.File = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-image//file!: arg 2: expected string")
			}
			return arg0
		},
	},
	"canvas-image//file?": {
		Doc:   "Get canvas.Image File value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//file?: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//file?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.File)
			return resObj
		},
	},
	"canvas-image//fill-mode!": {
		Doc:   "Set canvas.Image FillMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//fill-mode!: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//fill-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal canvas.ImageFill
				if natOk {
					natVal, natValOk = nat.Value.(canvas.ImageFill)
				}
				if natOk && natValOk {
					self.FillMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("canvas-image//fill-mode!: arg 2: expected integer")
					}
					self.FillMode = canvas.ImageFill(u)
				}
			}
			return arg0
		},
	},
	"canvas-image//fill-mode?": {
		Doc:   "Get canvas.Image FillMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//fill-mode?: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//fill-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillMode)))
			return resObj
		},
	},
	"canvas-image//image!": {
		Doc:   "Set canvas.Image Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//image!: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//image!: arg 2: expected native of type image.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-image//image?": {
		Doc:   "Get canvas.Image Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//image?: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "image-image")
			return resObj
		},
	},
	"canvas-image//resource!": {
		Doc:   "Set canvas.Image Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//resource!: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//resource!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//resource!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("canvas-image//resource!: arg 2: expected integer to be 0 or nil")
				}
				self.Resource = nil
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//resource!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-image//resource?": {
		Doc:   "Get canvas.Image Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//resource?: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//resource?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Resource)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Resource, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Resource, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"canvas-image//scale-mode!": {
		Doc:   "Set canvas.Image ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//scale-mode!: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal canvas.ImageScale
				if natOk {
					natVal, natValOk = nat.Value.(canvas.ImageScale)
				}
				if natOk && natValOk {
					self.ScaleMode = natVal
				} else {
					var u int32
					if v, ok := arg1.(env.Integer); ok {
						u = int32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("canvas-image//scale-mode!: arg 2: expected integer")
					}
					self.ScaleMode = canvas.ImageScale(u)
				}
			}
			return arg0
		},
	},
	"canvas-image//scale-mode?": {
		Doc:   "Get canvas.Image ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//scale-mode?: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(self.ScaleMode)))
			return resObj
		},
	},
	"canvas-image//translucency!": {
		Doc:   "Set canvas.Image Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//translucency!: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//translucency!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-image//translucency!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-image//translucency?": {
		Doc:   "Get canvas.Image Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image//translucency?: arg 1: expected native of type canvas.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image//translucency?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"canvas-line//hidden!": {
		Doc:   "Set canvas.Line Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//hidden!: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-line//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"canvas-line//hidden?": {
		Doc:   "Get canvas.Line Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//hidden?: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"canvas-line//position-1!": {
		Doc:   "Set canvas.Line Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//position-1!: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//position-1!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//position-1!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//position-1!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-line//position-1?": {
		Doc:   "Get canvas.Line Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//position-1?: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//position-1?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "fyne-position")
			return resObj
		},
	},
	"canvas-line//position-2!": {
		Doc:   "Set canvas.Line Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//position-2!: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//position-2!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//position-2!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//position-2!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-line//position-2?": {
		Doc:   "Get canvas.Line Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//position-2?: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//position-2?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "fyne-position")
			return resObj
		},
	},
	"canvas-line//stroke-color!": {
		Doc:   "Set canvas.Line StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//stroke-color!: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//stroke-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//stroke-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//stroke-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-line//stroke-color?": {
		Doc:   "Get canvas.Line StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//stroke-color?: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//stroke-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"canvas-line//stroke-width!": {
		Doc:   "Set canvas.Line StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//stroke-width!: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//stroke-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-line//stroke-width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-line//stroke-width?": {
		Doc:   "Get canvas.Line StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line//stroke-width?: arg 1: expected native of type canvas.Line")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line//stroke-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"canvas-linear-gradient//angle!": {
		Doc:   "Set canvas.LinearGradient Angle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient//angle!: arg 1: expected native of type canvas.LinearGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient//angle!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Angle = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient//angle!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-linear-gradient//angle?": {
		Doc:   "Get canvas.LinearGradient Angle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient//angle?: arg 1: expected native of type canvas.LinearGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient//angle?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Angle))
			return resObj
		},
	},
	"canvas-linear-gradient//end-color!": {
		Doc:   "Set canvas.LinearGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient//end-color!: arg 1: expected native of type canvas.LinearGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient//end-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient//end-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient//end-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-linear-gradient//end-color?": {
		Doc:   "Get canvas.LinearGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient//end-color?: arg 1: expected native of type canvas.LinearGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient//end-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color-color")
			return resObj
		},
	},
	"canvas-linear-gradient//start-color!": {
		Doc:   "Set canvas.LinearGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient//start-color!: arg 1: expected native of type canvas.LinearGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient//start-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient//start-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient//start-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-linear-gradient//start-color?": {
		Doc:   "Get canvas.LinearGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient//start-color?: arg 1: expected native of type canvas.LinearGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient//start-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color-color")
			return resObj
		},
	},
	"canvas-circle": {
		Doc:   "canvas.NewCircle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-circle: arg 1: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-circle: arg 1: expected native")
			}
			res0 := canvas.NewCircle(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-circle")
			return res0Obj
		},
	},
	"canvas-color-rgba-animation": {
		Doc:   "canvas.NewColorRGBAAnimation",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-color-rgba-animation: arg 1: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-color-rgba-animation: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-color-rgba-animation: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-color-rgba-animation: arg 2: expected native")
			}
			var arg2Val time.Duration
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-color-rgba-animation: arg 3: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-color-rgba-animation: arg 3: expected native")
			}
			var arg3Val func(color.Color)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("canvas-color-rgba-animation: arg 4: function has invalid number of arguments (expected 1)")
				}
				arg3Val = func(arg0 color.Color) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "color-color")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("canvas-color-rgba-animation: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-color-rgba-animation: arg 4: expected function or nil")
			}
			res0 := canvas.NewColorRGBAAnimation(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-animation")
			return res0Obj
		},
	},
	"canvas-horizontal-gradient": {
		Doc:   "canvas.NewHorizontalGradient",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-horizontal-gradient: arg 1: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-horizontal-gradient: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-horizontal-gradient: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-horizontal-gradient: arg 2: expected native")
			}
			res0 := canvas.NewHorizontalGradient(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-linear-gradient")
			return res0Obj
		},
	},
	"canvas-image-from-file": {
		Doc:   "canvas.NewImageFromFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-image-from-file: arg 1: expected string")
			}
			res0 := canvas.NewImageFromFile(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-image")
			return res0Obj
		},
	},
	"canvas-image-from-image": {
		Doc:   "canvas.NewImageFromImage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image-from-image: arg 1: expected native of type image.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image-from-image: arg 1: expected native")
			}
			res0 := canvas.NewImageFromImage(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-image")
			return res0Obj
		},
	},
	"canvas-image-from-reader": {
		Doc:   "canvas.NewImageFromReader",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image-from-reader: arg 1: expected native of type io.Reader")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image-from-reader: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-image-from-reader: arg 2: expected string")
			}
			res0 := canvas.NewImageFromReader(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-image")
			return res0Obj
		},
	},
	"canvas-image-from-resource": {
		Doc:   "canvas.NewImageFromResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image-from-resource: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("canvas-image-from-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image-from-resource: arg 1: expected native")
			}
			res0 := canvas.NewImageFromResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-image")
			return res0Obj
		},
	},
	"canvas-image-from-uri": {
		Doc:   "canvas.NewImageFromURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-image-from-uri: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-image-from-uri: arg 1: expected native")
			}
			res0 := canvas.NewImageFromURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-image")
			return res0Obj
		},
	},
	"canvas-line": {
		Doc:   "canvas.NewLine",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-line: arg 1: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-line: arg 1: expected native")
			}
			res0 := canvas.NewLine(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-line")
			return res0Obj
		},
	},
	"canvas-linear-gradient": {
		Doc:   "canvas.NewLinearGradient",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient: arg 1: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-linear-gradient: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient: arg 2: expected native")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-linear-gradient: arg 3: expected decimal")
			}
			res0 := canvas.NewLinearGradient(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-linear-gradient")
			return res0Obj
		},
	},
	"canvas-position-animation": {
		Doc:   "canvas.NewPositionAnimation",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-position-animation: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-position-animation: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-position-animation: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-position-animation: arg 2: expected native")
			}
			var arg2Val time.Duration
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-position-animation: arg 3: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-position-animation: arg 3: expected native")
			}
			var arg3Val func(fyne.Position)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("canvas-position-animation: arg 4: function has invalid number of arguments (expected 1)")
				}
				arg3Val = func(arg0 fyne.Position) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-position")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("canvas-position-animation: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-position-animation: arg 4: expected function or nil")
			}
			res0 := canvas.NewPositionAnimation(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-animation")
			return res0Obj
		},
	},
	"canvas-radial-gradient": {
		Doc:   "canvas.NewRadialGradient",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient: arg 1: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient: arg 2: expected native")
			}
			res0 := canvas.NewRadialGradient(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-radial-gradient")
			return res0Obj
		},
	},
	"canvas-raster": {
		Doc:   "canvas.NewRaster",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(int, int) image.Image
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("canvas-raster: arg 1: function has invalid number of arguments (expected 2)")
				}
				arg0Val = func(arg0 int, arg1 int) image.Image {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
					var res image.Image
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(image.Image)
						if !ok {
							// TODO: Cannot return error from function
						}
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("canvas-raster: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster: arg 1: expected function or nil")
			}
			res0 := canvas.NewRaster(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-raster")
			return res0Obj
		},
	},
	"canvas-raster-from-image": {
		Doc:   "canvas.NewRasterFromImage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-raster-from-image: arg 1: expected native of type image.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster-from-image: arg 1: expected native")
			}
			res0 := canvas.NewRasterFromImage(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-raster")
			return res0Obj
		},
	},
	"canvas-raster-with-pixels": {
		Doc:   "canvas.NewRasterWithPixels",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(int, int, int, int) color.Color
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 4 {
					ps.FailureFlag = true
					return env.NewError("canvas-raster-with-pixels: arg 1: function has invalid number of arguments (expected 4)")
				}
				arg0Val = func(arg0 int, arg1 int, arg2 int, arg3 int) color.Color {
					var arg0Val, arg1Val, arg2Val, arg3Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					arg2Val = *env.NewInteger(int64(arg2))
					arg3Val = *env.NewInteger(int64(arg3))
					evaldo.CallFunctionArgs4(fn, ps, arg0Val, arg1Val, arg2Val, arg3Val, ps.Ctx)
					var res color.Color
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(color.Color)
						if !ok {
							// TODO: Cannot return error from function
						}
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("canvas-raster-with-pixels: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster-with-pixels: arg 1: expected function or nil")
			}
			res0 := canvas.NewRasterWithPixels(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-raster")
			return res0Obj
		},
	},
	"canvas-rectangle": {
		Doc:   "canvas.NewRectangle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle: arg 1: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle: arg 1: expected native")
			}
			res0 := canvas.NewRectangle(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-rectangle")
			return res0Obj
		},
	},
	"canvas-size-animation": {
		Doc:   "canvas.NewSizeAnimation",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-size-animation: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-size-animation: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-size-animation: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-size-animation: arg 2: expected native")
			}
			var arg2Val time.Duration
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-size-animation: arg 3: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-size-animation: arg 3: expected native")
			}
			var arg3Val func(fyne.Size)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("canvas-size-animation: arg 4: function has invalid number of arguments (expected 1)")
				}
				arg3Val = func(arg0 fyne.Size) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-size")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("canvas-size-animation: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-size-animation: arg 4: expected function or nil")
			}
			res0 := canvas.NewSizeAnimation(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-animation")
			return res0Obj
		},
	},
	"canvas-text": {
		Doc:   "canvas.NewText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-text: arg 1: expected string")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text: arg 2: expected native")
			}
			res0 := canvas.NewText(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-text")
			return res0Obj
		},
	},
	"canvas-vertical-gradient": {
		Doc:   "canvas.NewVerticalGradient",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-vertical-gradient: arg 1: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-vertical-gradient: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-vertical-gradient: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-vertical-gradient: arg 2: expected native")
			}
			res0 := canvas.NewVerticalGradient(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-canvas-linear-gradient")
			return res0Obj
		},
	},
	"canvas-radial-gradient//center-offset-x!": {
		Doc:   "Set canvas.RadialGradient CenterOffsetX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//center-offset-x!: arg 1: expected native of type canvas.RadialGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//center-offset-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetX = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//center-offset-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-radial-gradient//center-offset-x?": {
		Doc:   "Get canvas.RadialGradient CenterOffsetX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//center-offset-x?: arg 1: expected native of type canvas.RadialGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//center-offset-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetX))
			return resObj
		},
	},
	"canvas-radial-gradient//center-offset-y!": {
		Doc:   "Set canvas.RadialGradient CenterOffsetY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//center-offset-y!: arg 1: expected native of type canvas.RadialGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//center-offset-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetY = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//center-offset-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-radial-gradient//center-offset-y?": {
		Doc:   "Get canvas.RadialGradient CenterOffsetY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//center-offset-y?: arg 1: expected native of type canvas.RadialGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//center-offset-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetY))
			return resObj
		},
	},
	"canvas-radial-gradient//end-color!": {
		Doc:   "Set canvas.RadialGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//end-color!: arg 1: expected native of type canvas.RadialGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//end-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//end-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//end-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-radial-gradient//end-color?": {
		Doc:   "Get canvas.RadialGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//end-color?: arg 1: expected native of type canvas.RadialGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//end-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color-color")
			return resObj
		},
	},
	"canvas-radial-gradient//start-color!": {
		Doc:   "Set canvas.RadialGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//start-color!: arg 1: expected native of type canvas.RadialGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//start-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//start-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//start-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-radial-gradient//start-color?": {
		Doc:   "Get canvas.RadialGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-radial-gradient//start-color?: arg 1: expected native of type canvas.RadialGradient")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-radial-gradient//start-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color-color")
			return resObj
		},
	},
	"canvas-raster//generator!": {
		Doc:   "Set canvas.Raster Generator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-raster//generator!: arg 1: expected native of type canvas.Raster")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster//generator!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("canvas-raster//generator!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.Generator = func(arg0 int, arg1 int) image.Image {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
					var res image.Image
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(image.Image)
						if !ok {
							// TODO: Cannot return error from function
						}
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("canvas-raster//generator!: arg 2: expected integer to be 0 or nil")
				}
				self.Generator = nil
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster//generator!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"canvas-raster//generator?": {
		Doc:   "Get canvas.Raster Generator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-raster//generator?: arg 1: expected native of type canvas.Raster")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster//generator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Generator, "func(int_int)_(image-image)")
			return resObj
		},
	},
	"canvas-raster//scale-mode!": {
		Doc:   "Set canvas.Raster ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-raster//scale-mode!: arg 1: expected native of type canvas.Raster")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster//scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal canvas.ImageScale
				if natOk {
					natVal, natValOk = nat.Value.(canvas.ImageScale)
				}
				if natOk && natValOk {
					self.ScaleMode = natVal
				} else {
					var u int32
					if v, ok := arg1.(env.Integer); ok {
						u = int32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("canvas-raster//scale-mode!: arg 2: expected integer")
					}
					self.ScaleMode = canvas.ImageScale(u)
				}
			}
			return arg0
		},
	},
	"canvas-raster//scale-mode?": {
		Doc:   "Get canvas.Raster ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-raster//scale-mode?: arg 1: expected native of type canvas.Raster")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster//scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(self.ScaleMode)))
			return resObj
		},
	},
	"canvas-raster//translucency!": {
		Doc:   "Set canvas.Raster Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-raster//translucency!: arg 1: expected native of type canvas.Raster")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster//translucency!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-raster//translucency!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-raster//translucency?": {
		Doc:   "Get canvas.Raster Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-raster//translucency?: arg 1: expected native of type canvas.Raster")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-raster//translucency?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"canvas-rectangle//corner-radius!": {
		Doc:   "Set canvas.Rectangle CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//corner-radius!: arg 1: expected native of type canvas.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//corner-radius!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CornerRadius = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//corner-radius!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-rectangle//corner-radius?": {
		Doc:   "Get canvas.Rectangle CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//corner-radius?: arg 1: expected native of type canvas.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//corner-radius?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CornerRadius))
			return resObj
		},
	},
	"canvas-rectangle//fill-color!": {
		Doc:   "Set canvas.Rectangle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//fill-color!: arg 1: expected native of type canvas.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//fill-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//fill-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//fill-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-rectangle//fill-color?": {
		Doc:   "Get canvas.Rectangle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//fill-color?: arg 1: expected native of type canvas.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//fill-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color-color")
			return resObj
		},
	},
	"canvas-rectangle//stroke-color!": {
		Doc:   "Set canvas.Rectangle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//stroke-color!: arg 1: expected native of type canvas.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//stroke-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//stroke-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//stroke-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-rectangle//stroke-color?": {
		Doc:   "Get canvas.Rectangle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//stroke-color?: arg 1: expected native of type canvas.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//stroke-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"canvas-rectangle//stroke-width!": {
		Doc:   "Set canvas.Rectangle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//stroke-width!: arg 1: expected native of type canvas.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//stroke-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//stroke-width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-rectangle//stroke-width?": {
		Doc:   "Get canvas.Rectangle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-rectangle//stroke-width?: arg 1: expected native of type canvas.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-rectangle//stroke-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"canvas-refresh": {
		Doc:   "canvas.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-refresh: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("canvas-refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-refresh: arg 1: expected native")
			}
			canvas.Refresh(arg0Val)
			return nil
		},
	},
	"canvas-text//alignment!": {
		Doc:   "Set canvas.Text Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//alignment!: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("canvas-text//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"canvas-text//alignment?": {
		Doc:   "Get canvas.Text Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//alignment?: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"canvas-text//color!": {
		Doc:   "Set canvas.Text Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//color!: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Color, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-text//color?": {
		Doc:   "Get canvas.Text Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//color?: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "color-color")
			return resObj
		},
	},
	"canvas-text//text!": {
		Doc:   "Set canvas.Text Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//text!: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-text//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"canvas-text//text-size!": {
		Doc:   "Set canvas.Text TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//text-size!: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//text-size!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.TextSize = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("canvas-text//text-size!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"canvas-text//text-size?": {
		Doc:   "Get canvas.Text TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//text-size?: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//text-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.TextSize))
			return resObj
		},
	},
	"canvas-text//text-style!": {
		Doc:   "Set canvas.Text TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//text-style!: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"canvas-text//text-style?": {
		Doc:   "Get canvas.Text TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//text-style?: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"canvas-text//text?": {
		Doc:   "Get canvas.Text Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("canvas-text//text?: arg 1: expected native of type canvas.Text")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("canvas-text//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"container-app-tabs//hidden!": {
		Doc:   "Set container.AppTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//hidden!: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"container-app-tabs//hidden?": {
		Doc:   "Get container.AppTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//hidden?: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container-app-tabs//items!": {
		Doc:   "Set container.AppTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//items!: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("container-app-tabs//items!: arg 2: block item: expected native of type *container.TabItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("container-app-tabs//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("container-app-tabs//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//items!: arg 2: expected native of type []*container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"container-app-tabs//items?": {
		Doc:   "Get container.AppTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//items?: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-container-tab-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"container-app-tabs//on-changed!": {
		Doc:   "Set container.AppTabs OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-changed!: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"container-app-tabs//on-changed?": {
		Doc:   "Get container.AppTabs OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-changed?: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"container-app-tabs//on-selected!": {
		Doc:   "Set container.AppTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-selected!: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"container-app-tabs//on-selected?": {
		Doc:   "Get container.AppTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-selected?: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"container-app-tabs//on-unselected!": {
		Doc:   "Set container.AppTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-unselected!: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"container-app-tabs//on-unselected?": {
		Doc:   "Get container.AppTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-app-tabs//on-unselected?: arg 1: expected native of type container.AppTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-app-tabs//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"container-doc-tabs//close-intercept!": {
		Doc:   "Set container.DocTabs CloseIntercept value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//close-intercept!: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//close-intercept!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//close-intercept!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.CloseIntercept = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//close-intercept!: arg 2: expected integer to be 0 or nil")
				}
				self.CloseIntercept = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//close-intercept!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"container-doc-tabs//close-intercept?": {
		Doc:   "Get container.DocTabs CloseIntercept value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//close-intercept?: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//close-intercept?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CloseIntercept, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"container-doc-tabs//create-tab!": {
		Doc:   "Set container.DocTabs CreateTab value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//create-tab!: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//create-tab!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//create-tab!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateTab = func() *container.TabItem {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res *container.TabItem
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(*container.TabItem)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//create-tab!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateTab = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//create-tab!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"container-doc-tabs//create-tab?": {
		Doc:   "Get container.DocTabs CreateTab value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//create-tab?: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//create-tab?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateTab, "func()_(ptr-container-tab-item)")
			return resObj
		},
	},
	"container-doc-tabs//hidden!": {
		Doc:   "Set container.DocTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//hidden!: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"container-doc-tabs//hidden?": {
		Doc:   "Get container.DocTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//hidden?: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container-doc-tabs//items!": {
		Doc:   "Set container.DocTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//items!: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("container-doc-tabs//items!: arg 2: block item: expected native of type *container.TabItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("container-doc-tabs//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("container-doc-tabs//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//items!: arg 2: expected native of type []*container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"container-doc-tabs//items?": {
		Doc:   "Get container.DocTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//items?: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-container-tab-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"container-doc-tabs//on-closed!": {
		Doc:   "Set container.DocTabs OnClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-closed!: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//on-closed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-closed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnClosed = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-closed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnClosed = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//on-closed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"container-doc-tabs//on-closed?": {
		Doc:   "Get container.DocTabs OnClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-closed?: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//on-closed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnClosed, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"container-doc-tabs//on-selected!": {
		Doc:   "Set container.DocTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-selected!: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"container-doc-tabs//on-selected?": {
		Doc:   "Get container.DocTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-selected?: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"container-doc-tabs//on-unselected!": {
		Doc:   "Set container.DocTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-unselected!: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"container-doc-tabs//on-unselected?": {
		Doc:   "Get container.DocTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-doc-tabs//on-unselected?: arg 1: expected native of type container.DocTabs")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-doc-tabs//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"container-container": {
		Doc:   "container.New",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-container: arg 1: expected native of type fyne.Layout")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-container: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-container: arg 1: expected native")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("container-container: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("container-container: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("container-container: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-container: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-container: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-container: arg 2: expected block, native or nil")
			}
			res0 := container.New(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"adaptive-grid": {
		Doc:   "container.NewAdaptiveGrid",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("adaptive-grid: arg 1: expected integer")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("adaptive-grid: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("adaptive-grid: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("adaptive-grid: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("adaptive-grid: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("adaptive-grid: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("adaptive-grid: arg 2: expected block, native or nil")
			}
			res0 := container.NewAdaptiveGrid(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"app-tabs": {
		Doc:   "container.NewAppTabs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*container.TabItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("app-tabs: arg 1: block item: expected native of type *container.TabItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("app-tabs: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("app-tabs: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-tabs: arg 1: expected native of type []*container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("app-tabs: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("app-tabs: arg 1: expected block, native or nil")
			}
			res0 := container.NewAppTabs(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-app-tabs")
			return res0Obj
		},
	},
	"border": {
		Doc:   "container.NewBorder",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("border: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("border: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("border: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("border: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("border: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("border: arg 2: expected native")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("border: arg 3: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("border: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("border: arg 3: expected native")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("border: arg 4: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("border: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("border: arg 4: expected native")
			}
			var arg4Val []fyne.CanvasObject
			switch v := arg4.(type) {
			case env.Block:
				arg4Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg4Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("border: arg 5: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("border: arg 5: block item: expected integer to be 0 or nil")
						}
						arg4Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("border: arg 5: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("border: arg 5: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("border: arg 5: expected integer to be 0 or nil")
				}
				arg4Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("border: arg 5: expected block, native or nil")
			}
			res0 := container.NewBorder(arg0Val, arg1Val, arg2Val, arg3Val, arg4Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"center": {
		Doc:   "container.NewCenter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("center: arg 1: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("center: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("center: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("center: arg 1: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("center: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("center: arg 1: expected block, native or nil")
			}
			res0 := container.NewCenter(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"doc-tabs": {
		Doc:   "container.NewDocTabs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*container.TabItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("doc-tabs: arg 1: block item: expected native of type *container.TabItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("doc-tabs: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("doc-tabs: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("doc-tabs: arg 1: expected native of type []*container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("doc-tabs: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("doc-tabs: arg 1: expected block, native or nil")
			}
			res0 := container.NewDocTabs(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-doc-tabs")
			return res0Obj
		},
	},
	"grid-with-columns": {
		Doc:   "container.NewGridWithColumns",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("grid-with-columns: arg 1: expected integer")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("grid-with-columns: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("grid-with-columns: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("grid-with-columns: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("grid-with-columns: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-with-columns: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("grid-with-columns: arg 2: expected block, native or nil")
			}
			res0 := container.NewGridWithColumns(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"grid-with-rows": {
		Doc:   "container.NewGridWithRows",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("grid-with-rows: arg 1: expected integer")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("grid-with-rows: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("grid-with-rows: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("grid-with-rows: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("grid-with-rows: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-with-rows: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("grid-with-rows: arg 2: expected block, native or nil")
			}
			res0 := container.NewGridWithRows(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"container-grid-wrap": {
		Doc:   "container.NewGridWrap",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-grid-wrap: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-grid-wrap: arg 1: expected native")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("container-grid-wrap: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("container-grid-wrap: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("container-grid-wrap: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-grid-wrap: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-grid-wrap: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-grid-wrap: arg 2: expected block, native or nil")
			}
			res0 := container.NewGridWrap(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"h-box": {
		Doc:   "container.NewHBox",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("h-box: arg 1: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("h-box: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("h-box: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("h-box: arg 1: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("h-box: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("h-box: arg 1: expected block, native or nil")
			}
			res0 := container.NewHBox(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"h-scroll": {
		Doc:   "container.NewHScroll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("h-scroll: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("h-scroll: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("h-scroll: arg 1: expected native")
			}
			res0 := container.NewHScroll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-scroll")
			return res0Obj
		},
	},
	"h-split": {
		Doc:   "container.NewHSplit",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("h-split: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("h-split: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("h-split: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("h-split: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("h-split: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("h-split: arg 2: expected native")
			}
			res0 := container.NewHSplit(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-split")
			return res0Obj
		},
	},
	"container-max": {
		Doc:   "container.NewMax",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("container-max: arg 1: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("container-max: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("container-max: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-max: arg 1: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-max: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-max: arg 1: expected block, native or nil")
			}
			res0 := container.NewMax(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"padded": {
		Doc:   "container.NewPadded",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("padded: arg 1: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("padded: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("padded: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("padded: arg 1: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("padded: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("padded: arg 1: expected block, native or nil")
			}
			res0 := container.NewPadded(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"scroll": {
		Doc:   "container.NewScroll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("scroll: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("scroll: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("scroll: arg 1: expected native")
			}
			res0 := container.NewScroll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-scroll")
			return res0Obj
		},
	},
	"stack": {
		Doc:   "container.NewStack",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("stack: arg 1: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("stack: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("stack: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("stack: arg 1: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("stack: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("stack: arg 1: expected block, native or nil")
			}
			res0 := container.NewStack(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"tab-item": {
		Doc:   "container.NewTabItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("tab-item: arg 1: expected string")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("tab-item: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("tab-item: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("tab-item: arg 2: expected native")
			}
			res0 := container.NewTabItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-tab-item")
			return res0Obj
		},
	},
	"tab-item-with-icon": {
		Doc:   "container.NewTabItemWithIcon",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("tab-item-with-icon: arg 1: expected string")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("tab-item-with-icon: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("tab-item-with-icon: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("tab-item-with-icon: arg 2: expected native")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("tab-item-with-icon: arg 3: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("tab-item-with-icon: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("tab-item-with-icon: arg 3: expected native")
			}
			res0 := container.NewTabItemWithIcon(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-tab-item")
			return res0Obj
		},
	},
	"v-box": {
		Doc:   "container.NewVBox",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("v-box: arg 1: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("v-box: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("v-box: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("v-box: arg 1: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("v-box: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("v-box: arg 1: expected block, native or nil")
			}
			res0 := container.NewVBox(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"v-scroll": {
		Doc:   "container.NewVScroll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("v-scroll: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("v-scroll: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("v-scroll: arg 1: expected native")
			}
			res0 := container.NewVScroll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-scroll")
			return res0Obj
		},
	},
	"v-split": {
		Doc:   "container.NewVSplit",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("v-split: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("v-split: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("v-split: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("v-split: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("v-split: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("v-split: arg 2: expected native")
			}
			res0 := container.NewVSplit(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-split")
			return res0Obj
		},
	},
	"without-layout": {
		Doc:   "container.NewWithoutLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("without-layout: arg 1: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("without-layout: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("without-layout: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("without-layout: arg 1: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("without-layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("without-layout: arg 1: expected block, native or nil")
			}
			res0 := container.NewWithoutLayout(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"scroll-both": {
		Doc:   "Get container.ScrollBoth value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(container.ScrollBoth)))
			return resObj
		},
	},
	"scroll-horizontal-only": {
		Doc:   "Get container.ScrollHorizontalOnly value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(container.ScrollHorizontalOnly)))
			return resObj
		},
	},
	"scroll-none": {
		Doc:   "Get container.ScrollNone value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(container.ScrollNone)))
			return resObj
		},
	},
	"scroll-vertical-only": {
		Doc:   "Get container.ScrollVerticalOnly value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(container.ScrollVerticalOnly)))
			return resObj
		},
	},
	"container-split//hidden!": {
		Doc:   "Set container.Split Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//hidden!: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("container-split//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"container-split//hidden?": {
		Doc:   "Get container.Split Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//hidden?: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container-split//horizontal!": {
		Doc:   "Set container.Split Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//horizontal!: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//horizontal!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("container-split//horizontal!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"container-split//horizontal?": {
		Doc:   "Get container.Split Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//horizontal?: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//horizontal?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"container-split//leading!": {
		Doc:   "Set container.Split Leading value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//leading!: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//leading!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Leading, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//leading!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-split//leading!: arg 2: expected integer to be 0 or nil")
				}
				self.Leading = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//leading!: arg 2: expected native")
			}
			return arg0
		},
	},
	"container-split//leading?": {
		Doc:   "Get container.Split Leading value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//leading?: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//leading?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Leading)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Leading, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Leading, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"container-split//offset!": {
		Doc:   "Set container.Split Offset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//offset!: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//offset!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Offset = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("container-split//offset!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"container-split//offset?": {
		Doc:   "Get container.Split Offset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//offset?: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//offset?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Offset))
			return resObj
		},
	},
	"container-split//trailing!": {
		Doc:   "Set container.Split Trailing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//trailing!: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//trailing!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Trailing, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//trailing!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-split//trailing!: arg 2: expected integer to be 0 or nil")
				}
				self.Trailing = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//trailing!: arg 2: expected native")
			}
			return arg0
		},
	},
	"container-split//trailing?": {
		Doc:   "Get container.Split Trailing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-split//trailing?: arg 1: expected native of type container.Split")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-split//trailing?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Trailing)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Trailing, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Trailing, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"container-tab-item//content!": {
		Doc:   "Set container.TabItem Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//content!: arg 1: expected native of type container.TabItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-tab-item//content!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//content!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//content!: arg 2: expected integer to be 0 or nil")
				}
				self.Content = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-tab-item//content!: arg 2: expected native")
			}
			return arg0
		},
	},
	"container-tab-item//content?": {
		Doc:   "Get container.TabItem Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//content?: arg 1: expected native of type container.TabItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-tab-item//content?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Content)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Content, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"container-tab-item//icon!": {
		Doc:   "Set container.TabItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//icon!: arg 1: expected native of type container.TabItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-tab-item//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-tab-item//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"container-tab-item//icon?": {
		Doc:   "Get container.TabItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//icon?: arg 1: expected native of type container.TabItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-tab-item//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"container-tab-item//text!": {
		Doc:   "Set container.TabItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//text!: arg 1: expected native of type container.TabItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-tab-item//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("container-tab-item//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"container-tab-item//text?": {
		Doc:   "Get container.TabItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-tab-item//text?: arg 1: expected native of type container.TabItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("container-tab-item//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"tab-location-bottom": {
		Doc:   "Get container.TabLocationBottom value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(container.TabLocationBottom)))
			return resObj
		},
	},
	"tab-location-leading": {
		Doc:   "Get container.TabLocationLeading value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(container.TabLocationLeading)))
			return resObj
		},
	},
	"tab-location-top": {
		Doc:   "Get container.TabLocationTop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(container.TabLocationTop)))
			return resObj
		},
	},
	"tab-location-trailing": {
		Doc:   "Get container.TabLocationTrailing value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(container.TabLocationTrailing)))
			return resObj
		},
	},
	"desktop-app//set-system-tray-icon": {
		Doc:   "desktop.App.SetSystemTrayIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-app//set-system-tray-icon: arg 1: expected native of type desktop.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-app//set-system-tray-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-app//set-system-tray-icon: arg 1: expected native")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-app//set-system-tray-icon: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-app//set-system-tray-icon: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-app//set-system-tray-icon: arg 2: expected native")
			}
			arg0Val.SetSystemTrayIcon(arg1Val)
			return arg0
		},
	},
	"desktop-app//set-system-tray-menu": {
		Doc:   "desktop.App.SetSystemTrayMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-app//set-system-tray-menu: arg 1: expected native of type desktop.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-app//set-system-tray-menu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-app//set-system-tray-menu: arg 1: expected native")
			}
			var arg1Val *fyne.Menu
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-app//set-system-tray-menu: arg 2: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-app//set-system-tray-menu: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-app//set-system-tray-menu: arg 2: expected native")
			}
			arg0Val.SetSystemTrayMenu(arg1Val)
			return arg0
		},
	},
	"desktop-canvas//on-key-down": {
		Doc:   "desktop.Canvas.OnKeyDown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//on-key-down: arg 1: expected native of type desktop.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//on-key-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-canvas//on-key-down: arg 1: expected native")
			}
			res0 := arg0Val.OnKeyDown()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "func(ptr-fyne-key-event)")
			return res0Obj
		},
	},
	"desktop-canvas//on-key-up": {
		Doc:   "desktop.Canvas.OnKeyUp",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//on-key-up: arg 1: expected native of type desktop.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//on-key-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-canvas//on-key-up: arg 1: expected native")
			}
			res0 := arg0Val.OnKeyUp()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "func(ptr-fyne-key-event)")
			return res0Obj
		},
	},
	"desktop-canvas//set-on-key-down": {
		Doc:   "desktop.Canvas.SetOnKeyDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//set-on-key-down: arg 1: expected native of type desktop.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//set-on-key-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-canvas//set-on-key-down: arg 1: expected native")
			}
			var arg1Val func(*fyne.KeyEvent)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//set-on-key-down: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 *fyne.KeyEvent) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-fyne-key-event")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//set-on-key-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-canvas//set-on-key-down: arg 2: expected function or nil")
			}
			arg0Val.SetOnKeyDown(arg1Val)
			return arg0
		},
	},
	"desktop-canvas//set-on-key-up": {
		Doc:   "desktop.Canvas.SetOnKeyUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//set-on-key-up: arg 1: expected native of type desktop.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//set-on-key-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-canvas//set-on-key-up: arg 1: expected native")
			}
			var arg1Val func(*fyne.KeyEvent)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//set-on-key-up: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 *fyne.KeyEvent) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-fyne-key-event")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-canvas//set-on-key-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-canvas//set-on-key-up: arg 2: expected function or nil")
			}
			arg0Val.SetOnKeyUp(arg1Val)
			return arg0
		},
	},
	"desktop-crosshair-cursor": {
		Doc:   "Get desktop.CrosshairCursor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.CrosshairCursor)))
			return resObj
		},
	},
	"desktop-cursor//image": {
		Doc:   "desktop.Cursor.Image",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Cursor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Cursor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-cursor//image: arg 1: expected native of type desktop.Cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-cursor//image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-cursor//image: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.Image()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
				"3": res2Obj,
			})
		},
	},
	"desktop-cursorable//cursor": {
		Doc:   "desktop.Cursorable.Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Cursorable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Cursorable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-cursorable//cursor: arg 1: expected native of type desktop.Cursorable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-cursorable//cursor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-cursorable//cursor: arg 1: expected native")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
				}
			}
			return res0Obj
		},
	},
	"desktop-custom-shortcut//modifier!": {
		Doc:   "Set desktop.CustomShortcut Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.CustomShortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-custom-shortcut//modifier!: arg 1: expected native of type desktop.CustomShortcut")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-custom-shortcut//modifier!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.KeyModifier
				if natOk {
					natVal, natValOk = nat.Value.(fyne.KeyModifier)
				}
				if natOk && natValOk {
					self.Modifier = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("desktop-custom-shortcut//modifier!: arg 2: expected integer")
					}
					self.Modifier = fyne.KeyModifier(u)
				}
			}
			return arg0
		},
	},
	"desktop-custom-shortcut//modifier?": {
		Doc:   "Get desktop.CustomShortcut Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.CustomShortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-custom-shortcut//modifier?: arg 1: expected native of type desktop.CustomShortcut")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-custom-shortcut//modifier?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Modifier)))
			return resObj
		},
	},
	"desktop-default-cursor": {
		Doc:   "Get desktop.DefaultCursor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.DefaultCursor)))
			return resObj
		},
	},
	"desktop-driver//create-splash-window": {
		Doc:   "desktop.Driver.CreateSplashWindow",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-driver//create-splash-window: arg 1: expected native of type desktop.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-driver//create-splash-window: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-driver//create-splash-window: arg 1: expected native")
			}
			res0 := arg0Val.CreateSplashWindow()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-window")
				}
			}
			return res0Obj
		},
	},
	"desktop-driver//current-key-modifiers": {
		Doc:   "desktop.Driver.CurrentKeyModifiers",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-driver//current-key-modifiers: arg 1: expected native of type desktop.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-driver//current-key-modifiers: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-driver//current-key-modifiers: arg 1: expected native")
			}
			res0 := arg0Val.CurrentKeyModifiers()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"desktop-h-resize-cursor": {
		Doc:   "Get desktop.HResizeCursor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.HResizeCursor)))
			return resObj
		},
	},
	"desktop-hidden-cursor": {
		Doc:   "Get desktop.HiddenCursor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.HiddenCursor)))
			return resObj
		},
	},
	"desktop-hoverable//mouse-in": {
		Doc:   "desktop.Hoverable.MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Hoverable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Hoverable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-in: arg 1: expected native of type desktop.Hoverable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-in: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-hoverable//mouse-in: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-in: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-in: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-hoverable//mouse-in: arg 2: expected native")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"desktop-hoverable//mouse-moved": {
		Doc:   "desktop.Hoverable.MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Hoverable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Hoverable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-moved: arg 1: expected native of type desktop.Hoverable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-moved: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-hoverable//mouse-moved: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-moved: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-moved: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-hoverable//mouse-moved: arg 2: expected native")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"desktop-hoverable//mouse-out": {
		Doc:   "desktop.Hoverable.MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Hoverable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Hoverable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-out: arg 1: expected native of type desktop.Hoverable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-hoverable//mouse-out: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-hoverable//mouse-out: arg 1: expected native")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"desktop-key-alt-left": {
		Doc:   "Get desktop.KeyAltLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyAltLeft))
			return resObj
		},
	},
	"desktop-key-alt-right": {
		Doc:   "Get desktop.KeyAltRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyAltRight))
			return resObj
		},
	},
	"desktop-key-caps-lock": {
		Doc:   "Get desktop.KeyCapsLock value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyCapsLock))
			return resObj
		},
	},
	"desktop-key-control-left": {
		Doc:   "Get desktop.KeyControlLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyControlLeft))
			return resObj
		},
	},
	"desktop-key-control-right": {
		Doc:   "Get desktop.KeyControlRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyControlRight))
			return resObj
		},
	},
	"desktop-key-menu": {
		Doc:   "Get desktop.KeyMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyMenu))
			return resObj
		},
	},
	"desktop-key-none": {
		Doc:   "Get desktop.KeyNone value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyNone))
			return resObj
		},
	},
	"desktop-key-print-screen": {
		Doc:   "Get desktop.KeyPrintScreen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyPrintScreen))
			return resObj
		},
	},
	"desktop-key-shift-left": {
		Doc:   "Get desktop.KeyShiftLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyShiftLeft))
			return resObj
		},
	},
	"desktop-key-shift-right": {
		Doc:   "Get desktop.KeyShiftRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeyShiftRight))
			return resObj
		},
	},
	"desktop-key-super-left": {
		Doc:   "Get desktop.KeySuperLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeySuperLeft))
			return resObj
		},
	},
	"desktop-key-super-right": {
		Doc:   "Get desktop.KeySuperRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(desktop.KeySuperRight))
			return resObj
		},
	},
	"desktop-left-mouse-button": {
		Doc:   "Get desktop.LeftMouseButton value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.LeftMouseButton)))
			return resObj
		},
	},
	"desktop-mouse-button-primary": {
		Doc:   "Get desktop.MouseButtonPrimary value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.MouseButtonPrimary)))
			return resObj
		},
	},
	"desktop-mouse-button-secondary": {
		Doc:   "Get desktop.MouseButtonSecondary value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.MouseButtonSecondary)))
			return resObj
		},
	},
	"desktop-mouse-button-tertiary": {
		Doc:   "Get desktop.MouseButtonTertiary value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.MouseButtonTertiary)))
			return resObj
		},
	},
	"desktop-mouse-event//absolute-position!": {
		Doc:   "Set desktop.MouseEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//absolute-position!: arg 1: expected native of type desktop.MouseEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"desktop-mouse-event//absolute-position?": {
		Doc:   "Get desktop.MouseEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//absolute-position?: arg 1: expected native of type desktop.MouseEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"desktop-mouse-event//button!": {
		Doc:   "Set desktop.MouseEvent Button value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//button!: arg 1: expected native of type desktop.MouseEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//button!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal desktop.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(desktop.MouseButton)
				}
				if natOk && natValOk {
					self.Button = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("desktop-mouse-event//button!: arg 2: expected integer")
					}
					self.Button = desktop.MouseButton(u)
				}
			}
			return arg0
		},
	},
	"desktop-mouse-event//button?": {
		Doc:   "Get desktop.MouseEvent Button value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//button?: arg 1: expected native of type desktop.MouseEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//button?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Button)))
			return resObj
		},
	},
	"desktop-mouse-event//modifier!": {
		Doc:   "Set desktop.MouseEvent Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//modifier!: arg 1: expected native of type desktop.MouseEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//modifier!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.KeyModifier
				if natOk {
					natVal, natValOk = nat.Value.(fyne.KeyModifier)
				}
				if natOk && natValOk {
					self.Modifier = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("desktop-mouse-event//modifier!: arg 2: expected integer")
					}
					self.Modifier = fyne.KeyModifier(u)
				}
			}
			return arg0
		},
	},
	"desktop-mouse-event//modifier?": {
		Doc:   "Get desktop.MouseEvent Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//modifier?: arg 1: expected native of type desktop.MouseEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//modifier?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Modifier)))
			return resObj
		},
	},
	"desktop-mouse-event//position!": {
		Doc:   "Set desktop.MouseEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//position!: arg 1: expected native of type desktop.MouseEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"desktop-mouse-event//position?": {
		Doc:   "Get desktop.MouseEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouse-event//position?: arg 1: expected native of type desktop.MouseEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouse-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"desktop-mouseable//mouse-down": {
		Doc:   "desktop.Mouseable.MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Mouseable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Mouseable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouseable//mouse-down: arg 1: expected native of type desktop.Mouseable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-mouseable//mouse-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouseable//mouse-down: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouseable//mouse-down: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-mouseable//mouse-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouseable//mouse-down: arg 2: expected native")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"desktop-mouseable//mouse-up": {
		Doc:   "desktop.Mouseable.MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Mouseable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Mouseable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouseable//mouse-up: arg 1: expected native of type desktop.Mouseable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-mouseable//mouse-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouseable//mouse-up: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("desktop-mouseable//mouse-up: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("desktop-mouseable//mouse-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("desktop-mouseable//mouse-up: arg 2: expected native")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"desktop-pointer-cursor": {
		Doc:   "Get desktop.PointerCursor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.PointerCursor)))
			return resObj
		},
	},
	"desktop-right-mouse-button": {
		Doc:   "Get desktop.RightMouseButton value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.RightMouseButton)))
			return resObj
		},
	},
	"desktop-standard-cursor//image": {
		Doc:   "desktop.StandardCursor.Image",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.StandardCursor
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal desktop.StandardCursor
				if natOk {
					natVal, natValOk = nat.Value.(desktop.StandardCursor)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("desktop-standard-cursor//image: arg 1: expected integer")
					}
					arg0Val = desktop.StandardCursor(u)
				}
			}
			res0, res1, res2 := arg0Val.Image()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
				"3": res2Obj,
			})
		},
	},
	"desktop-text-cursor": {
		Doc:   "Get desktop.TextCursor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.TextCursor)))
			return resObj
		},
	},
	"desktop-v-resize-cursor": {
		Doc:   "Get desktop.VResizeCursor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(desktop.VResizeCursor)))
			return resObj
		},
	},
	"dialog-color-picker-dialog//advanced!": {
		Doc:   "Set dialog.ColorPickerDialog Advanced value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(dialog.ColorPickerDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-color-picker-dialog//advanced!: arg 1: expected native of type dialog.ColorPickerDialog")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-color-picker-dialog//advanced!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Advanced = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-color-picker-dialog//advanced!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"dialog-color-picker-dialog//advanced?": {
		Doc:   "Get dialog.ColorPickerDialog Advanced value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(dialog.ColorPickerDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-color-picker-dialog//advanced?: arg 1: expected native of type dialog.ColorPickerDialog")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-color-picker-dialog//advanced?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Advanced))
			return resObj
		},
	},
	"dialog-dialog//hide": {
		Doc:   "dialog.Dialog.Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//hide: arg 1: expected native of type dialog.Dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"dialog-dialog//min-size": {
		Doc:   "dialog.Dialog.MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//min-size: arg 1: expected native of type dialog.Dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"dialog-dialog//refresh": {
		Doc:   "dialog.Dialog.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//refresh: arg 1: expected native of type dialog.Dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"dialog-dialog//resize": {
		Doc:   "dialog.Dialog.Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//resize: arg 1: expected native of type dialog.Dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"dialog-dialog//set-dismiss-text": {
		Doc:   "dialog.Dialog.SetDismissText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//set-dismiss-text: arg 1: expected native of type dialog.Dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//set-dismiss-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//set-dismiss-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//set-dismiss-text: arg 2: expected string")
			}
			arg0Val.SetDismissText(arg1Val)
			return arg0
		},
	},
	"dialog-dialog//set-on-closed": {
		Doc:   "dialog.Dialog.SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//set-on-closed: arg 1: expected native of type dialog.Dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//set-on-closed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//set-on-closed: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//set-on-closed: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//set-on-closed: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//set-on-closed: arg 2: expected function or nil")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"dialog-dialog//show": {
		Doc:   "dialog.Dialog.Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//show: arg 1: expected native of type dialog.Dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-dialog//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-dialog//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"dialog-color-picker": {
		Doc:   "dialog.NewColorPicker",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-color-picker: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-color-picker: arg 2: expected string")
			}
			var arg2Val func(color.Color)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("dialog-color-picker: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 color.Color) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "color-color")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-color-picker: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-color-picker: arg 3: expected function or nil")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-color-picker: arg 4: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-color-picker: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-color-picker: arg 4: expected native")
			}
			res0 := dialog.NewColorPicker(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-color-picker-dialog")
			return res0Obj
		},
	},
	"dialog-confirm": {
		Doc:   "dialog.NewConfirm",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-confirm: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-confirm: arg 2: expected string")
			}
			var arg2Val func(bool)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("dialog-confirm: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-confirm: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-confirm: arg 3: expected function or nil")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-confirm: arg 4: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-confirm: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-confirm: arg 4: expected native")
			}
			res0 := dialog.NewConfirm(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-confirm-dialog")
			return res0Obj
		},
	},
	"dialog-custom": {
		Doc:   "dialog.NewCustom",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-custom: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-custom: arg 2: expected string")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-custom: arg 3: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-custom: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-custom: arg 3: expected native")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-custom: arg 4: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-custom: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-custom: arg 4: expected native")
			}
			res0 := dialog.NewCustom(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-custom-dialog")
			return res0Obj
		},
	},
	"dialog-custom-without-buttons": {
		Doc:   "dialog.NewCustomWithoutButtons",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-custom-without-buttons: arg 1: expected string")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-custom-without-buttons: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-custom-without-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-custom-without-buttons: arg 2: expected native")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-custom-without-buttons: arg 3: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-custom-without-buttons: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-custom-without-buttons: arg 3: expected native")
			}
			res0 := dialog.NewCustomWithoutButtons(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-custom-dialog")
			return res0Obj
		},
	},
	"dialog-entry-dialog": {
		Doc:   "dialog.NewEntryDialog",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-entry-dialog: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-entry-dialog: arg 2: expected string")
			}
			var arg2Val func(string)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("dialog-entry-dialog: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-entry-dialog: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-entry-dialog: arg 3: expected function or nil")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-entry-dialog: arg 4: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-entry-dialog: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-entry-dialog: arg 4: expected native")
			}
			res0 := dialog.NewEntryDialog(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-entry-dialog")
			return res0Obj
		},
	},
	"dialog-error": {
		Doc:   "dialog.NewError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val error
			switch v := arg0.(type) {
			case env.String:
				arg0Val = errors.New(v.Value)
			case env.Error:
				arg0Val = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-error: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-error: arg 1: expected error, string or nil")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-error: arg 2: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-error: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-error: arg 2: expected native")
			}
			res0 := dialog.NewError(arg0Val, arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "dialog-dialog")
				}
			}
			return res0Obj
		},
	},
	"dialog-file-open": {
		Doc:   "dialog.NewFileOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.URIReadCloser, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("dialog-file-open: arg 1: function has invalid number of arguments (expected 2)")
				}
				arg0Val = func(arg0 fyne.URIReadCloser, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-uri-read-closer")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-file-open: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-file-open: arg 1: expected function or nil")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-file-open: arg 2: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-file-open: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-file-open: arg 2: expected native")
			}
			res0 := dialog.NewFileOpen(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-file-dialog")
			return res0Obj
		},
	},
	"dialog-file-save": {
		Doc:   "dialog.NewFileSave",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.URIWriteCloser, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("dialog-file-save: arg 1: function has invalid number of arguments (expected 2)")
				}
				arg0Val = func(arg0 fyne.URIWriteCloser, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-uri-write-closer")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-file-save: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-file-save: arg 1: expected function or nil")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-file-save: arg 2: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-file-save: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-file-save: arg 2: expected native")
			}
			res0 := dialog.NewFileSave(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-file-dialog")
			return res0Obj
		},
	},
	"dialog-folder-open": {
		Doc:   "dialog.NewFolderOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.ListableURI, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("dialog-folder-open: arg 1: function has invalid number of arguments (expected 2)")
				}
				arg0Val = func(arg0 fyne.ListableURI, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-listable-uri")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-folder-open: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-folder-open: arg 1: expected function or nil")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-folder-open: arg 2: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-folder-open: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-folder-open: arg 2: expected native")
			}
			res0 := dialog.NewFolderOpen(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-file-dialog")
			return res0Obj
		},
	},
	"dialog-information": {
		Doc:   "dialog.NewInformation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-information: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-information: arg 2: expected string")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-information: arg 3: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-information: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-information: arg 3: expected native")
			}
			res0 := dialog.NewInformation(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "dialog-dialog")
				}
			}
			return res0Obj
		},
	},
	"dialog-progress": {
		Doc:   "dialog.NewProgress",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-progress: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-progress: arg 2: expected string")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-progress: arg 3: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-progress: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-progress: arg 3: expected native")
			}
			res0 := dialog.NewProgress(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-progress-dialog")
			return res0Obj
		},
	},
	"dialog-progress-infinite": {
		Doc:   "dialog.NewProgressInfinite",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-progress-infinite: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-progress-infinite: arg 2: expected string")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-progress-infinite: arg 3: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-progress-infinite: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-progress-infinite: arg 3: expected native")
			}
			res0 := dialog.NewProgressInfinite(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-dialog-progress-infinite-dialog")
			return res0Obj
		},
	},
	"dialog-show-color-picker": {
		Doc:   "dialog.ShowColorPicker",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-color-picker: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-color-picker: arg 2: expected string")
			}
			var arg2Val func(color.Color)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-color-picker: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 color.Color) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "color-color")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-color-picker: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-color-picker: arg 3: expected function or nil")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-color-picker: arg 4: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-color-picker: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-color-picker: arg 4: expected native")
			}
			dialog.ShowColorPicker(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"dialog-show-confirm": {
		Doc:   "dialog.ShowConfirm",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-confirm: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-confirm: arg 2: expected string")
			}
			var arg2Val func(bool)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-confirm: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-confirm: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-confirm: arg 3: expected function or nil")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-confirm: arg 4: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-confirm: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-confirm: arg 4: expected native")
			}
			dialog.ShowConfirm(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"dialog-show-custom": {
		Doc:   "dialog.ShowCustom",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-custom: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-custom: arg 2: expected string")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-custom: arg 3: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-custom: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-custom: arg 3: expected native")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-custom: arg 4: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-custom: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-custom: arg 4: expected native")
			}
			dialog.ShowCustom(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"dialog-show-custom-without-buttons": {
		Doc:   "dialog.ShowCustomWithoutButtons",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-custom-without-buttons: arg 1: expected string")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-custom-without-buttons: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-custom-without-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-custom-without-buttons: arg 2: expected native")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-custom-without-buttons: arg 3: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-custom-without-buttons: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-custom-without-buttons: arg 3: expected native")
			}
			dialog.ShowCustomWithoutButtons(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"dialog-show-entry-dialog": {
		Doc:   "dialog.ShowEntryDialog",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-entry-dialog: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-entry-dialog: arg 2: expected string")
			}
			var arg2Val func(string)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-entry-dialog: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-entry-dialog: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-entry-dialog: arg 3: expected function or nil")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-entry-dialog: arg 4: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-entry-dialog: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-entry-dialog: arg 4: expected native")
			}
			dialog.ShowEntryDialog(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"dialog-show-error": {
		Doc:   "dialog.ShowError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val error
			switch v := arg0.(type) {
			case env.String:
				arg0Val = errors.New(v.Value)
			case env.Error:
				arg0Val = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-error: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-error: arg 1: expected error, string or nil")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-error: arg 2: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-error: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-error: arg 2: expected native")
			}
			dialog.ShowError(arg0Val, arg1Val)
			return nil
		},
	},
	"dialog-show-file-open": {
		Doc:   "dialog.ShowFileOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.URIReadCloser, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-file-open: arg 1: function has invalid number of arguments (expected 2)")
				}
				arg0Val = func(arg0 fyne.URIReadCloser, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-uri-read-closer")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-file-open: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-file-open: arg 1: expected function or nil")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-file-open: arg 2: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-file-open: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-file-open: arg 2: expected native")
			}
			dialog.ShowFileOpen(arg0Val, arg1Val)
			return nil
		},
	},
	"dialog-show-file-save": {
		Doc:   "dialog.ShowFileSave",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.URIWriteCloser, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-file-save: arg 1: function has invalid number of arguments (expected 2)")
				}
				arg0Val = func(arg0 fyne.URIWriteCloser, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-uri-write-closer")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-file-save: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-file-save: arg 1: expected function or nil")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-file-save: arg 2: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-file-save: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-file-save: arg 2: expected native")
			}
			dialog.ShowFileSave(arg0Val, arg1Val)
			return nil
		},
	},
	"dialog-show-folder-open": {
		Doc:   "dialog.ShowFolderOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.ListableURI, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-folder-open: arg 1: function has invalid number of arguments (expected 2)")
				}
				arg0Val = func(arg0 fyne.ListableURI, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-listable-uri")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-folder-open: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-folder-open: arg 1: expected function or nil")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-folder-open: arg 2: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-folder-open: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-folder-open: arg 2: expected native")
			}
			dialog.ShowFolderOpen(arg0Val, arg1Val)
			return nil
		},
	},
	"dialog-show-information": {
		Doc:   "dialog.ShowInformation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-information: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("dialog-show-information: arg 2: expected string")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("dialog-show-information: arg 3: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("dialog-show-information: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("dialog-show-information: arg 3: expected native")
			}
			dialog.ShowInformation(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"driver-1-android-context//ctx!": {
		Doc:   "Set driver_1.AndroidContext Ctx value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("driver-1-android-context//ctx!: arg 1: expected native of type driver_1.AndroidContext")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-android-context//ctx!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Ctx, ok = v.Value.(uintptr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("driver-1-android-context//ctx!: arg 2: expected native of type uintptr")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-android-context//ctx!: arg 2: expected native")
			}
			return arg0
		},
	},
	"driver-1-android-context//ctx?": {
		Doc:   "Get driver_1.AndroidContext Ctx value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("driver-1-android-context//ctx?: arg 1: expected native of type driver_1.AndroidContext")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-android-context//ctx?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Ctx, "uintptr")
			return resObj
		},
	},
	"driver-1-android-context//env!": {
		Doc:   "Set driver_1.AndroidContext Env value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("driver-1-android-context//env!: arg 1: expected native of type driver_1.AndroidContext")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-android-context//env!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Env, ok = v.Value.(uintptr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("driver-1-android-context//env!: arg 2: expected native of type uintptr")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-android-context//env!: arg 2: expected native")
			}
			return arg0
		},
	},
	"driver-1-android-context//env?": {
		Doc:   "Get driver_1.AndroidContext Env value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("driver-1-android-context//env?: arg 1: expected native of type driver_1.AndroidContext")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-android-context//env?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Env, "uintptr")
			return resObj
		},
	},
	"driver-1-android-context//vm!": {
		Doc:   "Set driver_1.AndroidContext VM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("driver-1-android-context//vm!: arg 1: expected native of type driver_1.AndroidContext")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-android-context//vm!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.VM, ok = v.Value.(uintptr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("driver-1-android-context//vm!: arg 2: expected native of type uintptr")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-android-context//vm!: arg 2: expected native")
			}
			return arg0
		},
	},
	"driver-1-android-context//vm?": {
		Doc:   "Get driver_1.AndroidContext VM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("driver-1-android-context//vm?: arg 1: expected native of type driver_1.AndroidContext")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-android-context//vm?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.VM, "uintptr")
			return resObj
		},
	},
	"driver-1-run-native": {
		Doc:   "driver_1.RunNative",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(any) error
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("driver-1-run-native: arg 1: function has invalid number of arguments (expected 1)")
				}
				arg0Val = func(arg0 any) error {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "any")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res error
					switch v := ps.Res.(type) {
					case env.String:
						res = errors.New(v.Value)
					case env.Error:
						res = errors.New(v.Print(*ps.Idx))
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("driver-1-run-native: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("driver-1-run-native: arg 1: expected function or nil")
			}
			res0 := driver_1.RunNative(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"fyne-animation//auto-reverse!": {
		Doc:   "Set fyne.Animation AutoReverse value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//auto-reverse!: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//auto-reverse!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AutoReverse = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-animation//auto-reverse!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-animation//auto-reverse?": {
		Doc:   "Get fyne.Animation AutoReverse value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//auto-reverse?: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//auto-reverse?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AutoReverse))
			return resObj
		},
	},
	"fyne-animation//curve!": {
		Doc:   "Set fyne.Animation Curve value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//curve!: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//curve!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.AnimationCurve
				if natOk {
					natVal, natValOk = nat.Value.(fyne.AnimationCurve)
				}
				if natOk && natValOk {
					self.Curve = natVal
				} else {
					var u func(float32) float32
					switch fn := arg1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("fyne-animation//curve!: arg 2: function has invalid number of arguments (expected 1)")
						}
						u = func(arg0 float32) float32 {
							var arg0Val env.Object
							arg0Val = *env.NewDecimal(float64(arg0))
							evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
							var res float32
							if v, ok := ps.Res.(env.Decimal); ok {
								res = float32(v.Value)
							} else {
								// TODO: Cannot return error from function
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("fyne-animation//curve!: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("fyne-animation//curve!: arg 2: expected function or nil")
					}
					self.Curve = fyne.AnimationCurve(u)
				}
			}
			return arg0
		},
	},
	"fyne-animation//curve?": {
		Doc:   "Get fyne.Animation Curve value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//curve?: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//curve?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, (func(float32) float32)(self.Curve), "func(float-32)_(float-32)")
			return resObj
		},
	},
	"fyne-animation//duration!": {
		Doc:   "Set fyne.Animation Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//duration!: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-animation//duration?": {
		Doc:   "Get fyne.Animation Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//duration?: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"fyne-animation//repeat-count!": {
		Doc:   "Set fyne.Animation RepeatCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//repeat-count!: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//repeat-count!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.RepeatCount = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-animation//repeat-count!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-animation//repeat-count?": {
		Doc:   "Get fyne.Animation RepeatCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//repeat-count?: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//repeat-count?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.RepeatCount))
			return resObj
		},
	},
	"fyne-animation//tick!": {
		Doc:   "Set fyne.Animation Tick value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//tick!: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//tick!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//tick!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.Tick = func(arg0 float32) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//tick!: arg 2: expected integer to be 0 or nil")
				}
				self.Tick = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//tick!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"fyne-animation//tick?": {
		Doc:   "Get fyne.Animation Tick value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-animation//tick?: arg 1: expected native of type fyne.Animation")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-animation//tick?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Tick, "func(float-32)")
			return resObj
		},
	},
	"fyne-app-metadata//build!": {
		Doc:   "Set fyne.AppMetadata Build value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//build!: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//build!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Build = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//build!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-app-metadata//build?": {
		Doc:   "Get fyne.AppMetadata Build value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//build?: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//build?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Build))
			return resObj
		},
	},
	"fyne-app-metadata//custom!": {
		Doc:   "Set fyne.AppMetadata Custom value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//custom!: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//custom!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//custom!: arg 2: expected block to have length of multiple of 2")
				}
				self.Custom = make(map[string]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-app-metadata//custom!: arg 2: map key: expected string")
					}
					var mapV string
					if v, ok := v.Series.S[i+1].(env.String); ok {
						mapV = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-app-metadata//custom!: arg 2: map value: expected string")
					}
					self.Custom[mapK] = mapV
				}
			case env.Dict:
				self.Custom = make(map[string]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV string
					if v, ok := dictV.(env.String); ok {
						mapV = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-app-metadata//custom!: arg 2: map value: expected string")
					}
					self.Custom[mapK] = mapV
				}
			case env.Native:
				var ok bool
				self.Custom, ok = v.Value.(map[string]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//custom!: arg 2: expected native of type map[string]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//custom!: arg 2: expected integer to be 0 or nil")
				}
				self.Custom = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//custom!: arg 2: expected native, block, dict or nil")
			}
			return arg0
		},
	},
	"fyne-app-metadata//custom?": {
		Doc:   "Get fyne.AppMetadata Custom value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//custom?: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//custom?: arg 1: expected native")
			}
			var resObj env.Object
			{
				data := make(map[string]any, len(self.Custom))
				for mKey, mVal := range self.Custom {
					var dVal env.Object
					dVal = *env.NewString(mVal)
					data[mKey] = dVal
				}
				resObj = *env.NewDict(data)
			}
			return resObj
		},
	},
	"fyne-app-metadata//icon!": {
		Doc:   "Set fyne.AppMetadata Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//icon!: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-app-metadata//icon?": {
		Doc:   "Get fyne.AppMetadata Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//icon?: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"fyne-app-metadata//id!": {
		Doc:   "Set fyne.AppMetadata ID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//id!: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//id!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.ID = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//id!: arg 2: expected string")
			}
			return arg0
		},
	},
	"fyne-app-metadata//id?": {
		Doc:   "Get fyne.AppMetadata ID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//id?: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//id?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ID)
			return resObj
		},
	},
	"fyne-app-metadata//name!": {
		Doc:   "Set fyne.AppMetadata Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//name!: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Name = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"fyne-app-metadata//name?": {
		Doc:   "Get fyne.AppMetadata Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//name?: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Name)
			return resObj
		},
	},
	"fyne-app-metadata//release!": {
		Doc:   "Set fyne.AppMetadata Release value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//release!: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//release!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Release = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//release!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-app-metadata//release?": {
		Doc:   "Get fyne.AppMetadata Release value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//release?: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//release?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Release))
			return resObj
		},
	},
	"fyne-app-metadata//version!": {
		Doc:   "Set fyne.AppMetadata Version value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//version!: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//version!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Version = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//version!: arg 2: expected string")
			}
			return arg0
		},
	},
	"fyne-app-metadata//version?": {
		Doc:   "Get fyne.AppMetadata Version value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app-metadata//version?: arg 1: expected native of type fyne.AppMetadata")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app-metadata//version?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Version)
			return resObj
		},
	},
	"fyne-app//cloud-provider": {
		Doc:   "fyne.App.CloudProvider",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//cloud-provider: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//cloud-provider: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//cloud-provider: arg 1: expected native")
			}
			res0 := arg0Val.CloudProvider()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-cloud-provider")
				}
			}
			return res0Obj
		},
	},
	"fyne-app//driver": {
		Doc:   "fyne.App.Driver",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//driver: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//driver: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//driver: arg 1: expected native")
			}
			res0 := arg0Val.Driver()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-driver")
				}
			}
			return res0Obj
		},
	},
	"fyne-app//icon": {
		Doc:   "fyne.App.Icon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//icon: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//icon: arg 1: expected native")
			}
			res0 := arg0Val.Icon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-app//lifecycle": {
		Doc:   "fyne.App.Lifecycle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//lifecycle: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//lifecycle: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//lifecycle: arg 1: expected native")
			}
			res0 := arg0Val.Lifecycle()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-lifecycle")
				}
			}
			return res0Obj
		},
	},
	"fyne-app//metadata": {
		Doc:   "fyne.App.Metadata",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//metadata: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//metadata: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//metadata: arg 1: expected native")
			}
			res0 := arg0Val.Metadata()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-app-metadata")
			return res0Obj
		},
	},
	"fyne-app//window": {
		Doc:   "fyne.App.NewWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//window: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//window: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//window: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-app//window: arg 2: expected string")
			}
			res0 := arg0Val.NewWindow(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-window")
				}
			}
			return res0Obj
		},
	},
	"fyne-app//open-url": {
		Doc:   "fyne.App.OpenURL",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//open-url: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//open-url: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//open-url: arg 1: expected native")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//open-url: arg 2: expected native of type *url.URL")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//open-url: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//open-url: arg 2: expected native")
			}
			res0 := arg0Val.OpenURL(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"fyne-app//preferences": {
		Doc:   "fyne.App.Preferences",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//preferences: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//preferences: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//preferences: arg 1: expected native")
			}
			res0 := arg0Val.Preferences()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-preferences")
				}
			}
			return res0Obj
		},
	},
	"fyne-app//quit": {
		Doc:   "fyne.App.Quit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//quit: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//quit: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//quit: arg 1: expected native")
			}
			arg0Val.Quit()
			return arg0
		},
	},
	"fyne-app//run": {
		Doc:   "fyne.App.Run",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//run: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//run: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//run: arg 1: expected native")
			}
			arg0Val.Run()
			return arg0
		},
	},
	"fyne-app//send-notification": {
		Doc:   "fyne.App.SendNotification",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//send-notification: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//send-notification: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//send-notification: arg 1: expected native")
			}
			var arg1Val *fyne.Notification
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Notification)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//send-notification: arg 2: expected native of type *fyne.Notification")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//send-notification: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//send-notification: arg 2: expected native")
			}
			arg0Val.SendNotification(arg1Val)
			return arg0
		},
	},
	"fyne-app//set-cloud-provider": {
		Doc:   "fyne.App.SetCloudProvider",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//set-cloud-provider: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//set-cloud-provider: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//set-cloud-provider: arg 1: expected native")
			}
			var arg1Val fyne.CloudProvider
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//set-cloud-provider: arg 2: expected native of type fyne.CloudProvider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//set-cloud-provider: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//set-cloud-provider: arg 2: expected native")
			}
			arg0Val.SetCloudProvider(arg1Val)
			return arg0
		},
	},
	"fyne-app//set-icon": {
		Doc:   "fyne.App.SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//set-icon: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//set-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//set-icon: arg 1: expected native")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//set-icon: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//set-icon: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//set-icon: arg 2: expected native")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"fyne-app//settings": {
		Doc:   "fyne.App.Settings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//settings: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//settings: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//settings: arg 1: expected native")
			}
			res0 := arg0Val.Settings()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-settings")
				}
			}
			return res0Obj
		},
	},
	"fyne-app//storage": {
		Doc:   "fyne.App.Storage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//storage: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//storage: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//storage: arg 1: expected native")
			}
			res0 := arg0Val.Storage()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-storage")
				}
			}
			return res0Obj
		},
	},
	"fyne-app//unique-id": {
		Doc:   "fyne.App.UniqueID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-app//unique-id: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-app//unique-id: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-app//unique-id: arg 1: expected native")
			}
			res0 := arg0Val.UniqueID()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"build-debug": {
		Doc:   "Get fyne.BuildDebug value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.BuildDebug)))
			return resObj
		},
	},
	"build-release": {
		Doc:   "Get fyne.BuildRelease value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.BuildRelease)))
			return resObj
		},
	},
	"build-standard": {
		Doc:   "Get fyne.BuildStandard value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.BuildStandard)))
			return resObj
		},
	},
	"fyne-canvas-object//hide": {
		Doc:   "fyne.CanvasObject.Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//hide: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"fyne-canvas-object//min-size": {
		Doc:   "fyne.CanvasObject.MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//min-size: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-canvas-object//move": {
		Doc:   "fyne.CanvasObject.Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//move: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"fyne-canvas-object//position": {
		Doc:   "fyne.CanvasObject.Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//position: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-canvas-object//refresh": {
		Doc:   "fyne.CanvasObject.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//refresh: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"fyne-canvas-object//resize": {
		Doc:   "fyne.CanvasObject.Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//resize: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"fyne-canvas-object//show": {
		Doc:   "fyne.CanvasObject.Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//show: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"fyne-canvas-object//size": {
		Doc:   "fyne.CanvasObject.Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//size: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-canvas-object//visible": {
		Doc:   "fyne.CanvasObject.Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//visible: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas-object//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas-object//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-canvas//add-shortcut": {
		Doc:   "fyne.Canvas.AddShortcut",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//add-shortcut: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//add-shortcut: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//add-shortcut: arg 1: expected native")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//add-shortcut: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//add-shortcut: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//add-shortcut: arg 2: expected native")
			}
			var arg2Val func(fyne.Shortcut)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//add-shortcut: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 fyne.Shortcut) {
					var arg0Val env.Object
					{
						typ := reflect.TypeOf(arg0)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
						} else {
							arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-shortcut")
						}
					}
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//add-shortcut: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//add-shortcut: arg 3: expected function or nil")
			}
			arg0Val.AddShortcut(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-canvas//capture": {
		Doc:   "fyne.Canvas.Capture",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//capture: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//capture: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//capture: arg 1: expected native")
			}
			res0 := arg0Val.Capture()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"fyne-canvas//content": {
		Doc:   "fyne.Canvas.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//content: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"fyne-canvas//focus": {
		Doc:   "fyne.Canvas.Focus",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focus: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focus: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//focus: arg 1: expected native")
			}
			var arg1Val fyne.Focusable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focus: arg 2: expected native of type fyne.Focusable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focus: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//focus: arg 2: expected native")
			}
			arg0Val.Focus(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//focus-next": {
		Doc:   "fyne.Canvas.FocusNext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focus-next: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focus-next: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//focus-next: arg 1: expected native")
			}
			arg0Val.FocusNext()
			return arg0
		},
	},
	"fyne-canvas//focus-previous": {
		Doc:   "fyne.Canvas.FocusPrevious",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focus-previous: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focus-previous: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//focus-previous: arg 1: expected native")
			}
			arg0Val.FocusPrevious()
			return arg0
		},
	},
	"fyne-canvas//focused": {
		Doc:   "fyne.Canvas.Focused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focused: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//focused: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//focused: arg 1: expected native")
			}
			res0 := arg0Val.Focused()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-focusable")
				}
			}
			return res0Obj
		},
	},
	"fyne-canvas//interactive-area": {
		Doc:   "fyne.Canvas.InteractiveArea",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//interactive-area: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//interactive-area: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//interactive-area: arg 1: expected native")
			}
			res0, res1 := arg0Val.InteractiveArea()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			var res1Obj env.Object
			res1Obj = *env.NewNative(ps.Idx, res1, "fyne-size")
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-canvas//on-typed-key": {
		Doc:   "fyne.Canvas.OnTypedKey",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//on-typed-key: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//on-typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//on-typed-key: arg 1: expected native")
			}
			res0 := arg0Val.OnTypedKey()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "func(ptr-fyne-key-event)")
			return res0Obj
		},
	},
	"fyne-canvas//on-typed-rune": {
		Doc:   "fyne.Canvas.OnTypedRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//on-typed-rune: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//on-typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//on-typed-rune: arg 1: expected native")
			}
			res0 := arg0Val.OnTypedRune()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "func(rune)")
			return res0Obj
		},
	},
	"fyne-canvas//overlays": {
		Doc:   "fyne.Canvas.Overlays",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//overlays: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//overlays: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//overlays: arg 1: expected native")
			}
			res0 := arg0Val.Overlays()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-overlay-stack")
				}
			}
			return res0Obj
		},
	},
	"fyne-canvas//pixel-coordinate-for-position": {
		Doc:   "fyne.Canvas.PixelCoordinateForPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//pixel-coordinate-for-position: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//pixel-coordinate-for-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//pixel-coordinate-for-position: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//pixel-coordinate-for-position: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//pixel-coordinate-for-position: arg 2: expected native")
			}
			res0, res1 := arg0Val.PixelCoordinateForPosition(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-canvas//refresh": {
		Doc:   "fyne.Canvas.Refresh",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//refresh: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//refresh: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//refresh: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//refresh: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//refresh: arg 2: expected native")
			}
			arg0Val.Refresh(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//remove-shortcut": {
		Doc:   "fyne.Canvas.RemoveShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//remove-shortcut: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//remove-shortcut: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//remove-shortcut: arg 1: expected native")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//remove-shortcut: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//remove-shortcut: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//remove-shortcut: arg 2: expected native")
			}
			arg0Val.RemoveShortcut(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//scale": {
		Doc:   "fyne.Canvas.Scale",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//scale: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//scale: arg 1: expected native")
			}
			res0 := arg0Val.Scale()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-canvas//set-content": {
		Doc:   "fyne.Canvas.SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-content: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//set-content: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-content: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-content: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//set-content: arg 2: expected native")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//set-on-typed-key": {
		Doc:   "fyne.Canvas.SetOnTypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-on-typed-key: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-on-typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//set-on-typed-key: arg 1: expected native")
			}
			var arg1Val func(*fyne.KeyEvent)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-on-typed-key: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 *fyne.KeyEvent) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-fyne-key-event")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-on-typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//set-on-typed-key: arg 2: expected function or nil")
			}
			arg0Val.SetOnTypedKey(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//set-on-typed-rune": {
		Doc:   "fyne.Canvas.SetOnTypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-on-typed-rune: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-on-typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//set-on-typed-rune: arg 1: expected native")
			}
			var arg1Val func(rune)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-on-typed-rune: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 rune) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//set-on-typed-rune: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//set-on-typed-rune: arg 2: expected function or nil")
			}
			arg0Val.SetOnTypedRune(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//size": {
		Doc:   "fyne.Canvas.Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//size: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-canvas//unfocus": {
		Doc:   "fyne.Canvas.Unfocus",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//unfocus: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-canvas//unfocus: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-canvas//unfocus: arg 1: expected native")
			}
			arg0Val.Unfocus()
			return arg0
		},
	},
	"fyne-clipboard//content": {
		Doc:   "fyne.Clipboard.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Clipboard
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Clipboard)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-clipboard//content: arg 1: expected native of type fyne.Clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-clipboard//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-clipboard//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-clipboard//set-content": {
		Doc:   "fyne.Clipboard.SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Clipboard
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Clipboard)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-clipboard//set-content: arg 1: expected native of type fyne.Clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-clipboard//set-content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-clipboard//set-content: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-clipboard//set-content: arg 2: expected string")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"fyne-cloud-provider-preferences//cloud-preferences": {
		Doc:   "fyne.CloudProviderPreferences.CloudPreferences",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProviderPreferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProviderPreferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider-preferences//cloud-preferences: arg 1: expected native of type fyne.CloudProviderPreferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider-preferences//cloud-preferences: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider-preferences//cloud-preferences: arg 1: expected native")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider-preferences//cloud-preferences: arg 2: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider-preferences//cloud-preferences: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider-preferences//cloud-preferences: arg 2: expected native")
			}
			res0 := arg0Val.CloudPreferences(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-preferences")
				}
			}
			return res0Obj
		},
	},
	"fyne-cloud-provider-storage//cloud-storage": {
		Doc:   "fyne.CloudProviderStorage.CloudStorage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProviderStorage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProviderStorage)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider-storage//cloud-storage: arg 1: expected native of type fyne.CloudProviderStorage")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider-storage//cloud-storage: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider-storage//cloud-storage: arg 1: expected native")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider-storage//cloud-storage: arg 2: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider-storage//cloud-storage: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider-storage//cloud-storage: arg 2: expected native")
			}
			res0 := arg0Val.CloudStorage(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-storage")
				}
			}
			return res0Obj
		},
	},
	"fyne-cloud-provider//cleanup": {
		Doc:   "fyne.CloudProvider.Cleanup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//cleanup: arg 1: expected native of type fyne.CloudProvider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//cleanup: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider//cleanup: arg 1: expected native")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//cleanup: arg 2: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//cleanup: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider//cleanup: arg 2: expected native")
			}
			arg0Val.Cleanup(arg1Val)
			return arg0
		},
	},
	"fyne-cloud-provider//provider-description": {
		Doc:   "fyne.CloudProvider.ProviderDescription",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//provider-description: arg 1: expected native of type fyne.CloudProvider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//provider-description: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider//provider-description: arg 1: expected native")
			}
			res0 := arg0Val.ProviderDescription()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-cloud-provider//provider-icon": {
		Doc:   "fyne.CloudProvider.ProviderIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//provider-icon: arg 1: expected native of type fyne.CloudProvider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//provider-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider//provider-icon: arg 1: expected native")
			}
			res0 := arg0Val.ProviderIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-cloud-provider//provider-name": {
		Doc:   "fyne.CloudProvider.ProviderName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//provider-name: arg 1: expected native of type fyne.CloudProvider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//provider-name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider//provider-name: arg 1: expected native")
			}
			res0 := arg0Val.ProviderName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-cloud-provider//setup": {
		Doc:   "fyne.CloudProvider.Setup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//setup: arg 1: expected native of type fyne.CloudProvider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//setup: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider//setup: arg 1: expected native")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//setup: arg 2: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-cloud-provider//setup: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-cloud-provider//setup: arg 2: expected native")
			}
			res0 := arg0Val.Setup(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"fyne-container//hidden!": {
		Doc:   "Set fyne.Container Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-container//hidden!: arg 1: expected native of type fyne.Container")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-container//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-container//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-container//hidden?": {
		Doc:   "Get fyne.Container Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-container//hidden?: arg 1: expected native of type fyne.Container")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-container//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"fyne-container//layout!": {
		Doc:   "Set fyne.Container Layout value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-container//layout!: arg 1: expected native of type fyne.Container")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-container//layout!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Layout, ok = v.Value.(fyne.Layout)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-container//layout!: arg 2: expected native of type fyne.Layout")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-container//layout!: arg 2: expected integer to be 0 or nil")
				}
				self.Layout = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-container//layout!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-container//layout?": {
		Doc:   "Get fyne.Container Layout value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-container//layout?: arg 1: expected native of type fyne.Container")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-container//layout?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Layout)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Layout, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Layout, "fyne-layout")
				}
			}
			return resObj
		},
	},
	"fyne-container//objects!": {
		Doc:   "Set fyne.Container Objects value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-container//objects!: arg 1: expected native of type fyne.Container")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-container//objects!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Objects = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Objects[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("fyne-container//objects!: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("fyne-container//objects!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Objects[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("fyne-container//objects!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Objects, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-container//objects!: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-container//objects!: arg 2: expected integer to be 0 or nil")
				}
				self.Objects = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-container//objects!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"fyne-container//objects?": {
		Doc:   "Get fyne.Container Objects value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-container//objects?: arg 1: expected native of type fyne.Container")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-container//objects?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Objects))
				for i, it := range self.Objects {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-canvas-object")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"current-app": {
		Doc:   "fyne.CurrentApp",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := fyne.CurrentApp()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-app")
				}
			}
			return res0Obj
		},
	},
	"current-device": {
		Doc:   "fyne.CurrentDevice",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := fyne.CurrentDevice()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-device")
				}
			}
			return res0Obj
		},
	},
	"fyne-delta//components": {
		Doc:   "fyne.Delta.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-delta//components: arg 1: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-delta//components: arg 1: expected native")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-delta//dx!": {
		Doc:   "Set fyne.Delta DX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-delta//dx!: arg 1: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-delta//dx!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DX = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-delta//dx!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"fyne-delta//dx?": {
		Doc:   "Get fyne.Delta DX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-delta//dx?: arg 1: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-delta//dx?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DX))
			return resObj
		},
	},
	"fyne-delta//dy!": {
		Doc:   "Set fyne.Delta DY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-delta//dy!: arg 1: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-delta//dy!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DY = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-delta//dy!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"fyne-delta//dy?": {
		Doc:   "Get fyne.Delta DY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-delta//dy?: arg 1: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-delta//dy?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DY))
			return resObj
		},
	},
	"fyne-delta//is-zero": {
		Doc:   "fyne.Delta.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-delta//is-zero: arg 1: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-delta//is-zero: arg 1: expected native")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-device//has-keyboard": {
		Doc:   "fyne.Device.HasKeyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-device//has-keyboard: arg 1: expected native of type fyne.Device")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-device//has-keyboard: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-device//has-keyboard: arg 1: expected native")
			}
			res0 := arg0Val.HasKeyboard()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-device//is-browser": {
		Doc:   "fyne.Device.IsBrowser",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-device//is-browser: arg 1: expected native of type fyne.Device")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-device//is-browser: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-device//is-browser: arg 1: expected native")
			}
			res0 := arg0Val.IsBrowser()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-device//is-mobile": {
		Doc:   "fyne.Device.IsMobile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-device//is-mobile: arg 1: expected native of type fyne.Device")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-device//is-mobile: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-device//is-mobile: arg 1: expected native")
			}
			res0 := arg0Val.IsMobile()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-device//orientation": {
		Doc:   "fyne.Device.Orientation",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-device//orientation: arg 1: expected native of type fyne.Device")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-device//orientation: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-device//orientation: arg 1: expected native")
			}
			res0 := arg0Val.Orientation()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"fyne-device//system-scale-for-window": {
		Doc:   "fyne.Device.SystemScaleForWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-device//system-scale-for-window: arg 1: expected native of type fyne.Device")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-device//system-scale-for-window: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-device//system-scale-for-window: arg 1: expected native")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-device//system-scale-for-window: arg 2: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-device//system-scale-for-window: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-device//system-scale-for-window: arg 2: expected native")
			}
			res0 := arg0Val.SystemScaleForWindow(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-disableable//disable": {
		Doc:   "fyne.Disableable.Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Disableable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Disableable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-disableable//disable: arg 1: expected native of type fyne.Disableable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-disableable//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-disableable//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"fyne-disableable//disabled": {
		Doc:   "fyne.Disableable.Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Disableable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Disableable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-disableable//disabled: arg 1: expected native of type fyne.Disableable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-disableable//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-disableable//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-disableable//enable": {
		Doc:   "fyne.Disableable.Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Disableable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Disableable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-disableable//enable: arg 1: expected native of type fyne.Disableable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-disableable//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-disableable//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"fyne-double-tappable//double-tapped": {
		Doc:   "fyne.DoubleTappable.DoubleTapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.DoubleTappable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.DoubleTappable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-double-tappable//double-tapped: arg 1: expected native of type fyne.DoubleTappable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-double-tappable//double-tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-double-tappable//double-tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-double-tappable//double-tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-double-tappable//double-tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-double-tappable//double-tapped: arg 2: expected native")
			}
			arg0Val.DoubleTapped(arg1Val)
			return arg0
		},
	},
	"fyne-drag-event//absolute-position!": {
		Doc:   "Set fyne.DragEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-drag-event//absolute-position!: arg 1: expected native of type fyne.DragEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-drag-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-drag-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-drag-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-drag-event//absolute-position?": {
		Doc:   "Get fyne.DragEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-drag-event//absolute-position?: arg 1: expected native of type fyne.DragEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-drag-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"fyne-drag-event//dragged!": {
		Doc:   "Set fyne.DragEvent Dragged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-drag-event//dragged!: arg 1: expected native of type fyne.DragEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-drag-event//dragged!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Dragged, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-drag-event//dragged!: arg 2: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-drag-event//dragged!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-drag-event//dragged?": {
		Doc:   "Get fyne.DragEvent Dragged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-drag-event//dragged?: arg 1: expected native of type fyne.DragEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-drag-event//dragged?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Dragged, "fyne-delta")
			return resObj
		},
	},
	"fyne-drag-event//position!": {
		Doc:   "Set fyne.DragEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-drag-event//position!: arg 1: expected native of type fyne.DragEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-drag-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-drag-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-drag-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-drag-event//position?": {
		Doc:   "Get fyne.DragEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-drag-event//position?: arg 1: expected native of type fyne.DragEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-drag-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"fyne-draggable//drag-end": {
		Doc:   "fyne.Draggable.DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Draggable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-draggable//drag-end: arg 1: expected native of type fyne.Draggable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-draggable//drag-end: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-draggable//drag-end: arg 1: expected native")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"fyne-draggable//dragged": {
		Doc:   "fyne.Draggable.Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Draggable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-draggable//dragged: arg 1: expected native of type fyne.Draggable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-draggable//dragged: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-draggable//dragged: arg 1: expected native")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-draggable//dragged: arg 2: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-draggable//dragged: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-draggable//dragged: arg 2: expected native")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"fyne-driver//absolute-position-for-object": {
		Doc:   "fyne.Driver.AbsolutePositionForObject",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//absolute-position-for-object: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//absolute-position-for-object: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//absolute-position-for-object: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//absolute-position-for-object: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//absolute-position-for-object: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//absolute-position-for-object: arg 2: expected native")
			}
			res0 := arg0Val.AbsolutePositionForObject(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-driver//all-windows": {
		Doc:   "fyne.Driver.AllWindows",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//all-windows: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//all-windows: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//all-windows: arg 1: expected native")
			}
			res0 := arg0Val.AllWindows()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-window")
						}
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-driver//canvas-for-object": {
		Doc:   "fyne.Driver.CanvasForObject",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//canvas-for-object: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//canvas-for-object: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//canvas-for-object: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//canvas-for-object: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//canvas-for-object: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//canvas-for-object: arg 2: expected native")
			}
			res0 := arg0Val.CanvasForObject(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas")
				}
			}
			return res0Obj
		},
	},
	"fyne-driver//create-window": {
		Doc:   "fyne.Driver.CreateWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//create-window: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//create-window: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//create-window: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-driver//create-window: arg 2: expected string")
			}
			res0 := arg0Val.CreateWindow(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-window")
				}
			}
			return res0Obj
		},
	},
	"fyne-driver//device": {
		Doc:   "fyne.Driver.Device",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//device: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//device: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//device: arg 1: expected native")
			}
			res0 := arg0Val.Device()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-device")
				}
			}
			return res0Obj
		},
	},
	"fyne-driver//quit": {
		Doc:   "fyne.Driver.Quit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//quit: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//quit: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//quit: arg 1: expected native")
			}
			arg0Val.Quit()
			return arg0
		},
	},
	"fyne-driver//rendered-text-size": {
		Doc:   "fyne.Driver.RenderedTextSize",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//rendered-text-size: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//rendered-text-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//rendered-text-size: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-driver//rendered-text-size: arg 2: expected string")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-driver//rendered-text-size: arg 3: expected decimal")
			}
			var arg3Val fyne.TextStyle
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//rendered-text-size: arg 4: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//rendered-text-size: arg 4: expected native")
			}
			res0, res1 := arg0Val.RenderedTextSize(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"size":     res0Obj,
				"baseline": res1Obj,
			})
		},
	},
	"fyne-driver//run": {
		Doc:   "fyne.Driver.Run",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//run: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//run: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//run: arg 1: expected native")
			}
			arg0Val.Run()
			return arg0
		},
	},
	"fyne-driver//start-animation": {
		Doc:   "fyne.Driver.StartAnimation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//start-animation: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//start-animation: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//start-animation: arg 1: expected native")
			}
			var arg1Val *fyne.Animation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//start-animation: arg 2: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//start-animation: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//start-animation: arg 2: expected native")
			}
			arg0Val.StartAnimation(arg1Val)
			return arg0
		},
	},
	"fyne-driver//stop-animation": {
		Doc:   "fyne.Driver.StopAnimation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//stop-animation: arg 1: expected native of type fyne.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//stop-animation: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//stop-animation: arg 1: expected native")
			}
			var arg1Val *fyne.Animation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//stop-animation: arg 2: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-driver//stop-animation: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-driver//stop-animation: arg 2: expected native")
			}
			arg0Val.StopAnimation(arg1Val)
			return arg0
		},
	},
	"fyne-focusable//focus-gained": {
		Doc:   "fyne.Focusable.FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//focus-gained: arg 1: expected native of type fyne.Focusable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-focusable//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"fyne-focusable//focus-lost": {
		Doc:   "fyne.Focusable.FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//focus-lost: arg 1: expected native of type fyne.Focusable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-focusable//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"fyne-focusable//typed-key": {
		Doc:   "fyne.Focusable.TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//typed-key: arg 1: expected native of type fyne.Focusable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-focusable//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-focusable//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"fyne-focusable//typed-rune": {
		Doc:   "fyne.Focusable.TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//typed-rune: arg 1: expected native of type fyne.Focusable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-focusable//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-focusable//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-focusable//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"fyne-hardware-key//scan-code!": {
		Doc:   "Set fyne.HardwareKey ScanCode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-hardware-key//scan-code!: arg 1: expected native of type fyne.HardwareKey")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-hardware-key//scan-code!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScanCode = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-hardware-key//scan-code!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-hardware-key//scan-code?": {
		Doc:   "Get fyne.HardwareKey ScanCode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-hardware-key//scan-code?: arg 1: expected native of type fyne.HardwareKey")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-hardware-key//scan-code?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.ScanCode))
			return resObj
		},
	},
	"is-horizontal": {
		Doc:   "fyne.IsHorizontal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.DeviceOrientation
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal fyne.DeviceOrientation
				if natOk {
					natVal, natValOk = nat.Value.(fyne.DeviceOrientation)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-horizontal: arg 1: expected integer")
					}
					arg0Val = fyne.DeviceOrientation(u)
				}
			}
			res0 := fyne.IsHorizontal(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-vertical": {
		Doc:   "fyne.IsVertical",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.DeviceOrientation
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal fyne.DeviceOrientation
				if natOk {
					natVal, natValOk = nat.Value.(fyne.DeviceOrientation)
				}
				if natOk && natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("is-vertical: arg 1: expected integer")
					}
					arg0Val = fyne.DeviceOrientation(u)
				}
			}
			res0 := fyne.IsVertical(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"key-0": {
		Doc:   "Get fyne.Key0 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key0))
			return resObj
		},
	},
	"key-1": {
		Doc:   "Get fyne.Key1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key1))
			return resObj
		},
	},
	"key-2": {
		Doc:   "Get fyne.Key2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key2))
			return resObj
		},
	},
	"key-3": {
		Doc:   "Get fyne.Key3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key3))
			return resObj
		},
	},
	"key-4": {
		Doc:   "Get fyne.Key4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key4))
			return resObj
		},
	},
	"key-5": {
		Doc:   "Get fyne.Key5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key5))
			return resObj
		},
	},
	"key-6": {
		Doc:   "Get fyne.Key6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key6))
			return resObj
		},
	},
	"key-7": {
		Doc:   "Get fyne.Key7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key7))
			return resObj
		},
	},
	"key-8": {
		Doc:   "Get fyne.Key8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key8))
			return resObj
		},
	},
	"key-9": {
		Doc:   "Get fyne.Key9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.Key9))
			return resObj
		},
	},
	"key-a": {
		Doc:   "Get fyne.KeyA value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyA))
			return resObj
		},
	},
	"key-apostrophe": {
		Doc:   "Get fyne.KeyApostrophe value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyApostrophe))
			return resObj
		},
	},
	"key-asterisk": {
		Doc:   "Get fyne.KeyAsterisk value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyAsterisk))
			return resObj
		},
	},
	"key-b": {
		Doc:   "Get fyne.KeyB value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyB))
			return resObj
		},
	},
	"key-back-tick": {
		Doc:   "Get fyne.KeyBackTick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyBackTick))
			return resObj
		},
	},
	"key-backslash": {
		Doc:   "Get fyne.KeyBackslash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyBackslash))
			return resObj
		},
	},
	"key-backspace": {
		Doc:   "Get fyne.KeyBackspace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyBackspace))
			return resObj
		},
	},
	"key-c": {
		Doc:   "Get fyne.KeyC value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyC))
			return resObj
		},
	},
	"key-comma": {
		Doc:   "Get fyne.KeyComma value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyComma))
			return resObj
		},
	},
	"key-d": {
		Doc:   "Get fyne.KeyD value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyD))
			return resObj
		},
	},
	"key-delete": {
		Doc:   "Get fyne.KeyDelete value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyDelete))
			return resObj
		},
	},
	"key-down": {
		Doc:   "Get fyne.KeyDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyDown))
			return resObj
		},
	},
	"key-e": {
		Doc:   "Get fyne.KeyE value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyE))
			return resObj
		},
	},
	"key-end": {
		Doc:   "Get fyne.KeyEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyEnd))
			return resObj
		},
	},
	"key-enter": {
		Doc:   "Get fyne.KeyEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyEnter))
			return resObj
		},
	},
	"key-equal": {
		Doc:   "Get fyne.KeyEqual value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyEqual))
			return resObj
		},
	},
	"key-escape": {
		Doc:   "Get fyne.KeyEscape value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyEscape))
			return resObj
		},
	},
	"fyne-key-event//name!": {
		Doc:   "Set fyne.KeyEvent Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-key-event//name!: arg 1: expected native of type fyne.KeyEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-key-event//name!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.KeyName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.KeyName)
				}
				if natOk && natValOk {
					self.Name = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-key-event//name!: arg 2: expected string")
					}
					self.Name = fyne.KeyName(u)
				}
			}
			return arg0
		},
	},
	"fyne-key-event//name?": {
		Doc:   "Get fyne.KeyEvent Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-key-event//name?: arg 1: expected native of type fyne.KeyEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-key-event//name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.Name))
			return resObj
		},
	},
	"fyne-key-event//physical!": {
		Doc:   "Set fyne.KeyEvent Physical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-key-event//physical!: arg 1: expected native of type fyne.KeyEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-key-event//physical!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Physical, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-key-event//physical!: arg 2: expected native of type fyne.HardwareKey")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-key-event//physical!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-key-event//physical?": {
		Doc:   "Get fyne.KeyEvent Physical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-key-event//physical?: arg 1: expected native of type fyne.KeyEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-key-event//physical?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Physical, "fyne-hardware-key")
			return resObj
		},
	},
	"key-f": {
		Doc:   "Get fyne.KeyF value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF))
			return resObj
		},
	},
	"key-f-1": {
		Doc:   "Get fyne.KeyF1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF1))
			return resObj
		},
	},
	"key-f-10": {
		Doc:   "Get fyne.KeyF10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF10))
			return resObj
		},
	},
	"key-f-11": {
		Doc:   "Get fyne.KeyF11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF11))
			return resObj
		},
	},
	"key-f-12": {
		Doc:   "Get fyne.KeyF12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF12))
			return resObj
		},
	},
	"key-f-2": {
		Doc:   "Get fyne.KeyF2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF2))
			return resObj
		},
	},
	"key-f-3": {
		Doc:   "Get fyne.KeyF3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF3))
			return resObj
		},
	},
	"key-f-4": {
		Doc:   "Get fyne.KeyF4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF4))
			return resObj
		},
	},
	"key-f-5": {
		Doc:   "Get fyne.KeyF5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF5))
			return resObj
		},
	},
	"key-f-6": {
		Doc:   "Get fyne.KeyF6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF6))
			return resObj
		},
	},
	"key-f-7": {
		Doc:   "Get fyne.KeyF7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF7))
			return resObj
		},
	},
	"key-f-8": {
		Doc:   "Get fyne.KeyF8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF8))
			return resObj
		},
	},
	"key-f-9": {
		Doc:   "Get fyne.KeyF9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyF9))
			return resObj
		},
	},
	"key-g": {
		Doc:   "Get fyne.KeyG value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyG))
			return resObj
		},
	},
	"key-h": {
		Doc:   "Get fyne.KeyH value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyH))
			return resObj
		},
	},
	"key-home": {
		Doc:   "Get fyne.KeyHome value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyHome))
			return resObj
		},
	},
	"key-i": {
		Doc:   "Get fyne.KeyI value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyI))
			return resObj
		},
	},
	"key-insert": {
		Doc:   "Get fyne.KeyInsert value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyInsert))
			return resObj
		},
	},
	"key-j": {
		Doc:   "Get fyne.KeyJ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyJ))
			return resObj
		},
	},
	"key-k": {
		Doc:   "Get fyne.KeyK value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyK))
			return resObj
		},
	},
	"key-l": {
		Doc:   "Get fyne.KeyL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyL))
			return resObj
		},
	},
	"key-left": {
		Doc:   "Get fyne.KeyLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyLeft))
			return resObj
		},
	},
	"key-left-bracket": {
		Doc:   "Get fyne.KeyLeftBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyLeftBracket))
			return resObj
		},
	},
	"key-m": {
		Doc:   "Get fyne.KeyM value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyM))
			return resObj
		},
	},
	"key-minus": {
		Doc:   "Get fyne.KeyMinus value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyMinus))
			return resObj
		},
	},
	"key-modifier-alt": {
		Doc:   "Get fyne.KeyModifierAlt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.KeyModifierAlt)))
			return resObj
		},
	},
	"key-modifier-control": {
		Doc:   "Get fyne.KeyModifierControl value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.KeyModifierControl)))
			return resObj
		},
	},
	"key-modifier-shift": {
		Doc:   "Get fyne.KeyModifierShift value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.KeyModifierShift)))
			return resObj
		},
	},
	"key-modifier-super": {
		Doc:   "Get fyne.KeyModifierSuper value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.KeyModifierSuper)))
			return resObj
		},
	},
	"key-n": {
		Doc:   "Get fyne.KeyN value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyN))
			return resObj
		},
	},
	"key-o": {
		Doc:   "Get fyne.KeyO value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyO))
			return resObj
		},
	},
	"key-p": {
		Doc:   "Get fyne.KeyP value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyP))
			return resObj
		},
	},
	"key-page-down": {
		Doc:   "Get fyne.KeyPageDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyPageDown))
			return resObj
		},
	},
	"key-page-up": {
		Doc:   "Get fyne.KeyPageUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyPageUp))
			return resObj
		},
	},
	"key-period": {
		Doc:   "Get fyne.KeyPeriod value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyPeriod))
			return resObj
		},
	},
	"key-plus": {
		Doc:   "Get fyne.KeyPlus value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyPlus))
			return resObj
		},
	},
	"key-q": {
		Doc:   "Get fyne.KeyQ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyQ))
			return resObj
		},
	},
	"key-r": {
		Doc:   "Get fyne.KeyR value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyR))
			return resObj
		},
	},
	"key-return": {
		Doc:   "Get fyne.KeyReturn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyReturn))
			return resObj
		},
	},
	"key-right": {
		Doc:   "Get fyne.KeyRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyRight))
			return resObj
		},
	},
	"key-right-bracket": {
		Doc:   "Get fyne.KeyRightBracket value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyRightBracket))
			return resObj
		},
	},
	"key-s": {
		Doc:   "Get fyne.KeyS value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyS))
			return resObj
		},
	},
	"key-semicolon": {
		Doc:   "Get fyne.KeySemicolon value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeySemicolon))
			return resObj
		},
	},
	"key-slash": {
		Doc:   "Get fyne.KeySlash value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeySlash))
			return resObj
		},
	},
	"key-space": {
		Doc:   "Get fyne.KeySpace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeySpace))
			return resObj
		},
	},
	"key-t": {
		Doc:   "Get fyne.KeyT value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyT))
			return resObj
		},
	},
	"key-tab": {
		Doc:   "Get fyne.KeyTab value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyTab))
			return resObj
		},
	},
	"key-u": {
		Doc:   "Get fyne.KeyU value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyU))
			return resObj
		},
	},
	"key-unknown": {
		Doc:   "Get fyne.KeyUnknown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyUnknown))
			return resObj
		},
	},
	"key-up": {
		Doc:   "Get fyne.KeyUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyUp))
			return resObj
		},
	},
	"key-v": {
		Doc:   "Get fyne.KeyV value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyV))
			return resObj
		},
	},
	"key-w": {
		Doc:   "Get fyne.KeyW value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyW))
			return resObj
		},
	},
	"key-x": {
		Doc:   "Get fyne.KeyX value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyX))
			return resObj
		},
	},
	"key-y": {
		Doc:   "Get fyne.KeyY value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyY))
			return resObj
		},
	},
	"key-z": {
		Doc:   "Get fyne.KeyZ value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(fyne.KeyZ))
			return resObj
		},
	},
	"fyne-keyboard-shortcut//key": {
		Doc:   "fyne.KeyboardShortcut.Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.KeyboardShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.KeyboardShortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-keyboard-shortcut//key: arg 1: expected native of type fyne.KeyboardShortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-keyboard-shortcut//key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-keyboard-shortcut//key: arg 1: expected native")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewString(string(res0))
			return res0Obj
		},
	},
	"fyne-keyboard-shortcut//mod": {
		Doc:   "fyne.KeyboardShortcut.Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.KeyboardShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.KeyboardShortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-keyboard-shortcut//mod: arg 1: expected native of type fyne.KeyboardShortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-keyboard-shortcut//mod: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-keyboard-shortcut//mod: arg 1: expected native")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"fyne-layout//layout": {
		Doc:   "fyne.Layout.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-layout//layout: arg 1: expected native of type fyne.Layout")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-layout//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-layout//layout: arg 1: expected native")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("fyne-layout//layout: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("fyne-layout//layout: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("fyne-layout//layout: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-layout//layout: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-layout//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-layout//layout: arg 2: expected block, native or nil")
			}
			var arg2Val fyne.Size
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-layout//layout: arg 3: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-layout//layout: arg 3: expected native")
			}
			arg0Val.Layout(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-layout//min-size": {
		Doc:   "fyne.Layout.MinSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-layout//min-size: arg 1: expected native of type fyne.Layout")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-layout//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-layout//min-size: arg 1: expected native")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("fyne-layout//min-size: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("fyne-layout//min-size: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("fyne-layout//min-size: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-layout//min-size: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-layout//min-size: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-layout//min-size: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.MinSize(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-legacy-theme//background-color": {
		Doc:   "fyne.LegacyTheme.BackgroundColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//background-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//background-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//background-color: arg 1: expected native")
			}
			res0 := arg0Val.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//button-color": {
		Doc:   "fyne.LegacyTheme.ButtonColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//button-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//button-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//button-color: arg 1: expected native")
			}
			res0 := arg0Val.ButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//disabled-button-color": {
		Doc:   "fyne.LegacyTheme.DisabledButtonColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//disabled-button-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//disabled-button-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//disabled-button-color: arg 1: expected native")
			}
			res0 := arg0Val.DisabledButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//disabled-text-color": {
		Doc:   "fyne.LegacyTheme.DisabledTextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//disabled-text-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//disabled-text-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//disabled-text-color: arg 1: expected native")
			}
			res0 := arg0Val.DisabledTextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//focus-color": {
		Doc:   "fyne.LegacyTheme.FocusColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//focus-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//focus-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//focus-color: arg 1: expected native")
			}
			res0 := arg0Val.FocusColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//hover-color": {
		Doc:   "fyne.LegacyTheme.HoverColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//hover-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//hover-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//hover-color: arg 1: expected native")
			}
			res0 := arg0Val.HoverColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//icon-inline-size": {
		Doc:   "fyne.LegacyTheme.IconInlineSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//icon-inline-size: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//icon-inline-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//icon-inline-size: arg 1: expected native")
			}
			res0 := arg0Val.IconInlineSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-legacy-theme//padding": {
		Doc:   "fyne.LegacyTheme.Padding",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//padding: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//padding: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//padding: arg 1: expected native")
			}
			res0 := arg0Val.Padding()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-legacy-theme//place-holder-color": {
		Doc:   "fyne.LegacyTheme.PlaceHolderColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//place-holder-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//place-holder-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//place-holder-color: arg 1: expected native")
			}
			res0 := arg0Val.PlaceHolderColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//primary-color": {
		Doc:   "fyne.LegacyTheme.PrimaryColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//primary-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//primary-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//primary-color: arg 1: expected native")
			}
			res0 := arg0Val.PrimaryColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//scroll-bar-color": {
		Doc:   "fyne.LegacyTheme.ScrollBarColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//scroll-bar-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//scroll-bar-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//scroll-bar-color: arg 1: expected native")
			}
			res0 := arg0Val.ScrollBarColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//scroll-bar-size": {
		Doc:   "fyne.LegacyTheme.ScrollBarSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//scroll-bar-size: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//scroll-bar-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//scroll-bar-size: arg 1: expected native")
			}
			res0 := arg0Val.ScrollBarSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-legacy-theme//scroll-bar-small-size": {
		Doc:   "fyne.LegacyTheme.ScrollBarSmallSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//scroll-bar-small-size: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//scroll-bar-small-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//scroll-bar-small-size: arg 1: expected native")
			}
			res0 := arg0Val.ScrollBarSmallSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-legacy-theme//shadow-color": {
		Doc:   "fyne.LegacyTheme.ShadowColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//shadow-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//shadow-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//shadow-color: arg 1: expected native")
			}
			res0 := arg0Val.ShadowColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-bold-font": {
		Doc:   "fyne.LegacyTheme.TextBoldFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-bold-font: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-bold-font: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//text-bold-font: arg 1: expected native")
			}
			res0 := arg0Val.TextBoldFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-bold-italic-font": {
		Doc:   "fyne.LegacyTheme.TextBoldItalicFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-bold-italic-font: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-bold-italic-font: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//text-bold-italic-font: arg 1: expected native")
			}
			res0 := arg0Val.TextBoldItalicFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-color": {
		Doc:   "fyne.LegacyTheme.TextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-color: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//text-color: arg 1: expected native")
			}
			res0 := arg0Val.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-font": {
		Doc:   "fyne.LegacyTheme.TextFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-font: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-font: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//text-font: arg 1: expected native")
			}
			res0 := arg0Val.TextFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-italic-font": {
		Doc:   "fyne.LegacyTheme.TextItalicFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-italic-font: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-italic-font: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//text-italic-font: arg 1: expected native")
			}
			res0 := arg0Val.TextItalicFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-monospace-font": {
		Doc:   "fyne.LegacyTheme.TextMonospaceFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-monospace-font: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-monospace-font: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//text-monospace-font: arg 1: expected native")
			}
			res0 := arg0Val.TextMonospaceFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-size": {
		Doc:   "fyne.LegacyTheme.TextSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-size: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-legacy-theme//text-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-legacy-theme//text-size: arg 1: expected native")
			}
			res0 := arg0Val.TextSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-lifecycle//set-on-entered-foreground": {
		Doc:   "fyne.Lifecycle.SetOnEnteredForeground",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Lifecycle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Lifecycle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-entered-foreground: arg 1: expected native of type fyne.Lifecycle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-entered-foreground: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-lifecycle//set-on-entered-foreground: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-entered-foreground: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-entered-foreground: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-lifecycle//set-on-entered-foreground: arg 2: expected function or nil")
			}
			arg0Val.SetOnEnteredForeground(arg1Val)
			return arg0
		},
	},
	"fyne-lifecycle//set-on-exited-foreground": {
		Doc:   "fyne.Lifecycle.SetOnExitedForeground",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Lifecycle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Lifecycle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-exited-foreground: arg 1: expected native of type fyne.Lifecycle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-exited-foreground: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-lifecycle//set-on-exited-foreground: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-exited-foreground: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-exited-foreground: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-lifecycle//set-on-exited-foreground: arg 2: expected function or nil")
			}
			arg0Val.SetOnExitedForeground(arg1Val)
			return arg0
		},
	},
	"fyne-lifecycle//set-on-started": {
		Doc:   "fyne.Lifecycle.SetOnStarted",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Lifecycle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Lifecycle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-started: arg 1: expected native of type fyne.Lifecycle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-started: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-lifecycle//set-on-started: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-started: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-started: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-lifecycle//set-on-started: arg 2: expected function or nil")
			}
			arg0Val.SetOnStarted(arg1Val)
			return arg0
		},
	},
	"fyne-lifecycle//set-on-stopped": {
		Doc:   "fyne.Lifecycle.SetOnStopped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Lifecycle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Lifecycle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-stopped: arg 1: expected native of type fyne.Lifecycle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-stopped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-lifecycle//set-on-stopped: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-stopped: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-lifecycle//set-on-stopped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-lifecycle//set-on-stopped: arg 2: expected function or nil")
			}
			arg0Val.SetOnStopped(arg1Val)
			return arg0
		},
	},
	"load-resource-from-path": {
		Doc:   "fyne.LoadResourceFromPath",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("load-resource-from-path: arg 1: expected string")
			}
			res0, res1 := fyne.LoadResourceFromPath(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"load-resource-from-url-string": {
		Doc:   "fyne.LoadResourceFromURLString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("load-resource-from-url-string: arg 1: expected string")
			}
			res0, res1 := fyne.LoadResourceFromURLString(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"log-error": {
		Doc:   "fyne.LogError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("log-error: arg 1: expected string")
			}
			var arg1Val error
			switch v := arg1.(type) {
			case env.String:
				arg1Val = errors.New(v.Value)
			case env.Error:
				arg1Val = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("log-error: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("log-error: arg 2: expected error, string or nil")
			}
			fyne.LogError(arg0Val, arg1Val)
			return nil
		},
	},
	"fyne-main-menu//items!": {
		Doc:   "Set fyne.MainMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MainMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-main-menu//items!: arg 1: expected native of type fyne.MainMenu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-main-menu//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.Menu, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.Menu)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("fyne-main-menu//items!: arg 2: block item: expected native of type *fyne.Menu")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("fyne-main-menu//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("fyne-main-menu//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-main-menu//items!: arg 2: expected native of type []*fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-main-menu//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-main-menu//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"fyne-main-menu//items?": {
		Doc:   "Get fyne.MainMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MainMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-main-menu//items?: arg 1: expected native of type fyne.MainMenu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-main-menu//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-fyne-menu")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"max": {
		Doc:   "fyne.Max",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("max: arg 1: expected decimal")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("max: arg 2: expected decimal")
			}
			res0 := fyne.Max(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"measure-text": {
		Doc:   "fyne.MeasureText",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("measure-text: arg 1: expected string")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("measure-text: arg 2: expected decimal")
			}
			var arg2Val fyne.TextStyle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("measure-text: arg 3: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("measure-text: arg 3: expected native")
			}
			res0 := fyne.MeasureText(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-menu-item//action!": {
		Doc:   "Set fyne.MenuItem Action value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//action!: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//action!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//action!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.Action = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//action!: arg 2: expected integer to be 0 or nil")
				}
				self.Action = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//action!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"fyne-menu-item//action?": {
		Doc:   "Get fyne.MenuItem Action value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//action?: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//action?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Action, "func()")
			return resObj
		},
	},
	"fyne-menu-item//checked!": {
		Doc:   "Set fyne.MenuItem Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//checked!: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//checked!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//checked!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-menu-item//checked?": {
		Doc:   "Get fyne.MenuItem Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//checked?: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//checked?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"fyne-menu-item//child-menu!": {
		Doc:   "Set fyne.MenuItem ChildMenu value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//child-menu!: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//child-menu!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ChildMenu, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//child-menu!: arg 2: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//child-menu!: arg 2: expected integer to be 0 or nil")
				}
				self.ChildMenu = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//child-menu!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-menu-item//child-menu?": {
		Doc:   "Get fyne.MenuItem ChildMenu value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//child-menu?: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//child-menu?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildMenu, "ptr-fyne-menu")
			return resObj
		},
	},
	"fyne-menu-item//disabled!": {
		Doc:   "Set fyne.MenuItem Disabled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//disabled!: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//disabled!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Disabled = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//disabled!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-menu-item//disabled?": {
		Doc:   "Get fyne.MenuItem Disabled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//disabled?: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//disabled?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Disabled))
			return resObj
		},
	},
	"fyne-menu-item//icon!": {
		Doc:   "Set fyne.MenuItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//icon!: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-menu-item//icon?": {
		Doc:   "Get fyne.MenuItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//icon?: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"fyne-menu-item//is-quit!": {
		Doc:   "Set fyne.MenuItem IsQuit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//is-quit!: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//is-quit!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsQuit = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//is-quit!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-menu-item//is-quit?": {
		Doc:   "Get fyne.MenuItem IsQuit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//is-quit?: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//is-quit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsQuit))
			return resObj
		},
	},
	"fyne-menu-item//is-separator!": {
		Doc:   "Set fyne.MenuItem IsSeparator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//is-separator!: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//is-separator!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsSeparator = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//is-separator!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-menu-item//is-separator?": {
		Doc:   "Get fyne.MenuItem IsSeparator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//is-separator?: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//is-separator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsSeparator))
			return resObj
		},
	},
	"fyne-menu-item//label!": {
		Doc:   "Set fyne.MenuItem Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//label!: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//label!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//label!: arg 2: expected string")
			}
			return arg0
		},
	},
	"fyne-menu-item//label?": {
		Doc:   "Get fyne.MenuItem Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//label?: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//label?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"fyne-menu-item//shortcut!": {
		Doc:   "Set fyne.MenuItem Shortcut value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//shortcut!: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//shortcut!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Shortcut, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//shortcut!: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//shortcut!: arg 2: expected integer to be 0 or nil")
				}
				self.Shortcut = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//shortcut!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-menu-item//shortcut?": {
		Doc:   "Get fyne.MenuItem Shortcut value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu-item//shortcut?: arg 1: expected native of type fyne.MenuItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu-item//shortcut?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Shortcut)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Shortcut, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Shortcut, "fyne-shortcut")
				}
			}
			return resObj
		},
	},
	"fyne-menu//items!": {
		Doc:   "Set fyne.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu//items!: arg 1: expected native of type fyne.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.MenuItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.MenuItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("fyne-menu//items!: arg 2: block item: expected native of type *fyne.MenuItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("fyne-menu//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("fyne-menu//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu//items!: arg 2: expected native of type []*fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-menu//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"fyne-menu//items?": {
		Doc:   "Get fyne.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu//items?: arg 1: expected native of type fyne.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-fyne-menu-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fyne-menu//label!": {
		Doc:   "Set fyne.Menu Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu//label!: arg 1: expected native of type fyne.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu//label!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-menu//label!: arg 2: expected string")
			}
			return arg0
		},
	},
	"fyne-menu//label?": {
		Doc:   "Get fyne.Menu Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-menu//label?: arg 1: expected native of type fyne.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-menu//label?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"min": {
		Doc:   "fyne.Min",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("min: arg 1: expected decimal")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("min: arg 2: expected decimal")
			}
			res0 := fyne.Min(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"animation": {
		Doc:   "fyne.NewAnimation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val time.Duration
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("animation: arg 1: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("animation: arg 1: expected native")
			}
			var arg1Val func(float32)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("animation: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 float32) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("animation: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("animation: arg 2: expected function or nil")
			}
			res0 := fyne.NewAnimation(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-animation")
			return res0Obj
		},
	},
	"container": {
		Doc:   "fyne.NewContainer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("container: arg 1: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("container: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("container: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container: arg 1: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container: arg 1: expected block, native or nil")
			}
			res0 := fyne.NewContainer(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"container-with-layout": {
		Doc:   "fyne.NewContainerWithLayout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-with-layout: arg 1: expected native of type fyne.Layout")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-with-layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-with-layout: arg 1: expected native")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("container-with-layout: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("container-with-layout: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("container-with-layout: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-with-layout: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-with-layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-with-layout: arg 2: expected block, native or nil")
			}
			res0 := fyne.NewContainerWithLayout(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"container-without-layout": {
		Doc:   "fyne.NewContainerWithoutLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("container-without-layout: arg 1: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("container-without-layout: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("container-without-layout: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("container-without-layout: arg 1: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("container-without-layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("container-without-layout: arg 1: expected block, native or nil")
			}
			res0 := fyne.NewContainerWithoutLayout(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-container")
			return res0Obj
		},
	},
	"delta": {
		Doc:   "fyne.NewDelta",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("delta: arg 1: expected decimal")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("delta: arg 2: expected decimal")
			}
			res0 := fyne.NewDelta(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-delta")
			return res0Obj
		},
	},
	"main-menu": {
		Doc:   "fyne.NewMainMenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*fyne.Menu
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*fyne.Menu, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*fyne.Menu)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("main-menu: arg 1: block item: expected native of type *fyne.Menu")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("main-menu: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("main-menu: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("main-menu: arg 1: expected native of type []*fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("main-menu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("main-menu: arg 1: expected block, native or nil")
			}
			res0 := fyne.NewMainMenu(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-main-menu")
			return res0Obj
		},
	},
	"menu": {
		Doc:   "fyne.NewMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("menu: arg 1: expected string")
			}
			var arg1Val []*fyne.MenuItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]*fyne.MenuItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(*fyne.MenuItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("menu: arg 2: block item: expected native of type *fyne.MenuItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("menu: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("menu: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("menu: arg 2: expected native of type []*fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("menu: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("menu: arg 2: expected block, native or nil")
			}
			res0 := fyne.NewMenu(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-menu")
			return res0Obj
		},
	},
	"menu-item": {
		Doc:   "fyne.NewMenuItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("menu-item: arg 1: expected string")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("menu-item: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("menu-item: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("menu-item: arg 2: expected function or nil")
			}
			res0 := fyne.NewMenuItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-menu-item")
			return res0Obj
		},
	},
	"menu-item-separator": {
		Doc:   "fyne.NewMenuItemSeparator",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := fyne.NewMenuItemSeparator()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-menu-item")
			return res0Obj
		},
	},
	"notification": {
		Doc:   "fyne.NewNotification",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("notification: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("notification: arg 2: expected string")
			}
			res0 := fyne.NewNotification(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-notification")
			return res0Obj
		},
	},
	"pos": {
		Doc:   "fyne.NewPos",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("pos: arg 1: expected decimal")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("pos: arg 2: expected decimal")
			}
			res0 := fyne.NewPos(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"size": {
		Doc:   "fyne.NewSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("size: arg 1: expected decimal")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("size: arg 2: expected decimal")
			}
			res0 := fyne.NewSize(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"square-offset-pos": {
		Doc:   "fyne.NewSquareOffsetPos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("square-offset-pos: arg 1: expected decimal")
			}
			res0 := fyne.NewSquareOffsetPos(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"square-size": {
		Doc:   "fyne.NewSquareSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("square-size: arg 1: expected decimal")
			}
			res0 := fyne.NewSquareSize(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"static-resource": {
		Doc:   "fyne.NewStaticResource",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("static-resource: arg 1: expected string")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("static-resource: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("static-resource: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("static-resource: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("static-resource: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("static-resource: arg 2: expected block, native or nil")
			}
			res0 := fyne.NewStaticResource(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-static-resource")
			return res0Obj
		},
	},
	"fyne-notification//content!": {
		Doc:   "Set fyne.Notification Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-notification//content!: arg 1: expected native of type fyne.Notification")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-notification//content!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Content = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-notification//content!: arg 2: expected string")
			}
			return arg0
		},
	},
	"fyne-notification//content?": {
		Doc:   "Get fyne.Notification Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-notification//content?: arg 1: expected native of type fyne.Notification")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-notification//content?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Content)
			return resObj
		},
	},
	"fyne-notification//title!": {
		Doc:   "Set fyne.Notification Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-notification//title!: arg 1: expected native of type fyne.Notification")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-notification//title!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-notification//title!: arg 2: expected string")
			}
			return arg0
		},
	},
	"fyne-notification//title?": {
		Doc:   "Get fyne.Notification Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-notification//title?: arg 1: expected native of type fyne.Notification")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-notification//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"orientation-horizontal-left": {
		Doc:   "Get fyne.OrientationHorizontalLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.OrientationHorizontalLeft)))
			return resObj
		},
	},
	"orientation-horizontal-right": {
		Doc:   "Get fyne.OrientationHorizontalRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.OrientationHorizontalRight)))
			return resObj
		},
	},
	"orientation-vertical": {
		Doc:   "Get fyne.OrientationVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.OrientationVertical)))
			return resObj
		},
	},
	"orientation-vertical-upside-down": {
		Doc:   "Get fyne.OrientationVerticalUpsideDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.OrientationVerticalUpsideDown)))
			return resObj
		},
	},
	"fyne-overlay-stack//add": {
		Doc:   "fyne.OverlayStack.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//add: arg 1: expected native of type fyne.OverlayStack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-overlay-stack//add: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//add: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-overlay-stack//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"fyne-overlay-stack//list": {
		Doc:   "fyne.OverlayStack.List",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//list: arg 1: expected native of type fyne.OverlayStack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-overlay-stack//list: arg 1: expected native")
			}
			res0 := arg0Val.List()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-canvas-object")
						}
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-overlay-stack//remove": {
		Doc:   "fyne.OverlayStack.Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//remove: arg 1: expected native of type fyne.OverlayStack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//remove: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-overlay-stack//remove: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//remove: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//remove: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-overlay-stack//remove: arg 2: expected native")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"fyne-overlay-stack//top": {
		Doc:   "fyne.OverlayStack.Top",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//top: arg 1: expected native of type fyne.OverlayStack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-overlay-stack//top: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-overlay-stack//top: arg 1: expected native")
			}
			res0 := arg0Val.Top()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"fyne-point-event//absolute-position!": {
		Doc:   "Set fyne.PointEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-point-event//absolute-position!: arg 1: expected native of type fyne.PointEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-point-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-point-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-point-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-point-event//absolute-position?": {
		Doc:   "Get fyne.PointEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-point-event//absolute-position?: arg 1: expected native of type fyne.PointEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-point-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"fyne-point-event//position!": {
		Doc:   "Set fyne.PointEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-point-event//position!: arg 1: expected native of type fyne.PointEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-point-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-point-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-point-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-point-event//position?": {
		Doc:   "Get fyne.PointEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-point-event//position?: arg 1: expected native of type fyne.PointEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-point-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"fyne-position//add": {
		Doc:   "fyne.Position.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//add: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//add: arg 1: expected native")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//add: arg 2: expected native of type fyne.Vector2")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-position//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//add: arg 2: expected native")
			}
			res0 := arg0Val.Add(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-position//add-xy": {
		Doc:   "fyne.Position.AddXY",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//add-xy: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//add-xy: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-position//add-xy: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-position//add-xy: arg 3: expected decimal")
			}
			res0 := arg0Val.AddXY(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-position//components": {
		Doc:   "fyne.Position.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//components: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//components: arg 1: expected native")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-position//is-zero": {
		Doc:   "fyne.Position.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//is-zero: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//is-zero: arg 1: expected native")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-position//subtract": {
		Doc:   "fyne.Position.Subtract",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//subtract: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//subtract: arg 1: expected native")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//subtract: arg 2: expected native of type fyne.Vector2")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-position//subtract: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//subtract: arg 2: expected native")
			}
			res0 := arg0Val.Subtract(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-position//subtract-xy": {
		Doc:   "fyne.Position.SubtractXY",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//subtract-xy: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//subtract-xy: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-position//subtract-xy: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-position//subtract-xy: arg 3: expected decimal")
			}
			res0 := arg0Val.SubtractXY(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-position//x!": {
		Doc:   "Set fyne.Position X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//x!: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-position//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"fyne-position//x?": {
		Doc:   "Get fyne.Position X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//x?: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"fyne-position//y!": {
		Doc:   "Set fyne.Position Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//y!: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-position//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"fyne-position//y?": {
		Doc:   "Get fyne.Position Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-position//y?: arg 1: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-position//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"fyne-preferences//add-change-listener": {
		Doc:   "fyne.Preferences.AddChangeListener",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//add-change-listener: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//add-change-listener: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//add-change-listener: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//add-change-listener: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//add-change-listener: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//add-change-listener: arg 2: expected function or nil")
			}
			arg0Val.AddChangeListener(arg1Val)
			return arg0
		},
	},
	"fyne-preferences//bool": {
		Doc:   "fyne.Preferences.Bool",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool: arg 2: expected string")
			}
			res0 := arg0Val.Bool(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//bool-list": {
		Doc:   "fyne.Preferences.BoolList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool-list: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool-list: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool-list: arg 2: expected string")
			}
			res0 := arg0Val.BoolList(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(boolToInt64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-preferences//bool-list-with-fallback": {
		Doc:   "fyne.Preferences.BoolListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool-list-with-fallback: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool-list-with-fallback: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool-list-with-fallback: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool-list-with-fallback: arg 2: expected string")
			}
			var arg2Val []bool
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]bool, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = v.Value != 0
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-preferences//bool-list-with-fallback: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool-list-with-fallback: arg 3: expected native of type []bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool-list-with-fallback: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool-list-with-fallback: arg 3: expected block, native or nil")
			}
			res0 := arg0Val.BoolListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(boolToInt64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-preferences//bool-with-fallback": {
		Doc:   "fyne.Preferences.BoolWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool-with-fallback: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//bool-with-fallback: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool-with-fallback: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool-with-fallback: arg 2: expected string")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//bool-with-fallback: arg 3: expected integer")
			}
			res0 := arg0Val.BoolWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//change-listeners": {
		Doc:   "fyne.Preferences.ChangeListeners",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//change-listeners: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//change-listeners: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//change-listeners: arg 1: expected native")
			}
			res0 := arg0Val.ChangeListeners()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "func()")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-preferences//float": {
		Doc:   "fyne.Preferences.Float",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float: arg 2: expected string")
			}
			res0 := arg0Val.Float(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//float-list": {
		Doc:   "fyne.Preferences.FloatList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float-list: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float-list: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float-list: arg 2: expected string")
			}
			res0 := arg0Val.FloatList(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewDecimal(float64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-preferences//float-list-with-fallback": {
		Doc:   "fyne.Preferences.FloatListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float-list-with-fallback: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float-list-with-fallback: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float-list-with-fallback: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float-list-with-fallback: arg 2: expected string")
			}
			var arg2Val []float64
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]float64, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg2Val[i] = float64(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-preferences//float-list-with-fallback: arg 3: block item: expected decimal")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]float64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float-list-with-fallback: arg 3: expected native of type []float64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float-list-with-fallback: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float-list-with-fallback: arg 3: expected block, native or nil")
			}
			res0 := arg0Val.FloatListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewDecimal(float64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-preferences//float-with-fallback": {
		Doc:   "fyne.Preferences.FloatWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float-with-fallback: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//float-with-fallback: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float-with-fallback: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float-with-fallback: arg 2: expected string")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//float-with-fallback: arg 3: expected decimal")
			}
			res0 := arg0Val.FloatWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//int": {
		Doc:   "fyne.Preferences.Int",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int: arg 2: expected string")
			}
			res0 := arg0Val.Int(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//int-list": {
		Doc:   "fyne.Preferences.IntList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int-list: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int-list: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int-list: arg 2: expected string")
			}
			res0 := arg0Val.IntList(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-preferences//int-list-with-fallback": {
		Doc:   "fyne.Preferences.IntListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int-list-with-fallback: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int-list-with-fallback: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int-list-with-fallback: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int-list-with-fallback: arg 2: expected string")
			}
			var arg2Val []int
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-preferences//int-list-with-fallback: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int-list-with-fallback: arg 3: expected native of type []int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int-list-with-fallback: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int-list-with-fallback: arg 3: expected block, native or nil")
			}
			res0 := arg0Val.IntListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-preferences//int-with-fallback": {
		Doc:   "fyne.Preferences.IntWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int-with-fallback: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//int-with-fallback: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int-with-fallback: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int-with-fallback: arg 2: expected string")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//int-with-fallback: arg 3: expected integer")
			}
			res0 := arg0Val.IntWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//remove-value": {
		Doc:   "fyne.Preferences.RemoveValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//remove-value: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//remove-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//remove-value: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//remove-value: arg 2: expected string")
			}
			arg0Val.RemoveValue(arg1Val)
			return arg0
		},
	},
	"fyne-preferences//set-bool": {
		Doc:   "fyne.Preferences.SetBool",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-bool: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-bool: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-bool: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-bool: arg 2: expected string")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-bool: arg 3: expected integer")
			}
			arg0Val.SetBool(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-bool-list": {
		Doc:   "fyne.Preferences.SetBoolList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-bool-list: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-bool-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-bool-list: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-bool-list: arg 2: expected string")
			}
			var arg2Val []bool
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]bool, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = v.Value != 0
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-preferences//set-bool-list: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-bool-list: arg 3: expected native of type []bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-bool-list: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-bool-list: arg 3: expected block, native or nil")
			}
			arg0Val.SetBoolList(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-float": {
		Doc:   "fyne.Preferences.SetFloat",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-float: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-float: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-float: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-float: arg 2: expected string")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-float: arg 3: expected decimal")
			}
			arg0Val.SetFloat(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-float-list": {
		Doc:   "fyne.Preferences.SetFloatList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-float-list: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-float-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-float-list: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-float-list: arg 2: expected string")
			}
			var arg2Val []float64
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]float64, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg2Val[i] = float64(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-preferences//set-float-list: arg 3: block item: expected decimal")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]float64)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-float-list: arg 3: expected native of type []float64")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-float-list: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-float-list: arg 3: expected block, native or nil")
			}
			arg0Val.SetFloatList(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-int": {
		Doc:   "fyne.Preferences.SetInt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-int: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-int: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-int: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-int: arg 2: expected string")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-int: arg 3: expected integer")
			}
			arg0Val.SetInt(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-int-list": {
		Doc:   "fyne.Preferences.SetIntList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-int-list: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-int-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-int-list: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-int-list: arg 2: expected string")
			}
			var arg2Val []int
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-preferences//set-int-list: arg 3: block item: expected integer")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]int)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-int-list: arg 3: expected native of type []int")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-int-list: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-int-list: arg 3: expected block, native or nil")
			}
			arg0Val.SetIntList(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-string": {
		Doc:   "fyne.Preferences.SetString",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-string: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-string: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-string: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-string: arg 3: expected string")
			}
			arg0Val.SetString(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-string-list": {
		Doc:   "fyne.Preferences.SetStringList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-string-list: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-string-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-string-list: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-string-list: arg 2: expected string")
			}
			var arg2Val []string
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg2Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-preferences//set-string-list: arg 3: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-string-list: arg 3: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//set-string-list: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//set-string-list: arg 3: expected block, native or nil")
			}
			arg0Val.SetStringList(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//string": {
		Doc:   "fyne.Preferences.String",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string: arg 2: expected string")
			}
			res0 := arg0Val.String(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-preferences//string-list": {
		Doc:   "fyne.Preferences.StringList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string-list: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string-list: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string-list: arg 2: expected string")
			}
			res0 := arg0Val.StringList(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-preferences//string-list-with-fallback": {
		Doc:   "fyne.Preferences.StringListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string-list-with-fallback: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string-list-with-fallback: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string-list-with-fallback: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string-list-with-fallback: arg 2: expected string")
			}
			var arg2Val []string
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg2Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-preferences//string-list-with-fallback: arg 3: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string-list-with-fallback: arg 3: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string-list-with-fallback: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string-list-with-fallback: arg 3: expected block, native or nil")
			}
			res0 := arg0Val.StringListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-preferences//string-with-fallback": {
		Doc:   "fyne.Preferences.StringWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string-with-fallback: arg 1: expected native of type fyne.Preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-preferences//string-with-fallback: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string-with-fallback: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string-with-fallback: arg 2: expected string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-preferences//string-with-fallback: arg 3: expected string")
			}
			res0 := arg0Val.StringWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-resource//content": {
		Doc:   "fyne.Resource.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-resource//content: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-resource//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-resource//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-resource//name": {
		Doc:   "fyne.Resource.Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-resource//name: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-resource//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-resource//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-scroll-event//absolute-position!": {
		Doc:   "Set fyne.ScrollEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scroll-event//absolute-position!: arg 1: expected native of type fyne.ScrollEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scroll-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scroll-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scroll-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-scroll-event//absolute-position?": {
		Doc:   "Get fyne.ScrollEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scroll-event//absolute-position?: arg 1: expected native of type fyne.ScrollEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scroll-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"fyne-scroll-event//position!": {
		Doc:   "Set fyne.ScrollEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scroll-event//position!: arg 1: expected native of type fyne.ScrollEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scroll-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scroll-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scroll-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-scroll-event//position?": {
		Doc:   "Get fyne.ScrollEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scroll-event//position?: arg 1: expected native of type fyne.ScrollEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scroll-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"fyne-scroll-event//scrolled!": {
		Doc:   "Set fyne.ScrollEvent Scrolled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scroll-event//scrolled!: arg 1: expected native of type fyne.ScrollEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scroll-event//scrolled!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scrolled, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scroll-event//scrolled!: arg 2: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scroll-event//scrolled!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-scroll-event//scrolled?": {
		Doc:   "Get fyne.ScrollEvent Scrolled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scroll-event//scrolled?: arg 1: expected native of type fyne.ScrollEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scroll-event//scrolled?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scrolled, "fyne-delta")
			return resObj
		},
	},
	"fyne-scrollable//scrolled": {
		Doc:   "fyne.Scrollable.Scrolled",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Scrollable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Scrollable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scrollable//scrolled: arg 1: expected native of type fyne.Scrollable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-scrollable//scrolled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scrollable//scrolled: arg 1: expected native")
			}
			var arg1Val *fyne.ScrollEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-scrollable//scrolled: arg 2: expected native of type *fyne.ScrollEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-scrollable//scrolled: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-scrollable//scrolled: arg 2: expected native")
			}
			arg0Val.Scrolled(arg1Val)
			return arg0
		},
	},
	"fyne-secondary-tappable//tapped-secondary": {
		Doc:   "fyne.SecondaryTappable.TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.SecondaryTappable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.SecondaryTappable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-secondary-tappable//tapped-secondary: arg 1: expected native of type fyne.SecondaryTappable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-secondary-tappable//tapped-secondary: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-secondary-tappable//tapped-secondary: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-secondary-tappable//tapped-secondary: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-secondary-tappable//tapped-secondary: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-secondary-tappable//tapped-secondary: arg 2: expected native")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"set-current-app": {
		Doc:   "fyne.SetCurrentApp",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("set-current-app: arg 1: expected native of type fyne.App")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("set-current-app: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("set-current-app: arg 1: expected native")
			}
			fyne.SetCurrentApp(arg0Val)
			return nil
		},
	},
	"fyne-settings//build-type": {
		Doc:   "fyne.Settings.BuildType",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//build-type: arg 1: expected native of type fyne.Settings")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//build-type: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-settings//build-type: arg 1: expected native")
			}
			res0 := arg0Val.BuildType()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"fyne-settings//primary-color": {
		Doc:   "fyne.Settings.PrimaryColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//primary-color: arg 1: expected native of type fyne.Settings")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//primary-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-settings//primary-color: arg 1: expected native")
			}
			res0 := arg0Val.PrimaryColor()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-settings//scale": {
		Doc:   "fyne.Settings.Scale",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//scale: arg 1: expected native of type fyne.Settings")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-settings//scale: arg 1: expected native")
			}
			res0 := arg0Val.Scale()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-settings//set-theme": {
		Doc:   "fyne.Settings.SetTheme",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//set-theme: arg 1: expected native of type fyne.Settings")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//set-theme: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-settings//set-theme: arg 1: expected native")
			}
			var arg1Val fyne.Theme
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//set-theme: arg 2: expected native of type fyne.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//set-theme: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-settings//set-theme: arg 2: expected native")
			}
			arg0Val.SetTheme(arg1Val)
			return arg0
		},
	},
	"fyne-settings//show-animations": {
		Doc:   "fyne.Settings.ShowAnimations",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//show-animations: arg 1: expected native of type fyne.Settings")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//show-animations: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-settings//show-animations: arg 1: expected native")
			}
			res0 := arg0Val.ShowAnimations()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-settings//theme": {
		Doc:   "fyne.Settings.Theme",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//theme: arg 1: expected native of type fyne.Settings")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//theme: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-settings//theme: arg 1: expected native")
			}
			res0 := arg0Val.Theme()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
				}
			}
			return res0Obj
		},
	},
	"fyne-settings//theme-variant": {
		Doc:   "fyne.Settings.ThemeVariant",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//theme-variant: arg 1: expected native of type fyne.Settings")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-settings//theme-variant: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-settings//theme-variant: arg 1: expected native")
			}
			res0 := arg0Val.ThemeVariant()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint(res0)))
			return res0Obj
		},
	},
	"fyne-shortcut-copy//clipboard!": {
		Doc:   "Set fyne.ShortcutCopy Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCopy)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-copy//clipboard!: arg 1: expected native of type fyne.ShortcutCopy")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut-copy//clipboard!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-copy//clipboard!: arg 2: expected native of type fyne.Clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-copy//clipboard!: arg 2: expected integer to be 0 or nil")
				}
				self.Clipboard = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut-copy//clipboard!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-shortcut-copy//clipboard?": {
		Doc:   "Get fyne.ShortcutCopy Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCopy)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-copy//clipboard?: arg 1: expected native of type fyne.ShortcutCopy")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut-copy//clipboard?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Clipboard)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
				}
			}
			return resObj
		},
	},
	"fyne-shortcut-cut//clipboard!": {
		Doc:   "Set fyne.ShortcutCut Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-cut//clipboard!: arg 1: expected native of type fyne.ShortcutCut")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut-cut//clipboard!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-cut//clipboard!: arg 2: expected native of type fyne.Clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-cut//clipboard!: arg 2: expected integer to be 0 or nil")
				}
				self.Clipboard = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut-cut//clipboard!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-shortcut-cut//clipboard?": {
		Doc:   "Get fyne.ShortcutCut Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-cut//clipboard?: arg 1: expected native of type fyne.ShortcutCut")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut-cut//clipboard?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Clipboard)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
				}
			}
			return resObj
		},
	},
	"fyne-shortcut-paste//clipboard!": {
		Doc:   "Set fyne.ShortcutPaste Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutPaste)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-paste//clipboard!: arg 1: expected native of type fyne.ShortcutPaste")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut-paste//clipboard!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-paste//clipboard!: arg 2: expected native of type fyne.Clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-paste//clipboard!: arg 2: expected integer to be 0 or nil")
				}
				self.Clipboard = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut-paste//clipboard!: arg 2: expected native")
			}
			return arg0
		},
	},
	"fyne-shortcut-paste//clipboard?": {
		Doc:   "Get fyne.ShortcutPaste Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutPaste)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut-paste//clipboard?: arg 1: expected native of type fyne.ShortcutPaste")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut-paste//clipboard?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Clipboard)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
				}
			}
			return resObj
		},
	},
	"fyne-shortcut//shortcut-name": {
		Doc:   "fyne.Shortcut.ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Shortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut//shortcut-name: arg 1: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcut//shortcut-name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcut//shortcut-name: arg 1: expected native")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-shortcutable//typed-shortcut": {
		Doc:   "fyne.Shortcutable.TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Shortcutable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Shortcutable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcutable//typed-shortcut: arg 1: expected native of type fyne.Shortcutable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcutable//typed-shortcut: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcutable//typed-shortcut: arg 1: expected native")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcutable//typed-shortcut: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-shortcutable//typed-shortcut: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-shortcutable//typed-shortcut: arg 2: expected native")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"fyne-size//add": {
		Doc:   "fyne.Size.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//add: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//add: arg 1: expected native")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//add: arg 2: expected native of type fyne.Vector2")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-size//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//add: arg 2: expected native")
			}
			res0 := arg0Val.Add(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//add-width-height": {
		Doc:   "fyne.Size.AddWidthHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//add-width-height: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//add-width-height: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-size//add-width-height: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-size//add-width-height: arg 3: expected decimal")
			}
			res0 := arg0Val.AddWidthHeight(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//components": {
		Doc:   "fyne.Size.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//components: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//components: arg 1: expected native")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-size//height!": {
		Doc:   "Set fyne.Size Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//height!: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//height!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Height = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-size//height!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"fyne-size//height?": {
		Doc:   "Get fyne.Size Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//height?: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Height))
			return resObj
		},
	},
	"fyne-size//is-zero": {
		Doc:   "fyne.Size.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//is-zero: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//is-zero: arg 1: expected native")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-size//max": {
		Doc:   "fyne.Size.Max",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//max: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//max: arg 1: expected native")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//max: arg 2: expected native of type fyne.Vector2")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-size//max: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//max: arg 2: expected native")
			}
			res0 := arg0Val.Max(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//min": {
		Doc:   "fyne.Size.Min",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//min: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//min: arg 1: expected native")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//min: arg 2: expected native of type fyne.Vector2")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-size//min: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//min: arg 2: expected native")
			}
			res0 := arg0Val.Min(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//subtract": {
		Doc:   "fyne.Size.Subtract",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//subtract: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//subtract: arg 1: expected native")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//subtract: arg 2: expected native of type fyne.Vector2")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-size//subtract: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//subtract: arg 2: expected native")
			}
			res0 := arg0Val.Subtract(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//subtract-width-height": {
		Doc:   "fyne.Size.SubtractWidthHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//subtract-width-height: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//subtract-width-height: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-size//subtract-width-height: arg 2: expected decimal")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-size//subtract-width-height: arg 3: expected decimal")
			}
			res0 := arg0Val.SubtractWidthHeight(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//width!": {
		Doc:   "Set fyne.Size Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//width!: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-size//width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"fyne-size//width?": {
		Doc:   "Get fyne.Size Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-size//width?: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-size//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"fyne-static-resource//static-content!": {
		Doc:   "Set fyne.StaticResource StaticContent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-static-resource//static-content!: arg 1: expected native of type fyne.StaticResource")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-static-resource//static-content!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.StaticContent = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.StaticContent[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("fyne-static-resource//static-content!: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("fyne-static-resource//static-content!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.StaticContent, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-static-resource//static-content!: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-static-resource//static-content!: arg 2: expected integer to be 0 or nil")
				}
				self.StaticContent = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-static-resource//static-content!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"fyne-static-resource//static-content?": {
		Doc:   "Get fyne.StaticResource StaticContent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-static-resource//static-content?: arg 1: expected native of type fyne.StaticResource")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-static-resource//static-content?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.StaticContent))
				for i, it := range self.StaticContent {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"fyne-static-resource//static-name!": {
		Doc:   "Set fyne.StaticResource StaticName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-static-resource//static-name!: arg 1: expected native of type fyne.StaticResource")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-static-resource//static-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.StaticName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-static-resource//static-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"fyne-static-resource//static-name?": {
		Doc:   "Get fyne.StaticResource StaticName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-static-resource//static-name?: arg 1: expected native of type fyne.StaticResource")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-static-resource//static-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.StaticName)
			return resObj
		},
	},
	"fyne-storage//create": {
		Doc:   "fyne.Storage.Create",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//create: arg 1: expected native of type fyne.Storage")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//create: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-storage//create: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-storage//create: arg 2: expected string")
			}
			res0, res1 := arg0Val.Create(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"fyne-storage//list": {
		Doc:   "fyne.Storage.List",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//list: arg 1: expected native of type fyne.Storage")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-storage//list: arg 1: expected native")
			}
			res0 := arg0Val.List()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-storage//open": {
		Doc:   "fyne.Storage.Open",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//open: arg 1: expected native of type fyne.Storage")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//open: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-storage//open: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-storage//open: arg 2: expected string")
			}
			res0, res1 := arg0Val.Open(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"fyne-storage//remove": {
		Doc:   "fyne.Storage.Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//remove: arg 1: expected native of type fyne.Storage")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//remove: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-storage//remove: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-storage//remove: arg 2: expected string")
			}
			res0 := arg0Val.Remove(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"fyne-storage//root-uri": {
		Doc:   "fyne.Storage.RootURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//root-uri: arg 1: expected native of type fyne.Storage")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//root-uri: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-storage//root-uri: arg 1: expected native")
			}
			res0 := arg0Val.RootURI()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			return res0Obj
		},
	},
	"fyne-storage//save": {
		Doc:   "fyne.Storage.Save",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//save: arg 1: expected native of type fyne.Storage")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-storage//save: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-storage//save: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-storage//save: arg 2: expected string")
			}
			res0, res1 := arg0Val.Save(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"fyne-tabbable//accepts-tab": {
		Doc:   "fyne.Tabbable.AcceptsTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Tabbable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Tabbable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-tabbable//accepts-tab: arg 1: expected native of type fyne.Tabbable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-tabbable//accepts-tab: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-tabbable//accepts-tab: arg 1: expected native")
			}
			res0 := arg0Val.AcceptsTab()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-tappable//tapped": {
		Doc:   "fyne.Tappable.Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Tappable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Tappable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-tappable//tapped: arg 1: expected native of type fyne.Tappable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-tappable//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-tappable//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-tappable//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-tappable//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-tappable//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"text-align-center": {
		Doc:   "Get fyne.TextAlignCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextAlignCenter)))
			return resObj
		},
	},
	"text-align-leading": {
		Doc:   "Get fyne.TextAlignLeading value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextAlignLeading)))
			return resObj
		},
	},
	"text-align-trailing": {
		Doc:   "Get fyne.TextAlignTrailing value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextAlignTrailing)))
			return resObj
		},
	},
	"fyne-text-style//bold!": {
		Doc:   "Set fyne.TextStyle Bold value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//bold!: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//bold!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Bold = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//bold!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-text-style//bold?": {
		Doc:   "Get fyne.TextStyle Bold value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//bold?: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//bold?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Bold))
			return resObj
		},
	},
	"fyne-text-style//italic!": {
		Doc:   "Set fyne.TextStyle Italic value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//italic!: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//italic!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Italic = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//italic!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-text-style//italic?": {
		Doc:   "Get fyne.TextStyle Italic value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//italic?: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//italic?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Italic))
			return resObj
		},
	},
	"fyne-text-style//monospace!": {
		Doc:   "Set fyne.TextStyle Monospace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//monospace!: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//monospace!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Monospace = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//monospace!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-text-style//monospace?": {
		Doc:   "Get fyne.TextStyle Monospace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//monospace?: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//monospace?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Monospace))
			return resObj
		},
	},
	"fyne-text-style//symbol!": {
		Doc:   "Set fyne.TextStyle Symbol value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//symbol!: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//symbol!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Symbol = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//symbol!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-text-style//symbol?": {
		Doc:   "Get fyne.TextStyle Symbol value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//symbol?: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//symbol?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Symbol))
			return resObj
		},
	},
	"fyne-text-style//tab-width!": {
		Doc:   "Set fyne.TextStyle TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//tab-width!: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//tab-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//tab-width!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"fyne-text-style//tab-width?": {
		Doc:   "Get fyne.TextStyle TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-text-style//tab-width?: arg 1: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-text-style//tab-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"text-truncate": {
		Doc:   "Get fyne.TextTruncate value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextTruncate)))
			return resObj
		},
	},
	"text-truncate-clip": {
		Doc:   "Get fyne.TextTruncateClip value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextTruncateClip)))
			return resObj
		},
	},
	"text-truncate-ellipsis": {
		Doc:   "Get fyne.TextTruncateEllipsis value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextTruncateEllipsis)))
			return resObj
		},
	},
	"text-truncate-off": {
		Doc:   "Get fyne.TextTruncateOff value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextTruncateOff)))
			return resObj
		},
	},
	"text-wrap-break": {
		Doc:   "Get fyne.TextWrapBreak value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextWrapBreak)))
			return resObj
		},
	},
	"text-wrap-off": {
		Doc:   "Get fyne.TextWrapOff value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextWrapOff)))
			return resObj
		},
	},
	"text-wrap-word": {
		Doc:   "Get fyne.TextWrapWord value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(fyne.TextWrapWord)))
			return resObj
		},
	},
	"fyne-theme//color": {
		Doc:   "fyne.Theme.Color",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-theme//color: arg 1: expected native of type fyne.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-theme//color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-theme//color: arg 1: expected native")
			}
			var arg1Val fyne.ThemeColorName
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeColorName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeColorName)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-theme//color: arg 2: expected string")
					}
					arg1Val = fyne.ThemeColorName(u)
				}
			}
			var arg2Val fyne.ThemeVariant
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeVariant
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeVariant)
				}
				if natOk && natValOk {
					arg2Val = natVal
				} else {
					var u uint
					if v, ok := arg2.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-theme//color: arg 3: expected integer")
					}
					arg2Val = fyne.ThemeVariant(u)
				}
			}
			res0 := arg0Val.Color(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-theme//font": {
		Doc:   "fyne.Theme.Font",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-theme//font: arg 1: expected native of type fyne.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-theme//font: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-theme//font: arg 1: expected native")
			}
			var arg1Val fyne.TextStyle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-theme//font: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-theme//font: arg 2: expected native")
			}
			res0 := arg0Val.Font(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-theme//icon": {
		Doc:   "fyne.Theme.Icon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-theme//icon: arg 1: expected native of type fyne.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-theme//icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-theme//icon: arg 1: expected native")
			}
			var arg1Val fyne.ThemeIconName
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeIconName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeIconName)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-theme//icon: arg 2: expected string")
					}
					arg1Val = fyne.ThemeIconName(u)
				}
			}
			res0 := arg0Val.Icon(arg1Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-theme//size": {
		Doc:   "fyne.Theme.Size",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-theme//size: arg 1: expected native of type fyne.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-theme//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-theme//size: arg 1: expected native")
			}
			var arg1Val fyne.ThemeSizeName
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeSizeName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeSizeName)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("fyne-theme//size: arg 2: expected string")
					}
					arg1Val = fyne.ThemeSizeName(u)
				}
			}
			res0 := arg0Val.Size(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-validatable//set-on-validation-changed": {
		Doc:   "fyne.Validatable.SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Validatable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Validatable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-validatable//set-on-validation-changed: arg 1: expected native of type fyne.Validatable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-validatable//set-on-validation-changed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-validatable//set-on-validation-changed: arg 1: expected native")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("fyne-validatable//set-on-validation-changed: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-validatable//set-on-validation-changed: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-validatable//set-on-validation-changed: arg 2: expected function or nil")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"fyne-validatable//validate": {
		Doc:   "fyne.Validatable.Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Validatable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Validatable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-validatable//validate: arg 1: expected native of type fyne.Validatable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-validatable//validate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-validatable//validate: arg 1: expected native")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"fyne-vector-2//components": {
		Doc:   "fyne.Vector2.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Vector2
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-vector-2//components: arg 1: expected native of type fyne.Vector2")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-vector-2//components: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-vector-2//components: arg 1: expected native")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-vector-2//is-zero": {
		Doc:   "fyne.Vector2.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Vector2
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-vector-2//is-zero: arg 1: expected native of type fyne.Vector2")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-vector-2//is-zero: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-vector-2//is-zero: arg 1: expected native")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-widget-renderer//destroy": {
		Doc:   "fyne.WidgetRenderer.Destroy",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//destroy: arg 1: expected native of type fyne.WidgetRenderer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//destroy: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-widget-renderer//destroy: arg 1: expected native")
			}
			arg0Val.Destroy()
			return arg0
		},
	},
	"fyne-widget-renderer//layout": {
		Doc:   "fyne.WidgetRenderer.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//layout: arg 1: expected native of type fyne.WidgetRenderer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-widget-renderer//layout: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//layout: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-widget-renderer//layout: arg 2: expected native")
			}
			arg0Val.Layout(arg1Val)
			return arg0
		},
	},
	"fyne-widget-renderer//min-size": {
		Doc:   "fyne.WidgetRenderer.MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//min-size: arg 1: expected native of type fyne.WidgetRenderer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-widget-renderer//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-widget-renderer//objects": {
		Doc:   "fyne.WidgetRenderer.Objects",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//objects: arg 1: expected native of type fyne.WidgetRenderer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//objects: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-widget-renderer//objects: arg 1: expected native")
			}
			res0 := arg0Val.Objects()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-canvas-object")
						}
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"fyne-widget-renderer//refresh": {
		Doc:   "fyne.WidgetRenderer.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//refresh: arg 1: expected native of type fyne.WidgetRenderer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-widget-renderer//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-widget-renderer//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"fyne-widget//create-renderer": {
		Doc:   "fyne.Widget.CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Widget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-widget//create-renderer: arg 1: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-widget//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-widget//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"fyne-window//canvas": {
		Doc:   "fyne.Window.Canvas",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//canvas: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//canvas: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//canvas: arg 1: expected native")
			}
			res0 := arg0Val.Canvas()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas")
				}
			}
			return res0Obj
		},
	},
	"fyne-window//center-on-screen": {
		Doc:   "fyne.Window.CenterOnScreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//center-on-screen: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//center-on-screen: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//center-on-screen: arg 1: expected native")
			}
			arg0Val.CenterOnScreen()
			return arg0
		},
	},
	"fyne-window//clipboard": {
		Doc:   "fyne.Window.Clipboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//clipboard: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//clipboard: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//clipboard: arg 1: expected native")
			}
			res0 := arg0Val.Clipboard()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-clipboard")
				}
			}
			return res0Obj
		},
	},
	"fyne-window//close": {
		Doc:   "fyne.Window.Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//close: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//close: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//close: arg 1: expected native")
			}
			arg0Val.Close()
			return arg0
		},
	},
	"fyne-window//content": {
		Doc:   "fyne.Window.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//content: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"fyne-window//fixed-size": {
		Doc:   "fyne.Window.FixedSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//fixed-size: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//fixed-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//fixed-size: arg 1: expected native")
			}
			res0 := arg0Val.FixedSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-window//full-screen": {
		Doc:   "fyne.Window.FullScreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//full-screen: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//full-screen: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//full-screen: arg 1: expected native")
			}
			res0 := arg0Val.FullScreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-window//hide": {
		Doc:   "fyne.Window.Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//hide: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"fyne-window//icon": {
		Doc:   "fyne.Window.Icon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//icon: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//icon: arg 1: expected native")
			}
			res0 := arg0Val.Icon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"fyne-window//main-menu": {
		Doc:   "fyne.Window.MainMenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//main-menu: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//main-menu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//main-menu: arg 1: expected native")
			}
			res0 := arg0Val.MainMenu()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-fyne-main-menu")
			return res0Obj
		},
	},
	"fyne-window//padded": {
		Doc:   "fyne.Window.Padded",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//padded: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//padded: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//padded: arg 1: expected native")
			}
			res0 := arg0Val.Padded()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-window//request-focus": {
		Doc:   "fyne.Window.RequestFocus",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//request-focus: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//request-focus: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//request-focus: arg 1: expected native")
			}
			arg0Val.RequestFocus()
			return arg0
		},
	},
	"fyne-window//resize": {
		Doc:   "fyne.Window.Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//resize: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-close-intercept": {
		Doc:   "fyne.Window.SetCloseIntercept",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-close-intercept: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-close-intercept: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-close-intercept: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-close-intercept: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-close-intercept: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-close-intercept: arg 2: expected function or nil")
			}
			arg0Val.SetCloseIntercept(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-content": {
		Doc:   "fyne.Window.SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-content: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-content: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-content: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-content: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-content: arg 2: expected native")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-fixed-size": {
		Doc:   "fyne.Window.SetFixedSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-fixed-size: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-fixed-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-fixed-size: arg 1: expected native")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-fixed-size: arg 2: expected integer")
			}
			arg0Val.SetFixedSize(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-full-screen": {
		Doc:   "fyne.Window.SetFullScreen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-full-screen: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-full-screen: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-full-screen: arg 1: expected native")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-full-screen: arg 2: expected integer")
			}
			arg0Val.SetFullScreen(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-icon": {
		Doc:   "fyne.Window.SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-icon: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-icon: arg 1: expected native")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-icon: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-icon: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-icon: arg 2: expected native")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-main-menu": {
		Doc:   "fyne.Window.SetMainMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-main-menu: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-main-menu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-main-menu: arg 1: expected native")
			}
			var arg1Val *fyne.MainMenu
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-main-menu: arg 2: expected native of type *fyne.MainMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-main-menu: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-main-menu: arg 2: expected native")
			}
			arg0Val.SetMainMenu(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-master": {
		Doc:   "fyne.Window.SetMaster",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-master: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-master: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-master: arg 1: expected native")
			}
			arg0Val.SetMaster()
			return arg0
		},
	},
	"fyne-window//set-on-closed": {
		Doc:   "fyne.Window.SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-on-closed: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-on-closed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-on-closed: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-on-closed: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-on-closed: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-on-closed: arg 2: expected function or nil")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-on-dropped": {
		Doc:   "fyne.Window.SetOnDropped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-on-dropped: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-on-dropped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-on-dropped: arg 1: expected native")
			}
			var arg1Val func(fyne.Position, []fyne.URI)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-on-dropped: arg 2: function has invalid number of arguments (expected 2)")
				}
				arg1Val = func(arg0 fyne.Position, arg1 []fyne.URI) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-position")
					{
						items := make([]env.Object, len(arg1))
						for i, it := range arg1 {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-uri")
						}
						arg1Val = *env.NewBlock(*env.NewTSeries(items))
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-on-dropped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-on-dropped: arg 2: expected function or nil")
			}
			arg0Val.SetOnDropped(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-padded": {
		Doc:   "fyne.Window.SetPadded",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-padded: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-padded: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-padded: arg 1: expected native")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-padded: arg 2: expected integer")
			}
			arg0Val.SetPadded(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-title": {
		Doc:   "fyne.Window.SetTitle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-title: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//set-title: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-title: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("fyne-window//set-title: arg 2: expected string")
			}
			arg0Val.SetTitle(arg1Val)
			return arg0
		},
	},
	"fyne-window//show": {
		Doc:   "fyne.Window.Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//show: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"fyne-window//show-and-run": {
		Doc:   "fyne.Window.ShowAndRun",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//show-and-run: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//show-and-run: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//show-and-run: arg 1: expected native")
			}
			arg0Val.ShowAndRun()
			return arg0
		},
	},
	"fyne-window//title": {
		Doc:   "fyne.Window.Title",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("fyne-window//title: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("fyne-window//title: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("fyne-window//title: arg 1: expected native")
			}
			res0 := arg0Val.Title()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"layout-adaptive-grid-layout": {
		Doc:   "layout.NewAdaptiveGridLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("layout-adaptive-grid-layout: arg 1: expected integer")
			}
			res0 := layout.NewAdaptiveGridLayout(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-border-layout": {
		Doc:   "layout.NewBorderLayout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-border-layout: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("layout-border-layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("layout-border-layout: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-border-layout: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("layout-border-layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("layout-border-layout: arg 2: expected native")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-border-layout: arg 3: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("layout-border-layout: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("layout-border-layout: arg 3: expected native")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-border-layout: arg 4: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("layout-border-layout: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("layout-border-layout: arg 4: expected native")
			}
			res0 := layout.NewBorderLayout(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-center-layout": {
		Doc:   "layout.NewCenterLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewCenterLayout()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-form-layout": {
		Doc:   "layout.NewFormLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewFormLayout()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-grid-layout": {
		Doc:   "layout.NewGridLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("layout-grid-layout: arg 1: expected integer")
			}
			res0 := layout.NewGridLayout(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-grid-layout-with-columns": {
		Doc:   "layout.NewGridLayoutWithColumns",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("layout-grid-layout-with-columns: arg 1: expected integer")
			}
			res0 := layout.NewGridLayoutWithColumns(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-grid-layout-with-rows": {
		Doc:   "layout.NewGridLayoutWithRows",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("layout-grid-layout-with-rows: arg 1: expected integer")
			}
			res0 := layout.NewGridLayoutWithRows(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-grid-wrap-layout": {
		Doc:   "layout.NewGridWrapLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-grid-wrap-layout: arg 1: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("layout-grid-wrap-layout: arg 1: expected native")
			}
			res0 := layout.NewGridWrapLayout(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-h-box-layout": {
		Doc:   "layout.NewHBoxLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewHBoxLayout()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-max-layout": {
		Doc:   "layout.NewMaxLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewMaxLayout()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-padded-layout": {
		Doc:   "layout.NewPaddedLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewPaddedLayout()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-spacer": {
		Doc:   "layout.NewSpacer",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewSpacer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"layout-stack-layout": {
		Doc:   "layout.NewStackLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewStackLayout()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-v-box-layout": {
		Doc:   "layout.NewVBoxLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewVBoxLayout()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
				}
			}
			return res0Obj
		},
	},
	"layout-spacer-object//expand-horizontal": {
		Doc:   "layout.SpacerObject.ExpandHorizontal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val layout.SpacerObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(layout.SpacerObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-spacer-object//expand-horizontal: arg 1: expected native of type layout.SpacerObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("layout-spacer-object//expand-horizontal: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("layout-spacer-object//expand-horizontal: arg 1: expected native")
			}
			res0 := arg0Val.ExpandHorizontal()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"layout-spacer-object//expand-vertical": {
		Doc:   "layout.SpacerObject.ExpandVertical",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val layout.SpacerObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(layout.SpacerObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-spacer-object//expand-vertical: arg 1: expected native of type layout.SpacerObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("layout-spacer-object//expand-vertical: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("layout-spacer-object//expand-vertical: arg 1: expected native")
			}
			res0 := arg0Val.ExpandVertical()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"layout-spacer//fix-horizontal!": {
		Doc:   "Set layout.Spacer FixHorizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-spacer//fix-horizontal!: arg 1: expected native of type layout.Spacer")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("layout-spacer//fix-horizontal!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixHorizontal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("layout-spacer//fix-horizontal!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"layout-spacer//fix-horizontal?": {
		Doc:   "Get layout.Spacer FixHorizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-spacer//fix-horizontal?: arg 1: expected native of type layout.Spacer")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("layout-spacer//fix-horizontal?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixHorizontal))
			return resObj
		},
	},
	"layout-spacer//fix-vertical!": {
		Doc:   "Set layout.Spacer FixVertical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-spacer//fix-vertical!: arg 1: expected native of type layout.Spacer")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("layout-spacer//fix-vertical!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixVertical = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("layout-spacer//fix-vertical!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"layout-spacer//fix-vertical?": {
		Doc:   "Get layout.Spacer FixVertical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-spacer//fix-vertical?: arg 1: expected native of type layout.Spacer")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("layout-spacer//fix-vertical?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixVertical))
			return resObj
		},
	},
	"mobile-default-keyboard": {
		Doc:   "Get mobile.DefaultKeyboard value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(mobile.DefaultKeyboard)))
			return resObj
		},
	},
	"mobile-device//hide-virtual-keyboard": {
		Doc:   "mobile.Device.HideVirtualKeyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Device)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-device//hide-virtual-keyboard: arg 1: expected native of type mobile.Device")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-device//hide-virtual-keyboard: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-device//hide-virtual-keyboard: arg 1: expected native")
			}
			arg0Val.HideVirtualKeyboard()
			return arg0
		},
	},
	"mobile-device//show-virtual-keyboard": {
		Doc:   "mobile.Device.ShowVirtualKeyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Device)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-device//show-virtual-keyboard: arg 1: expected native of type mobile.Device")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-device//show-virtual-keyboard: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-device//show-virtual-keyboard: arg 1: expected native")
			}
			arg0Val.ShowVirtualKeyboard()
			return arg0
		},
	},
	"mobile-device//show-virtual-keyboard-type": {
		Doc:   "mobile.Device.ShowVirtualKeyboardType",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Device)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-device//show-virtual-keyboard-type: arg 1: expected native of type mobile.Device")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-device//show-virtual-keyboard-type: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-device//show-virtual-keyboard-type: arg 1: expected native")
			}
			var arg1Val mobile.KeyboardType
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal mobile.KeyboardType
				if natOk {
					natVal, natValOk = nat.Value.(mobile.KeyboardType)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int32
					if v, ok := arg1.(env.Integer); ok {
						u = int32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("mobile-device//show-virtual-keyboard-type: arg 2: expected integer")
					}
					arg1Val = mobile.KeyboardType(u)
				}
			}
			arg0Val.ShowVirtualKeyboardType(arg1Val)
			return arg0
		},
	},
	"mobile-driver//go-back": {
		Doc:   "mobile.Driver.GoBack",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Driver)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-driver//go-back: arg 1: expected native of type mobile.Driver")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-driver//go-back: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-driver//go-back: arg 1: expected native")
			}
			arg0Val.GoBack()
			return arg0
		},
	},
	"mobile-key-back": {
		Doc:   "Get mobile.KeyBack value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(mobile.KeyBack))
			return resObj
		},
	},
	"mobile-number-keyboard": {
		Doc:   "Get mobile.NumberKeyboard value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(mobile.NumberKeyboard)))
			return resObj
		},
	},
	"mobile-password-keyboard": {
		Doc:   "Get mobile.PasswordKeyboard value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(mobile.PasswordKeyboard)))
			return resObj
		},
	},
	"mobile-single-line-keyboard": {
		Doc:   "Get mobile.SingleLineKeyboard value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(mobile.SingleLineKeyboard)))
			return resObj
		},
	},
	"mobile-touch-event//absolute-position!": {
		Doc:   "Set mobile.TouchEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touch-event//absolute-position!: arg 1: expected native of type mobile.TouchEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touch-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touch-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touch-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"mobile-touch-event//absolute-position?": {
		Doc:   "Get mobile.TouchEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touch-event//absolute-position?: arg 1: expected native of type mobile.TouchEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touch-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"mobile-touch-event//position!": {
		Doc:   "Set mobile.TouchEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touch-event//position!: arg 1: expected native of type mobile.TouchEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touch-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touch-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touch-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"mobile-touch-event//position?": {
		Doc:   "Get mobile.TouchEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touch-event//position?: arg 1: expected native of type mobile.TouchEvent")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touch-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"mobile-touchable//touch-cancel": {
		Doc:   "mobile.Touchable.TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Touchable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Touchable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-cancel: arg 1: expected native of type mobile.Touchable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-cancel: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touchable//touch-cancel: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-cancel: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-cancel: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touchable//touch-cancel: arg 2: expected native")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"mobile-touchable//touch-down": {
		Doc:   "mobile.Touchable.TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Touchable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Touchable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-down: arg 1: expected native of type mobile.Touchable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touchable//touch-down: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-down: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touchable//touch-down: arg 2: expected native")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"mobile-touchable//touch-up": {
		Doc:   "mobile.Touchable.TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Touchable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Touchable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-up: arg 1: expected native of type mobile.Touchable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touchable//touch-up: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-up: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("mobile-touchable//touch-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("mobile-touchable//touch-up: arg 2: expected native")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"playground-render": {
		Doc:   "playground.Render",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("playground-render: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("playground-render: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("playground-render: arg 1: expected native")
			}
			playground.Render(arg0Val)
			return nil
		},
	},
	"playground-render-canvas": {
		Doc:   "playground.RenderCanvas",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("playground-render-canvas: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("playground-render-canvas: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("playground-render-canvas: arg 1: expected native")
			}
			playground.RenderCanvas(arg0Val)
			return nil
		},
	},
	"playground-render-window": {
		Doc:   "playground.RenderWindow",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("playground-render-window: arg 1: expected native of type fyne.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("playground-render-window: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("playground-render-window: arg 1: expected native")
			}
			playground.RenderWindow(arg0Val)
			return nil
		},
	},
	"ptr-app-settings-schema//cloud-config!": {
		Doc:   "Set *app.SettingsSchema CloudConfig value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//cloud-config!: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//cloud-config!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//cloud-config!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudConfig = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//cloud-config!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-app-settings-schema//cloud-config?": {
		Doc:   "Get *app.SettingsSchema CloudConfig value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//cloud-config?: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//cloud-config?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//cloud-config?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudConfig)
			return resObj
		},
	},
	"ptr-app-settings-schema//cloud-name!": {
		Doc:   "Set *app.SettingsSchema CloudName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//cloud-name!: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//cloud-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//cloud-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//cloud-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-app-settings-schema//cloud-name?": {
		Doc:   "Get *app.SettingsSchema CloudName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//cloud-name?: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//cloud-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//cloud-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudName)
			return resObj
		},
	},
	"ptr-app-settings-schema//disable-animations!": {
		Doc:   "Set *app.SettingsSchema DisableAnimations value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//disable-animations!: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//disable-animations!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//disable-animations!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.DisableAnimations = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//disable-animations!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-app-settings-schema//disable-animations?": {
		Doc:   "Get *app.SettingsSchema DisableAnimations value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//disable-animations?: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//disable-animations?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//disable-animations?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.DisableAnimations))
			return resObj
		},
	},
	"ptr-app-settings-schema//primary-color!": {
		Doc:   "Set *app.SettingsSchema PrimaryColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//primary-color!: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//primary-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//primary-color!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.PrimaryColor = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//primary-color!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-app-settings-schema//primary-color?": {
		Doc:   "Get *app.SettingsSchema PrimaryColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//primary-color?: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//primary-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//primary-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PrimaryColor)
			return resObj
		},
	},
	"ptr-app-settings-schema//scale!": {
		Doc:   "Set *app.SettingsSchema Scale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//scale!: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//scale!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Scale = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//scale!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-app-settings-schema//scale?": {
		Doc:   "Get *app.SettingsSchema Scale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//scale?: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Scale))
			return resObj
		},
	},
	"ptr-app-settings-schema//storage-path": {
		Doc:   "(*app.SettingsSchema).StoragePath",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//storage-path: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//storage-path: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//storage-path: arg 1: expected native")
			}
			res0 := arg0Val.StoragePath()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-app-settings-schema//theme-name!": {
		Doc:   "Set *app.SettingsSchema ThemeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//theme-name!: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//theme-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//theme-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.ThemeName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//theme-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-app-settings-schema//theme-name?": {
		Doc:   "Get *app.SettingsSchema ThemeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//theme-name?: arg 1: expected native of type *app.SettingsSchema")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-app-settings-schema//theme-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-app-settings-schema//theme-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ThemeName)
			return resObj
		},
	},
	"ptr-canvas-circle//fill-color!": {
		Doc:   "Set *canvas.Circle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//fill-color!: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//fill-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//fill-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//fill-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//fill-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-circle//fill-color?": {
		Doc:   "Get *canvas.Circle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//fill-color?: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//fill-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//fill-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color-color")
			return resObj
		},
	},
	"ptr-canvas-circle//hidden!": {
		Doc:   "Set *canvas.Circle Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//hidden!: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-canvas-circle//hidden?": {
		Doc:   "Get *canvas.Circle Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//hidden?: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-canvas-circle//hide": {
		Doc:   "(*canvas.Circle).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//hide: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-canvas-circle//min-size": {
		Doc:   "(*canvas.Circle).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//min-size: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-canvas-circle//move": {
		Doc:   "(*canvas.Circle).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//move: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-circle//position": {
		Doc:   "(*canvas.Circle).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-canvas-circle//position-1!": {
		Doc:   "Set *canvas.Circle Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-1!: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-1!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//position-1!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-1!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//position-1!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-circle//position-1?": {
		Doc:   "Get *canvas.Circle Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-1?: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-1?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//position-1?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "fyne-position")
			return resObj
		},
	},
	"ptr-canvas-circle//position-2!": {
		Doc:   "Set *canvas.Circle Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-2!: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-2!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//position-2!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-2!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//position-2!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-circle//position-2?": {
		Doc:   "Get *canvas.Circle Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-2?: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//position-2?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//position-2?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "fyne-position")
			return resObj
		},
	},
	"ptr-canvas-circle//refresh": {
		Doc:   "(*canvas.Circle).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//refresh: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-canvas-circle//resize": {
		Doc:   "(*canvas.Circle).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//resize: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-circle//show": {
		Doc:   "(*canvas.Circle).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//show: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-canvas-circle//size": {
		Doc:   "(*canvas.Circle).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//size: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-canvas-circle//stroke-color!": {
		Doc:   "Set *canvas.Circle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//stroke-color!: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//stroke-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//stroke-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//stroke-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//stroke-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-circle//stroke-color?": {
		Doc:   "Get *canvas.Circle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//stroke-color?: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//stroke-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//stroke-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"ptr-canvas-circle//stroke-width!": {
		Doc:   "Set *canvas.Circle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//stroke-width!: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//stroke-width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//stroke-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//stroke-width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-circle//stroke-width?": {
		Doc:   "Get *canvas.Circle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//stroke-width?: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//stroke-width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//stroke-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"ptr-canvas-circle//visible": {
		Doc:   "(*canvas.Circle).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//visible: arg 1: expected native of type *canvas.Circle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-circle//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-circle//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-canvas-image//alpha": {
		Doc:   "(*canvas.Image).Alpha",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//alpha: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//alpha: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//alpha: arg 1: expected native")
			}
			res0 := arg0Val.Alpha()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-canvas-image//aspect": {
		Doc:   "(*canvas.Image).Aspect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//aspect: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//aspect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//aspect: arg 1: expected native")
			}
			res0 := arg0Val.Aspect()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-canvas-image//file!": {
		Doc:   "Set *canvas.Image File value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//file!: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//file!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//file!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.File = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//file!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-canvas-image//file?": {
		Doc:   "Get *canvas.Image File value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//file?: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//file?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//file?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.File)
			return resObj
		},
	},
	"ptr-canvas-image//fill-mode!": {
		Doc:   "Set *canvas.Image FillMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//fill-mode!: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//fill-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//fill-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal canvas.ImageFill
				if natOk {
					natVal, natValOk = nat.Value.(canvas.ImageFill)
				}
				if natOk && natValOk {
					self.FillMode = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-canvas-image//fill-mode!: arg 2: expected integer")
					}
					self.FillMode = canvas.ImageFill(u)
				}
			}
			return arg0
		},
	},
	"ptr-canvas-image//fill-mode?": {
		Doc:   "Get *canvas.Image FillMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//fill-mode?: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//fill-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//fill-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.FillMode)))
			return resObj
		},
	},
	"ptr-canvas-image//hide": {
		Doc:   "(*canvas.Image).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//hide: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-canvas-image//image!": {
		Doc:   "Set *canvas.Image Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//image!: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//image!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//image!: arg 2: expected native of type image.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-image//image?": {
		Doc:   "Get *canvas.Image Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//image?: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//image?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "image-image")
			return resObj
		},
	},
	"ptr-canvas-image//min-size": {
		Doc:   "(*canvas.Image).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//min-size: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-canvas-image//move": {
		Doc:   "(*canvas.Image).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//move: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-image//refresh": {
		Doc:   "(*canvas.Image).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//refresh: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-canvas-image//resize": {
		Doc:   "(*canvas.Image).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//resize: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-image//resource!": {
		Doc:   "Set *canvas.Image Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//resource!: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//resource!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//resource!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//resource!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//resource!: arg 2: expected integer to be 0 or nil")
				}
				self.Resource = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//resource!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-image//resource?": {
		Doc:   "Get *canvas.Image Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//resource?: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//resource?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//resource?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Resource)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Resource, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Resource, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"ptr-canvas-image//scale-mode!": {
		Doc:   "Set *canvas.Image ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//scale-mode!: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//scale-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal canvas.ImageScale
				if natOk {
					natVal, natValOk = nat.Value.(canvas.ImageScale)
				}
				if natOk && natValOk {
					self.ScaleMode = natVal
				} else {
					var u int32
					if v, ok := arg1.(env.Integer); ok {
						u = int32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-canvas-image//scale-mode!: arg 2: expected integer")
					}
					self.ScaleMode = canvas.ImageScale(u)
				}
			}
			return arg0
		},
	},
	"ptr-canvas-image//scale-mode?": {
		Doc:   "Get *canvas.Image ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//scale-mode?: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//scale-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(self.ScaleMode)))
			return resObj
		},
	},
	"ptr-canvas-image//translucency!": {
		Doc:   "Set *canvas.Image Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//translucency!: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//translucency!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//translucency!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//translucency!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-image//translucency?": {
		Doc:   "Get *canvas.Image Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//translucency?: arg 1: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-image//translucency?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-image//translucency?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"ptr-canvas-line//hidden!": {
		Doc:   "Set *canvas.Line Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//hidden!: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-canvas-line//hidden?": {
		Doc:   "Get *canvas.Line Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//hidden?: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-canvas-line//hide": {
		Doc:   "(*canvas.Line).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//hide: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-canvas-line//min-size": {
		Doc:   "(*canvas.Line).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//min-size: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-canvas-line//move": {
		Doc:   "(*canvas.Line).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//move: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-line//position": {
		Doc:   "(*canvas.Line).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-canvas-line//position-1!": {
		Doc:   "Set *canvas.Line Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-1!: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-1!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//position-1!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-1!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//position-1!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-line//position-1?": {
		Doc:   "Get *canvas.Line Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-1?: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-1?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//position-1?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "fyne-position")
			return resObj
		},
	},
	"ptr-canvas-line//position-2!": {
		Doc:   "Set *canvas.Line Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-2!: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-2!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//position-2!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-2!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//position-2!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-line//position-2?": {
		Doc:   "Get *canvas.Line Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-2?: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//position-2?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//position-2?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "fyne-position")
			return resObj
		},
	},
	"ptr-canvas-line//refresh": {
		Doc:   "(*canvas.Line).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//refresh: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-canvas-line//resize": {
		Doc:   "(*canvas.Line).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//resize: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-line//show": {
		Doc:   "(*canvas.Line).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//show: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-canvas-line//size": {
		Doc:   "(*canvas.Line).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//size: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-canvas-line//stroke-color!": {
		Doc:   "Set *canvas.Line StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//stroke-color!: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//stroke-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//stroke-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//stroke-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//stroke-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-line//stroke-color?": {
		Doc:   "Get *canvas.Line StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//stroke-color?: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//stroke-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//stroke-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"ptr-canvas-line//stroke-width!": {
		Doc:   "Set *canvas.Line StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//stroke-width!: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//stroke-width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//stroke-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//stroke-width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-line//stroke-width?": {
		Doc:   "Get *canvas.Line StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//stroke-width?: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//stroke-width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//stroke-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"ptr-canvas-line//visible": {
		Doc:   "(*canvas.Line).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//visible: arg 1: expected native of type *canvas.Line")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-line//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-line//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-canvas-linear-gradient//angle!": {
		Doc:   "Set *canvas.LinearGradient Angle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//angle!: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//angle!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//angle!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Angle = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//angle!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-linear-gradient//angle?": {
		Doc:   "Get *canvas.LinearGradient Angle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//angle?: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//angle?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//angle?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Angle))
			return resObj
		},
	},
	"ptr-canvas-linear-gradient//end-color!": {
		Doc:   "Set *canvas.LinearGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//end-color!: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//end-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//end-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//end-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//end-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-linear-gradient//end-color?": {
		Doc:   "Get *canvas.LinearGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//end-color?: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//end-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//end-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color-color")
			return resObj
		},
	},
	"ptr-canvas-linear-gradient//generate": {
		Doc:   "(*canvas.LinearGradient).Generate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//generate: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//generate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//generate: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//generate: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//generate: arg 3: expected integer")
			}
			res0 := arg0Val.Generate(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"ptr-canvas-linear-gradient//hide": {
		Doc:   "(*canvas.LinearGradient).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//hide: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-canvas-linear-gradient//move": {
		Doc:   "(*canvas.LinearGradient).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//move: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-linear-gradient//refresh": {
		Doc:   "(*canvas.LinearGradient).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//refresh: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-canvas-linear-gradient//start-color!": {
		Doc:   "Set *canvas.LinearGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//start-color!: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//start-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//start-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//start-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//start-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-linear-gradient//start-color?": {
		Doc:   "Get *canvas.LinearGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//start-color?: arg 1: expected native of type *canvas.LinearGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-linear-gradient//start-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-linear-gradient//start-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color-color")
			return resObj
		},
	},
	"ptr-canvas-radial-gradient//center-offset-x!": {
		Doc:   "Set *canvas.RadialGradient CenterOffsetX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//center-offset-x!: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//center-offset-x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//center-offset-x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetX = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//center-offset-x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-radial-gradient//center-offset-x?": {
		Doc:   "Get *canvas.RadialGradient CenterOffsetX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//center-offset-x?: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//center-offset-x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//center-offset-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetX))
			return resObj
		},
	},
	"ptr-canvas-radial-gradient//center-offset-y!": {
		Doc:   "Set *canvas.RadialGradient CenterOffsetY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//center-offset-y!: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//center-offset-y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//center-offset-y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetY = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//center-offset-y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-radial-gradient//center-offset-y?": {
		Doc:   "Get *canvas.RadialGradient CenterOffsetY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//center-offset-y?: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//center-offset-y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//center-offset-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetY))
			return resObj
		},
	},
	"ptr-canvas-radial-gradient//end-color!": {
		Doc:   "Set *canvas.RadialGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//end-color!: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//end-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//end-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//end-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//end-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-radial-gradient//end-color?": {
		Doc:   "Get *canvas.RadialGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//end-color?: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//end-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//end-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color-color")
			return resObj
		},
	},
	"ptr-canvas-radial-gradient//generate": {
		Doc:   "(*canvas.RadialGradient).Generate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//generate: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//generate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//generate: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//generate: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//generate: arg 3: expected integer")
			}
			res0 := arg0Val.Generate(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"ptr-canvas-radial-gradient//hide": {
		Doc:   "(*canvas.RadialGradient).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//hide: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-canvas-radial-gradient//move": {
		Doc:   "(*canvas.RadialGradient).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//move: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-radial-gradient//refresh": {
		Doc:   "(*canvas.RadialGradient).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//refresh: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-canvas-radial-gradient//start-color!": {
		Doc:   "Set *canvas.RadialGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//start-color!: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//start-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//start-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//start-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//start-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-radial-gradient//start-color?": {
		Doc:   "Get *canvas.RadialGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//start-color?: arg 1: expected native of type *canvas.RadialGradient")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-radial-gradient//start-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-radial-gradient//start-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color-color")
			return resObj
		},
	},
	"ptr-canvas-raster//alpha": {
		Doc:   "(*canvas.Raster).Alpha",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//alpha: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//alpha: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//alpha: arg 1: expected native")
			}
			res0 := arg0Val.Alpha()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-canvas-raster//generator!": {
		Doc:   "Set *canvas.Raster Generator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//generator!: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//generator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//generator!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//generator!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.Generator = func(arg0 int, arg1 int) image.Image {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
					var res image.Image
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(image.Image)
						if !ok {
							// TODO: Cannot return error from function
						}
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//generator!: arg 2: expected integer to be 0 or nil")
				}
				self.Generator = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//generator!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-canvas-raster//generator?": {
		Doc:   "Get *canvas.Raster Generator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//generator?: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//generator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//generator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Generator, "func(int_int)_(image-image)")
			return resObj
		},
	},
	"ptr-canvas-raster//hide": {
		Doc:   "(*canvas.Raster).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//hide: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-canvas-raster//move": {
		Doc:   "(*canvas.Raster).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//move: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-raster//refresh": {
		Doc:   "(*canvas.Raster).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//refresh: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-canvas-raster//resize": {
		Doc:   "(*canvas.Raster).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//resize: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-raster//scale-mode!": {
		Doc:   "Set *canvas.Raster ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//scale-mode!: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//scale-mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//scale-mode!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal canvas.ImageScale
				if natOk {
					natVal, natValOk = nat.Value.(canvas.ImageScale)
				}
				if natOk && natValOk {
					self.ScaleMode = natVal
				} else {
					var u int32
					if v, ok := arg1.(env.Integer); ok {
						u = int32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-canvas-raster//scale-mode!: arg 2: expected integer")
					}
					self.ScaleMode = canvas.ImageScale(u)
				}
			}
			return arg0
		},
	},
	"ptr-canvas-raster//scale-mode?": {
		Doc:   "Get *canvas.Raster ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//scale-mode?: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//scale-mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//scale-mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int32(self.ScaleMode)))
			return resObj
		},
	},
	"ptr-canvas-raster//translucency!": {
		Doc:   "Set *canvas.Raster Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//translucency!: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//translucency!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//translucency!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//translucency!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-raster//translucency?": {
		Doc:   "Get *canvas.Raster Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//translucency?: arg 1: expected native of type *canvas.Raster")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-raster//translucency?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-raster//translucency?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"ptr-canvas-rectangle//corner-radius!": {
		Doc:   "Set *canvas.Rectangle CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//corner-radius!: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//corner-radius!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//corner-radius!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CornerRadius = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//corner-radius!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-rectangle//corner-radius?": {
		Doc:   "Get *canvas.Rectangle CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//corner-radius?: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//corner-radius?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//corner-radius?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CornerRadius))
			return resObj
		},
	},
	"ptr-canvas-rectangle//fill-color!": {
		Doc:   "Set *canvas.Rectangle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//fill-color!: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//fill-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//fill-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//fill-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//fill-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-rectangle//fill-color?": {
		Doc:   "Get *canvas.Rectangle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//fill-color?: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//fill-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//fill-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color-color")
			return resObj
		},
	},
	"ptr-canvas-rectangle//hide": {
		Doc:   "(*canvas.Rectangle).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//hide: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-canvas-rectangle//move": {
		Doc:   "(*canvas.Rectangle).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//move: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-rectangle//refresh": {
		Doc:   "(*canvas.Rectangle).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//refresh: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-canvas-rectangle//resize": {
		Doc:   "(*canvas.Rectangle).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//resize: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-rectangle//stroke-color!": {
		Doc:   "Set *canvas.Rectangle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//stroke-color!: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//stroke-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//stroke-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//stroke-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//stroke-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-rectangle//stroke-color?": {
		Doc:   "Get *canvas.Rectangle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//stroke-color?: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//stroke-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//stroke-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"ptr-canvas-rectangle//stroke-width!": {
		Doc:   "Set *canvas.Rectangle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//stroke-width!: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//stroke-width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//stroke-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//stroke-width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-rectangle//stroke-width?": {
		Doc:   "Get *canvas.Rectangle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//stroke-width?: arg 1: expected native of type *canvas.Rectangle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-rectangle//stroke-width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-rectangle//stroke-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"ptr-canvas-text//alignment!": {
		Doc:   "Set *canvas.Text Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//alignment!: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-canvas-text//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"ptr-canvas-text//alignment?": {
		Doc:   "Get *canvas.Text Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//alignment?: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"ptr-canvas-text//color!": {
		Doc:   "Set *canvas.Text Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//color!: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Color, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-text//color?": {
		Doc:   "Get *canvas.Text Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//color?: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "color-color")
			return resObj
		},
	},
	"ptr-canvas-text//hide": {
		Doc:   "(*canvas.Text).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//hide: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-canvas-text//min-size": {
		Doc:   "(*canvas.Text).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//min-size: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-canvas-text//move": {
		Doc:   "(*canvas.Text).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//move: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-text//refresh": {
		Doc:   "(*canvas.Text).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//refresh: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-canvas-text//resize": {
		Doc:   "(*canvas.Text).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//resize: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-text//set-min-size": {
		Doc:   "(*canvas.Text).SetMinSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//set-min-size: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//set-min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//set-min-size: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//set-min-size: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//set-min-size: arg 2: expected native")
			}
			arg0Val.SetMinSize(arg1Val)
			return arg0
		},
	},
	"ptr-canvas-text//text!": {
		Doc:   "Set *canvas.Text Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text!: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-canvas-text//text-size!": {
		Doc:   "Set *canvas.Text TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text-size!: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text-size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//text-size!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.TextSize = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//text-size!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-canvas-text//text-size?": {
		Doc:   "Get *canvas.Text TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text-size?: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text-size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//text-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.TextSize))
			return resObj
		},
	},
	"ptr-canvas-text//text-style!": {
		Doc:   "Set *canvas.Text TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text-style!: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text-style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-canvas-text//text-style?": {
		Doc:   "Get *canvas.Text TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text-style?: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text-style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"ptr-canvas-text//text?": {
		Doc:   "Get *canvas.Text Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text?: arg 1: expected native of type *canvas.Text")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-canvas-text//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-canvas-text//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-container-app-tabs//append": {
		Doc:   "(*container.AppTabs).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//append: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//append: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//append: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//append: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//append: arg 2: expected native")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//create-renderer": {
		Doc:   "(*container.AppTabs).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//create-renderer: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-container-app-tabs//current-tab": {
		Doc:   "(*container.AppTabs).CurrentTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//current-tab: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//current-tab: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//current-tab: arg 1: expected native")
			}
			res0 := arg0Val.CurrentTab()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-tab-item")
			return res0Obj
		},
	},
	"ptr-container-app-tabs//current-tab-index": {
		Doc:   "(*container.AppTabs).CurrentTabIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//current-tab-index: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//current-tab-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//current-tab-index: arg 1: expected native")
			}
			res0 := arg0Val.CurrentTabIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-container-app-tabs//disable-index": {
		Doc:   "(*container.AppTabs).DisableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//disable-index: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//disable-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//disable-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//disable-index: arg 2: expected integer")
			}
			arg0Val.DisableIndex(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//disable-item": {
		Doc:   "(*container.AppTabs).DisableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//disable-item: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//disable-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//disable-item: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//disable-item: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//disable-item: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//disable-item: arg 2: expected native")
			}
			arg0Val.DisableItem(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//enable-index": {
		Doc:   "(*container.AppTabs).EnableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//enable-index: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//enable-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//enable-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//enable-index: arg 2: expected integer")
			}
			arg0Val.EnableIndex(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//enable-item": {
		Doc:   "(*container.AppTabs).EnableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//enable-item: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//enable-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//enable-item: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//enable-item: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//enable-item: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//enable-item: arg 2: expected native")
			}
			arg0Val.EnableItem(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//extend-base-widget": {
		Doc:   "(*container.AppTabs).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//extend-base-widget: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//hidden!": {
		Doc:   "Set *container.AppTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//hidden!: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-container-app-tabs//hidden?": {
		Doc:   "Get *container.AppTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//hidden?: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-container-app-tabs//hide": {
		Doc:   "(*container.AppTabs).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//hide: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-container-app-tabs//items!": {
		Doc:   "Set *container.AppTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//items!: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-container-app-tabs//items!: arg 2: block item: expected native of type *container.TabItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-container-app-tabs//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-container-app-tabs//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//items!: arg 2: expected native of type []*container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-container-app-tabs//items?": {
		Doc:   "Get *container.AppTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//items?: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-container-tab-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-container-app-tabs//min-size": {
		Doc:   "(*container.AppTabs).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//min-size: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-container-app-tabs//move": {
		Doc:   "(*container.AppTabs).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//move: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//on-changed!": {
		Doc:   "Set *container.AppTabs OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-changed!: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-container-app-tabs//on-changed?": {
		Doc:   "Get *container.AppTabs OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-changed?: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"ptr-container-app-tabs//on-selected!": {
		Doc:   "Set *container.AppTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-selected!: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-container-app-tabs//on-selected?": {
		Doc:   "Get *container.AppTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-selected?: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"ptr-container-app-tabs//on-unselected!": {
		Doc:   "Set *container.AppTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-unselected!: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-unselected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-container-app-tabs//on-unselected?": {
		Doc:   "Get *container.AppTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-unselected?: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//on-unselected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"ptr-container-app-tabs//position": {
		Doc:   "(*container.AppTabs).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//position: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-container-app-tabs//refresh": {
		Doc:   "(*container.AppTabs).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//refresh: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-container-app-tabs//remove": {
		Doc:   "(*container.AppTabs).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//remove: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//remove: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//remove: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//remove: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//remove: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//remove: arg 2: expected native")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//remove-index": {
		Doc:   "(*container.AppTabs).RemoveIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//remove-index: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//remove-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//remove-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//remove-index: arg 2: expected integer")
			}
			arg0Val.RemoveIndex(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//resize": {
		Doc:   "(*container.AppTabs).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//resize: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//select": {
		Doc:   "(*container.AppTabs).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//select: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//select: arg 2: expected native")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//select-index": {
		Doc:   "(*container.AppTabs).SelectIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select-index: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//select-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//select-index: arg 2: expected integer")
			}
			arg0Val.SelectIndex(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//select-tab": {
		Doc:   "(*container.AppTabs).SelectTab",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select-tab: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select-tab: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//select-tab: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select-tab: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select-tab: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//select-tab: arg 2: expected native")
			}
			arg0Val.SelectTab(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//select-tab-index": {
		Doc:   "(*container.AppTabs).SelectTabIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select-tab-index: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//select-tab-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//select-tab-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//select-tab-index: arg 2: expected integer")
			}
			arg0Val.SelectTabIndex(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//selected": {
		Doc:   "(*container.AppTabs).Selected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//selected: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//selected: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//selected: arg 1: expected native")
			}
			res0 := arg0Val.Selected()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-tab-item")
			return res0Obj
		},
	},
	"ptr-container-app-tabs//selected-index": {
		Doc:   "(*container.AppTabs).SelectedIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//selected-index: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//selected-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//selected-index: arg 1: expected native")
			}
			res0 := arg0Val.SelectedIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-container-app-tabs//set-items": {
		Doc:   "(*container.AppTabs).SetItems",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//set-items: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//set-items: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//set-items: arg 1: expected native")
			}
			var arg1Val []*container.TabItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-container-app-tabs//set-items: arg 2: block item: expected native of type *container.TabItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-container-app-tabs//set-items: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-container-app-tabs//set-items: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//set-items: arg 2: expected native of type []*container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//set-items: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//set-items: arg 2: expected block, native or nil")
			}
			arg0Val.SetItems(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//set-tab-location": {
		Doc:   "(*container.AppTabs).SetTabLocation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//set-tab-location: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//set-tab-location: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//set-tab-location: arg 1: expected native")
			}
			var arg1Val container.TabLocation
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal container.TabLocation
				if natOk {
					natVal, natValOk = nat.Value.(container.TabLocation)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-container-app-tabs//set-tab-location: arg 2: expected integer")
					}
					arg1Val = container.TabLocation(u)
				}
			}
			arg0Val.SetTabLocation(arg1Val)
			return arg0
		},
	},
	"ptr-container-app-tabs//show": {
		Doc:   "(*container.AppTabs).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//show: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-container-app-tabs//size": {
		Doc:   "(*container.AppTabs).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//size: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-container-app-tabs//visible": {
		Doc:   "(*container.AppTabs).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//visible: arg 1: expected native of type *container.AppTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-app-tabs//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-app-tabs//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-container-doc-tabs//append": {
		Doc:   "(*container.DocTabs).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//append: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//append: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//append: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//append: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//append: arg 2: expected native")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//close-intercept!": {
		Doc:   "Set *container.DocTabs CloseIntercept value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//close-intercept!: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//close-intercept!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//close-intercept!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//close-intercept!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.CloseIntercept = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//close-intercept!: arg 2: expected integer to be 0 or nil")
				}
				self.CloseIntercept = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//close-intercept!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-container-doc-tabs//close-intercept?": {
		Doc:   "Get *container.DocTabs CloseIntercept value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//close-intercept?: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//close-intercept?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//close-intercept?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CloseIntercept, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"ptr-container-doc-tabs//create-renderer": {
		Doc:   "(*container.DocTabs).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//create-renderer: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-container-doc-tabs//create-tab!": {
		Doc:   "Set *container.DocTabs CreateTab value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//create-tab!: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//create-tab!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//create-tab!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//create-tab!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateTab = func() *container.TabItem {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res *container.TabItem
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(*container.TabItem)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//create-tab!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateTab = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//create-tab!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-container-doc-tabs//create-tab?": {
		Doc:   "Get *container.DocTabs CreateTab value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//create-tab?: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//create-tab?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//create-tab?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateTab, "func()_(ptr-container-tab-item)")
			return resObj
		},
	},
	"ptr-container-doc-tabs//disable-index": {
		Doc:   "(*container.DocTabs).DisableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//disable-index: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//disable-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//disable-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//disable-index: arg 2: expected integer")
			}
			arg0Val.DisableIndex(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//disable-item": {
		Doc:   "(*container.DocTabs).DisableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//disable-item: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//disable-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//disable-item: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//disable-item: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//disable-item: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//disable-item: arg 2: expected native")
			}
			arg0Val.DisableItem(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//enable-index": {
		Doc:   "(*container.DocTabs).EnableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//enable-index: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//enable-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//enable-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//enable-index: arg 2: expected integer")
			}
			arg0Val.EnableIndex(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//enable-item": {
		Doc:   "(*container.DocTabs).EnableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//enable-item: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//enable-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//enable-item: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//enable-item: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//enable-item: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//enable-item: arg 2: expected native")
			}
			arg0Val.EnableItem(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//extend-base-widget": {
		Doc:   "(*container.DocTabs).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//extend-base-widget: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//hidden!": {
		Doc:   "Set *container.DocTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//hidden!: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-container-doc-tabs//hidden?": {
		Doc:   "Get *container.DocTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//hidden?: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-container-doc-tabs//hide": {
		Doc:   "(*container.DocTabs).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//hide: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-container-doc-tabs//items!": {
		Doc:   "Set *container.DocTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//items!: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-container-doc-tabs//items!: arg 2: block item: expected native of type *container.TabItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-container-doc-tabs//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-container-doc-tabs//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//items!: arg 2: expected native of type []*container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-container-doc-tabs//items?": {
		Doc:   "Get *container.DocTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//items?: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-container-tab-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-container-doc-tabs//min-size": {
		Doc:   "(*container.DocTabs).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//min-size: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-container-doc-tabs//move": {
		Doc:   "(*container.DocTabs).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//move: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//on-closed!": {
		Doc:   "Set *container.DocTabs OnClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-closed!: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-closed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//on-closed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-closed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnClosed = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-closed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnClosed = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//on-closed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-container-doc-tabs//on-closed?": {
		Doc:   "Get *container.DocTabs OnClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-closed?: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-closed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//on-closed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnClosed, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"ptr-container-doc-tabs//on-selected!": {
		Doc:   "Set *container.DocTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-selected!: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-container-doc-tabs//on-selected?": {
		Doc:   "Get *container.DocTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-selected?: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"ptr-container-doc-tabs//on-unselected!": {
		Doc:   "Set *container.DocTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-unselected!: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-unselected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-container-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-container-doc-tabs//on-unselected?": {
		Doc:   "Get *container.DocTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-unselected?: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//on-unselected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(ptr-container-tab-item)")
			return resObj
		},
	},
	"ptr-container-doc-tabs//position": {
		Doc:   "(*container.DocTabs).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//position: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-container-doc-tabs//refresh": {
		Doc:   "(*container.DocTabs).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//refresh: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-container-doc-tabs//remove": {
		Doc:   "(*container.DocTabs).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//remove: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//remove: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//remove: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//remove: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//remove: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//remove: arg 2: expected native")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//remove-index": {
		Doc:   "(*container.DocTabs).RemoveIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//remove-index: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//remove-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//remove-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//remove-index: arg 2: expected integer")
			}
			arg0Val.RemoveIndex(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//resize": {
		Doc:   "(*container.DocTabs).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//resize: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//select": {
		Doc:   "(*container.DocTabs).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//select: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//select: arg 1: expected native")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//select: arg 2: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//select: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//select: arg 2: expected native")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//select-index": {
		Doc:   "(*container.DocTabs).SelectIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//select-index: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//select-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//select-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//select-index: arg 2: expected integer")
			}
			arg0Val.SelectIndex(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//selected": {
		Doc:   "(*container.DocTabs).Selected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//selected: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//selected: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//selected: arg 1: expected native")
			}
			res0 := arg0Val.Selected()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container-tab-item")
			return res0Obj
		},
	},
	"ptr-container-doc-tabs//selected-index": {
		Doc:   "(*container.DocTabs).SelectedIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//selected-index: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//selected-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//selected-index: arg 1: expected native")
			}
			res0 := arg0Val.SelectedIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-container-doc-tabs//set-items": {
		Doc:   "(*container.DocTabs).SetItems",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//set-items: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//set-items: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//set-items: arg 1: expected native")
			}
			var arg1Val []*container.TabItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-container-doc-tabs//set-items: arg 2: block item: expected native of type *container.TabItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-container-doc-tabs//set-items: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-container-doc-tabs//set-items: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//set-items: arg 2: expected native of type []*container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//set-items: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//set-items: arg 2: expected block, native or nil")
			}
			arg0Val.SetItems(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//set-tab-location": {
		Doc:   "(*container.DocTabs).SetTabLocation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//set-tab-location: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//set-tab-location: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//set-tab-location: arg 1: expected native")
			}
			var arg1Val container.TabLocation
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal container.TabLocation
				if natOk {
					natVal, natValOk = nat.Value.(container.TabLocation)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-container-doc-tabs//set-tab-location: arg 2: expected integer")
					}
					arg1Val = container.TabLocation(u)
				}
			}
			arg0Val.SetTabLocation(arg1Val)
			return arg0
		},
	},
	"ptr-container-doc-tabs//show": {
		Doc:   "(*container.DocTabs).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//show: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-container-doc-tabs//size": {
		Doc:   "(*container.DocTabs).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//size: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-container-doc-tabs//visible": {
		Doc:   "(*container.DocTabs).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//visible: arg 1: expected native of type *container.DocTabs")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-doc-tabs//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-doc-tabs//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-container-split//create-renderer": {
		Doc:   "(*container.Split).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//create-renderer: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-container-split//extend-base-widget": {
		Doc:   "(*container.Split).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//extend-base-widget: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-container-split//hidden!": {
		Doc:   "Set *container.Split Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//hidden!: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-container-split//hidden?": {
		Doc:   "Get *container.Split Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//hidden?: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-container-split//hide": {
		Doc:   "(*container.Split).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//hide: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-container-split//horizontal!": {
		Doc:   "Set *container.Split Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//horizontal!: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//horizontal!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//horizontal!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//horizontal!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-container-split//horizontal?": {
		Doc:   "Get *container.Split Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//horizontal?: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//horizontal?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//horizontal?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"ptr-container-split//leading!": {
		Doc:   "Set *container.Split Leading value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//leading!: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//leading!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//leading!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Leading, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//leading!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//leading!: arg 2: expected integer to be 0 or nil")
				}
				self.Leading = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//leading!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-container-split//leading?": {
		Doc:   "Get *container.Split Leading value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//leading?: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//leading?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//leading?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Leading)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Leading, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Leading, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"ptr-container-split//min-size": {
		Doc:   "(*container.Split).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//min-size: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-container-split//move": {
		Doc:   "(*container.Split).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//move: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-container-split//offset!": {
		Doc:   "Set *container.Split Offset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//offset!: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//offset!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//offset!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Offset = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//offset!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-container-split//offset?": {
		Doc:   "Get *container.Split Offset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//offset?: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//offset?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//offset?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Offset))
			return resObj
		},
	},
	"ptr-container-split//position": {
		Doc:   "(*container.Split).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//position: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-container-split//refresh": {
		Doc:   "(*container.Split).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//refresh: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-container-split//resize": {
		Doc:   "(*container.Split).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//resize: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-container-split//set-offset": {
		Doc:   "(*container.Split).SetOffset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//set-offset: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//set-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//set-offset: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//set-offset: arg 2: expected decimal")
			}
			arg0Val.SetOffset(arg1Val)
			return arg0
		},
	},
	"ptr-container-split//show": {
		Doc:   "(*container.Split).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//show: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-container-split//size": {
		Doc:   "(*container.Split).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//size: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-container-split//trailing!": {
		Doc:   "Set *container.Split Trailing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//trailing!: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//trailing!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//trailing!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Trailing, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//trailing!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//trailing!: arg 2: expected integer to be 0 or nil")
				}
				self.Trailing = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//trailing!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-container-split//trailing?": {
		Doc:   "Get *container.Split Trailing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//trailing?: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//trailing?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//trailing?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Trailing)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Trailing, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Trailing, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"ptr-container-split//visible": {
		Doc:   "(*container.Split).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//visible: arg 1: expected native of type *container.Split")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-split//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-split//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-container-tab-item//content!": {
		Doc:   "Set *container.TabItem Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//content!: arg 1: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//content!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//content!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//content!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//content!: arg 2: expected integer to be 0 or nil")
				}
				self.Content = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//content!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-container-tab-item//content?": {
		Doc:   "Get *container.TabItem Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//content?: arg 1: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//content?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//content?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Content)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Content, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"ptr-container-tab-item//disabled": {
		Doc:   "(*container.TabItem).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//disabled: arg 1: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-container-tab-item//icon!": {
		Doc:   "Set *container.TabItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//icon!: arg 1: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//icon!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-container-tab-item//icon?": {
		Doc:   "Get *container.TabItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//icon?: arg 1: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//icon?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"ptr-container-tab-item//text!": {
		Doc:   "Set *container.TabItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//text!: arg 1: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-container-tab-item//text?": {
		Doc:   "Get *container.TabItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//text?: arg 1: expected native of type *container.TabItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-container-tab-item//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-container-tab-item//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-desktop-custom-shortcut//key": {
		Doc:   "(*desktop.CustomShortcut).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//key: arg 1: expected native of type *desktop.CustomShortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-custom-shortcut//key: arg 1: expected native")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewString(string(res0))
			return res0Obj
		},
	},
	"ptr-desktop-custom-shortcut//mod": {
		Doc:   "(*desktop.CustomShortcut).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//mod: arg 1: expected native of type *desktop.CustomShortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//mod: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-custom-shortcut//mod: arg 1: expected native")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-desktop-custom-shortcut//modifier!": {
		Doc:   "Set *desktop.CustomShortcut Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//modifier!: arg 1: expected native of type *desktop.CustomShortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//modifier!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-custom-shortcut//modifier!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.KeyModifier
				if natOk {
					natVal, natValOk = nat.Value.(fyne.KeyModifier)
				}
				if natOk && natValOk {
					self.Modifier = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-desktop-custom-shortcut//modifier!: arg 2: expected integer")
					}
					self.Modifier = fyne.KeyModifier(u)
				}
			}
			return arg0
		},
	},
	"ptr-desktop-custom-shortcut//modifier?": {
		Doc:   "Get *desktop.CustomShortcut Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//modifier?: arg 1: expected native of type *desktop.CustomShortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//modifier?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-custom-shortcut//modifier?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Modifier)))
			return resObj
		},
	},
	"ptr-desktop-custom-shortcut//shortcut-name": {
		Doc:   "(*desktop.CustomShortcut).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//shortcut-name: arg 1: expected native of type *desktop.CustomShortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-custom-shortcut//shortcut-name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-custom-shortcut//shortcut-name: arg 1: expected native")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-desktop-mouse-event//absolute-position!": {
		Doc:   "Set *desktop.MouseEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//absolute-position!: arg 1: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//absolute-position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-desktop-mouse-event//absolute-position?": {
		Doc:   "Get *desktop.MouseEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//absolute-position?: arg 1: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//absolute-position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"ptr-desktop-mouse-event//button!": {
		Doc:   "Set *desktop.MouseEvent Button value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//button!: arg 1: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//button!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//button!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal desktop.MouseButton
				if natOk {
					natVal, natValOk = nat.Value.(desktop.MouseButton)
				}
				if natOk && natValOk {
					self.Button = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-desktop-mouse-event//button!: arg 2: expected integer")
					}
					self.Button = desktop.MouseButton(u)
				}
			}
			return arg0
		},
	},
	"ptr-desktop-mouse-event//button?": {
		Doc:   "Get *desktop.MouseEvent Button value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//button?: arg 1: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//button?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//button?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Button)))
			return resObj
		},
	},
	"ptr-desktop-mouse-event//modifier!": {
		Doc:   "Set *desktop.MouseEvent Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//modifier!: arg 1: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//modifier!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//modifier!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.KeyModifier
				if natOk {
					natVal, natValOk = nat.Value.(fyne.KeyModifier)
				}
				if natOk && natValOk {
					self.Modifier = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-desktop-mouse-event//modifier!: arg 2: expected integer")
					}
					self.Modifier = fyne.KeyModifier(u)
				}
			}
			return arg0
		},
	},
	"ptr-desktop-mouse-event//modifier?": {
		Doc:   "Get *desktop.MouseEvent Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//modifier?: arg 1: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//modifier?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//modifier?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Modifier)))
			return resObj
		},
	},
	"ptr-desktop-mouse-event//position!": {
		Doc:   "Set *desktop.MouseEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//position!: arg 1: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-desktop-mouse-event//position?": {
		Doc:   "Get *desktop.MouseEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//position?: arg 1: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-desktop-mouse-event//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-desktop-mouse-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"ptr-dialog-color-picker-dialog//advanced!": {
		Doc:   "Set *dialog.ColorPickerDialog Advanced value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//advanced!: arg 1: expected native of type *dialog.ColorPickerDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//advanced!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-color-picker-dialog//advanced!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Advanced = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-color-picker-dialog//advanced!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-dialog-color-picker-dialog//advanced?": {
		Doc:   "Get *dialog.ColorPickerDialog Advanced value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//advanced?: arg 1: expected native of type *dialog.ColorPickerDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//advanced?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-color-picker-dialog//advanced?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Advanced))
			return resObj
		},
	},
	"ptr-dialog-color-picker-dialog//refresh": {
		Doc:   "(*dialog.ColorPickerDialog).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//refresh: arg 1: expected native of type *dialog.ColorPickerDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-color-picker-dialog//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-dialog-color-picker-dialog//set-color": {
		Doc:   "(*dialog.ColorPickerDialog).SetColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//set-color: arg 1: expected native of type *dialog.ColorPickerDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//set-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-color-picker-dialog//set-color: arg 1: expected native")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//set-color: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-color-picker-dialog//set-color: arg 2: expected native")
			}
			arg0Val.SetColor(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-color-picker-dialog//show": {
		Doc:   "(*dialog.ColorPickerDialog).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//show: arg 1: expected native of type *dialog.ColorPickerDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-color-picker-dialog//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-color-picker-dialog//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-dialog-confirm-dialog//set-confirm-importance": {
		Doc:   "(*dialog.ConfirmDialog).SetConfirmImportance",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ConfirmDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ConfirmDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-confirm-dialog//set-confirm-importance: arg 1: expected native of type *dialog.ConfirmDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-confirm-dialog//set-confirm-importance: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-confirm-dialog//set-confirm-importance: arg 1: expected native")
			}
			var arg1Val widget.Importance
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.Importance
				if natOk {
					natVal, natValOk = nat.Value.(widget.Importance)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-dialog-confirm-dialog//set-confirm-importance: arg 2: expected integer")
					}
					arg1Val = widget.Importance(u)
				}
			}
			arg0Val.SetConfirmImportance(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-confirm-dialog//set-confirm-text": {
		Doc:   "(*dialog.ConfirmDialog).SetConfirmText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ConfirmDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ConfirmDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-confirm-dialog//set-confirm-text: arg 1: expected native of type *dialog.ConfirmDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-confirm-dialog//set-confirm-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-confirm-dialog//set-confirm-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-confirm-dialog//set-confirm-text: arg 2: expected string")
			}
			arg0Val.SetConfirmText(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-custom-dialog//set-buttons": {
		Doc:   "(*dialog.CustomDialog).SetButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.CustomDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.CustomDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-custom-dialog//set-buttons: arg 1: expected native of type *dialog.CustomDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-custom-dialog//set-buttons: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-custom-dialog//set-buttons: arg 1: expected native")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-dialog-custom-dialog//set-buttons: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-dialog-custom-dialog//set-buttons: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-dialog-custom-dialog//set-buttons: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-custom-dialog//set-buttons: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-custom-dialog//set-buttons: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-custom-dialog//set-buttons: arg 2: expected block, native or nil")
			}
			arg0Val.SetButtons(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-entry-dialog//set-on-closed": {
		Doc:   "(*dialog.EntryDialog).SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//set-on-closed: arg 1: expected native of type *dialog.EntryDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//set-on-closed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-entry-dialog//set-on-closed: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//set-on-closed: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//set-on-closed: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-entry-dialog//set-on-closed: arg 2: expected function or nil")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-entry-dialog//set-placeholder": {
		Doc:   "(*dialog.EntryDialog).SetPlaceholder",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//set-placeholder: arg 1: expected native of type *dialog.EntryDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//set-placeholder: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-entry-dialog//set-placeholder: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-entry-dialog//set-placeholder: arg 2: expected string")
			}
			arg0Val.SetPlaceholder(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-entry-dialog//set-text": {
		Doc:   "(*dialog.EntryDialog).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//set-text: arg 1: expected native of type *dialog.EntryDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-entry-dialog//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-entry-dialog//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-entry-dialog//submit": {
		Doc:   "(*dialog.EntryDialog).Submit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//submit: arg 1: expected native of type *dialog.EntryDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-entry-dialog//submit: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-entry-dialog//submit: arg 1: expected native")
			}
			arg0Val.Submit()
			return arg0
		},
	},
	"ptr-dialog-file-dialog//hide": {
		Doc:   "(*dialog.FileDialog).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//hide: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-dialog-file-dialog//min-size": {
		Doc:   "(*dialog.FileDialog).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//min-size: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-dialog-file-dialog//refresh": {
		Doc:   "(*dialog.FileDialog).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//refresh: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-dialog-file-dialog//resize": {
		Doc:   "(*dialog.FileDialog).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//resize: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-file-dialog//set-confirm-text": {
		Doc:   "(*dialog.FileDialog).SetConfirmText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-confirm-text: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-confirm-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-confirm-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-confirm-text: arg 2: expected string")
			}
			arg0Val.SetConfirmText(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-file-dialog//set-dismiss-text": {
		Doc:   "(*dialog.FileDialog).SetDismissText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-dismiss-text: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-dismiss-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-dismiss-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-dismiss-text: arg 2: expected string")
			}
			arg0Val.SetDismissText(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-file-dialog//set-file-name": {
		Doc:   "(*dialog.FileDialog).SetFileName",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-file-name: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-file-name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-file-name: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-file-name: arg 2: expected string")
			}
			arg0Val.SetFileName(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-file-dialog//set-filter": {
		Doc:   "(*dialog.FileDialog).SetFilter",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-filter: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-filter: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-filter: arg 1: expected native")
			}
			var arg1Val storage.FileFilter
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(storage.FileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-filter: arg 2: expected native of type storage.FileFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-filter: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-filter: arg 2: expected native")
			}
			arg0Val.SetFilter(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-file-dialog//set-location": {
		Doc:   "(*dialog.FileDialog).SetLocation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-location: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-location: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-location: arg 1: expected native")
			}
			var arg1Val fyne.ListableURI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.ListableURI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-location: arg 2: expected native of type fyne.ListableURI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-location: arg 2: expected native")
			}
			arg0Val.SetLocation(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-file-dialog//set-on-closed": {
		Doc:   "(*dialog.FileDialog).SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-on-closed: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-on-closed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-on-closed: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-on-closed: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//set-on-closed: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//set-on-closed: arg 2: expected function or nil")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-file-dialog//show": {
		Doc:   "(*dialog.FileDialog).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FileDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FileDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//show: arg 1: expected native of type *dialog.FileDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-file-dialog//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-file-dialog//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-dialog-form-dialog//submit": {
		Doc:   "(*dialog.FormDialog).Submit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FormDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FormDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-form-dialog//submit: arg 1: expected native of type *dialog.FormDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-form-dialog//submit: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-form-dialog//submit: arg 1: expected native")
			}
			arg0Val.Submit()
			return arg0
		},
	},
	"ptr-dialog-progress-dialog//set-value": {
		Doc:   "(*dialog.ProgressDialog).SetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ProgressDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ProgressDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-progress-dialog//set-value: arg 1: expected native of type *dialog.ProgressDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-progress-dialog//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-progress-dialog//set-value: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-progress-dialog//set-value: arg 2: expected decimal")
			}
			arg0Val.SetValue(arg1Val)
			return arg0
		},
	},
	"ptr-dialog-progress-infinite-dialog//hide": {
		Doc:   "(*dialog.ProgressInfiniteDialog).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ProgressInfiniteDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ProgressInfiniteDialog)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-progress-infinite-dialog//hide: arg 1: expected native of type *dialog.ProgressInfiniteDialog")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-dialog-progress-infinite-dialog//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-dialog-progress-infinite-dialog//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-driver-1-android-context//ctx!": {
		Doc:   "Set *driver_1.AndroidContext Ctx value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//ctx!: arg 1: expected native of type *driver_1.AndroidContext")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//ctx!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-driver-1-android-context//ctx!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Ctx, ok = v.Value.(uintptr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//ctx!: arg 2: expected native of type uintptr")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-driver-1-android-context//ctx!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-driver-1-android-context//ctx?": {
		Doc:   "Get *driver_1.AndroidContext Ctx value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//ctx?: arg 1: expected native of type *driver_1.AndroidContext")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//ctx?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-driver-1-android-context//ctx?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Ctx, "uintptr")
			return resObj
		},
	},
	"ptr-driver-1-android-context//env!": {
		Doc:   "Set *driver_1.AndroidContext Env value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//env!: arg 1: expected native of type *driver_1.AndroidContext")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//env!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-driver-1-android-context//env!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Env, ok = v.Value.(uintptr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//env!: arg 2: expected native of type uintptr")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-driver-1-android-context//env!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-driver-1-android-context//env?": {
		Doc:   "Get *driver_1.AndroidContext Env value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//env?: arg 1: expected native of type *driver_1.AndroidContext")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//env?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-driver-1-android-context//env?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Env, "uintptr")
			return resObj
		},
	},
	"ptr-driver-1-android-context//vm!": {
		Doc:   "Set *driver_1.AndroidContext VM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//vm!: arg 1: expected native of type *driver_1.AndroidContext")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//vm!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-driver-1-android-context//vm!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.VM, ok = v.Value.(uintptr)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//vm!: arg 2: expected native of type uintptr")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-driver-1-android-context//vm!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-driver-1-android-context//vm?": {
		Doc:   "Get *driver_1.AndroidContext VM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver_1.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver_1.AndroidContext)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//vm?: arg 1: expected native of type *driver_1.AndroidContext")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-driver-1-android-context//vm?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-driver-1-android-context//vm?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.VM, "uintptr")
			return resObj
		},
	},
	"ptr-fyne-animation//auto-reverse!": {
		Doc:   "Set *fyne.Animation AutoReverse value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//auto-reverse!: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//auto-reverse!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//auto-reverse!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AutoReverse = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//auto-reverse!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-animation//auto-reverse?": {
		Doc:   "Get *fyne.Animation AutoReverse value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//auto-reverse?: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//auto-reverse?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//auto-reverse?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AutoReverse))
			return resObj
		},
	},
	"ptr-fyne-animation//curve!": {
		Doc:   "Set *fyne.Animation Curve value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//curve!: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//curve!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//curve!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.AnimationCurve
				if natOk {
					natVal, natValOk = nat.Value.(fyne.AnimationCurve)
				}
				if natOk && natValOk {
					self.Curve = natVal
				} else {
					var u func(float32) float32
					switch fn := arg1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("ptr-fyne-animation//curve!: arg 2: function has invalid number of arguments (expected 1)")
						}
						u = func(arg0 float32) float32 {
							var arg0Val env.Object
							arg0Val = *env.NewDecimal(float64(arg0))
							evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
							var res float32
							if v, ok := ps.Res.(env.Decimal); ok {
								res = float32(v.Value)
							} else {
								// TODO: Cannot return error from function
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-fyne-animation//curve!: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-fyne-animation//curve!: arg 2: expected function or nil")
					}
					self.Curve = fyne.AnimationCurve(u)
				}
			}
			return arg0
		},
	},
	"ptr-fyne-animation//curve?": {
		Doc:   "Get *fyne.Animation Curve value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//curve?: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//curve?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//curve?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, (func(float32) float32)(self.Curve), "func(float-32)_(float-32)")
			return resObj
		},
	},
	"ptr-fyne-animation//duration!": {
		Doc:   "Set *fyne.Animation Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//duration!: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//duration!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//duration!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//duration!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//duration!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-animation//duration?": {
		Doc:   "Get *fyne.Animation Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//duration?: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//duration?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//duration?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"ptr-fyne-animation//repeat-count!": {
		Doc:   "Set *fyne.Animation RepeatCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//repeat-count!: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//repeat-count!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//repeat-count!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.RepeatCount = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//repeat-count!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-animation//repeat-count?": {
		Doc:   "Get *fyne.Animation RepeatCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//repeat-count?: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//repeat-count?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//repeat-count?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.RepeatCount))
			return resObj
		},
	},
	"ptr-fyne-animation//start": {
		Doc:   "(*fyne.Animation).Start",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//start: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//start: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//start: arg 1: expected native")
			}
			arg0Val.Start()
			return arg0
		},
	},
	"ptr-fyne-animation//stop": {
		Doc:   "(*fyne.Animation).Stop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//stop: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//stop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//stop: arg 1: expected native")
			}
			arg0Val.Stop()
			return arg0
		},
	},
	"ptr-fyne-animation//tick!": {
		Doc:   "Set *fyne.Animation Tick value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//tick!: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//tick!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//tick!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//tick!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.Tick = func(arg0 float32) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//tick!: arg 2: expected integer to be 0 or nil")
				}
				self.Tick = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//tick!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-fyne-animation//tick?": {
		Doc:   "Get *fyne.Animation Tick value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//tick?: arg 1: expected native of type *fyne.Animation")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-animation//tick?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-animation//tick?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Tick, "func(float-32)")
			return resObj
		},
	},
	"ptr-fyne-app-metadata//build!": {
		Doc:   "Set *fyne.AppMetadata Build value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//build!: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//build!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//build!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Build = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//build!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-app-metadata//build?": {
		Doc:   "Get *fyne.AppMetadata Build value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//build?: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//build?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//build?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Build))
			return resObj
		},
	},
	"ptr-fyne-app-metadata//custom!": {
		Doc:   "Set *fyne.AppMetadata Custom value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//custom!: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//custom!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//custom!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//custom!: arg 2: expected block to have length of multiple of 2")
				}
				self.Custom = make(map[string]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-fyne-app-metadata//custom!: arg 2: map key: expected string")
					}
					var mapV string
					if v, ok := v.Series.S[i+1].(env.String); ok {
						mapV = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-fyne-app-metadata//custom!: arg 2: map value: expected string")
					}
					self.Custom[mapK] = mapV
				}
			case env.Dict:
				self.Custom = make(map[string]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV string
					if v, ok := dictV.(env.String); ok {
						mapV = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-fyne-app-metadata//custom!: arg 2: map value: expected string")
					}
					self.Custom[mapK] = mapV
				}
			case env.Native:
				var ok bool
				self.Custom, ok = v.Value.(map[string]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//custom!: arg 2: expected native of type map[string]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//custom!: arg 2: expected integer to be 0 or nil")
				}
				self.Custom = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//custom!: arg 2: expected native, block, dict or nil")
			}
			return arg0
		},
	},
	"ptr-fyne-app-metadata//custom?": {
		Doc:   "Get *fyne.AppMetadata Custom value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//custom?: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//custom?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//custom?: arg 1: expected native")
			}
			var resObj env.Object
			{
				data := make(map[string]any, len(self.Custom))
				for mKey, mVal := range self.Custom {
					var dVal env.Object
					dVal = *env.NewString(mVal)
					data[mKey] = dVal
				}
				resObj = *env.NewDict(data)
			}
			return resObj
		},
	},
	"ptr-fyne-app-metadata//icon!": {
		Doc:   "Set *fyne.AppMetadata Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//icon!: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//icon!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-app-metadata//icon?": {
		Doc:   "Get *fyne.AppMetadata Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//icon?: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//icon?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"ptr-fyne-app-metadata//id!": {
		Doc:   "Set *fyne.AppMetadata ID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//id!: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//id!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//id!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.ID = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//id!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-fyne-app-metadata//id?": {
		Doc:   "Get *fyne.AppMetadata ID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//id?: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//id?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//id?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ID)
			return resObj
		},
	},
	"ptr-fyne-app-metadata//name!": {
		Doc:   "Set *fyne.AppMetadata Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//name!: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Name = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-fyne-app-metadata//name?": {
		Doc:   "Get *fyne.AppMetadata Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//name?: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Name)
			return resObj
		},
	},
	"ptr-fyne-app-metadata//release!": {
		Doc:   "Set *fyne.AppMetadata Release value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//release!: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//release!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//release!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Release = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//release!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-app-metadata//release?": {
		Doc:   "Get *fyne.AppMetadata Release value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//release?: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//release?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//release?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Release))
			return resObj
		},
	},
	"ptr-fyne-app-metadata//version!": {
		Doc:   "Set *fyne.AppMetadata Version value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//version!: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//version!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//version!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Version = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//version!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-fyne-app-metadata//version?": {
		Doc:   "Get *fyne.AppMetadata Version value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//version?: arg 1: expected native of type *fyne.AppMetadata")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-app-metadata//version?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-app-metadata//version?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Version)
			return resObj
		},
	},
	"ptr-fyne-container//add": {
		Doc:   "(*fyne.Container).Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//add: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//add: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//add: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"ptr-fyne-container//add-object": {
		Doc:   "(*fyne.Container).AddObject",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//add-object: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//add-object: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//add-object: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//add-object: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//add-object: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//add-object: arg 2: expected native")
			}
			arg0Val.AddObject(arg1Val)
			return arg0
		},
	},
	"ptr-fyne-container//hidden!": {
		Doc:   "Set *fyne.Container Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//hidden!: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-container//hidden?": {
		Doc:   "Get *fyne.Container Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//hidden?: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-fyne-container//hide": {
		Doc:   "(*fyne.Container).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//hide: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-fyne-container//layout!": {
		Doc:   "Set *fyne.Container Layout value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//layout!: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//layout!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//layout!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Layout, ok = v.Value.(fyne.Layout)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//layout!: arg 2: expected native of type fyne.Layout")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//layout!: arg 2: expected integer to be 0 or nil")
				}
				self.Layout = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//layout!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-container//layout?": {
		Doc:   "Get *fyne.Container Layout value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//layout?: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//layout?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//layout?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Layout)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Layout, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Layout, "fyne-layout")
				}
			}
			return resObj
		},
	},
	"ptr-fyne-container//min-size": {
		Doc:   "(*fyne.Container).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//min-size: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-fyne-container//move": {
		Doc:   "(*fyne.Container).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//move: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-fyne-container//objects!": {
		Doc:   "Set *fyne.Container Objects value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//objects!: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//objects!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//objects!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Objects = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Objects[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-fyne-container//objects!: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-fyne-container//objects!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Objects[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-fyne-container//objects!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Objects, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//objects!: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//objects!: arg 2: expected integer to be 0 or nil")
				}
				self.Objects = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//objects!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-fyne-container//objects?": {
		Doc:   "Get *fyne.Container Objects value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//objects?: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//objects?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//objects?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Objects))
				for i, it := range self.Objects {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-canvas-object")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-fyne-container//position": {
		Doc:   "(*fyne.Container).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//position: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-fyne-container//refresh": {
		Doc:   "(*fyne.Container).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//refresh: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-fyne-container//remove": {
		Doc:   "(*fyne.Container).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//remove: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//remove: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//remove: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//remove: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//remove: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//remove: arg 2: expected native")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"ptr-fyne-container//remove-all": {
		Doc:   "(*fyne.Container).RemoveAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//remove-all: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//remove-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//remove-all: arg 1: expected native")
			}
			arg0Val.RemoveAll()
			return arg0
		},
	},
	"ptr-fyne-container//resize": {
		Doc:   "(*fyne.Container).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//resize: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-fyne-container//show": {
		Doc:   "(*fyne.Container).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//show: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-fyne-container//size": {
		Doc:   "(*fyne.Container).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//size: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-fyne-container//visible": {
		Doc:   "(*fyne.Container).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//visible: arg 1: expected native of type *fyne.Container")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-container//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-container//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-fyne-delta//dx!": {
		Doc:   "Set *fyne.Delta DX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-delta//dx!: arg 1: expected native of type *fyne.Delta")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-delta//dx!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-delta//dx!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DX = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-delta//dx!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-fyne-delta//dx?": {
		Doc:   "Get *fyne.Delta DX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-delta//dx?: arg 1: expected native of type *fyne.Delta")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-delta//dx?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-delta//dx?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DX))
			return resObj
		},
	},
	"ptr-fyne-delta//dy!": {
		Doc:   "Set *fyne.Delta DY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-delta//dy!: arg 1: expected native of type *fyne.Delta")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-delta//dy!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-delta//dy!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DY = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-delta//dy!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-fyne-delta//dy?": {
		Doc:   "Get *fyne.Delta DY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-delta//dy?: arg 1: expected native of type *fyne.Delta")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-delta//dy?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-delta//dy?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DY))
			return resObj
		},
	},
	"ptr-fyne-drag-event//absolute-position!": {
		Doc:   "Set *fyne.DragEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//absolute-position!: arg 1: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//absolute-position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-drag-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-drag-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-drag-event//absolute-position?": {
		Doc:   "Get *fyne.DragEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//absolute-position?: arg 1: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//absolute-position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-drag-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"ptr-fyne-drag-event//dragged!": {
		Doc:   "Set *fyne.DragEvent Dragged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//dragged!: arg 1: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//dragged!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-drag-event//dragged!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Dragged, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//dragged!: arg 2: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-drag-event//dragged!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-drag-event//dragged?": {
		Doc:   "Get *fyne.DragEvent Dragged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//dragged?: arg 1: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//dragged?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-drag-event//dragged?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Dragged, "fyne-delta")
			return resObj
		},
	},
	"ptr-fyne-drag-event//position!": {
		Doc:   "Set *fyne.DragEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//position!: arg 1: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-drag-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-drag-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-drag-event//position?": {
		Doc:   "Get *fyne.DragEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//position?: arg 1: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-drag-event//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-drag-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"ptr-fyne-hardware-key//scan-code!": {
		Doc:   "Set *fyne.HardwareKey ScanCode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.HardwareKey)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-hardware-key//scan-code!: arg 1: expected native of type *fyne.HardwareKey")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-hardware-key//scan-code!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-hardware-key//scan-code!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScanCode = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-hardware-key//scan-code!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-hardware-key//scan-code?": {
		Doc:   "Get *fyne.HardwareKey ScanCode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.HardwareKey)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-hardware-key//scan-code?: arg 1: expected native of type *fyne.HardwareKey")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-hardware-key//scan-code?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-hardware-key//scan-code?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.ScanCode))
			return resObj
		},
	},
	"ptr-fyne-key-event//name!": {
		Doc:   "Set *fyne.KeyEvent Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-key-event//name!: arg 1: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-key-event//name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-key-event//name!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.KeyName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.KeyName)
				}
				if natOk && natValOk {
					self.Name = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-fyne-key-event//name!: arg 2: expected string")
					}
					self.Name = fyne.KeyName(u)
				}
			}
			return arg0
		},
	},
	"ptr-fyne-key-event//name?": {
		Doc:   "Get *fyne.KeyEvent Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-key-event//name?: arg 1: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-key-event//name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-key-event//name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.Name))
			return resObj
		},
	},
	"ptr-fyne-key-event//physical!": {
		Doc:   "Set *fyne.KeyEvent Physical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-key-event//physical!: arg 1: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-key-event//physical!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-key-event//physical!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Physical, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-key-event//physical!: arg 2: expected native of type fyne.HardwareKey")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-key-event//physical!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-key-event//physical?": {
		Doc:   "Get *fyne.KeyEvent Physical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-key-event//physical?: arg 1: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-key-event//physical?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-key-event//physical?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Physical, "fyne-hardware-key")
			return resObj
		},
	},
	"ptr-fyne-main-menu//items!": {
		Doc:   "Set *fyne.MainMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-main-menu//items!: arg 1: expected native of type *fyne.MainMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-main-menu//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-main-menu//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.Menu, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.Menu)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-fyne-main-menu//items!: arg 2: block item: expected native of type *fyne.Menu")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-fyne-main-menu//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-fyne-main-menu//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-main-menu//items!: arg 2: expected native of type []*fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-main-menu//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-main-menu//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-fyne-main-menu//items?": {
		Doc:   "Get *fyne.MainMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-main-menu//items?: arg 1: expected native of type *fyne.MainMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-main-menu//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-main-menu//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-fyne-menu")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-fyne-main-menu//refresh": {
		Doc:   "(*fyne.MainMenu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-main-menu//refresh: arg 1: expected native of type *fyne.MainMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-main-menu//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-main-menu//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-fyne-menu-item//action!": {
		Doc:   "Set *fyne.MenuItem Action value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//action!: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//action!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//action!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//action!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.Action = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//action!: arg 2: expected integer to be 0 or nil")
				}
				self.Action = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//action!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-fyne-menu-item//action?": {
		Doc:   "Get *fyne.MenuItem Action value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//action?: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//action?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//action?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Action, "func()")
			return resObj
		},
	},
	"ptr-fyne-menu-item//checked!": {
		Doc:   "Set *fyne.MenuItem Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//checked!: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//checked!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//checked!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//checked!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-menu-item//checked?": {
		Doc:   "Get *fyne.MenuItem Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//checked?: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//checked?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//checked?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"ptr-fyne-menu-item//child-menu!": {
		Doc:   "Set *fyne.MenuItem ChildMenu value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//child-menu!: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//child-menu!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//child-menu!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ChildMenu, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//child-menu!: arg 2: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//child-menu!: arg 2: expected integer to be 0 or nil")
				}
				self.ChildMenu = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//child-menu!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-menu-item//child-menu?": {
		Doc:   "Get *fyne.MenuItem ChildMenu value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//child-menu?: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//child-menu?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//child-menu?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildMenu, "ptr-fyne-menu")
			return resObj
		},
	},
	"ptr-fyne-menu-item//disabled!": {
		Doc:   "Set *fyne.MenuItem Disabled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//disabled!: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//disabled!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//disabled!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Disabled = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//disabled!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-menu-item//disabled?": {
		Doc:   "Get *fyne.MenuItem Disabled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//disabled?: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//disabled?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//disabled?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Disabled))
			return resObj
		},
	},
	"ptr-fyne-menu-item//icon!": {
		Doc:   "Set *fyne.MenuItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//icon!: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//icon!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-menu-item//icon?": {
		Doc:   "Get *fyne.MenuItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//icon?: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//icon?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"ptr-fyne-menu-item//is-quit!": {
		Doc:   "Set *fyne.MenuItem IsQuit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//is-quit!: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//is-quit!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//is-quit!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsQuit = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//is-quit!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-menu-item//is-quit?": {
		Doc:   "Get *fyne.MenuItem IsQuit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//is-quit?: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//is-quit?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//is-quit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsQuit))
			return resObj
		},
	},
	"ptr-fyne-menu-item//is-separator!": {
		Doc:   "Set *fyne.MenuItem IsSeparator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//is-separator!: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//is-separator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//is-separator!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsSeparator = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//is-separator!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-menu-item//is-separator?": {
		Doc:   "Get *fyne.MenuItem IsSeparator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//is-separator?: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//is-separator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//is-separator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsSeparator))
			return resObj
		},
	},
	"ptr-fyne-menu-item//label!": {
		Doc:   "Set *fyne.MenuItem Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//label!: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//label!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//label!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//label!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-fyne-menu-item//label?": {
		Doc:   "Get *fyne.MenuItem Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//label?: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//label?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//label?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"ptr-fyne-menu-item//shortcut!": {
		Doc:   "Set *fyne.MenuItem Shortcut value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//shortcut!: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//shortcut!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//shortcut!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Shortcut, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//shortcut!: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//shortcut!: arg 2: expected integer to be 0 or nil")
				}
				self.Shortcut = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//shortcut!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-menu-item//shortcut?": {
		Doc:   "Get *fyne.MenuItem Shortcut value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//shortcut?: arg 1: expected native of type *fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu-item//shortcut?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu-item//shortcut?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Shortcut)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Shortcut, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Shortcut, "fyne-shortcut")
				}
			}
			return resObj
		},
	},
	"ptr-fyne-menu//items!": {
		Doc:   "Set *fyne.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//items!: arg 1: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.MenuItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.MenuItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-fyne-menu//items!: arg 2: block item: expected native of type *fyne.MenuItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-fyne-menu//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-fyne-menu//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.MenuItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//items!: arg 2: expected native of type []*fyne.MenuItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-fyne-menu//items?": {
		Doc:   "Get *fyne.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//items?: arg 1: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-fyne-menu-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-fyne-menu//label!": {
		Doc:   "Set *fyne.Menu Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//label!: arg 1: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//label!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu//label!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu//label!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-fyne-menu//label?": {
		Doc:   "Get *fyne.Menu Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//label?: arg 1: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//label?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu//label?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"ptr-fyne-menu//refresh": {
		Doc:   "(*fyne.Menu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//refresh: arg 1: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-menu//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-menu//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-fyne-notification//content!": {
		Doc:   "Set *fyne.Notification Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-notification//content!: arg 1: expected native of type *fyne.Notification")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-notification//content!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-notification//content!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Content = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-notification//content!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-fyne-notification//content?": {
		Doc:   "Get *fyne.Notification Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-notification//content?: arg 1: expected native of type *fyne.Notification")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-notification//content?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-notification//content?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Content)
			return resObj
		},
	},
	"ptr-fyne-notification//title!": {
		Doc:   "Set *fyne.Notification Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-notification//title!: arg 1: expected native of type *fyne.Notification")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-notification//title!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-notification//title!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-notification//title!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-fyne-notification//title?": {
		Doc:   "Get *fyne.Notification Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-notification//title?: arg 1: expected native of type *fyne.Notification")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-notification//title?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-notification//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"ptr-fyne-point-event//absolute-position!": {
		Doc:   "Set *fyne.PointEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//absolute-position!: arg 1: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//absolute-position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-point-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-point-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-point-event//absolute-position?": {
		Doc:   "Get *fyne.PointEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//absolute-position?: arg 1: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//absolute-position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-point-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"ptr-fyne-point-event//position!": {
		Doc:   "Set *fyne.PointEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//position!: arg 1: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-point-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-point-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-point-event//position?": {
		Doc:   "Get *fyne.PointEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//position?: arg 1: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-point-event//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-point-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"ptr-fyne-position//x!": {
		Doc:   "Set *fyne.Position X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-position//x!: arg 1: expected native of type *fyne.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-position//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-position//x!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-position//x!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-fyne-position//x?": {
		Doc:   "Get *fyne.Position X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-position//x?: arg 1: expected native of type *fyne.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-position//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-position//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"ptr-fyne-position//y!": {
		Doc:   "Set *fyne.Position Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-position//y!: arg 1: expected native of type *fyne.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-position//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-position//y!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-position//y!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-fyne-position//y?": {
		Doc:   "Get *fyne.Position Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-position//y?: arg 1: expected native of type *fyne.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-position//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-position//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"ptr-fyne-scroll-event//absolute-position!": {
		Doc:   "Set *fyne.ScrollEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//absolute-position!: arg 1: expected native of type *fyne.ScrollEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//absolute-position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-scroll-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-scroll-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-scroll-event//absolute-position?": {
		Doc:   "Get *fyne.ScrollEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//absolute-position?: arg 1: expected native of type *fyne.ScrollEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//absolute-position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-scroll-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"ptr-fyne-scroll-event//position!": {
		Doc:   "Set *fyne.ScrollEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//position!: arg 1: expected native of type *fyne.ScrollEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-scroll-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-scroll-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-scroll-event//position?": {
		Doc:   "Get *fyne.ScrollEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//position?: arg 1: expected native of type *fyne.ScrollEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-scroll-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"ptr-fyne-scroll-event//scrolled!": {
		Doc:   "Set *fyne.ScrollEvent Scrolled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//scrolled!: arg 1: expected native of type *fyne.ScrollEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//scrolled!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-scroll-event//scrolled!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scrolled, ok = v.Value.(fyne.Delta)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//scrolled!: arg 2: expected native of type fyne.Delta")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-scroll-event//scrolled!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-scroll-event//scrolled?": {
		Doc:   "Get *fyne.ScrollEvent Scrolled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//scrolled?: arg 1: expected native of type *fyne.ScrollEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-scroll-event//scrolled?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-scroll-event//scrolled?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scrolled, "fyne-delta")
			return resObj
		},
	},
	"ptr-fyne-shortcut-copy//clipboard!": {
		Doc:   "Set *fyne.ShortcutCopy Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//clipboard!: arg 1: expected native of type *fyne.ShortcutCopy")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//clipboard!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-copy//clipboard!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//clipboard!: arg 2: expected native of type fyne.Clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//clipboard!: arg 2: expected integer to be 0 or nil")
				}
				self.Clipboard = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-copy//clipboard!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-shortcut-copy//clipboard?": {
		Doc:   "Get *fyne.ShortcutCopy Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//clipboard?: arg 1: expected native of type *fyne.ShortcutCopy")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//clipboard?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-copy//clipboard?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Clipboard)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
				}
			}
			return resObj
		},
	},
	"ptr-fyne-shortcut-copy//key": {
		Doc:   "(*fyne.ShortcutCopy).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//key: arg 1: expected native of type *fyne.ShortcutCopy")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-copy//key: arg 1: expected native")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewString(string(res0))
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-copy//mod": {
		Doc:   "(*fyne.ShortcutCopy).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//mod: arg 1: expected native of type *fyne.ShortcutCopy")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//mod: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-copy//mod: arg 1: expected native")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-copy//shortcut-name": {
		Doc:   "(*fyne.ShortcutCopy).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//shortcut-name: arg 1: expected native of type *fyne.ShortcutCopy")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-copy//shortcut-name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-copy//shortcut-name: arg 1: expected native")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-cut//clipboard!": {
		Doc:   "Set *fyne.ShortcutCut Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//clipboard!: arg 1: expected native of type *fyne.ShortcutCut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//clipboard!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-cut//clipboard!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//clipboard!: arg 2: expected native of type fyne.Clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//clipboard!: arg 2: expected integer to be 0 or nil")
				}
				self.Clipboard = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-cut//clipboard!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-shortcut-cut//clipboard?": {
		Doc:   "Get *fyne.ShortcutCut Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//clipboard?: arg 1: expected native of type *fyne.ShortcutCut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//clipboard?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-cut//clipboard?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Clipboard)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
				}
			}
			return resObj
		},
	},
	"ptr-fyne-shortcut-cut//key": {
		Doc:   "(*fyne.ShortcutCut).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//key: arg 1: expected native of type *fyne.ShortcutCut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-cut//key: arg 1: expected native")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewString(string(res0))
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-cut//mod": {
		Doc:   "(*fyne.ShortcutCut).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//mod: arg 1: expected native of type *fyne.ShortcutCut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//mod: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-cut//mod: arg 1: expected native")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-cut//shortcut-name": {
		Doc:   "(*fyne.ShortcutCut).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//shortcut-name: arg 1: expected native of type *fyne.ShortcutCut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-cut//shortcut-name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-cut//shortcut-name: arg 1: expected native")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-handler//add-shortcut": {
		Doc:   "(*fyne.ShortcutHandler).AddShortcut",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutHandler
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutHandler)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//add-shortcut: arg 1: expected native of type *fyne.ShortcutHandler")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//add-shortcut: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-handler//add-shortcut: arg 1: expected native")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//add-shortcut: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//add-shortcut: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-handler//add-shortcut: arg 2: expected native")
			}
			var arg2Val func(fyne.Shortcut)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//add-shortcut: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 fyne.Shortcut) {
					var arg0Val env.Object
					{
						typ := reflect.TypeOf(arg0)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
						} else {
							arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-shortcut")
						}
					}
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//add-shortcut: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-handler//add-shortcut: arg 3: expected function or nil")
			}
			arg0Val.AddShortcut(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-fyne-shortcut-handler//remove-shortcut": {
		Doc:   "(*fyne.ShortcutHandler).RemoveShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutHandler
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutHandler)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//remove-shortcut: arg 1: expected native of type *fyne.ShortcutHandler")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//remove-shortcut: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-handler//remove-shortcut: arg 1: expected native")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//remove-shortcut: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//remove-shortcut: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-handler//remove-shortcut: arg 2: expected native")
			}
			arg0Val.RemoveShortcut(arg1Val)
			return arg0
		},
	},
	"ptr-fyne-shortcut-handler//typed-shortcut": {
		Doc:   "(*fyne.ShortcutHandler).TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutHandler
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutHandler)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//typed-shortcut: arg 1: expected native of type *fyne.ShortcutHandler")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//typed-shortcut: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-handler//typed-shortcut: arg 1: expected native")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//typed-shortcut: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-handler//typed-shortcut: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-handler//typed-shortcut: arg 2: expected native")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"ptr-fyne-shortcut-paste//clipboard!": {
		Doc:   "Set *fyne.ShortcutPaste Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//clipboard!: arg 1: expected native of type *fyne.ShortcutPaste")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//clipboard!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-paste//clipboard!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//clipboard!: arg 2: expected native of type fyne.Clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//clipboard!: arg 2: expected integer to be 0 or nil")
				}
				self.Clipboard = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-paste//clipboard!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-fyne-shortcut-paste//clipboard?": {
		Doc:   "Get *fyne.ShortcutPaste Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//clipboard?: arg 1: expected native of type *fyne.ShortcutPaste")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//clipboard?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-paste//clipboard?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Clipboard)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
				}
			}
			return resObj
		},
	},
	"ptr-fyne-shortcut-paste//key": {
		Doc:   "(*fyne.ShortcutPaste).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//key: arg 1: expected native of type *fyne.ShortcutPaste")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-paste//key: arg 1: expected native")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewString(string(res0))
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-paste//mod": {
		Doc:   "(*fyne.ShortcutPaste).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//mod: arg 1: expected native of type *fyne.ShortcutPaste")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//mod: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-paste//mod: arg 1: expected native")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-paste//shortcut-name": {
		Doc:   "(*fyne.ShortcutPaste).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//shortcut-name: arg 1: expected native of type *fyne.ShortcutPaste")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-paste//shortcut-name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-paste//shortcut-name: arg 1: expected native")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-select-all//key": {
		Doc:   "(*fyne.ShortcutSelectAll).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutSelectAll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutSelectAll)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-select-all//key: arg 1: expected native of type *fyne.ShortcutSelectAll")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-select-all//key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-select-all//key: arg 1: expected native")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewString(string(res0))
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-select-all//mod": {
		Doc:   "(*fyne.ShortcutSelectAll).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutSelectAll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutSelectAll)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-select-all//mod: arg 1: expected native of type *fyne.ShortcutSelectAll")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-select-all//mod: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-select-all//mod: arg 1: expected native")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int(res0)))
			return res0Obj
		},
	},
	"ptr-fyne-shortcut-select-all//shortcut-name": {
		Doc:   "(*fyne.ShortcutSelectAll).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutSelectAll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutSelectAll)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-select-all//shortcut-name: arg 1: expected native of type *fyne.ShortcutSelectAll")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-shortcut-select-all//shortcut-name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-shortcut-select-all//shortcut-name: arg 1: expected native")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-fyne-size//height!": {
		Doc:   "Set *fyne.Size Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-size//height!: arg 1: expected native of type *fyne.Size")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-size//height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-size//height!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Height = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-size//height!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-fyne-size//height?": {
		Doc:   "Get *fyne.Size Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-size//height?: arg 1: expected native of type *fyne.Size")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-size//height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-size//height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Height))
			return resObj
		},
	},
	"ptr-fyne-size//width!": {
		Doc:   "Set *fyne.Size Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-size//width!: arg 1: expected native of type *fyne.Size")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-size//width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-size//width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-size//width!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-fyne-size//width?": {
		Doc:   "Get *fyne.Size Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-size//width?: arg 1: expected native of type *fyne.Size")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-size//width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-size//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"ptr-fyne-static-resource//content": {
		Doc:   "(*fyne.StaticResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//content: arg 1: expected native of type *fyne.StaticResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-static-resource//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-fyne-static-resource//go-string": {
		Doc:   "(*fyne.StaticResource).GoString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//go-string: arg 1: expected native of type *fyne.StaticResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//go-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-static-resource//go-string: arg 1: expected native")
			}
			res0 := arg0Val.GoString()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-fyne-static-resource//name": {
		Doc:   "(*fyne.StaticResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//name: arg 1: expected native of type *fyne.StaticResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-static-resource//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-fyne-static-resource//static-content!": {
		Doc:   "Set *fyne.StaticResource StaticContent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-content!: arg 1: expected native of type *fyne.StaticResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-content!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-static-resource//static-content!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.StaticContent = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.StaticContent[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-fyne-static-resource//static-content!: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-fyne-static-resource//static-content!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.StaticContent, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-content!: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-content!: arg 2: expected integer to be 0 or nil")
				}
				self.StaticContent = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-static-resource//static-content!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-fyne-static-resource//static-content?": {
		Doc:   "Get *fyne.StaticResource StaticContent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-content?: arg 1: expected native of type *fyne.StaticResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-content?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-static-resource//static-content?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.StaticContent))
				for i, it := range self.StaticContent {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-fyne-static-resource//static-name!": {
		Doc:   "Set *fyne.StaticResource StaticName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-name!: arg 1: expected native of type *fyne.StaticResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-static-resource//static-name!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.StaticName = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-static-resource//static-name!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-fyne-static-resource//static-name?": {
		Doc:   "Get *fyne.StaticResource StaticName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-name?: arg 1: expected native of type *fyne.StaticResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-static-resource//static-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-static-resource//static-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.StaticName)
			return resObj
		},
	},
	"ptr-fyne-text-style//bold!": {
		Doc:   "Set *fyne.TextStyle Bold value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//bold!: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//bold!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//bold!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Bold = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//bold!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-text-style//bold?": {
		Doc:   "Get *fyne.TextStyle Bold value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//bold?: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//bold?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//bold?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Bold))
			return resObj
		},
	},
	"ptr-fyne-text-style//italic!": {
		Doc:   "Set *fyne.TextStyle Italic value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//italic!: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//italic!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//italic!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Italic = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//italic!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-text-style//italic?": {
		Doc:   "Get *fyne.TextStyle Italic value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//italic?: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//italic?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//italic?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Italic))
			return resObj
		},
	},
	"ptr-fyne-text-style//monospace!": {
		Doc:   "Set *fyne.TextStyle Monospace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//monospace!: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//monospace!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//monospace!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Monospace = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//monospace!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-text-style//monospace?": {
		Doc:   "Get *fyne.TextStyle Monospace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//monospace?: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//monospace?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//monospace?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Monospace))
			return resObj
		},
	},
	"ptr-fyne-text-style//symbol!": {
		Doc:   "Set *fyne.TextStyle Symbol value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//symbol!: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//symbol!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//symbol!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Symbol = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//symbol!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-text-style//symbol?": {
		Doc:   "Get *fyne.TextStyle Symbol value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//symbol?: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//symbol?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//symbol?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Symbol))
			return resObj
		},
	},
	"ptr-fyne-text-style//tab-width!": {
		Doc:   "Set *fyne.TextStyle TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//tab-width!: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//tab-width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//tab-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//tab-width!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-fyne-text-style//tab-width?": {
		Doc:   "Get *fyne.TextStyle TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//tab-width?: arg 1: expected native of type *fyne.TextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-fyne-text-style//tab-width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-fyne-text-style//tab-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"ptr-layout-spacer//expand-horizontal": {
		Doc:   "(*layout.Spacer).ExpandHorizontal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//expand-horizontal: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//expand-horizontal: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//expand-horizontal: arg 1: expected native")
			}
			res0 := arg0Val.ExpandHorizontal()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-layout-spacer//expand-vertical": {
		Doc:   "(*layout.Spacer).ExpandVertical",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//expand-vertical: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//expand-vertical: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//expand-vertical: arg 1: expected native")
			}
			res0 := arg0Val.ExpandVertical()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-layout-spacer//fix-horizontal!": {
		Doc:   "Set *layout.Spacer FixHorizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//fix-horizontal!: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//fix-horizontal!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//fix-horizontal!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixHorizontal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//fix-horizontal!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-layout-spacer//fix-horizontal?": {
		Doc:   "Get *layout.Spacer FixHorizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//fix-horizontal?: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//fix-horizontal?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//fix-horizontal?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixHorizontal))
			return resObj
		},
	},
	"ptr-layout-spacer//fix-vertical!": {
		Doc:   "Set *layout.Spacer FixVertical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//fix-vertical!: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//fix-vertical!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//fix-vertical!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixVertical = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//fix-vertical!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-layout-spacer//fix-vertical?": {
		Doc:   "Get *layout.Spacer FixVertical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//fix-vertical?: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//fix-vertical?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//fix-vertical?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixVertical))
			return resObj
		},
	},
	"ptr-layout-spacer//hide": {
		Doc:   "(*layout.Spacer).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//hide: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-layout-spacer//min-size": {
		Doc:   "(*layout.Spacer).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//min-size: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-layout-spacer//move": {
		Doc:   "(*layout.Spacer).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//move: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-layout-spacer//position": {
		Doc:   "(*layout.Spacer).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//position: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-layout-spacer//refresh": {
		Doc:   "(*layout.Spacer).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//refresh: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-layout-spacer//resize": {
		Doc:   "(*layout.Spacer).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//resize: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-layout-spacer//show": {
		Doc:   "(*layout.Spacer).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//show: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-layout-spacer//size": {
		Doc:   "(*layout.Spacer).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//size: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-layout-spacer//visible": {
		Doc:   "(*layout.Spacer).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//visible: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-layout-spacer//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-layout-spacer//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-mobile-touch-event//absolute-position!": {
		Doc:   "Set *mobile.TouchEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//absolute-position!: arg 1: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//absolute-position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mobile-touch-event//absolute-position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//absolute-position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mobile-touch-event//absolute-position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-mobile-touch-event//absolute-position?": {
		Doc:   "Get *mobile.TouchEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//absolute-position?: arg 1: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//absolute-position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mobile-touch-event//absolute-position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"ptr-mobile-touch-event//position!": {
		Doc:   "Set *mobile.TouchEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//position!: arg 1: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mobile-touch-event//position!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//position!: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mobile-touch-event//position!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-mobile-touch-event//position?": {
		Doc:   "Get *mobile.TouchEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//position?: arg 1: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-mobile-touch-event//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-mobile-touch-event//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"ptr-storage-extension-file-filter//extensions!": {
		Doc:   "Set *storage.ExtensionFileFilter Extensions value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.ExtensionFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-extension-file-filter//extensions!: arg 1: expected native of type *storage.ExtensionFileFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-extension-file-filter//extensions!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-extension-file-filter//extensions!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Extensions = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Extensions[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-storage-extension-file-filter//extensions!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Extensions, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-extension-file-filter//extensions!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-extension-file-filter//extensions!: arg 2: expected integer to be 0 or nil")
				}
				self.Extensions = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-extension-file-filter//extensions!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-storage-extension-file-filter//extensions?": {
		Doc:   "Get *storage.ExtensionFileFilter Extensions value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.ExtensionFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-extension-file-filter//extensions?: arg 1: expected native of type *storage.ExtensionFileFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-extension-file-filter//extensions?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-extension-file-filter//extensions?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Extensions))
				for i, it := range self.Extensions {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-storage-extension-file-filter//matches": {
		Doc:   "(*storage.ExtensionFileFilter).Matches",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*storage.ExtensionFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-extension-file-filter//matches: arg 1: expected native of type *storage.ExtensionFileFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-extension-file-filter//matches: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-extension-file-filter//matches: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-extension-file-filter//matches: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-extension-file-filter//matches: arg 2: expected native")
			}
			res0 := arg0Val.Matches(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-storage-mime-type-file-filter//matches": {
		Doc:   "(*storage.MimeTypeFileFilter).Matches",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*storage.MimeTypeFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-mime-type-file-filter//matches: arg 1: expected native of type *storage.MimeTypeFileFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-mime-type-file-filter//matches: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-mime-type-file-filter//matches: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-mime-type-file-filter//matches: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-mime-type-file-filter//matches: arg 2: expected native")
			}
			res0 := arg0Val.Matches(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-storage-mime-type-file-filter//mime-types!": {
		Doc:   "Set *storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.MimeTypeFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-mime-type-file-filter//mime-types!: arg 1: expected native of type *storage.MimeTypeFileFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-mime-type-file-filter//mime-types!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-mime-type-file-filter//mime-types!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.MimeTypes = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.MimeTypes[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-storage-mime-type-file-filter//mime-types!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.MimeTypes, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-mime-type-file-filter//mime-types!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-mime-type-file-filter//mime-types!: arg 2: expected integer to be 0 or nil")
				}
				self.MimeTypes = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-mime-type-file-filter//mime-types!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-storage-mime-type-file-filter//mime-types?": {
		Doc:   "Get *storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.MimeTypeFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-mime-type-file-filter//mime-types?: arg 1: expected native of type *storage.MimeTypeFileFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-storage-mime-type-file-filter//mime-types?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-storage-mime-type-file-filter//mime-types?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.MimeTypes))
				for i, it := range self.MimeTypes {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-theme-disabled-resource//content": {
		Doc:   "(*theme.DisabledResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.DisabledResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.DisabledResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-disabled-resource//content: arg 1: expected native of type *theme.DisabledResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-disabled-resource//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-disabled-resource//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-theme-disabled-resource//name": {
		Doc:   "(*theme.DisabledResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.DisabledResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.DisabledResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-disabled-resource//name: arg 1: expected native of type *theme.DisabledResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-disabled-resource//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-disabled-resource//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-theme-error-themed-resource//content": {
		Doc:   "(*theme.ErrorThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ErrorThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ErrorThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-error-themed-resource//content: arg 1: expected native of type *theme.ErrorThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-error-themed-resource//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-error-themed-resource//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-theme-error-themed-resource//name": {
		Doc:   "(*theme.ErrorThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ErrorThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ErrorThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-error-themed-resource//name: arg 1: expected native of type *theme.ErrorThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-error-themed-resource//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-error-themed-resource//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-theme-error-themed-resource//original": {
		Doc:   "(*theme.ErrorThemedResource).Original",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ErrorThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ErrorThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-error-themed-resource//original: arg 1: expected native of type *theme.ErrorThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-error-themed-resource//original: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-error-themed-resource//original: arg 1: expected native")
			}
			res0 := arg0Val.Original()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"ptr-theme-inverted-themed-resource//content": {
		Doc:   "(*theme.InvertedThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.InvertedThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.InvertedThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-inverted-themed-resource//content: arg 1: expected native of type *theme.InvertedThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-inverted-themed-resource//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-inverted-themed-resource//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-theme-inverted-themed-resource//name": {
		Doc:   "(*theme.InvertedThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.InvertedThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.InvertedThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-inverted-themed-resource//name: arg 1: expected native of type *theme.InvertedThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-inverted-themed-resource//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-inverted-themed-resource//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-theme-inverted-themed-resource//original": {
		Doc:   "(*theme.InvertedThemedResource).Original",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.InvertedThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.InvertedThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-inverted-themed-resource//original: arg 1: expected native of type *theme.InvertedThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-inverted-themed-resource//original: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-inverted-themed-resource//original: arg 1: expected native")
			}
			res0 := arg0Val.Original()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"ptr-theme-primary-themed-resource//content": {
		Doc:   "(*theme.PrimaryThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.PrimaryThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.PrimaryThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-primary-themed-resource//content: arg 1: expected native of type *theme.PrimaryThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-primary-themed-resource//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-primary-themed-resource//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-theme-primary-themed-resource//name": {
		Doc:   "(*theme.PrimaryThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.PrimaryThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.PrimaryThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-primary-themed-resource//name: arg 1: expected native of type *theme.PrimaryThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-primary-themed-resource//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-primary-themed-resource//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-theme-primary-themed-resource//original": {
		Doc:   "(*theme.PrimaryThemedResource).Original",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.PrimaryThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.PrimaryThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-primary-themed-resource//original: arg 1: expected native of type *theme.PrimaryThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-primary-themed-resource//original: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-primary-themed-resource//original: arg 1: expected native")
			}
			res0 := arg0Val.Original()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"ptr-theme-themed-resource//color-name!": {
		Doc:   "Set *theme.ThemedResource ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//color-name!: arg 1: expected native of type *theme.ThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//color-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-themed-resource//color-name!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeColorName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeColorName)
				}
				if natOk && natValOk {
					self.ColorName = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-theme-themed-resource//color-name!: arg 2: expected string")
					}
					self.ColorName = fyne.ThemeColorName(u)
				}
			}
			return arg0
		},
	},
	"ptr-theme-themed-resource//color-name?": {
		Doc:   "Get *theme.ThemedResource ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//color-name?: arg 1: expected native of type *theme.ThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//color-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-themed-resource//color-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.ColorName))
			return resObj
		},
	},
	"ptr-theme-themed-resource//content": {
		Doc:   "(*theme.ThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//content: arg 1: expected native of type *theme.ThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-themed-resource//content: arg 1: expected native")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-theme-themed-resource//error": {
		Doc:   "(*theme.ThemedResource).Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//error: arg 1: expected native of type *theme.ThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//error: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-themed-resource//error: arg 1: expected native")
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-theme-error-themed-resource")
			return res0Obj
		},
	},
	"ptr-theme-themed-resource//name": {
		Doc:   "(*theme.ThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//name: arg 1: expected native of type *theme.ThemedResource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-theme-themed-resource//name: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-theme-themed-resource//name: arg 1: expected native")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-accordion-item//detail!": {
		Doc:   "Set *widget.AccordionItem Detail value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//detail!: arg 1: expected native of type *widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//detail!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion-item//detail!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Detail, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//detail!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//detail!: arg 2: expected integer to be 0 or nil")
				}
				self.Detail = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion-item//detail!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-accordion-item//detail?": {
		Doc:   "Get *widget.AccordionItem Detail value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//detail?: arg 1: expected native of type *widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//detail?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion-item//detail?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Detail)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Detail, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Detail, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"ptr-widget-accordion-item//open!": {
		Doc:   "Set *widget.AccordionItem Open value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//open!: arg 1: expected native of type *widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//open!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion-item//open!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Open = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion-item//open!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-accordion-item//open?": {
		Doc:   "Get *widget.AccordionItem Open value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//open?: arg 1: expected native of type *widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//open?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion-item//open?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Open))
			return resObj
		},
	},
	"ptr-widget-accordion-item//title!": {
		Doc:   "Set *widget.AccordionItem Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//title!: arg 1: expected native of type *widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//title!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion-item//title!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion-item//title!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-accordion-item//title?": {
		Doc:   "Get *widget.AccordionItem Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//title?: arg 1: expected native of type *widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion-item//title?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion-item//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"ptr-widget-accordion//append": {
		Doc:   "(*widget.Accordion).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//append: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//append: arg 1: expected native")
			}
			var arg1Val *widget.AccordionItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//append: arg 2: expected native of type *widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//append: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//append: arg 2: expected native")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-widget-accordion//close": {
		Doc:   "(*widget.Accordion).Close",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//close: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//close: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//close: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//close: arg 2: expected integer")
			}
			arg0Val.Close(arg1Val)
			return arg0
		},
	},
	"ptr-widget-accordion//close-all": {
		Doc:   "(*widget.Accordion).CloseAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//close-all: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//close-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//close-all: arg 1: expected native")
			}
			arg0Val.CloseAll()
			return arg0
		},
	},
	"ptr-widget-accordion//create-renderer": {
		Doc:   "(*widget.Accordion).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//create-renderer: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-accordion//extend-base-widget": {
		Doc:   "(*widget.Accordion).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//extend-base-widget: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-accordion//hidden!": {
		Doc:   "Set *widget.Accordion Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//hidden!: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-accordion//hidden?": {
		Doc:   "Get *widget.Accordion Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//hidden?: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-accordion//hide": {
		Doc:   "(*widget.Accordion).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//hide: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-accordion//items!": {
		Doc:   "Set *widget.Accordion Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//items!: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.AccordionItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.AccordionItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-accordion//items!: arg 2: block item: expected native of type *widget.AccordionItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-accordion//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-accordion//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//items!: arg 2: expected native of type []*widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-accordion//items?": {
		Doc:   "Get *widget.Accordion Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//items?: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-widget-accordion-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-accordion//min-size": {
		Doc:   "(*widget.Accordion).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//min-size: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-accordion//move": {
		Doc:   "(*widget.Accordion).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//move: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-accordion//multi-open!": {
		Doc:   "Set *widget.Accordion MultiOpen value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//multi-open!: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//multi-open!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//multi-open!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiOpen = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//multi-open!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-accordion//multi-open?": {
		Doc:   "Get *widget.Accordion MultiOpen value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//multi-open?: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//multi-open?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//multi-open?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiOpen))
			return resObj
		},
	},
	"ptr-widget-accordion//open": {
		Doc:   "(*widget.Accordion).Open",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//open: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//open: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//open: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//open: arg 2: expected integer")
			}
			arg0Val.Open(arg1Val)
			return arg0
		},
	},
	"ptr-widget-accordion//open-all": {
		Doc:   "(*widget.Accordion).OpenAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//open-all: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//open-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//open-all: arg 1: expected native")
			}
			arg0Val.OpenAll()
			return arg0
		},
	},
	"ptr-widget-accordion//position": {
		Doc:   "(*widget.Accordion).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//position: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-accordion//refresh": {
		Doc:   "(*widget.Accordion).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//refresh: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-accordion//remove": {
		Doc:   "(*widget.Accordion).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//remove: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//remove: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//remove: arg 1: expected native")
			}
			var arg1Val *widget.AccordionItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//remove: arg 2: expected native of type *widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//remove: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//remove: arg 2: expected native")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"ptr-widget-accordion//remove-index": {
		Doc:   "(*widget.Accordion).RemoveIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//remove-index: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//remove-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//remove-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//remove-index: arg 2: expected integer")
			}
			arg0Val.RemoveIndex(arg1Val)
			return arg0
		},
	},
	"ptr-widget-accordion//resize": {
		Doc:   "(*widget.Accordion).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//resize: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-accordion//show": {
		Doc:   "(*widget.Accordion).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//show: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-accordion//size": {
		Doc:   "(*widget.Accordion).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//size: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-accordion//visible": {
		Doc:   "(*widget.Accordion).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//visible: arg 1: expected native of type *widget.Accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-accordion//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-accordion//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-base-widget//extend-base-widget": {
		Doc:   "(*widget.BaseWidget).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//extend-base-widget: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-base-widget//hidden!": {
		Doc:   "Set *widget.BaseWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//hidden!: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-base-widget//hidden?": {
		Doc:   "Get *widget.BaseWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//hidden?: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-base-widget//hide": {
		Doc:   "(*widget.BaseWidget).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//hide: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-base-widget//min-size": {
		Doc:   "(*widget.BaseWidget).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//min-size: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-base-widget//move": {
		Doc:   "(*widget.BaseWidget).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//move: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-base-widget//position": {
		Doc:   "(*widget.BaseWidget).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//position: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-base-widget//refresh": {
		Doc:   "(*widget.BaseWidget).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//refresh: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-base-widget//resize": {
		Doc:   "(*widget.BaseWidget).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//resize: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-base-widget//show": {
		Doc:   "(*widget.BaseWidget).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//show: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-base-widget//size": {
		Doc:   "(*widget.BaseWidget).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//size: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-base-widget//visible": {
		Doc:   "(*widget.BaseWidget).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//visible: arg 1: expected native of type *widget.BaseWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-base-widget//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-base-widget//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-button//alignment!": {
		Doc:   "Set *widget.Button Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//alignment!: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.ButtonAlign
				if natOk {
					natVal, natValOk = nat.Value.(widget.ButtonAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-button//alignment!: arg 2: expected integer")
					}
					self.Alignment = widget.ButtonAlign(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-button//alignment?": {
		Doc:   "Get *widget.Button Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//alignment?: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"ptr-widget-button//create-renderer": {
		Doc:   "(*widget.Button).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//create-renderer: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-button//cursor": {
		Doc:   "(*widget.Button).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//cursor: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//cursor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//cursor: arg 1: expected native")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-button//disable": {
		Doc:   "(*widget.Button).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//disable: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-widget-button//disabled": {
		Doc:   "(*widget.Button).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//disabled: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-button//enable": {
		Doc:   "(*widget.Button).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//enable: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-widget-button//extend-base-widget": {
		Doc:   "(*widget.Button).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//extend-base-widget: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//focus-gained": {
		Doc:   "(*widget.Button).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//focus-gained: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-button//focus-lost": {
		Doc:   "(*widget.Button).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//focus-lost: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-button//hidden!": {
		Doc:   "Set *widget.Button Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//hidden!: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-button//hidden?": {
		Doc:   "Get *widget.Button Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//hidden?: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-button//hide": {
		Doc:   "(*widget.Button).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//hide: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-button//icon!": {
		Doc:   "Set *widget.Button Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon!: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-button//icon-placement!": {
		Doc:   "Set *widget.Button IconPlacement value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon-placement!: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon-placement!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//icon-placement!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.ButtonIconPlacement
				if natOk {
					natVal, natValOk = nat.Value.(widget.ButtonIconPlacement)
				}
				if natOk && natValOk {
					self.IconPlacement = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-button//icon-placement!: arg 2: expected integer")
					}
					self.IconPlacement = widget.ButtonIconPlacement(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-button//icon-placement?": {
		Doc:   "Get *widget.Button IconPlacement value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon-placement?: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon-placement?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//icon-placement?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.IconPlacement)))
			return resObj
		},
	},
	"ptr-widget-button//icon?": {
		Doc:   "Get *widget.Button Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon?: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//icon?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"ptr-widget-button//importance!": {
		Doc:   "Set *widget.Button Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//importance!: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//importance!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//importance!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.Importance
				if natOk {
					natVal, natValOk = nat.Value.(widget.Importance)
				}
				if natOk && natValOk {
					self.Importance = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-button//importance!: arg 2: expected integer")
					}
					self.Importance = widget.Importance(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-button//importance?": {
		Doc:   "Get *widget.Button Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//importance?: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//importance?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//importance?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Importance)))
			return resObj
		},
	},
	"ptr-widget-button//min-size": {
		Doc:   "(*widget.Button).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//min-size: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-button//mouse-in": {
		Doc:   "(*widget.Button).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-in: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-in: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//mouse-in: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-in: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-in: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//mouse-in: arg 2: expected native")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//mouse-moved": {
		Doc:   "(*widget.Button).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-moved: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-moved: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//mouse-moved: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-moved: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-moved: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//mouse-moved: arg 2: expected native")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//mouse-out": {
		Doc:   "(*widget.Button).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-out: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//mouse-out: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//mouse-out: arg 1: expected native")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-widget-button//move": {
		Doc:   "(*widget.Button).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//move: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//on-tapped!": {
		Doc:   "Set *widget.Button OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//on-tapped!: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//on-tapped!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//on-tapped!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//on-tapped!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//on-tapped!: arg 2: expected integer to be 0 or nil")
				}
				self.OnTapped = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//on-tapped!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-button//on-tapped?": {
		Doc:   "Get *widget.Button OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//on-tapped?: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//on-tapped?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//on-tapped?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"ptr-widget-button//position": {
		Doc:   "(*widget.Button).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//position: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-button//refresh": {
		Doc:   "(*widget.Button).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//refresh: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-button//resize": {
		Doc:   "(*widget.Button).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//resize: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//set-icon": {
		Doc:   "(*widget.Button).SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//set-icon: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//set-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//set-icon: arg 1: expected native")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//set-icon: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//set-icon: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//set-icon: arg 2: expected native")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//set-text": {
		Doc:   "(*widget.Button).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//set-text: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//show": {
		Doc:   "(*widget.Button).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//show: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-button//size": {
		Doc:   "(*widget.Button).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//size: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-button//tapped": {
		Doc:   "(*widget.Button).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//tapped: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//text!": {
		Doc:   "Set *widget.Button Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//text!: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-button//text?": {
		Doc:   "Get *widget.Button Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//text?: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-widget-button//typed-key": {
		Doc:   "(*widget.Button).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//typed-key: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//typed-rune": {
		Doc:   "(*widget.Button).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//typed-rune: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-button//visible": {
		Doc:   "(*widget.Button).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//visible: arg 1: expected native of type *widget.Button")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-button//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-button//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-card//content!": {
		Doc:   "Set *widget.Card Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//content!: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//content!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//content!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//content!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//content!: arg 2: expected integer to be 0 or nil")
				}
				self.Content = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//content!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-card//content?": {
		Doc:   "Get *widget.Card Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//content?: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//content?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//content?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Content)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Content, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"ptr-widget-card//create-renderer": {
		Doc:   "(*widget.Card).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//create-renderer: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-card//extend-base-widget": {
		Doc:   "(*widget.Card).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//extend-base-widget: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-card//hidden!": {
		Doc:   "Set *widget.Card Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//hidden!: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-card//hidden?": {
		Doc:   "Get *widget.Card Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//hidden?: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-card//hide": {
		Doc:   "(*widget.Card).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//hide: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-card//image!": {
		Doc:   "Set *widget.Card Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//image!: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//image!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//image!: arg 2: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-card//image?": {
		Doc:   "Get *widget.Card Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//image?: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//image?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-canvas-image")
			return resObj
		},
	},
	"ptr-widget-card//min-size": {
		Doc:   "(*widget.Card).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//min-size: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-card//move": {
		Doc:   "(*widget.Card).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//move: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-card//position": {
		Doc:   "(*widget.Card).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//position: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-card//refresh": {
		Doc:   "(*widget.Card).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//refresh: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-card//resize": {
		Doc:   "(*widget.Card).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//resize: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-card//set-content": {
		Doc:   "(*widget.Card).SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-content: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-content: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//set-content: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-content: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-content: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//set-content: arg 2: expected native")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"ptr-widget-card//set-image": {
		Doc:   "(*widget.Card).SetImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-image: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-image: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//set-image: arg 1: expected native")
			}
			var arg1Val *canvas.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-image: arg 2: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-image: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//set-image: arg 2: expected native")
			}
			arg0Val.SetImage(arg1Val)
			return arg0
		},
	},
	"ptr-widget-card//set-sub-title": {
		Doc:   "(*widget.Card).SetSubTitle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-sub-title: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-sub-title: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//set-sub-title: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//set-sub-title: arg 2: expected string")
			}
			arg0Val.SetSubTitle(arg1Val)
			return arg0
		},
	},
	"ptr-widget-card//set-title": {
		Doc:   "(*widget.Card).SetTitle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-title: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//set-title: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//set-title: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//set-title: arg 2: expected string")
			}
			arg0Val.SetTitle(arg1Val)
			return arg0
		},
	},
	"ptr-widget-card//show": {
		Doc:   "(*widget.Card).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//show: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-card//size": {
		Doc:   "(*widget.Card).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//size: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-card//subtitle!": {
		Doc:   "Set *widget.Card Subtitle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//subtitle!: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//subtitle!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//subtitle!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Subtitle = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//subtitle!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-card//subtitle?": {
		Doc:   "Get *widget.Card Subtitle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//subtitle?: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//subtitle?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//subtitle?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Subtitle)
			return resObj
		},
	},
	"ptr-widget-card//title!": {
		Doc:   "Set *widget.Card Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//title!: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//title!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//title!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//title!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-card//title?": {
		Doc:   "Get *widget.Card Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//title?: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//title?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"ptr-widget-card//visible": {
		Doc:   "(*widget.Card).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//visible: arg 1: expected native of type *widget.Card")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-card//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-card//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-check-group//append": {
		Doc:   "(*widget.CheckGroup).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//append: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//append: arg 2: expected string")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check-group//create-renderer": {
		Doc:   "(*widget.CheckGroup).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//create-renderer: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-check-group//disable": {
		Doc:   "(*widget.CheckGroup).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//disable: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-widget-check-group//disabled": {
		Doc:   "(*widget.CheckGroup).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//disabled: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-check-group//enable": {
		Doc:   "(*widget.CheckGroup).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//enable: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-widget-check-group//extend-base-widget": {
		Doc:   "(*widget.CheckGroup).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//extend-base-widget: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check-group//hidden!": {
		Doc:   "Set *widget.CheckGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//hidden!: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-check-group//hidden?": {
		Doc:   "Get *widget.CheckGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//hidden?: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-check-group//hide": {
		Doc:   "(*widget.CheckGroup).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//hide: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-check-group//horizontal!": {
		Doc:   "Set *widget.CheckGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//horizontal!: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//horizontal!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//horizontal!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//horizontal!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-check-group//horizontal?": {
		Doc:   "Get *widget.CheckGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//horizontal?: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//horizontal?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//horizontal?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"ptr-widget-check-group//min-size": {
		Doc:   "(*widget.CheckGroup).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//min-size: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-check-group//move": {
		Doc:   "(*widget.CheckGroup).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//move: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check-group//on-changed!": {
		Doc:   "Set *widget.CheckGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//on-changed!: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//on-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 []string) {
					var arg0Val env.Object
					{
						items := make([]env.Object, len(arg0))
						for i, it := range arg0 {
							items[i] = *env.NewString(it)
						}
						arg0Val = *env.NewBlock(*env.NewTSeries(items))
					}
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-check-group//on-changed?": {
		Doc:   "Get *widget.CheckGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//on-changed?: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//on-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(arr-string)")
			return resObj
		},
	},
	"ptr-widget-check-group//options!": {
		Doc:   "Set *widget.CheckGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//options!: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//options!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//options!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-check-group//options!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//options!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//options!: arg 2: expected integer to be 0 or nil")
				}
				self.Options = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//options!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-check-group//options?": {
		Doc:   "Get *widget.CheckGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//options?: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//options?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//options?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-check-group//position": {
		Doc:   "(*widget.CheckGroup).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//position: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-check-group//refresh": {
		Doc:   "(*widget.CheckGroup).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//refresh: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-check-group//remove": {
		Doc:   "(*widget.CheckGroup).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//remove: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//remove: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//remove: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//remove: arg 2: expected string")
			}
			res0 := arg0Val.Remove(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-check-group//required!": {
		Doc:   "Set *widget.CheckGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//required!: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//required!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//required!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//required!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-check-group//required?": {
		Doc:   "Get *widget.CheckGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//required?: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//required?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//required?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"ptr-widget-check-group//resize": {
		Doc:   "(*widget.CheckGroup).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//resize: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check-group//selected!": {
		Doc:   "Set *widget.CheckGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//selected!: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//selected!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Selected = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Selected[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-check-group//selected!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Selected, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//selected!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//selected!: arg 2: expected integer to be 0 or nil")
				}
				self.Selected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//selected!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-check-group//selected?": {
		Doc:   "Get *widget.CheckGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//selected?: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//selected?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Selected))
				for i, it := range self.Selected {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-check-group//set-selected": {
		Doc:   "(*widget.CheckGroup).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//set-selected: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//set-selected: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//set-selected: arg 1: expected native")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-check-group//set-selected: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//set-selected: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//set-selected: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//set-selected: arg 2: expected block, native or nil")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check-group//show": {
		Doc:   "(*widget.CheckGroup).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//show: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-check-group//size": {
		Doc:   "(*widget.CheckGroup).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//size: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-check-group//visible": {
		Doc:   "(*widget.CheckGroup).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//visible: arg 1: expected native of type *widget.CheckGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check-group//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check-group//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-check//bind": {
		Doc:   "(*widget.Check).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//bind: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//bind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//bind: arg 1: expected native")
			}
			var arg1Val binding.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//bind: arg 2: expected native of type binding.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//bind: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//bind: arg 2: expected native")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//checked!": {
		Doc:   "Set *widget.Check Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//checked!: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//checked!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//checked!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//checked!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-check//checked?": {
		Doc:   "Get *widget.Check Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//checked?: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//checked?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//checked?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"ptr-widget-check//create-renderer": {
		Doc:   "(*widget.Check).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//create-renderer: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-check//disable": {
		Doc:   "(*widget.Check).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//disable: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-widget-check//disabled": {
		Doc:   "(*widget.Check).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//disabled: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-check//enable": {
		Doc:   "(*widget.Check).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//enable: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-widget-check//extend-base-widget": {
		Doc:   "(*widget.Check).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//extend-base-widget: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//focus-gained": {
		Doc:   "(*widget.Check).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//focus-gained: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-check//focus-lost": {
		Doc:   "(*widget.Check).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//focus-lost: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-check//hidden!": {
		Doc:   "Set *widget.Check Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//hidden!: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-check//hidden?": {
		Doc:   "Get *widget.Check Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//hidden?: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-check//hide": {
		Doc:   "(*widget.Check).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//hide: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-check//min-size": {
		Doc:   "(*widget.Check).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//min-size: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-check//mouse-in": {
		Doc:   "(*widget.Check).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-in: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-in: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//mouse-in: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-in: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-in: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//mouse-in: arg 2: expected native")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//mouse-moved": {
		Doc:   "(*widget.Check).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-moved: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-moved: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//mouse-moved: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-moved: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-moved: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//mouse-moved: arg 2: expected native")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//mouse-out": {
		Doc:   "(*widget.Check).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-out: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//mouse-out: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//mouse-out: arg 1: expected native")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-widget-check//move": {
		Doc:   "(*widget.Check).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//move: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//on-changed!": {
		Doc:   "Set *widget.Check OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//on-changed!: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//on-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-check//on-changed?": {
		Doc:   "Get *widget.Check OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//on-changed?: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//on-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(bool)")
			return resObj
		},
	},
	"ptr-widget-check//position": {
		Doc:   "(*widget.Check).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//position: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-check//refresh": {
		Doc:   "(*widget.Check).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//refresh: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-check//resize": {
		Doc:   "(*widget.Check).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//resize: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//set-checked": {
		Doc:   "(*widget.Check).SetChecked",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//set-checked: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//set-checked: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//set-checked: arg 1: expected native")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//set-checked: arg 2: expected integer")
			}
			arg0Val.SetChecked(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//set-text": {
		Doc:   "(*widget.Check).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//set-text: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//show": {
		Doc:   "(*widget.Check).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//show: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-check//size": {
		Doc:   "(*widget.Check).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//size: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-check//tapped": {
		Doc:   "(*widget.Check).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//tapped: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//text!": {
		Doc:   "Set *widget.Check Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//text!: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-check//text?": {
		Doc:   "Get *widget.Check Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//text?: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-widget-check//typed-key": {
		Doc:   "(*widget.Check).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//typed-key: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//typed-rune": {
		Doc:   "(*widget.Check).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//typed-rune: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-check//unbind": {
		Doc:   "(*widget.Check).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//unbind: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//unbind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//unbind: arg 1: expected native")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-widget-check//visible": {
		Doc:   "(*widget.Check).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//visible: arg 1: expected native of type *widget.Check")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-check//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-check//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-custom-text-grid-style//background-color": {
		Doc:   "(*widget.CustomTextGridStyle).BackgroundColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//background-color: arg 1: expected native of type *widget.CustomTextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//background-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-custom-text-grid-style//background-color: arg 1: expected native")
			}
			res0 := arg0Val.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"ptr-widget-custom-text-grid-style//bg-color!": {
		Doc:   "Set *widget.CustomTextGridStyle BGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//bg-color!: arg 1: expected native of type *widget.CustomTextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//bg-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-custom-text-grid-style//bg-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.BGColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//bg-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-custom-text-grid-style//bg-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-custom-text-grid-style//bg-color?": {
		Doc:   "Get *widget.CustomTextGridStyle BGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//bg-color?: arg 1: expected native of type *widget.CustomTextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//bg-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-custom-text-grid-style//bg-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.BGColor, "color-color")
			return resObj
		},
	},
	"ptr-widget-custom-text-grid-style//fg-color!": {
		Doc:   "Set *widget.CustomTextGridStyle FGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//fg-color!: arg 1: expected native of type *widget.CustomTextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//fg-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-custom-text-grid-style//fg-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FGColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//fg-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-custom-text-grid-style//fg-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-custom-text-grid-style//fg-color?": {
		Doc:   "Get *widget.CustomTextGridStyle FGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//fg-color?: arg 1: expected native of type *widget.CustomTextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//fg-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-custom-text-grid-style//fg-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FGColor, "color-color")
			return resObj
		},
	},
	"ptr-widget-custom-text-grid-style//text-color": {
		Doc:   "(*widget.CustomTextGridStyle).TextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//text-color: arg 1: expected native of type *widget.CustomTextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-custom-text-grid-style//text-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-custom-text-grid-style//text-color: arg 1: expected native")
			}
			res0 := arg0Val.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"ptr-widget-disableable-widget//disable": {
		Doc:   "(*widget.DisableableWidget).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//disable: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-widget-disableable-widget//disabled": {
		Doc:   "(*widget.DisableableWidget).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//disabled: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-disableable-widget//enable": {
		Doc:   "(*widget.DisableableWidget).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//enable: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-widget-disableable-widget//extend-base-widget": {
		Doc:   "(*widget.DisableableWidget).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//extend-base-widget: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-disableable-widget//hidden!": {
		Doc:   "Set *widget.DisableableWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//hidden!: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-disableable-widget//hidden?": {
		Doc:   "Get *widget.DisableableWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//hidden?: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-disableable-widget//hide": {
		Doc:   "(*widget.DisableableWidget).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//hide: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-disableable-widget//min-size": {
		Doc:   "(*widget.DisableableWidget).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//min-size: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-disableable-widget//move": {
		Doc:   "(*widget.DisableableWidget).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//move: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-disableable-widget//position": {
		Doc:   "(*widget.DisableableWidget).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//position: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-disableable-widget//refresh": {
		Doc:   "(*widget.DisableableWidget).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//refresh: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-disableable-widget//resize": {
		Doc:   "(*widget.DisableableWidget).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//resize: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-disableable-widget//show": {
		Doc:   "(*widget.DisableableWidget).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//show: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-disableable-widget//size": {
		Doc:   "(*widget.DisableableWidget).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//size: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-disableable-widget//visible": {
		Doc:   "(*widget.DisableableWidget).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//visible: arg 1: expected native of type *widget.DisableableWidget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-disableable-widget//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-disableable-widget//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-entry//accepts-tab": {
		Doc:   "(*widget.Entry).AcceptsTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//accepts-tab: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//accepts-tab: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//accepts-tab: arg 1: expected native")
			}
			res0 := arg0Val.AcceptsTab()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-entry//action-item!": {
		Doc:   "Set *widget.Entry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//action-item!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//action-item!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//action-item!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//action-item!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//action-item!: arg 2: expected integer to be 0 or nil")
				}
				self.ActionItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//action-item!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-entry//action-item?": {
		Doc:   "Get *widget.Entry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//action-item?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//action-item?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//action-item?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.ActionItem)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.ActionItem, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.ActionItem, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"ptr-widget-entry//append": {
		Doc:   "(*widget.Entry).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//append: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//append: arg 2: expected string")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//bind": {
		Doc:   "(*widget.Entry).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//bind: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//bind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//bind: arg 1: expected native")
			}
			var arg1Val binding.String
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//bind: arg 2: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//bind: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//bind: arg 2: expected native")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//create-renderer": {
		Doc:   "(*widget.Entry).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//create-renderer: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-entry//cursor": {
		Doc:   "(*widget.Entry).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//cursor: arg 1: expected native")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-entry//cursor-column!": {
		Doc:   "Set *widget.Entry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor-column!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor-column!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//cursor-column!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//cursor-column!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-entry//cursor-column?": {
		Doc:   "Get *widget.Entry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor-column?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor-column?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//cursor-column?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"ptr-widget-entry//cursor-row!": {
		Doc:   "Set *widget.Entry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor-row!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor-row!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//cursor-row!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//cursor-row!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-entry//cursor-row?": {
		Doc:   "Get *widget.Entry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor-row?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//cursor-row?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//cursor-row?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"ptr-widget-entry//disable": {
		Doc:   "(*widget.Entry).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//disable: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-widget-entry//disabled": {
		Doc:   "(*widget.Entry).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//disabled: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-entry//double-tapped": {
		Doc:   "(*widget.Entry).DoubleTapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//double-tapped: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//double-tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//double-tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//double-tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//double-tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//double-tapped: arg 2: expected native")
			}
			arg0Val.DoubleTapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//drag-end": {
		Doc:   "(*widget.Entry).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//drag-end: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//drag-end: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//drag-end: arg 1: expected native")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"ptr-widget-entry//dragged": {
		Doc:   "(*widget.Entry).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//dragged: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//dragged: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//dragged: arg 1: expected native")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//dragged: arg 2: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//dragged: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//dragged: arg 2: expected native")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//enable": {
		Doc:   "(*widget.Entry).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//enable: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-widget-entry//extend-base-widget": {
		Doc:   "(*widget.Entry).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//extend-base-widget: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//focus-gained": {
		Doc:   "(*widget.Entry).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//focus-gained: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-entry//focus-lost": {
		Doc:   "(*widget.Entry).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//focus-lost: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-entry//hidden!": {
		Doc:   "Set *widget.Entry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//hidden!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-entry//hidden?": {
		Doc:   "Get *widget.Entry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//hidden?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-entry//hide": {
		Doc:   "(*widget.Entry).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//hide: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-entry//key-down": {
		Doc:   "(*widget.Entry).KeyDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//key-down: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//key-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//key-down: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//key-down: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//key-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//key-down: arg 2: expected native")
			}
			arg0Val.KeyDown(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//key-up": {
		Doc:   "(*widget.Entry).KeyUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//key-up: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//key-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//key-up: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//key-up: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//key-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//key-up: arg 2: expected native")
			}
			arg0Val.KeyUp(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//keyboard": {
		Doc:   "(*widget.Entry).Keyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//keyboard: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//keyboard: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//keyboard: arg 1: expected native")
			}
			res0 := arg0Val.Keyboard()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int32(res0)))
			return res0Obj
		},
	},
	"ptr-widget-entry//min-size": {
		Doc:   "(*widget.Entry).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//min-size: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-entry//mouse-down": {
		Doc:   "(*widget.Entry).MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//mouse-down: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//mouse-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//mouse-down: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//mouse-down: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//mouse-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//mouse-down: arg 2: expected native")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//mouse-up": {
		Doc:   "(*widget.Entry).MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//mouse-up: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//mouse-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//mouse-up: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//mouse-up: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//mouse-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//mouse-up: arg 2: expected native")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//move": {
		Doc:   "(*widget.Entry).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//move: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//multi-line!": {
		Doc:   "Set *widget.Entry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//multi-line!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//multi-line!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//multi-line!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//multi-line!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-entry//multi-line?": {
		Doc:   "Get *widget.Entry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//multi-line?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//multi-line?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//multi-line?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"ptr-widget-entry//on-changed!": {
		Doc:   "Set *widget.Entry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-changed!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-entry//on-changed?": {
		Doc:   "Get *widget.Entry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-changed?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"ptr-widget-entry//on-cursor-changed!": {
		Doc:   "Set *widget.Entry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-cursor-changed!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-cursor-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//on-cursor-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-cursor-changed!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-cursor-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnCursorChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//on-cursor-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-entry//on-cursor-changed?": {
		Doc:   "Get *widget.Entry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-cursor-changed?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-cursor-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//on-cursor-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "func()")
			return resObj
		},
	},
	"ptr-widget-entry//on-submitted!": {
		Doc:   "Set *widget.Entry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-submitted!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-submitted!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//on-submitted!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-submitted!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-submitted!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSubmitted = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//on-submitted!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-entry//on-submitted?": {
		Doc:   "Get *widget.Entry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-submitted?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//on-submitted?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//on-submitted?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "func(string)")
			return resObj
		},
	},
	"ptr-widget-entry//password!": {
		Doc:   "Set *widget.Entry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//password!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//password!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//password!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//password!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-entry//password?": {
		Doc:   "Get *widget.Entry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//password?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//password?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//password?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"ptr-widget-entry//place-holder!": {
		Doc:   "Set *widget.Entry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//place-holder!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//place-holder!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//place-holder!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//place-holder!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-entry//place-holder?": {
		Doc:   "Get *widget.Entry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//place-holder?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//place-holder?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//place-holder?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"ptr-widget-entry//position": {
		Doc:   "(*widget.Entry).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//position: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-entry//refresh": {
		Doc:   "(*widget.Entry).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//refresh: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-entry//resize": {
		Doc:   "(*widget.Entry).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//resize: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//scroll!": {
		Doc:   "Set *widget.Entry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//scroll!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//scroll!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//scroll!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var rOut, rIn reflect.Value
				if natOk {
					// HACK: self.Scroll, natValOk = widget_1.ScrollDirection(u)
					rOut = reflect.ValueOf(&self.Scroll).Elem()
					rIn = reflect.ValueOf(nat.Value)
					natValOk = rIn.CanConvert(rOut.Type())
				}
				if natOk && natValOk {
					rOut.Set(rIn.Convert(rOut.Type()))
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-entry//scroll!: arg 2: expected integer")
					}
					// HACK: self.Scroll = widget_1.ScrollDirection(u)
					rOut := reflect.ValueOf(&self.Scroll).Elem()
					rIn := reflect.ValueOf(u)
					rOut.Set(rIn.Convert(rOut.Type()))
				}
			}
			return arg0
		},
	},
	"ptr-widget-entry//scroll?": {
		Doc:   "Get *widget.Entry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//scroll?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//scroll?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//scroll?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Scroll)))
			return resObj
		},
	},
	"ptr-widget-entry//selected-text": {
		Doc:   "(*widget.Entry).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//selected-text: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-entry//set-min-rows-visible": {
		Doc:   "(*widget.Entry).SetMinRowsVisible",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-min-rows-visible: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-min-rows-visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-min-rows-visible: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-min-rows-visible: arg 2: expected integer")
			}
			arg0Val.SetMinRowsVisible(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//set-on-validation-changed": {
		Doc:   "(*widget.Entry).SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-on-validation-changed: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-on-validation-changed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-on-validation-changed: arg 1: expected native")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-on-validation-changed: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-on-validation-changed: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-on-validation-changed: arg 2: expected function or nil")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//set-place-holder": {
		Doc:   "(*widget.Entry).SetPlaceHolder",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-place-holder: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-place-holder: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-place-holder: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-place-holder: arg 2: expected string")
			}
			arg0Val.SetPlaceHolder(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//set-text": {
		Doc:   "(*widget.Entry).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-text: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//set-validation-error": {
		Doc:   "(*widget.Entry).SetValidationError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-validation-error: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-validation-error: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-validation-error: arg 1: expected native")
			}
			var arg1Val error
			switch v := arg1.(type) {
			case env.String:
				arg1Val = errors.New(v.Value)
			case env.Error:
				arg1Val = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//set-validation-error: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//set-validation-error: arg 2: expected error, string or nil")
			}
			arg0Val.SetValidationError(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//show": {
		Doc:   "(*widget.Entry).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//show: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-entry//size": {
		Doc:   "(*widget.Entry).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//size: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-entry//tapped": {
		Doc:   "(*widget.Entry).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//tapped: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//tapped-secondary": {
		Doc:   "(*widget.Entry).TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//tapped-secondary: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//tapped-secondary: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//tapped-secondary: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//tapped-secondary: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//tapped-secondary: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//tapped-secondary: arg 2: expected native")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//text!": {
		Doc:   "Set *widget.Entry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//text!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-entry//text-style!": {
		Doc:   "Set *widget.Entry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//text-style!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//text-style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-entry//text-style?": {
		Doc:   "Get *widget.Entry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//text-style?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//text-style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"ptr-widget-entry//text?": {
		Doc:   "Get *widget.Entry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//text?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-widget-entry//touch-cancel": {
		Doc:   "(*widget.Entry).TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-cancel: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-cancel: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//touch-cancel: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-cancel: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-cancel: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//touch-cancel: arg 2: expected native")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//touch-down": {
		Doc:   "(*widget.Entry).TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-down: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//touch-down: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-down: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//touch-down: arg 2: expected native")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//touch-up": {
		Doc:   "(*widget.Entry).TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-up: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//touch-up: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-up: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//touch-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//touch-up: arg 2: expected native")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//typed-key": {
		Doc:   "(*widget.Entry).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-key: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//typed-rune": {
		Doc:   "(*widget.Entry).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-rune: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//typed-shortcut": {
		Doc:   "(*widget.Entry).TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-shortcut: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-shortcut: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//typed-shortcut: arg 1: expected native")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-shortcut: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//typed-shortcut: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//typed-shortcut: arg 2: expected native")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"ptr-widget-entry//unbind": {
		Doc:   "(*widget.Entry).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//unbind: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//unbind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//unbind: arg 1: expected native")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-widget-entry//validate": {
		Doc:   "(*widget.Entry).Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//validate: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//validate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//validate: arg 1: expected native")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-widget-entry//validator!": {
		Doc:   "Set *widget.Entry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//validator!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//validator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//validator!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.StringValidator
				if natOk {
					natVal, natValOk = nat.Value.(fyne.StringValidator)
				}
				if natOk && natValOk {
					self.Validator = natVal
				} else {
					var u func(string) error
					switch fn := arg1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-entry//validator!: arg 2: function has invalid number of arguments (expected 1)")
						}
						u = func(arg0 string) error {
							var arg0Val env.Object
							arg0Val = *env.NewString(arg0)
							evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
							var res error
							switch v := ps.Res.(type) {
							case env.String:
								res = errors.New(v.Value)
							case env.Error:
								res = errors.New(v.Print(*ps.Idx))
							case env.Integer:
								if v.Value != 0 {
									// TODO: Cannot return error from function
								}
								res = nil
							default:
								// TODO: Cannot return error from function
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-entry//validator!: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-entry//validator!: arg 2: expected function or nil")
					}
					self.Validator = fyne.StringValidator(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-entry//validator?": {
		Doc:   "Get *widget.Entry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//validator?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//validator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//validator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, (func(string) error)(self.Validator), "func(string)_(error)")
			return resObj
		},
	},
	"ptr-widget-entry//visible": {
		Doc:   "(*widget.Entry).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//visible: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-entry//wrapping!": {
		Doc:   "Set *widget.Entry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//wrapping!: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//wrapping!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-entry//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-entry//wrapping?": {
		Doc:   "Get *widget.Entry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//wrapping?: arg 1: expected native of type *widget.Entry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-entry//wrapping?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-entry//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"ptr-widget-file-icon//create-renderer": {
		Doc:   "(*widget.FileIcon).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//create-renderer: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-file-icon//extend-base-widget": {
		Doc:   "(*widget.FileIcon).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//extend-base-widget: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-file-icon//hidden!": {
		Doc:   "Set *widget.FileIcon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//hidden!: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-file-icon//hidden?": {
		Doc:   "Get *widget.FileIcon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//hidden?: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-file-icon//hide": {
		Doc:   "(*widget.FileIcon).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//hide: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-file-icon//min-size": {
		Doc:   "(*widget.FileIcon).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//min-size: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-file-icon//move": {
		Doc:   "(*widget.FileIcon).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//move: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-file-icon//position": {
		Doc:   "(*widget.FileIcon).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//position: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-file-icon//refresh": {
		Doc:   "(*widget.FileIcon).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//refresh: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-file-icon//resize": {
		Doc:   "(*widget.FileIcon).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//resize: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-file-icon//selected!": {
		Doc:   "Set *widget.FileIcon Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//selected!: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//selected!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Selected = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//selected!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-file-icon//selected?": {
		Doc:   "Get *widget.FileIcon Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//selected?: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Selected))
			return resObj
		},
	},
	"ptr-widget-file-icon//set-selected": {
		Doc:   "(*widget.FileIcon).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//set-selected: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//set-selected: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//set-selected: arg 1: expected native")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//set-selected: arg 2: expected integer")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"ptr-widget-file-icon//set-uri": {
		Doc:   "(*widget.FileIcon).SetURI",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//set-uri: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//set-uri: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//set-uri: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//set-uri: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//set-uri: arg 2: expected native")
			}
			arg0Val.SetURI(arg1Val)
			return arg0
		},
	},
	"ptr-widget-file-icon//show": {
		Doc:   "(*widget.FileIcon).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//show: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-file-icon//size": {
		Doc:   "(*widget.FileIcon).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//size: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-file-icon//uri!": {
		Doc:   "Set *widget.FileIcon URI value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//uri!: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//uri!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//uri!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URI, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//uri!: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//uri!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-file-icon//uri?": {
		Doc:   "Get *widget.FileIcon URI value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//uri?: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//uri?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//uri?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URI, "fyne-uri")
			return resObj
		},
	},
	"ptr-widget-file-icon//visible": {
		Doc:   "(*widget.FileIcon).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//visible: arg 1: expected native of type *widget.FileIcon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-file-icon//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-file-icon//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-form-item//hint-text!": {
		Doc:   "Set *widget.FormItem HintText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//hint-text!: arg 1: expected native of type *widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//hint-text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form-item//hint-text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.HintText = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form-item//hint-text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-form-item//hint-text?": {
		Doc:   "Get *widget.FormItem HintText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//hint-text?: arg 1: expected native of type *widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//hint-text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form-item//hint-text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.HintText)
			return resObj
		},
	},
	"ptr-widget-form-item//text!": {
		Doc:   "Set *widget.FormItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//text!: arg 1: expected native of type *widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form-item//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form-item//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-form-item//text?": {
		Doc:   "Get *widget.FormItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//text?: arg 1: expected native of type *widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form-item//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-widget-form-item//widget!": {
		Doc:   "Set *widget.FormItem Widget value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//widget!: arg 1: expected native of type *widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//widget!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form-item//widget!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Widget, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//widget!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//widget!: arg 2: expected integer to be 0 or nil")
				}
				self.Widget = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form-item//widget!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-form-item//widget?": {
		Doc:   "Get *widget.FormItem Widget value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//widget?: arg 1: expected native of type *widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form-item//widget?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form-item//widget?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Widget)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Widget, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Widget, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"ptr-widget-form//append": {
		Doc:   "(*widget.Form).Append",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//append: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//append: arg 2: expected string")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//append: arg 3: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//append: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//append: arg 3: expected native")
			}
			arg0Val.Append(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-form//append-item": {
		Doc:   "(*widget.Form).AppendItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//append-item: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//append-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//append-item: arg 1: expected native")
			}
			var arg1Val *widget.FormItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//append-item: arg 2: expected native of type *widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//append-item: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//append-item: arg 2: expected native")
			}
			arg0Val.AppendItem(arg1Val)
			return arg0
		},
	},
	"ptr-widget-form//cancel-text!": {
		Doc:   "Set *widget.Form CancelText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//cancel-text!: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//cancel-text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//cancel-text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.CancelText = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//cancel-text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-form//cancel-text?": {
		Doc:   "Get *widget.Form CancelText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//cancel-text?: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//cancel-text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//cancel-text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CancelText)
			return resObj
		},
	},
	"ptr-widget-form//create-renderer": {
		Doc:   "(*widget.Form).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//create-renderer: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-form//disable": {
		Doc:   "(*widget.Form).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//disable: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-widget-form//disabled": {
		Doc:   "(*widget.Form).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//disabled: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-form//enable": {
		Doc:   "(*widget.Form).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//enable: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-widget-form//extend-base-widget": {
		Doc:   "(*widget.Form).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//extend-base-widget: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-form//hidden!": {
		Doc:   "Set *widget.Form Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//hidden!: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-form//hidden?": {
		Doc:   "Get *widget.Form Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//hidden?: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-form//hide": {
		Doc:   "(*widget.Form).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//hide: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-form//items!": {
		Doc:   "Set *widget.Form Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//items!: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.FormItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.FormItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-form//items!: arg 2: block item: expected native of type *widget.FormItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-form//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-form//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//items!: arg 2: expected native of type []*widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-form//items?": {
		Doc:   "Get *widget.Form Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//items?: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-widget-form-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-form//min-size": {
		Doc:   "(*widget.Form).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//min-size: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-form//move": {
		Doc:   "(*widget.Form).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//move: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-form//on-cancel!": {
		Doc:   "Set *widget.Form OnCancel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-cancel!: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-cancel!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//on-cancel!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-cancel!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnCancel = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-cancel!: arg 2: expected integer to be 0 or nil")
				}
				self.OnCancel = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//on-cancel!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-form//on-cancel?": {
		Doc:   "Get *widget.Form OnCancel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-cancel?: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-cancel?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//on-cancel?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCancel, "func()")
			return resObj
		},
	},
	"ptr-widget-form//on-submit!": {
		Doc:   "Set *widget.Form OnSubmit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-submit!: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-submit!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//on-submit!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-submit!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnSubmit = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-submit!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSubmit = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//on-submit!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-form//on-submit?": {
		Doc:   "Get *widget.Form OnSubmit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-submit?: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//on-submit?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//on-submit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmit, "func()")
			return resObj
		},
	},
	"ptr-widget-form//position": {
		Doc:   "(*widget.Form).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//position: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-form//refresh": {
		Doc:   "(*widget.Form).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//refresh: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-form//resize": {
		Doc:   "(*widget.Form).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//resize: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-form//set-on-validation-changed": {
		Doc:   "(*widget.Form).SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//set-on-validation-changed: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//set-on-validation-changed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//set-on-validation-changed: arg 1: expected native")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//set-on-validation-changed: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//set-on-validation-changed: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//set-on-validation-changed: arg 2: expected function or nil")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"ptr-widget-form//show": {
		Doc:   "(*widget.Form).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//show: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-form//size": {
		Doc:   "(*widget.Form).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//size: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-form//submit-text!": {
		Doc:   "Set *widget.Form SubmitText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//submit-text!: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//submit-text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//submit-text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.SubmitText = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//submit-text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-form//submit-text?": {
		Doc:   "Get *widget.Form SubmitText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//submit-text?: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//submit-text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//submit-text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.SubmitText)
			return resObj
		},
	},
	"ptr-widget-form//validate": {
		Doc:   "(*widget.Form).Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//validate: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//validate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//validate: arg 1: expected native")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-widget-form//visible": {
		Doc:   "(*widget.Form).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//visible: arg 1: expected native of type *widget.Form")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-form//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-form//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-grid-wrap//create-item!": {
		Doc:   "Set *widget.GridWrap CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//create-item!: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//create-item!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//create-item!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//create-item!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//create-item!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//create-item!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-grid-wrap//create-item?": {
		Doc:   "Get *widget.GridWrap CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//create-item?: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//create-item?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//create-item?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "func()_(fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-grid-wrap//create-renderer": {
		Doc:   "(*widget.GridWrap).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//create-renderer: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-grid-wrap//extend-base-widget": {
		Doc:   "(*widget.GridWrap).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//extend-base-widget: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//focus-gained": {
		Doc:   "(*widget.GridWrap).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//focus-gained: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-grid-wrap//focus-lost": {
		Doc:   "(*widget.GridWrap).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//focus-lost: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-grid-wrap//get-scroll-offset": {
		Doc:   "(*widget.GridWrap).GetScrollOffset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//get-scroll-offset: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//get-scroll-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//get-scroll-offset: arg 1: expected native")
			}
			res0 := arg0Val.GetScrollOffset()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-widget-grid-wrap//hidden!": {
		Doc:   "Set *widget.GridWrap Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//hidden!: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-grid-wrap//hidden?": {
		Doc:   "Get *widget.GridWrap Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//hidden?: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-grid-wrap//hide": {
		Doc:   "(*widget.GridWrap).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//hide: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-grid-wrap//length!": {
		Doc:   "Set *widget.GridWrap Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//length!: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//length!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//length!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//length!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//length!: arg 2: expected integer to be 0 or nil")
				}
				self.Length = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//length!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-grid-wrap//length?": {
		Doc:   "Get *widget.GridWrap Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//length?: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//length?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//length?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int)")
			return resObj
		},
	},
	"ptr-widget-grid-wrap//min-size": {
		Doc:   "(*widget.GridWrap).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//min-size: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-grid-wrap//move": {
		Doc:   "(*widget.GridWrap).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//move: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//on-selected!": {
		Doc:   "Set *widget.GridWrap OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-selected!: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-grid-wrap//on-selected?": {
		Doc:   "Get *widget.GridWrap OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-selected?: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(widget-grid-wrap-item-id)")
			return resObj
		},
	},
	"ptr-widget-grid-wrap//on-unselected!": {
		Doc:   "Set *widget.GridWrap OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-unselected!: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-unselected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-grid-wrap//on-unselected?": {
		Doc:   "Get *widget.GridWrap OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-unselected?: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//on-unselected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(widget-grid-wrap-item-id)")
			return resObj
		},
	},
	"ptr-widget-grid-wrap//position": {
		Doc:   "(*widget.GridWrap).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//position: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-grid-wrap//refresh": {
		Doc:   "(*widget.GridWrap).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//refresh: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-grid-wrap//refresh-item": {
		Doc:   "(*widget.GridWrap).RefreshItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//refresh-item: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//refresh-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//refresh-item: arg 1: expected native")
			}
			var arg1Val widget.GridWrapItemID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.GridWrapItemID
				if natOk {
					natVal, natValOk = nat.Value.(widget.GridWrapItemID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-grid-wrap//refresh-item: arg 2: expected integer")
					}
					arg1Val = widget.GridWrapItemID(u)
				}
			}
			arg0Val.RefreshItem(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//resize": {
		Doc:   "(*widget.GridWrap).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//resize: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//scroll-to": {
		Doc:   "(*widget.GridWrap).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//scroll-to: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//scroll-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//scroll-to: arg 1: expected native")
			}
			var arg1Val widget.GridWrapItemID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.GridWrapItemID
				if natOk {
					natVal, natValOk = nat.Value.(widget.GridWrapItemID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-grid-wrap//scroll-to: arg 2: expected integer")
					}
					arg1Val = widget.GridWrapItemID(u)
				}
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//scroll-to-bottom": {
		Doc:   "(*widget.GridWrap).ScrollToBottom",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//scroll-to-bottom: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//scroll-to-bottom: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//scroll-to-bottom: arg 1: expected native")
			}
			arg0Val.ScrollToBottom()
			return arg0
		},
	},
	"ptr-widget-grid-wrap//scroll-to-offset": {
		Doc:   "(*widget.GridWrap).ScrollToOffset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//scroll-to-offset: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//scroll-to-offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//scroll-to-offset: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//scroll-to-offset: arg 2: expected decimal")
			}
			arg0Val.ScrollToOffset(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//scroll-to-top": {
		Doc:   "(*widget.GridWrap).ScrollToTop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//scroll-to-top: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//scroll-to-top: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//scroll-to-top: arg 1: expected native")
			}
			arg0Val.ScrollToTop()
			return arg0
		},
	},
	"ptr-widget-grid-wrap//select": {
		Doc:   "(*widget.GridWrap).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//select: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//select: arg 1: expected native")
			}
			var arg1Val widget.GridWrapItemID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.GridWrapItemID
				if natOk {
					natVal, natValOk = nat.Value.(widget.GridWrapItemID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-grid-wrap//select: arg 2: expected integer")
					}
					arg1Val = widget.GridWrapItemID(u)
				}
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//show": {
		Doc:   "(*widget.GridWrap).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//show: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-grid-wrap//size": {
		Doc:   "(*widget.GridWrap).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//size: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-grid-wrap//typed-key": {
		Doc:   "(*widget.GridWrap).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//typed-key: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//typed-rune": {
		Doc:   "(*widget.GridWrap).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//typed-rune: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//unselect": {
		Doc:   "(*widget.GridWrap).Unselect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//unselect: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//unselect: arg 1: expected native")
			}
			var arg1Val widget.GridWrapItemID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.GridWrapItemID
				if natOk {
					natVal, natValOk = nat.Value.(widget.GridWrapItemID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-grid-wrap//unselect: arg 2: expected integer")
					}
					arg1Val = widget.GridWrapItemID(u)
				}
			}
			arg0Val.Unselect(arg1Val)
			return arg0
		},
	},
	"ptr-widget-grid-wrap//unselect-all": {
		Doc:   "(*widget.GridWrap).UnselectAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//unselect-all: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//unselect-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//unselect-all: arg 1: expected native")
			}
			arg0Val.UnselectAll()
			return arg0
		},
	},
	"ptr-widget-grid-wrap//update-item!": {
		Doc:   "Set *widget.GridWrap UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//update-item!: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//update-item!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//update-item!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//update-item!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.UpdateItem = func(arg0 widget.GridWrapItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//update-item!: arg 2: expected integer to be 0 or nil")
				}
				self.UpdateItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//update-item!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-grid-wrap//update-item?": {
		Doc:   "Get *widget.GridWrap UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//update-item?: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//update-item?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//update-item?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "func(widget-grid-wrap-item-id_fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-grid-wrap//visible": {
		Doc:   "(*widget.GridWrap).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//visible: arg 1: expected native of type *widget.GridWrap")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-grid-wrap//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-grid-wrap//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-hyperlink-segment//alignment!": {
		Doc:   "Set *widget.HyperlinkSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//alignment!: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-hyperlink-segment//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink-segment//alignment?": {
		Doc:   "Get *widget.HyperlinkSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//alignment?: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"ptr-widget-hyperlink-segment//inline": {
		Doc:   "(*widget.HyperlinkSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//inline: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//inline: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//inline: arg 1: expected native")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-hyperlink-segment//on-tapped!": {
		Doc:   "Set *widget.HyperlinkSegment OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//on-tapped!: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//on-tapped!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//on-tapped!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//on-tapped!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//on-tapped!: arg 2: expected integer to be 0 or nil")
				}
				self.OnTapped = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//on-tapped!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink-segment//on-tapped?": {
		Doc:   "Get *widget.HyperlinkSegment OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//on-tapped?: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//on-tapped?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//on-tapped?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"ptr-widget-hyperlink-segment//select": {
		Doc:   "(*widget.HyperlinkSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//select: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//select: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//select: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//select: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//select: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//select: arg 3: expected native")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink-segment//selected-text": {
		Doc:   "(*widget.HyperlinkSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//selected-text: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-hyperlink-segment//text!": {
		Doc:   "Set *widget.HyperlinkSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//text!: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink-segment//text?": {
		Doc:   "Get *widget.HyperlinkSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//text?: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-widget-hyperlink-segment//textual": {
		Doc:   "(*widget.HyperlinkSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//textual: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//textual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//textual: arg 1: expected native")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-hyperlink-segment//unselect": {
		Doc:   "(*widget.HyperlinkSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//unselect: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//unselect: arg 1: expected native")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-widget-hyperlink-segment//update": {
		Doc:   "(*widget.HyperlinkSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//update: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//update: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//update: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//update: arg 2: expected native")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink-segment//url!": {
		Doc:   "Set *widget.HyperlinkSegment URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//url!: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//url!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//url!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//url!: arg 2: expected native of type *url.URL")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//url!: arg 2: expected integer to be 0 or nil")
				}
				self.URL = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//url!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink-segment//url?": {
		Doc:   "Get *widget.HyperlinkSegment URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//url?: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//url?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//url?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "ptr-url-url")
			return resObj
		},
	},
	"ptr-widget-hyperlink-segment//visual": {
		Doc:   "(*widget.HyperlinkSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//visual: arg 1: expected native of type *widget.HyperlinkSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink-segment//visual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink-segment//visual: arg 1: expected native")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-hyperlink//alignment!": {
		Doc:   "Set *widget.Hyperlink Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//alignment!: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-hyperlink//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink//alignment?": {
		Doc:   "Get *widget.Hyperlink Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//alignment?: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"ptr-widget-hyperlink//create-renderer": {
		Doc:   "(*widget.Hyperlink).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//create-renderer: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-hyperlink//cursor": {
		Doc:   "(*widget.Hyperlink).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//cursor: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//cursor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//cursor: arg 1: expected native")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-hyperlink//extend-base-widget": {
		Doc:   "(*widget.Hyperlink).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//extend-base-widget: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//focus-gained": {
		Doc:   "(*widget.Hyperlink).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//focus-gained: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-hyperlink//focus-lost": {
		Doc:   "(*widget.Hyperlink).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//focus-lost: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-hyperlink//hidden!": {
		Doc:   "Set *widget.Hyperlink Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//hidden!: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink//hidden?": {
		Doc:   "Get *widget.Hyperlink Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//hidden?: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-hyperlink//hide": {
		Doc:   "(*widget.Hyperlink).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//hide: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-hyperlink//min-size": {
		Doc:   "(*widget.Hyperlink).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//min-size: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-hyperlink//mouse-in": {
		Doc:   "(*widget.Hyperlink).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-in: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-in: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//mouse-in: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-in: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-in: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//mouse-in: arg 2: expected native")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//mouse-moved": {
		Doc:   "(*widget.Hyperlink).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-moved: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-moved: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//mouse-moved: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-moved: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-moved: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//mouse-moved: arg 2: expected native")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//mouse-out": {
		Doc:   "(*widget.Hyperlink).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-out: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//mouse-out: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//mouse-out: arg 1: expected native")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-widget-hyperlink//move": {
		Doc:   "(*widget.Hyperlink).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//move: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//on-tapped!": {
		Doc:   "Set *widget.Hyperlink OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//on-tapped!: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//on-tapped!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//on-tapped!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//on-tapped!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//on-tapped!: arg 2: expected integer to be 0 or nil")
				}
				self.OnTapped = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//on-tapped!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink//on-tapped?": {
		Doc:   "Get *widget.Hyperlink OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//on-tapped?: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//on-tapped?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//on-tapped?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"ptr-widget-hyperlink//position": {
		Doc:   "(*widget.Hyperlink).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//position: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-hyperlink//refresh": {
		Doc:   "(*widget.Hyperlink).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//refresh: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-hyperlink//resize": {
		Doc:   "(*widget.Hyperlink).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//resize: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//set-text": {
		Doc:   "(*widget.Hyperlink).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//set-text: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//set-url": {
		Doc:   "(*widget.Hyperlink).SetURL",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//set-url: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//set-url: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//set-url: arg 1: expected native")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//set-url: arg 2: expected native of type *url.URL")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//set-url: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//set-url: arg 2: expected native")
			}
			arg0Val.SetURL(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//set-url-from-string": {
		Doc:   "(*widget.Hyperlink).SetURLFromString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//set-url-from-string: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//set-url-from-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//set-url-from-string: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//set-url-from-string: arg 2: expected string")
			}
			res0 := arg0Val.SetURLFromString(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-widget-hyperlink//show": {
		Doc:   "(*widget.Hyperlink).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//show: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-hyperlink//size": {
		Doc:   "(*widget.Hyperlink).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//size: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-hyperlink//tapped": {
		Doc:   "(*widget.Hyperlink).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//tapped: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//text!": {
		Doc:   "Set *widget.Hyperlink Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//text!: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink//text-style!": {
		Doc:   "Set *widget.Hyperlink TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//text-style!: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//text-style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink//text-style?": {
		Doc:   "Get *widget.Hyperlink TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//text-style?: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//text-style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"ptr-widget-hyperlink//text?": {
		Doc:   "Get *widget.Hyperlink Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//text?: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-widget-hyperlink//typed-key": {
		Doc:   "(*widget.Hyperlink).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//typed-key: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//typed-rune": {
		Doc:   "(*widget.Hyperlink).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//typed-rune: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-hyperlink//url!": {
		Doc:   "Set *widget.Hyperlink URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//url!: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//url!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//url!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//url!: arg 2: expected native of type *url.URL")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//url!: arg 2: expected integer to be 0 or nil")
				}
				self.URL = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//url!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink//url?": {
		Doc:   "Get *widget.Hyperlink URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//url?: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//url?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//url?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "ptr-url-url")
			return resObj
		},
	},
	"ptr-widget-hyperlink//visible": {
		Doc:   "(*widget.Hyperlink).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//visible: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-hyperlink//wrapping!": {
		Doc:   "Set *widget.Hyperlink Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//wrapping!: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//wrapping!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-hyperlink//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-hyperlink//wrapping?": {
		Doc:   "Get *widget.Hyperlink Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//wrapping?: arg 1: expected native of type *widget.Hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-hyperlink//wrapping?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-hyperlink//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"ptr-widget-icon//create-renderer": {
		Doc:   "(*widget.Icon).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//create-renderer: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-icon//extend-base-widget": {
		Doc:   "(*widget.Icon).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//extend-base-widget: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-icon//hidden!": {
		Doc:   "Set *widget.Icon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//hidden!: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-icon//hidden?": {
		Doc:   "Get *widget.Icon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//hidden?: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-icon//hide": {
		Doc:   "(*widget.Icon).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//hide: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-icon//min-size": {
		Doc:   "(*widget.Icon).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//min-size: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-icon//move": {
		Doc:   "(*widget.Icon).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//move: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-icon//position": {
		Doc:   "(*widget.Icon).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//position: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-icon//refresh": {
		Doc:   "(*widget.Icon).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//refresh: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-icon//resize": {
		Doc:   "(*widget.Icon).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//resize: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-icon//resource!": {
		Doc:   "Set *widget.Icon Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//resource!: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//resource!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//resource!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//resource!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//resource!: arg 2: expected integer to be 0 or nil")
				}
				self.Resource = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//resource!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-icon//resource?": {
		Doc:   "Get *widget.Icon Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//resource?: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//resource?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//resource?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Resource)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Resource, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Resource, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"ptr-widget-icon//set-resource": {
		Doc:   "(*widget.Icon).SetResource",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//set-resource: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//set-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//set-resource: arg 1: expected native")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//set-resource: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//set-resource: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//set-resource: arg 2: expected native")
			}
			arg0Val.SetResource(arg1Val)
			return arg0
		},
	},
	"ptr-widget-icon//show": {
		Doc:   "(*widget.Icon).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//show: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-icon//size": {
		Doc:   "(*widget.Icon).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//size: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-icon//visible": {
		Doc:   "(*widget.Icon).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//visible: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-icon//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-icon//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-image-segment//alignment!": {
		Doc:   "Set *widget.ImageSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//alignment!: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-image-segment//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-image-segment//alignment?": {
		Doc:   "Get *widget.ImageSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//alignment?: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"ptr-widget-image-segment//inline": {
		Doc:   "(*widget.ImageSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//inline: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//inline: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//inline: arg 1: expected native")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-image-segment//select": {
		Doc:   "(*widget.ImageSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//select: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//select: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//select: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//select: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//select: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//select: arg 3: expected native")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-image-segment//selected-text": {
		Doc:   "(*widget.ImageSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//selected-text: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-image-segment//source!": {
		Doc:   "Set *widget.ImageSegment Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//source!: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//source!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//source!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//source!: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//source!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-image-segment//source?": {
		Doc:   "Get *widget.ImageSegment Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//source?: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//source?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "fyne-uri")
			return resObj
		},
	},
	"ptr-widget-image-segment//textual": {
		Doc:   "(*widget.ImageSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//textual: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//textual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//textual: arg 1: expected native")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-image-segment//title!": {
		Doc:   "Set *widget.ImageSegment Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//title!: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//title!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//title!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//title!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-image-segment//title?": {
		Doc:   "Get *widget.ImageSegment Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//title?: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//title?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"ptr-widget-image-segment//unselect": {
		Doc:   "(*widget.ImageSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//unselect: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//unselect: arg 1: expected native")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-widget-image-segment//update": {
		Doc:   "(*widget.ImageSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//update: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//update: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//update: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//update: arg 2: expected native")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-widget-image-segment//visual": {
		Doc:   "(*widget.ImageSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//visual: arg 1: expected native of type *widget.ImageSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-image-segment//visual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-image-segment//visual: arg 1: expected native")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-label//alignment!": {
		Doc:   "Set *widget.Label Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//alignment!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-label//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-label//alignment?": {
		Doc:   "Get *widget.Label Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//alignment?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"ptr-widget-label//bind": {
		Doc:   "(*widget.Label).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//bind: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//bind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//bind: arg 1: expected native")
			}
			var arg1Val binding.String
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//bind: arg 2: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//bind: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//bind: arg 2: expected native")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-widget-label//create-renderer": {
		Doc:   "(*widget.Label).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//create-renderer: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-label//extend-base-widget": {
		Doc:   "(*widget.Label).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//extend-base-widget: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-label//hidden!": {
		Doc:   "Set *widget.Label Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//hidden!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-label//hidden?": {
		Doc:   "Get *widget.Label Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//hidden?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-label//hide": {
		Doc:   "(*widget.Label).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//hide: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-label//importance!": {
		Doc:   "Set *widget.Label Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//importance!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//importance!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//importance!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.Importance
				if natOk {
					natVal, natValOk = nat.Value.(widget.Importance)
				}
				if natOk && natValOk {
					self.Importance = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-label//importance!: arg 2: expected integer")
					}
					self.Importance = widget.Importance(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-label//importance?": {
		Doc:   "Get *widget.Label Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//importance?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//importance?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//importance?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Importance)))
			return resObj
		},
	},
	"ptr-widget-label//min-size": {
		Doc:   "(*widget.Label).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//min-size: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-label//move": {
		Doc:   "(*widget.Label).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//move: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-label//position": {
		Doc:   "(*widget.Label).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//position: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-label//refresh": {
		Doc:   "(*widget.Label).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//refresh: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-label//resize": {
		Doc:   "(*widget.Label).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//resize: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-label//set-text": {
		Doc:   "(*widget.Label).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//set-text: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-widget-label//show": {
		Doc:   "(*widget.Label).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//show: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-label//size": {
		Doc:   "(*widget.Label).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//size: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-label//text!": {
		Doc:   "Set *widget.Label Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//text!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-label//text-style!": {
		Doc:   "Set *widget.Label TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//text-style!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//text-style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-label//text-style?": {
		Doc:   "Get *widget.Label TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//text-style?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//text-style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"ptr-widget-label//text?": {
		Doc:   "Get *widget.Label Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//text?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-widget-label//truncation!": {
		Doc:   "Set *widget.Label Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//truncation!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//truncation!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//truncation!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextTruncation
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextTruncation)
				}
				if natOk && natValOk {
					self.Truncation = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-label//truncation!: arg 2: expected integer")
					}
					self.Truncation = fyne.TextTruncation(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-label//truncation?": {
		Doc:   "Get *widget.Label Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//truncation?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//truncation?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//truncation?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Truncation)))
			return resObj
		},
	},
	"ptr-widget-label//unbind": {
		Doc:   "(*widget.Label).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//unbind: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//unbind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//unbind: arg 1: expected native")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-widget-label//visible": {
		Doc:   "(*widget.Label).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//visible: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-label//wrapping!": {
		Doc:   "Set *widget.Label Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//wrapping!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//wrapping!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-label//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-label//wrapping?": {
		Doc:   "Get *widget.Label Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//wrapping?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-label//wrapping?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-label//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"ptr-widget-list-segment//inline": {
		Doc:   "(*widget.ListSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//inline: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//inline: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//inline: arg 1: expected native")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-list-segment//items!": {
		Doc:   "Set *widget.ListSegment Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//items!: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-list-segment//items!: arg 2: block item: expected native of type widget.RichTextSegment")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-list-segment//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-list-segment//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//items!: arg 2: expected native of type []widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-list-segment//items?": {
		Doc:   "Get *widget.ListSegment Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//items?: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-rich-text-segment")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-list-segment//ordered!": {
		Doc:   "Set *widget.ListSegment Ordered value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//ordered!: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//ordered!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//ordered!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Ordered = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//ordered!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-list-segment//ordered?": {
		Doc:   "Get *widget.ListSegment Ordered value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//ordered?: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//ordered?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//ordered?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Ordered))
			return resObj
		},
	},
	"ptr-widget-list-segment//segments": {
		Doc:   "(*widget.ListSegment).Segments",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//segments: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//segments: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//segments: arg 1: expected native")
			}
			res0 := arg0Val.Segments()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-rich-text-segment")
						}
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-widget-list-segment//select": {
		Doc:   "(*widget.ListSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//select: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//select: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//select: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//select: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//select: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//select: arg 3: expected native")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-list-segment//selected-text": {
		Doc:   "(*widget.ListSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//selected-text: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-list-segment//textual": {
		Doc:   "(*widget.ListSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//textual: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//textual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//textual: arg 1: expected native")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-list-segment//unselect": {
		Doc:   "(*widget.ListSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//unselect: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//unselect: arg 1: expected native")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-widget-list-segment//update": {
		Doc:   "(*widget.ListSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//update: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//update: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//update: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//update: arg 2: expected native")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list-segment//visual": {
		Doc:   "(*widget.ListSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//visual: arg 1: expected native of type *widget.ListSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list-segment//visual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list-segment//visual: arg 1: expected native")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-list//create-item!": {
		Doc:   "Set *widget.List CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//create-item!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//create-item!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//create-item!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//create-item!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//create-item!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//create-item!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-list//create-item?": {
		Doc:   "Get *widget.List CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//create-item?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//create-item?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//create-item?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "func()_(fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-list//create-renderer": {
		Doc:   "(*widget.List).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//create-renderer: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-list//extend-base-widget": {
		Doc:   "(*widget.List).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//extend-base-widget: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list//focus-gained": {
		Doc:   "(*widget.List).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//focus-gained: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-list//focus-lost": {
		Doc:   "(*widget.List).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//focus-lost: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-list//hidden!": {
		Doc:   "Set *widget.List Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//hidden!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-list//hidden?": {
		Doc:   "Get *widget.List Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//hidden?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-list//hide": {
		Doc:   "(*widget.List).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//hide: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-list//length!": {
		Doc:   "Set *widget.List Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//length!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//length!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//length!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//length!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//length!: arg 2: expected integer to be 0 or nil")
				}
				self.Length = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//length!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-list//length?": {
		Doc:   "Get *widget.List Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//length?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//length?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//length?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int)")
			return resObj
		},
	},
	"ptr-widget-list//min-size": {
		Doc:   "(*widget.List).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//min-size: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-list//move": {
		Doc:   "(*widget.List).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//move: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list//on-selected!": {
		Doc:   "Set *widget.List OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-selected!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 widget.ListItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-list//on-selected?": {
		Doc:   "Get *widget.List OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-selected?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(widget-list-item-id)")
			return resObj
		},
	},
	"ptr-widget-list//on-unselected!": {
		Doc:   "Set *widget.List OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-unselected!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-unselected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 widget.ListItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-list//on-unselected?": {
		Doc:   "Get *widget.List OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-unselected?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//on-unselected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(widget-list-item-id)")
			return resObj
		},
	},
	"ptr-widget-list//position": {
		Doc:   "(*widget.List).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//position: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-list//refresh": {
		Doc:   "(*widget.List).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//refresh: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-list//refresh-item": {
		Doc:   "(*widget.List).RefreshItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//refresh-item: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//refresh-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//refresh-item: arg 1: expected native")
			}
			var arg1Val widget.ListItemID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.ListItemID
				if natOk {
					natVal, natValOk = nat.Value.(widget.ListItemID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-list//refresh-item: arg 2: expected integer")
					}
					arg1Val = widget.ListItemID(u)
				}
			}
			arg0Val.RefreshItem(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list//resize": {
		Doc:   "(*widget.List).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//resize: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list//scroll-to": {
		Doc:   "(*widget.List).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//scroll-to: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//scroll-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//scroll-to: arg 1: expected native")
			}
			var arg1Val widget.ListItemID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.ListItemID
				if natOk {
					natVal, natValOk = nat.Value.(widget.ListItemID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-list//scroll-to: arg 2: expected integer")
					}
					arg1Val = widget.ListItemID(u)
				}
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list//scroll-to-bottom": {
		Doc:   "(*widget.List).ScrollToBottom",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//scroll-to-bottom: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//scroll-to-bottom: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//scroll-to-bottom: arg 1: expected native")
			}
			arg0Val.ScrollToBottom()
			return arg0
		},
	},
	"ptr-widget-list//scroll-to-top": {
		Doc:   "(*widget.List).ScrollToTop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//scroll-to-top: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//scroll-to-top: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//scroll-to-top: arg 1: expected native")
			}
			arg0Val.ScrollToTop()
			return arg0
		},
	},
	"ptr-widget-list//select": {
		Doc:   "(*widget.List).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//select: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//select: arg 1: expected native")
			}
			var arg1Val widget.ListItemID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.ListItemID
				if natOk {
					natVal, natValOk = nat.Value.(widget.ListItemID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-list//select: arg 2: expected integer")
					}
					arg1Val = widget.ListItemID(u)
				}
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list//set-item-height": {
		Doc:   "(*widget.List).SetItemHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//set-item-height: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//set-item-height: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//set-item-height: arg 1: expected native")
			}
			var arg1Val widget.ListItemID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.ListItemID
				if natOk {
					natVal, natValOk = nat.Value.(widget.ListItemID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-list//set-item-height: arg 2: expected integer")
					}
					arg1Val = widget.ListItemID(u)
				}
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//set-item-height: arg 3: expected decimal")
			}
			arg0Val.SetItemHeight(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-list//show": {
		Doc:   "(*widget.List).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//show: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-list//size": {
		Doc:   "(*widget.List).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//size: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-list//typed-key": {
		Doc:   "(*widget.List).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//typed-key: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list//typed-rune": {
		Doc:   "(*widget.List).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//typed-rune: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list//unselect": {
		Doc:   "(*widget.List).Unselect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//unselect: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//unselect: arg 1: expected native")
			}
			var arg1Val widget.ListItemID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.ListItemID
				if natOk {
					natVal, natValOk = nat.Value.(widget.ListItemID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-list//unselect: arg 2: expected integer")
					}
					arg1Val = widget.ListItemID(u)
				}
			}
			arg0Val.Unselect(arg1Val)
			return arg0
		},
	},
	"ptr-widget-list//unselect-all": {
		Doc:   "(*widget.List).UnselectAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//unselect-all: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//unselect-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//unselect-all: arg 1: expected native")
			}
			arg0Val.UnselectAll()
			return arg0
		},
	},
	"ptr-widget-list//update-item!": {
		Doc:   "Set *widget.List UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//update-item!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//update-item!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//update-item!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//update-item!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.UpdateItem = func(arg0 widget.ListItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//update-item!: arg 2: expected integer to be 0 or nil")
				}
				self.UpdateItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//update-item!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-list//update-item?": {
		Doc:   "Get *widget.List UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//update-item?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//update-item?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//update-item?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "func(widget-list-item-id_fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-list//visible": {
		Doc:   "(*widget.List).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//visible: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-list//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-list//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-menu//activate-last-submenu": {
		Doc:   "(*widget.Menu).ActivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//activate-last-submenu: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//activate-last-submenu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//activate-last-submenu: arg 1: expected native")
			}
			res0 := arg0Val.ActivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-menu//activate-next": {
		Doc:   "(*widget.Menu).ActivateNext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//activate-next: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//activate-next: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//activate-next: arg 1: expected native")
			}
			arg0Val.ActivateNext()
			return arg0
		},
	},
	"ptr-widget-menu//activate-previous": {
		Doc:   "(*widget.Menu).ActivatePrevious",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//activate-previous: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//activate-previous: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//activate-previous: arg 1: expected native")
			}
			arg0Val.ActivatePrevious()
			return arg0
		},
	},
	"ptr-widget-menu//create-renderer": {
		Doc:   "(*widget.Menu).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//create-renderer: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-menu//deactivate-child": {
		Doc:   "(*widget.Menu).DeactivateChild",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//deactivate-child: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//deactivate-child: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//deactivate-child: arg 1: expected native")
			}
			arg0Val.DeactivateChild()
			return arg0
		},
	},
	"ptr-widget-menu//deactivate-last-submenu": {
		Doc:   "(*widget.Menu).DeactivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//deactivate-last-submenu: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//deactivate-last-submenu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//deactivate-last-submenu: arg 1: expected native")
			}
			res0 := arg0Val.DeactivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-menu//dismiss": {
		Doc:   "(*widget.Menu).Dismiss",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//dismiss: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//dismiss: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//dismiss: arg 1: expected native")
			}
			arg0Val.Dismiss()
			return arg0
		},
	},
	"ptr-widget-menu//extend-base-widget": {
		Doc:   "(*widget.Menu).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//extend-base-widget: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-menu//hidden!": {
		Doc:   "Set *widget.Menu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//hidden!: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-menu//hidden?": {
		Doc:   "Get *widget.Menu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//hidden?: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-menu//hide": {
		Doc:   "(*widget.Menu).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//hide: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-menu//items!": {
		Doc:   "Set *widget.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//items!: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-menu//items!: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-menu//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-menu//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//items!: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-menu//items?": {
		Doc:   "Get *widget.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//items?: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-canvas-object")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-menu//min-size": {
		Doc:   "(*widget.Menu).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//min-size: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-menu//move": {
		Doc:   "(*widget.Menu).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//move: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-menu//on-dismiss!": {
		Doc:   "Set *widget.Menu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//on-dismiss!: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//on-dismiss!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//on-dismiss!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//on-dismiss!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//on-dismiss!: arg 2: expected integer to be 0 or nil")
				}
				self.OnDismiss = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//on-dismiss!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-menu//on-dismiss?": {
		Doc:   "Get *widget.Menu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//on-dismiss?: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//on-dismiss?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//on-dismiss?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "func()")
			return resObj
		},
	},
	"ptr-widget-menu//position": {
		Doc:   "(*widget.Menu).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//position: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-menu//refresh": {
		Doc:   "(*widget.Menu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//refresh: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-menu//resize": {
		Doc:   "(*widget.Menu).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//resize: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-menu//show": {
		Doc:   "(*widget.Menu).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//show: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-menu//size": {
		Doc:   "(*widget.Menu).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//size: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-menu//tapped": {
		Doc:   "(*widget.Menu).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//tapped: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-menu//trigger-last": {
		Doc:   "(*widget.Menu).TriggerLast",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//trigger-last: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//trigger-last: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//trigger-last: arg 1: expected native")
			}
			arg0Val.TriggerLast()
			return arg0
		},
	},
	"ptr-widget-menu//visible": {
		Doc:   "(*widget.Menu).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//visible: arg 1: expected native of type *widget.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-menu//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-menu//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-paragraph-segment//inline": {
		Doc:   "(*widget.ParagraphSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//inline: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//inline: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//inline: arg 1: expected native")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-paragraph-segment//segments": {
		Doc:   "(*widget.ParagraphSegment).Segments",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//segments: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//segments: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//segments: arg 1: expected native")
			}
			res0 := arg0Val.Segments()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-rich-text-segment")
						}
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-widget-paragraph-segment//select": {
		Doc:   "(*widget.ParagraphSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//select: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//select: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//select: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//select: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//select: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//select: arg 3: expected native")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-paragraph-segment//selected-text": {
		Doc:   "(*widget.ParagraphSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//selected-text: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-paragraph-segment//texts!": {
		Doc:   "Set *widget.ParagraphSegment Texts value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//texts!: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//texts!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//texts!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Texts = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Texts[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-paragraph-segment//texts!: arg 2: block item: expected native of type widget.RichTextSegment")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-paragraph-segment//texts!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Texts[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-paragraph-segment//texts!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Texts, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//texts!: arg 2: expected native of type []widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//texts!: arg 2: expected integer to be 0 or nil")
				}
				self.Texts = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//texts!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-paragraph-segment//texts?": {
		Doc:   "Get *widget.ParagraphSegment Texts value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//texts?: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//texts?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//texts?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Texts))
				for i, it := range self.Texts {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-rich-text-segment")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-paragraph-segment//textual": {
		Doc:   "(*widget.ParagraphSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//textual: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//textual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//textual: arg 1: expected native")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-paragraph-segment//unselect": {
		Doc:   "(*widget.ParagraphSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//unselect: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//unselect: arg 1: expected native")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-widget-paragraph-segment//update": {
		Doc:   "(*widget.ParagraphSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//update: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//update: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//update: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//update: arg 2: expected native")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-widget-paragraph-segment//visual": {
		Doc:   "(*widget.ParagraphSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//visual: arg 1: expected native of type *widget.ParagraphSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-paragraph-segment//visual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-paragraph-segment//visual: arg 1: expected native")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-pop-up-menu//activate-last-submenu": {
		Doc:   "(*widget.PopUpMenu).ActivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//activate-last-submenu: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//activate-last-submenu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//activate-last-submenu: arg 1: expected native")
			}
			res0 := arg0Val.ActivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-pop-up-menu//activate-next": {
		Doc:   "(*widget.PopUpMenu).ActivateNext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//activate-next: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//activate-next: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//activate-next: arg 1: expected native")
			}
			arg0Val.ActivateNext()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//activate-previous": {
		Doc:   "(*widget.PopUpMenu).ActivatePrevious",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//activate-previous: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//activate-previous: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//activate-previous: arg 1: expected native")
			}
			arg0Val.ActivatePrevious()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//create-renderer": {
		Doc:   "(*widget.PopUpMenu).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//create-renderer: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-pop-up-menu//deactivate-child": {
		Doc:   "(*widget.PopUpMenu).DeactivateChild",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//deactivate-child: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//deactivate-child: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//deactivate-child: arg 1: expected native")
			}
			arg0Val.DeactivateChild()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//deactivate-last-submenu": {
		Doc:   "(*widget.PopUpMenu).DeactivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//deactivate-last-submenu: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//deactivate-last-submenu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//deactivate-last-submenu: arg 1: expected native")
			}
			res0 := arg0Val.DeactivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-pop-up-menu//dismiss": {
		Doc:   "(*widget.PopUpMenu).Dismiss",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//dismiss: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//dismiss: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//dismiss: arg 1: expected native")
			}
			arg0Val.Dismiss()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//extend-base-widget": {
		Doc:   "(*widget.PopUpMenu).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//extend-base-widget: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//focus-gained": {
		Doc:   "(*widget.PopUpMenu).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//focus-gained: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//focus-lost": {
		Doc:   "(*widget.PopUpMenu).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//focus-lost: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//hidden!": {
		Doc:   "Set *widget.PopUpMenu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//hidden!: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//hidden?": {
		Doc:   "Get *widget.PopUpMenu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//hidden?: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-pop-up-menu//hide": {
		Doc:   "(*widget.PopUpMenu).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//hide: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//items!": {
		Doc:   "Set *widget.PopUpMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//items!: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-pop-up-menu//items!: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-pop-up-menu//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-pop-up-menu//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//items!: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//items?": {
		Doc:   "Get *widget.PopUpMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//items?: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-canvas-object")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-pop-up-menu//min-size": {
		Doc:   "(*widget.PopUpMenu).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//min-size: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-pop-up-menu//move": {
		Doc:   "(*widget.PopUpMenu).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//move: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//on-dismiss!": {
		Doc:   "Set *widget.PopUpMenu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//on-dismiss!: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//on-dismiss!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//on-dismiss!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//on-dismiss!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//on-dismiss!: arg 2: expected integer to be 0 or nil")
				}
				self.OnDismiss = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//on-dismiss!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//on-dismiss?": {
		Doc:   "Get *widget.PopUpMenu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//on-dismiss?: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//on-dismiss?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//on-dismiss?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "func()")
			return resObj
		},
	},
	"ptr-widget-pop-up-menu//position": {
		Doc:   "(*widget.PopUpMenu).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//position: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-pop-up-menu//refresh": {
		Doc:   "(*widget.PopUpMenu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//refresh: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//resize": {
		Doc:   "(*widget.PopUpMenu).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//resize: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//show": {
		Doc:   "(*widget.PopUpMenu).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//show-at-position": {
		Doc:   "(*widget.PopUpMenu).ShowAtPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show-at-position: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show-at-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//show-at-position: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show-at-position: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//show-at-position: arg 2: expected native")
			}
			arg0Val.ShowAtPosition(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//show-at-relative-position": {
		Doc:   "(*widget.PopUpMenu).ShowAtRelativePosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show-at-relative-position: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show-at-relative-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//show-at-relative-position: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show-at-relative-position: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//show-at-relative-position: arg 2: expected native")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show-at-relative-position: arg 3: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//show-at-relative-position: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//show-at-relative-position: arg 3: expected native")
			}
			arg0Val.ShowAtRelativePosition(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//size": {
		Doc:   "(*widget.PopUpMenu).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//size: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-pop-up-menu//tapped": {
		Doc:   "(*widget.PopUpMenu).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//tapped: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//trigger-last": {
		Doc:   "(*widget.PopUpMenu).TriggerLast",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//trigger-last: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//trigger-last: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//trigger-last: arg 1: expected native")
			}
			arg0Val.TriggerLast()
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//typed-key": {
		Doc:   "(*widget.PopUpMenu).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//typed-key: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//typed-rune": {
		Doc:   "(*widget.PopUpMenu).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//typed-rune: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up-menu//visible": {
		Doc:   "(*widget.PopUpMenu).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//visible: arg 1: expected native of type *widget.PopUpMenu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up-menu//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up-menu//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-pop-up//canvas!": {
		Doc:   "Set *widget.PopUp Canvas value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//canvas!: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//canvas!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//canvas!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Canvas, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//canvas!: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//canvas!: arg 2: expected integer to be 0 or nil")
				}
				self.Canvas = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//canvas!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-pop-up//canvas?": {
		Doc:   "Get *widget.PopUp Canvas value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//canvas?: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//canvas?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//canvas?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Canvas)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Canvas, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Canvas, "fyne-canvas")
				}
			}
			return resObj
		},
	},
	"ptr-widget-pop-up//content!": {
		Doc:   "Set *widget.PopUp Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//content!: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//content!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//content!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//content!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//content!: arg 2: expected integer to be 0 or nil")
				}
				self.Content = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//content!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-pop-up//content?": {
		Doc:   "Get *widget.PopUp Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//content?: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//content?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//content?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Content)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Content, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"ptr-widget-pop-up//create-renderer": {
		Doc:   "(*widget.PopUp).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//create-renderer: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-pop-up//extend-base-widget": {
		Doc:   "(*widget.PopUp).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//extend-base-widget: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up//hidden!": {
		Doc:   "Set *widget.PopUp Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//hidden!: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-pop-up//hidden?": {
		Doc:   "Get *widget.PopUp Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//hidden?: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-pop-up//hide": {
		Doc:   "(*widget.PopUp).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//hide: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-pop-up//min-size": {
		Doc:   "(*widget.PopUp).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//min-size: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-pop-up//move": {
		Doc:   "(*widget.PopUp).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//move: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up//position": {
		Doc:   "(*widget.PopUp).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//position: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-pop-up//refresh": {
		Doc:   "(*widget.PopUp).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//refresh: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-pop-up//resize": {
		Doc:   "(*widget.PopUp).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//resize: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up//show": {
		Doc:   "(*widget.PopUp).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-pop-up//show-at-position": {
		Doc:   "(*widget.PopUp).ShowAtPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show-at-position: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show-at-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//show-at-position: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show-at-position: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//show-at-position: arg 2: expected native")
			}
			arg0Val.ShowAtPosition(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up//show-at-relative-position": {
		Doc:   "(*widget.PopUp).ShowAtRelativePosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show-at-relative-position: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show-at-relative-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//show-at-relative-position: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show-at-relative-position: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//show-at-relative-position: arg 2: expected native")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show-at-relative-position: arg 3: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//show-at-relative-position: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//show-at-relative-position: arg 3: expected native")
			}
			arg0Val.ShowAtRelativePosition(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-pop-up//size": {
		Doc:   "(*widget.PopUp).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//size: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-pop-up//tapped": {
		Doc:   "(*widget.PopUp).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//tapped: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up//tapped-secondary": {
		Doc:   "(*widget.PopUp).TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//tapped-secondary: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//tapped-secondary: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//tapped-secondary: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//tapped-secondary: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//tapped-secondary: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//tapped-secondary: arg 2: expected native")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"ptr-widget-pop-up//visible": {
		Doc:   "(*widget.PopUp).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//visible: arg 1: expected native of type *widget.PopUp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-pop-up//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-pop-up//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-progress-bar-infinite//create-renderer": {
		Doc:   "(*widget.ProgressBarInfinite).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//create-renderer: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-progress-bar-infinite//extend-base-widget": {
		Doc:   "(*widget.ProgressBarInfinite).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//extend-base-widget: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-progress-bar-infinite//hidden!": {
		Doc:   "Set *widget.ProgressBarInfinite Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//hidden!: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-progress-bar-infinite//hidden?": {
		Doc:   "Get *widget.ProgressBarInfinite Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//hidden?: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-progress-bar-infinite//hide": {
		Doc:   "(*widget.ProgressBarInfinite).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//hide: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-progress-bar-infinite//min-size": {
		Doc:   "(*widget.ProgressBarInfinite).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//min-size: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-progress-bar-infinite//move": {
		Doc:   "(*widget.ProgressBarInfinite).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//move: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-progress-bar-infinite//position": {
		Doc:   "(*widget.ProgressBarInfinite).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//position: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-progress-bar-infinite//refresh": {
		Doc:   "(*widget.ProgressBarInfinite).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//refresh: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-progress-bar-infinite//resize": {
		Doc:   "(*widget.ProgressBarInfinite).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//resize: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-progress-bar-infinite//running": {
		Doc:   "(*widget.ProgressBarInfinite).Running",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//running: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//running: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//running: arg 1: expected native")
			}
			res0 := arg0Val.Running()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-progress-bar-infinite//show": {
		Doc:   "(*widget.ProgressBarInfinite).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//show: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-progress-bar-infinite//size": {
		Doc:   "(*widget.ProgressBarInfinite).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//size: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-progress-bar-infinite//start": {
		Doc:   "(*widget.ProgressBarInfinite).Start",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//start: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//start: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//start: arg 1: expected native")
			}
			arg0Val.Start()
			return arg0
		},
	},
	"ptr-widget-progress-bar-infinite//stop": {
		Doc:   "(*widget.ProgressBarInfinite).Stop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//stop: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//stop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//stop: arg 1: expected native")
			}
			arg0Val.Stop()
			return arg0
		},
	},
	"ptr-widget-progress-bar-infinite//visible": {
		Doc:   "(*widget.ProgressBarInfinite).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//visible: arg 1: expected native of type *widget.ProgressBarInfinite")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar-infinite//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar-infinite//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-progress-bar//bind": {
		Doc:   "(*widget.ProgressBar).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//bind: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//bind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//bind: arg 1: expected native")
			}
			var arg1Val binding.Float
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//bind: arg 2: expected native of type binding.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//bind: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//bind: arg 2: expected native")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-widget-progress-bar//create-renderer": {
		Doc:   "(*widget.ProgressBar).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//create-renderer: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-progress-bar//extend-base-widget": {
		Doc:   "(*widget.ProgressBar).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//extend-base-widget: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-progress-bar//hidden!": {
		Doc:   "Set *widget.ProgressBar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//hidden!: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-progress-bar//hidden?": {
		Doc:   "Get *widget.ProgressBar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//hidden?: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-progress-bar//hide": {
		Doc:   "(*widget.ProgressBar).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//hide: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-progress-bar//max!": {
		Doc:   "Set *widget.ProgressBar Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//max!: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//max!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//max!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//max!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-widget-progress-bar//max?": {
		Doc:   "Get *widget.ProgressBar Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//max?: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//max?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//max?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"ptr-widget-progress-bar//min!": {
		Doc:   "Set *widget.ProgressBar Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//min!: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//min!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//min!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//min!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-widget-progress-bar//min-size": {
		Doc:   "(*widget.ProgressBar).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//min-size: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-progress-bar//min?": {
		Doc:   "Get *widget.ProgressBar Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//min?: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//min?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//min?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"ptr-widget-progress-bar//move": {
		Doc:   "(*widget.ProgressBar).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//move: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-progress-bar//position": {
		Doc:   "(*widget.ProgressBar).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//position: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-progress-bar//refresh": {
		Doc:   "(*widget.ProgressBar).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//refresh: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-progress-bar//resize": {
		Doc:   "(*widget.ProgressBar).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//resize: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-progress-bar//set-value": {
		Doc:   "(*widget.ProgressBar).SetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//set-value: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//set-value: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//set-value: arg 2: expected decimal")
			}
			arg0Val.SetValue(arg1Val)
			return arg0
		},
	},
	"ptr-widget-progress-bar//show": {
		Doc:   "(*widget.ProgressBar).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//show: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-progress-bar//size": {
		Doc:   "(*widget.ProgressBar).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//size: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-progress-bar//text-formatter!": {
		Doc:   "Set *widget.ProgressBar TextFormatter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//text-formatter!: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//text-formatter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//text-formatter!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//text-formatter!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.TextFormatter = func() string {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res string
					if v, ok := ps.Res.(env.String); ok {
						res = string(v.Value)
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//text-formatter!: arg 2: expected integer to be 0 or nil")
				}
				self.TextFormatter = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//text-formatter!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-progress-bar//text-formatter?": {
		Doc:   "Get *widget.ProgressBar TextFormatter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//text-formatter?: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//text-formatter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//text-formatter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextFormatter, "func()_(string)")
			return resObj
		},
	},
	"ptr-widget-progress-bar//unbind": {
		Doc:   "(*widget.ProgressBar).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//unbind: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//unbind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//unbind: arg 1: expected native")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-widget-progress-bar//value!": {
		Doc:   "Set *widget.ProgressBar Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//value!: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//value!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//value!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//value!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-widget-progress-bar//value?": {
		Doc:   "Get *widget.ProgressBar Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//value?: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//value?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//value?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"ptr-widget-progress-bar//visible": {
		Doc:   "(*widget.ProgressBar).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//visible: arg 1: expected native of type *widget.ProgressBar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-progress-bar//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-progress-bar//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-radio-group//append": {
		Doc:   "(*widget.RadioGroup).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//append: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//append: arg 2: expected string")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-widget-radio-group//create-renderer": {
		Doc:   "(*widget.RadioGroup).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//create-renderer: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-radio-group//disable": {
		Doc:   "(*widget.RadioGroup).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//disable: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-widget-radio-group//disabled": {
		Doc:   "(*widget.RadioGroup).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//disabled: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-radio-group//enable": {
		Doc:   "(*widget.RadioGroup).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//enable: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-widget-radio-group//extend-base-widget": {
		Doc:   "(*widget.RadioGroup).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//extend-base-widget: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-radio-group//hidden!": {
		Doc:   "Set *widget.RadioGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//hidden!: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-radio-group//hidden?": {
		Doc:   "Get *widget.RadioGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//hidden?: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-radio-group//hide": {
		Doc:   "(*widget.RadioGroup).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//hide: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-radio-group//horizontal!": {
		Doc:   "Set *widget.RadioGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//horizontal!: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//horizontal!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//horizontal!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//horizontal!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-radio-group//horizontal?": {
		Doc:   "Get *widget.RadioGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//horizontal?: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//horizontal?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//horizontal?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"ptr-widget-radio-group//min-size": {
		Doc:   "(*widget.RadioGroup).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//min-size: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-radio-group//move": {
		Doc:   "(*widget.RadioGroup).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//move: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-radio-group//on-changed!": {
		Doc:   "Set *widget.RadioGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//on-changed!: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//on-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-radio-group//on-changed?": {
		Doc:   "Get *widget.RadioGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//on-changed?: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//on-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"ptr-widget-radio-group//options!": {
		Doc:   "Set *widget.RadioGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//options!: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//options!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//options!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-radio-group//options!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//options!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//options!: arg 2: expected integer to be 0 or nil")
				}
				self.Options = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//options!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-radio-group//options?": {
		Doc:   "Get *widget.RadioGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//options?: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//options?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//options?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-radio-group//position": {
		Doc:   "(*widget.RadioGroup).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//position: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-radio-group//refresh": {
		Doc:   "(*widget.RadioGroup).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//refresh: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-radio-group//required!": {
		Doc:   "Set *widget.RadioGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//required!: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//required!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//required!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//required!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-radio-group//required?": {
		Doc:   "Get *widget.RadioGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//required?: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//required?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//required?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"ptr-widget-radio-group//resize": {
		Doc:   "(*widget.RadioGroup).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//resize: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-radio-group//selected!": {
		Doc:   "Set *widget.RadioGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//selected!: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//selected!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//selected!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-radio-group//selected?": {
		Doc:   "Get *widget.RadioGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//selected?: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"ptr-widget-radio-group//set-selected": {
		Doc:   "(*widget.RadioGroup).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//set-selected: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//set-selected: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//set-selected: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//set-selected: arg 2: expected string")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"ptr-widget-radio-group//show": {
		Doc:   "(*widget.RadioGroup).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//show: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-radio-group//size": {
		Doc:   "(*widget.RadioGroup).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//size: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-radio-group//visible": {
		Doc:   "(*widget.RadioGroup).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//visible: arg 1: expected native of type *widget.RadioGroup")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-radio-group//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-radio-group//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-rich-text-style//alignment!": {
		Doc:   "Set *widget.RichTextStyle Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//alignment!: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-rich-text-style//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-rich-text-style//alignment?": {
		Doc:   "Get *widget.RichTextStyle Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//alignment?: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"ptr-widget-rich-text-style//color-name!": {
		Doc:   "Set *widget.RichTextStyle ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//color-name!: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//color-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//color-name!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeColorName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeColorName)
				}
				if natOk && natValOk {
					self.ColorName = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-rich-text-style//color-name!: arg 2: expected string")
					}
					self.ColorName = fyne.ThemeColorName(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-rich-text-style//color-name?": {
		Doc:   "Get *widget.RichTextStyle ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//color-name?: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//color-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//color-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.ColorName))
			return resObj
		},
	},
	"ptr-widget-rich-text-style//inline!": {
		Doc:   "Set *widget.RichTextStyle Inline value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//inline!: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//inline!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//inline!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Inline = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//inline!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-rich-text-style//inline?": {
		Doc:   "Get *widget.RichTextStyle Inline value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//inline?: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//inline?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//inline?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Inline))
			return resObj
		},
	},
	"ptr-widget-rich-text-style//size-name!": {
		Doc:   "Set *widget.RichTextStyle SizeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//size-name!: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//size-name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//size-name!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeSizeName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeSizeName)
				}
				if natOk && natValOk {
					self.SizeName = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-rich-text-style//size-name!: arg 2: expected string")
					}
					self.SizeName = fyne.ThemeSizeName(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-rich-text-style//size-name?": {
		Doc:   "Get *widget.RichTextStyle SizeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//size-name?: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//size-name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//size-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.SizeName))
			return resObj
		},
	},
	"ptr-widget-rich-text-style//text-style!": {
		Doc:   "Set *widget.RichTextStyle TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//text-style!: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//text-style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-rich-text-style//text-style?": {
		Doc:   "Get *widget.RichTextStyle TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//text-style?: arg 1: expected native of type *widget.RichTextStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text-style//text-style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text-style//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"ptr-widget-rich-text//create-renderer": {
		Doc:   "(*widget.RichText).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//create-renderer: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-rich-text//extend-base-widget": {
		Doc:   "(*widget.RichText).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//extend-base-widget: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-rich-text//hidden!": {
		Doc:   "Set *widget.RichText Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//hidden!: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-rich-text//hidden?": {
		Doc:   "Get *widget.RichText Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//hidden?: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-rich-text//hide": {
		Doc:   "(*widget.RichText).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//hide: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-rich-text//min-size": {
		Doc:   "(*widget.RichText).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//min-size: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-rich-text//move": {
		Doc:   "(*widget.RichText).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//move: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-rich-text//parse-markdown": {
		Doc:   "(*widget.RichText).ParseMarkdown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//parse-markdown: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//parse-markdown: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//parse-markdown: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//parse-markdown: arg 2: expected string")
			}
			arg0Val.ParseMarkdown(arg1Val)
			return arg0
		},
	},
	"ptr-widget-rich-text//position": {
		Doc:   "(*widget.RichText).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//position: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-rich-text//refresh": {
		Doc:   "(*widget.RichText).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//refresh: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-rich-text//resize": {
		Doc:   "(*widget.RichText).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//resize: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-rich-text//scroll!": {
		Doc:   "Set *widget.RichText Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//scroll!: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//scroll!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//scroll!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var rOut, rIn reflect.Value
				if natOk {
					// HACK: self.Scroll, natValOk = widget_1.ScrollDirection(u)
					rOut = reflect.ValueOf(&self.Scroll).Elem()
					rIn = reflect.ValueOf(nat.Value)
					natValOk = rIn.CanConvert(rOut.Type())
				}
				if natOk && natValOk {
					rOut.Set(rIn.Convert(rOut.Type()))
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-rich-text//scroll!: arg 2: expected integer")
					}
					// HACK: self.Scroll = widget_1.ScrollDirection(u)
					rOut := reflect.ValueOf(&self.Scroll).Elem()
					rIn := reflect.ValueOf(u)
					rOut.Set(rIn.Convert(rOut.Type()))
				}
			}
			return arg0
		},
	},
	"ptr-widget-rich-text//scroll?": {
		Doc:   "Get *widget.RichText Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//scroll?: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//scroll?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//scroll?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Scroll)))
			return resObj
		},
	},
	"ptr-widget-rich-text//segments!": {
		Doc:   "Set *widget.RichText Segments value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//segments!: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//segments!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//segments!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Segments = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Segments[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-rich-text//segments!: arg 2: block item: expected native of type widget.RichTextSegment")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-rich-text//segments!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Segments[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-rich-text//segments!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Segments, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//segments!: arg 2: expected native of type []widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//segments!: arg 2: expected integer to be 0 or nil")
				}
				self.Segments = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//segments!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-rich-text//segments?": {
		Doc:   "Get *widget.RichText Segments value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//segments?: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//segments?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//segments?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Segments))
				for i, it := range self.Segments {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-rich-text-segment")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-rich-text//show": {
		Doc:   "(*widget.RichText).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//show: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-rich-text//size": {
		Doc:   "(*widget.RichText).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//size: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-rich-text//string": {
		Doc:   "(*widget.RichText).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//string: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//string: arg 1: expected native")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-rich-text//truncation!": {
		Doc:   "Set *widget.RichText Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//truncation!: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//truncation!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//truncation!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextTruncation
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextTruncation)
				}
				if natOk && natValOk {
					self.Truncation = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-rich-text//truncation!: arg 2: expected integer")
					}
					self.Truncation = fyne.TextTruncation(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-rich-text//truncation?": {
		Doc:   "Get *widget.RichText Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//truncation?: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//truncation?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//truncation?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Truncation)))
			return resObj
		},
	},
	"ptr-widget-rich-text//visible": {
		Doc:   "(*widget.RichText).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//visible: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-rich-text//wrapping!": {
		Doc:   "Set *widget.RichText Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//wrapping!: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//wrapping!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-rich-text//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-rich-text//wrapping?": {
		Doc:   "Get *widget.RichText Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//wrapping?: arg 1: expected native of type *widget.RichText")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-rich-text//wrapping?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-rich-text//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"ptr-widget-select-entry//accepts-tab": {
		Doc:   "(*widget.SelectEntry).AcceptsTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//accepts-tab: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//accepts-tab: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//accepts-tab: arg 1: expected native")
			}
			res0 := arg0Val.AcceptsTab()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-select-entry//action-item!": {
		Doc:   "Set *widget.SelectEntry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//action-item!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//action-item!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//action-item!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//action-item!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//action-item!: arg 2: expected integer to be 0 or nil")
				}
				self.ActionItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//action-item!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//action-item?": {
		Doc:   "Get *widget.SelectEntry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//action-item?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//action-item?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//action-item?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.ActionItem)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.ActionItem, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.ActionItem, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"ptr-widget-select-entry//append": {
		Doc:   "(*widget.SelectEntry).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//append: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//append: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//append: arg 2: expected string")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//bind": {
		Doc:   "(*widget.SelectEntry).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//bind: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//bind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//bind: arg 1: expected native")
			}
			var arg1Val binding.String
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//bind: arg 2: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//bind: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//bind: arg 2: expected native")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//create-renderer": {
		Doc:   "(*widget.SelectEntry).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//create-renderer: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-select-entry//cursor": {
		Doc:   "(*widget.SelectEntry).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//cursor: arg 1: expected native")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-select-entry//cursor-column!": {
		Doc:   "Set *widget.SelectEntry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor-column!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor-column!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//cursor-column!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//cursor-column!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//cursor-column?": {
		Doc:   "Get *widget.SelectEntry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor-column?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor-column?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//cursor-column?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"ptr-widget-select-entry//cursor-row!": {
		Doc:   "Set *widget.SelectEntry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor-row!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor-row!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//cursor-row!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//cursor-row!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//cursor-row?": {
		Doc:   "Get *widget.SelectEntry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor-row?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//cursor-row?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//cursor-row?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"ptr-widget-select-entry//disable": {
		Doc:   "(*widget.SelectEntry).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//disable: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-widget-select-entry//disabled": {
		Doc:   "(*widget.SelectEntry).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//disabled: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-select-entry//double-tapped": {
		Doc:   "(*widget.SelectEntry).DoubleTapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//double-tapped: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//double-tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//double-tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//double-tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//double-tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//double-tapped: arg 2: expected native")
			}
			arg0Val.DoubleTapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//drag-end": {
		Doc:   "(*widget.SelectEntry).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//drag-end: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//drag-end: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//drag-end: arg 1: expected native")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"ptr-widget-select-entry//dragged": {
		Doc:   "(*widget.SelectEntry).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//dragged: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//dragged: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//dragged: arg 1: expected native")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//dragged: arg 2: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//dragged: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//dragged: arg 2: expected native")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//enable": {
		Doc:   "(*widget.SelectEntry).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//enable: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-widget-select-entry//extend-base-widget": {
		Doc:   "(*widget.SelectEntry).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//extend-base-widget: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//focus-gained": {
		Doc:   "(*widget.SelectEntry).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//focus-gained: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-select-entry//focus-lost": {
		Doc:   "(*widget.SelectEntry).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//focus-lost: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-select-entry//hidden!": {
		Doc:   "Set *widget.SelectEntry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//hidden!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//hidden?": {
		Doc:   "Get *widget.SelectEntry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//hidden?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-select-entry//hide": {
		Doc:   "(*widget.SelectEntry).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//hide: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-select-entry//key-down": {
		Doc:   "(*widget.SelectEntry).KeyDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//key-down: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//key-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//key-down: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//key-down: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//key-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//key-down: arg 2: expected native")
			}
			arg0Val.KeyDown(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//key-up": {
		Doc:   "(*widget.SelectEntry).KeyUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//key-up: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//key-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//key-up: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//key-up: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//key-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//key-up: arg 2: expected native")
			}
			arg0Val.KeyUp(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//keyboard": {
		Doc:   "(*widget.SelectEntry).Keyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//keyboard: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//keyboard: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//keyboard: arg 1: expected native")
			}
			res0 := arg0Val.Keyboard()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(int32(res0)))
			return res0Obj
		},
	},
	"ptr-widget-select-entry//min-size": {
		Doc:   "(*widget.SelectEntry).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//min-size: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-select-entry//mouse-down": {
		Doc:   "(*widget.SelectEntry).MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//mouse-down: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//mouse-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//mouse-down: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//mouse-down: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//mouse-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//mouse-down: arg 2: expected native")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//mouse-up": {
		Doc:   "(*widget.SelectEntry).MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//mouse-up: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//mouse-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//mouse-up: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//mouse-up: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//mouse-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//mouse-up: arg 2: expected native")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//move": {
		Doc:   "(*widget.SelectEntry).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//move: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//multi-line!": {
		Doc:   "Set *widget.SelectEntry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//multi-line!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//multi-line!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//multi-line!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//multi-line!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//multi-line?": {
		Doc:   "Get *widget.SelectEntry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//multi-line?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//multi-line?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//multi-line?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"ptr-widget-select-entry//on-changed!": {
		Doc:   "Set *widget.SelectEntry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-changed!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//on-changed?": {
		Doc:   "Get *widget.SelectEntry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-changed?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"ptr-widget-select-entry//on-cursor-changed!": {
		Doc:   "Set *widget.SelectEntry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-cursor-changed!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-cursor-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//on-cursor-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-cursor-changed!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-cursor-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnCursorChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//on-cursor-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//on-cursor-changed?": {
		Doc:   "Get *widget.SelectEntry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-cursor-changed?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-cursor-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//on-cursor-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "func()")
			return resObj
		},
	},
	"ptr-widget-select-entry//on-submitted!": {
		Doc:   "Set *widget.SelectEntry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-submitted!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-submitted!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//on-submitted!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-submitted!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-submitted!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSubmitted = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//on-submitted!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//on-submitted?": {
		Doc:   "Get *widget.SelectEntry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-submitted?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//on-submitted?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//on-submitted?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "func(string)")
			return resObj
		},
	},
	"ptr-widget-select-entry//password!": {
		Doc:   "Set *widget.SelectEntry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//password!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//password!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//password!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//password!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//password?": {
		Doc:   "Get *widget.SelectEntry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//password?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//password?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//password?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"ptr-widget-select-entry//place-holder!": {
		Doc:   "Set *widget.SelectEntry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//place-holder!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//place-holder!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//place-holder!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//place-holder!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//place-holder?": {
		Doc:   "Get *widget.SelectEntry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//place-holder?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//place-holder?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//place-holder?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"ptr-widget-select-entry//position": {
		Doc:   "(*widget.SelectEntry).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//position: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-select-entry//refresh": {
		Doc:   "(*widget.SelectEntry).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//refresh: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-select-entry//resize": {
		Doc:   "(*widget.SelectEntry).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//resize: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//scroll!": {
		Doc:   "Set *widget.SelectEntry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//scroll!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//scroll!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//scroll!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var rOut, rIn reflect.Value
				if natOk {
					// HACK: self.Scroll, natValOk = widget_1.ScrollDirection(u)
					rOut = reflect.ValueOf(&self.Scroll).Elem()
					rIn = reflect.ValueOf(nat.Value)
					natValOk = rIn.CanConvert(rOut.Type())
				}
				if natOk && natValOk {
					rOut.Set(rIn.Convert(rOut.Type()))
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-select-entry//scroll!: arg 2: expected integer")
					}
					// HACK: self.Scroll = widget_1.ScrollDirection(u)
					rOut := reflect.ValueOf(&self.Scroll).Elem()
					rIn := reflect.ValueOf(u)
					rOut.Set(rIn.Convert(rOut.Type()))
				}
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//scroll?": {
		Doc:   "Get *widget.SelectEntry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//scroll?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//scroll?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//scroll?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Scroll)))
			return resObj
		},
	},
	"ptr-widget-select-entry//selected-text": {
		Doc:   "(*widget.SelectEntry).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//selected-text: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-select-entry//set-min-rows-visible": {
		Doc:   "(*widget.SelectEntry).SetMinRowsVisible",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-min-rows-visible: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-min-rows-visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-min-rows-visible: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-min-rows-visible: arg 2: expected integer")
			}
			arg0Val.SetMinRowsVisible(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//set-on-validation-changed": {
		Doc:   "(*widget.SelectEntry).SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-on-validation-changed: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-on-validation-changed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-on-validation-changed: arg 1: expected native")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-on-validation-changed: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-on-validation-changed: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-on-validation-changed: arg 2: expected function or nil")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//set-options": {
		Doc:   "(*widget.SelectEntry).SetOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-options: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-options: arg 1: expected native")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-select-entry//set-options: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-options: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-options: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-options: arg 2: expected block, native or nil")
			}
			arg0Val.SetOptions(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//set-place-holder": {
		Doc:   "(*widget.SelectEntry).SetPlaceHolder",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-place-holder: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-place-holder: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-place-holder: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-place-holder: arg 2: expected string")
			}
			arg0Val.SetPlaceHolder(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//set-text": {
		Doc:   "(*widget.SelectEntry).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-text: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//set-validation-error": {
		Doc:   "(*widget.SelectEntry).SetValidationError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-validation-error: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-validation-error: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-validation-error: arg 1: expected native")
			}
			var arg1Val error
			switch v := arg1.(type) {
			case env.String:
				arg1Val = errors.New(v.Value)
			case env.Error:
				arg1Val = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//set-validation-error: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//set-validation-error: arg 2: expected error, string or nil")
			}
			arg0Val.SetValidationError(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//show": {
		Doc:   "(*widget.SelectEntry).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//show: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-select-entry//size": {
		Doc:   "(*widget.SelectEntry).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//size: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-select-entry//tapped": {
		Doc:   "(*widget.SelectEntry).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//tapped: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//tapped-secondary": {
		Doc:   "(*widget.SelectEntry).TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//tapped-secondary: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//tapped-secondary: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//tapped-secondary: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//tapped-secondary: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//tapped-secondary: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//tapped-secondary: arg 2: expected native")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//text!": {
		Doc:   "Set *widget.SelectEntry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//text!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//text-style!": {
		Doc:   "Set *widget.SelectEntry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//text-style!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//text-style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//text-style?": {
		Doc:   "Get *widget.SelectEntry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//text-style?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//text-style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"ptr-widget-select-entry//text?": {
		Doc:   "Get *widget.SelectEntry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//text?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-widget-select-entry//touch-cancel": {
		Doc:   "(*widget.SelectEntry).TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-cancel: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-cancel: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//touch-cancel: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-cancel: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-cancel: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//touch-cancel: arg 2: expected native")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//touch-down": {
		Doc:   "(*widget.SelectEntry).TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-down: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//touch-down: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-down: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//touch-down: arg 2: expected native")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//touch-up": {
		Doc:   "(*widget.SelectEntry).TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-up: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//touch-up: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-up: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//touch-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//touch-up: arg 2: expected native")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//typed-key": {
		Doc:   "(*widget.SelectEntry).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-key: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//typed-rune": {
		Doc:   "(*widget.SelectEntry).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-rune: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//typed-shortcut": {
		Doc:   "(*widget.SelectEntry).TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-shortcut: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-shortcut: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//typed-shortcut: arg 1: expected native")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-shortcut: arg 2: expected native of type fyne.Shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//typed-shortcut: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//typed-shortcut: arg 2: expected native")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select-entry//unbind": {
		Doc:   "(*widget.SelectEntry).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//unbind: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//unbind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//unbind: arg 1: expected native")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-widget-select-entry//validate": {
		Doc:   "(*widget.SelectEntry).Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//validate: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//validate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//validate: arg 1: expected native")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-widget-select-entry//validator!": {
		Doc:   "Set *widget.SelectEntry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//validator!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//validator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//validator!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.StringValidator
				if natOk {
					natVal, natValOk = nat.Value.(fyne.StringValidator)
				}
				if natOk && natValOk {
					self.Validator = natVal
				} else {
					var u func(string) error
					switch fn := arg1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-select-entry//validator!: arg 2: function has invalid number of arguments (expected 1)")
						}
						u = func(arg0 string) error {
							var arg0Val env.Object
							arg0Val = *env.NewString(arg0)
							evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
							var res error
							switch v := ps.Res.(type) {
							case env.String:
								res = errors.New(v.Value)
							case env.Error:
								res = errors.New(v.Print(*ps.Idx))
							case env.Integer:
								if v.Value != 0 {
									// TODO: Cannot return error from function
								}
								res = nil
							default:
								// TODO: Cannot return error from function
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-select-entry//validator!: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-select-entry//validator!: arg 2: expected function or nil")
					}
					self.Validator = fyne.StringValidator(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//validator?": {
		Doc:   "Get *widget.SelectEntry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//validator?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//validator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//validator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, (func(string) error)(self.Validator), "func(string)_(error)")
			return resObj
		},
	},
	"ptr-widget-select-entry//visible": {
		Doc:   "(*widget.SelectEntry).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//visible: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-select-entry//wrapping!": {
		Doc:   "Set *widget.SelectEntry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//wrapping!: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//wrapping!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-select-entry//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-select-entry//wrapping?": {
		Doc:   "Get *widget.SelectEntry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//wrapping?: arg 1: expected native of type *widget.SelectEntry")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select-entry//wrapping?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select-entry//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"ptr-widget-select//alignment!": {
		Doc:   "Set *widget.Select Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//alignment!: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-select//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-select//alignment?": {
		Doc:   "Get *widget.Select Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//alignment?: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"ptr-widget-select//clear-selected": {
		Doc:   "(*widget.Select).ClearSelected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//clear-selected: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//clear-selected: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//clear-selected: arg 1: expected native")
			}
			arg0Val.ClearSelected()
			return arg0
		},
	},
	"ptr-widget-select//create-renderer": {
		Doc:   "(*widget.Select).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//create-renderer: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-select//disable": {
		Doc:   "(*widget.Select).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//disable: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//disable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//disable: arg 1: expected native")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-widget-select//disabled": {
		Doc:   "(*widget.Select).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//disabled: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//disabled: arg 1: expected native")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-select//enable": {
		Doc:   "(*widget.Select).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//enable: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//enable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//enable: arg 1: expected native")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-widget-select//extend-base-widget": {
		Doc:   "(*widget.Select).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//extend-base-widget: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//focus-gained": {
		Doc:   "(*widget.Select).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//focus-gained: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-select//focus-lost": {
		Doc:   "(*widget.Select).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//focus-lost: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-select//hidden!": {
		Doc:   "Set *widget.Select Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//hidden!: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-select//hidden?": {
		Doc:   "Get *widget.Select Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//hidden?: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-select//hide": {
		Doc:   "(*widget.Select).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//hide: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-select//min-size": {
		Doc:   "(*widget.Select).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//min-size: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-select//mouse-in": {
		Doc:   "(*widget.Select).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-in: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-in: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//mouse-in: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-in: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-in: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//mouse-in: arg 2: expected native")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//mouse-moved": {
		Doc:   "(*widget.Select).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-moved: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-moved: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//mouse-moved: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-moved: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-moved: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//mouse-moved: arg 2: expected native")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//mouse-out": {
		Doc:   "(*widget.Select).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-out: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//mouse-out: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//mouse-out: arg 1: expected native")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-widget-select//move": {
		Doc:   "(*widget.Select).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//move: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//on-changed!": {
		Doc:   "Set *widget.Select OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//on-changed!: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//on-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-select//on-changed?": {
		Doc:   "Get *widget.Select OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//on-changed?: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//on-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"ptr-widget-select//options!": {
		Doc:   "Set *widget.Select Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//options!: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//options!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//options!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-select//options!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//options!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//options!: arg 2: expected integer to be 0 or nil")
				}
				self.Options = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//options!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-select//options?": {
		Doc:   "Get *widget.Select Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//options?: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//options?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//options?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-select//place-holder!": {
		Doc:   "Set *widget.Select PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//place-holder!: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//place-holder!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//place-holder!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//place-holder!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-select//place-holder?": {
		Doc:   "Get *widget.Select PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//place-holder?: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//place-holder?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//place-holder?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"ptr-widget-select//position": {
		Doc:   "(*widget.Select).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//position: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-select//refresh": {
		Doc:   "(*widget.Select).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//refresh: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-select//resize": {
		Doc:   "(*widget.Select).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//resize: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//selected!": {
		Doc:   "Set *widget.Select Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//selected!: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//selected!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//selected!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-select//selected-index": {
		Doc:   "(*widget.Select).SelectedIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//selected-index: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//selected-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//selected-index: arg 1: expected native")
			}
			res0 := arg0Val.SelectedIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-widget-select//selected?": {
		Doc:   "Get *widget.Select Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//selected?: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"ptr-widget-select//set-options": {
		Doc:   "(*widget.Select).SetOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//set-options: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//set-options: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//set-options: arg 1: expected native")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-select//set-options: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//set-options: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//set-options: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//set-options: arg 2: expected block, native or nil")
			}
			arg0Val.SetOptions(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//set-selected": {
		Doc:   "(*widget.Select).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//set-selected: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//set-selected: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//set-selected: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//set-selected: arg 2: expected string")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//set-selected-index": {
		Doc:   "(*widget.Select).SetSelectedIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//set-selected-index: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//set-selected-index: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//set-selected-index: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//set-selected-index: arg 2: expected integer")
			}
			arg0Val.SetSelectedIndex(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//show": {
		Doc:   "(*widget.Select).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//show: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-select//size": {
		Doc:   "(*widget.Select).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//size: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-select//tapped": {
		Doc:   "(*widget.Select).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//tapped: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//typed-key": {
		Doc:   "(*widget.Select).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//typed-key: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//typed-rune": {
		Doc:   "(*widget.Select).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//typed-rune: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-select//visible": {
		Doc:   "(*widget.Select).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//visible: arg 1: expected native of type *widget.Select")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-select//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-select//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-separator-segment//inline": {
		Doc:   "(*widget.SeparatorSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//inline: arg 1: expected native of type *widget.SeparatorSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//inline: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//inline: arg 1: expected native")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-separator-segment//select": {
		Doc:   "(*widget.SeparatorSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//select: arg 1: expected native of type *widget.SeparatorSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//select: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//select: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//select: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//select: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//select: arg 3: expected native")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-separator-segment//selected-text": {
		Doc:   "(*widget.SeparatorSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//selected-text: arg 1: expected native of type *widget.SeparatorSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-separator-segment//textual": {
		Doc:   "(*widget.SeparatorSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//textual: arg 1: expected native of type *widget.SeparatorSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//textual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//textual: arg 1: expected native")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-separator-segment//unselect": {
		Doc:   "(*widget.SeparatorSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//unselect: arg 1: expected native of type *widget.SeparatorSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//unselect: arg 1: expected native")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-widget-separator-segment//update": {
		Doc:   "(*widget.SeparatorSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//update: arg 1: expected native of type *widget.SeparatorSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//update: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//update: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//update: arg 2: expected native")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-widget-separator-segment//visual": {
		Doc:   "(*widget.SeparatorSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//visual: arg 1: expected native of type *widget.SeparatorSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator-segment//visual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator-segment//visual: arg 1: expected native")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-separator//create-renderer": {
		Doc:   "(*widget.Separator).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//create-renderer: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-separator//extend-base-widget": {
		Doc:   "(*widget.Separator).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//extend-base-widget: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-separator//hidden!": {
		Doc:   "Set *widget.Separator Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//hidden!: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-separator//hidden?": {
		Doc:   "Get *widget.Separator Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//hidden?: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-separator//hide": {
		Doc:   "(*widget.Separator).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//hide: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-separator//min-size": {
		Doc:   "(*widget.Separator).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//min-size: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-separator//move": {
		Doc:   "(*widget.Separator).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//move: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-separator//position": {
		Doc:   "(*widget.Separator).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//position: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-separator//refresh": {
		Doc:   "(*widget.Separator).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//refresh: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-separator//resize": {
		Doc:   "(*widget.Separator).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//resize: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-separator//show": {
		Doc:   "(*widget.Separator).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//show: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-separator//size": {
		Doc:   "(*widget.Separator).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//size: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-separator//visible": {
		Doc:   "(*widget.Separator).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//visible: arg 1: expected native of type *widget.Separator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-separator//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-separator//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-slider//bind": {
		Doc:   "(*widget.Slider).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//bind: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//bind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//bind: arg 1: expected native")
			}
			var arg1Val binding.Float
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//bind: arg 2: expected native of type binding.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//bind: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//bind: arg 2: expected native")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//create-renderer": {
		Doc:   "(*widget.Slider).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//create-renderer: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-slider//drag-end": {
		Doc:   "(*widget.Slider).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//drag-end: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//drag-end: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//drag-end: arg 1: expected native")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"ptr-widget-slider//dragged": {
		Doc:   "(*widget.Slider).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//dragged: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//dragged: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//dragged: arg 1: expected native")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//dragged: arg 2: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//dragged: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//dragged: arg 2: expected native")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//extend-base-widget": {
		Doc:   "(*widget.Slider).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//extend-base-widget: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//focus-gained": {
		Doc:   "(*widget.Slider).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//focus-gained: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-slider//focus-lost": {
		Doc:   "(*widget.Slider).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//focus-lost: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-slider//hidden!": {
		Doc:   "Set *widget.Slider Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//hidden!: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-slider//hidden?": {
		Doc:   "Get *widget.Slider Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//hidden?: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-slider//hide": {
		Doc:   "(*widget.Slider).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//hide: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-slider//max!": {
		Doc:   "Set *widget.Slider Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//max!: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//max!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//max!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//max!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-widget-slider//max?": {
		Doc:   "Get *widget.Slider Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//max?: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//max?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//max?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"ptr-widget-slider//min!": {
		Doc:   "Set *widget.Slider Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//min!: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//min!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//min!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//min!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-widget-slider//min-size": {
		Doc:   "(*widget.Slider).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//min-size: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-slider//min?": {
		Doc:   "Get *widget.Slider Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//min?: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//min?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//min?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"ptr-widget-slider//mouse-in": {
		Doc:   "(*widget.Slider).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-in: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-in: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//mouse-in: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-in: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-in: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//mouse-in: arg 2: expected native")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//mouse-moved": {
		Doc:   "(*widget.Slider).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-moved: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-moved: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//mouse-moved: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-moved: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-moved: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//mouse-moved: arg 2: expected native")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//mouse-out": {
		Doc:   "(*widget.Slider).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-out: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//mouse-out: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//mouse-out: arg 1: expected native")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-widget-slider//move": {
		Doc:   "(*widget.Slider).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//move: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//on-change-ended!": {
		Doc:   "Set *widget.Slider OnChangeEnded value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-change-ended!: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-change-ended!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//on-change-ended!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-change-ended!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChangeEnded = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-change-ended!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChangeEnded = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//on-change-ended!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-slider//on-change-ended?": {
		Doc:   "Get *widget.Slider OnChangeEnded value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-change-ended?: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-change-ended?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//on-change-ended?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChangeEnded, "func(float-64)")
			return resObj
		},
	},
	"ptr-widget-slider//on-changed!": {
		Doc:   "Set *widget.Slider OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-changed!: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-changed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-slider//on-changed?": {
		Doc:   "Get *widget.Slider OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-changed?: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//on-changed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(float-64)")
			return resObj
		},
	},
	"ptr-widget-slider//orientation!": {
		Doc:   "Set *widget.Slider Orientation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//orientation!: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//orientation!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//orientation!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.Orientation
				if natOk {
					natVal, natValOk = nat.Value.(widget.Orientation)
				}
				if natOk && natValOk {
					self.Orientation = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-slider//orientation!: arg 2: expected integer")
					}
					self.Orientation = widget.Orientation(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-slider//orientation?": {
		Doc:   "Get *widget.Slider Orientation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//orientation?: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//orientation?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//orientation?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Orientation)))
			return resObj
		},
	},
	"ptr-widget-slider//position": {
		Doc:   "(*widget.Slider).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//position: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-slider//refresh": {
		Doc:   "(*widget.Slider).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//refresh: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-slider//resize": {
		Doc:   "(*widget.Slider).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//resize: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//set-value": {
		Doc:   "(*widget.Slider).SetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//set-value: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//set-value: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//set-value: arg 1: expected native")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//set-value: arg 2: expected decimal")
			}
			arg0Val.SetValue(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//show": {
		Doc:   "(*widget.Slider).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//show: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-slider//size": {
		Doc:   "(*widget.Slider).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//size: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-slider//step!": {
		Doc:   "Set *widget.Slider Step value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//step!: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//step!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//step!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Step = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//step!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-widget-slider//step?": {
		Doc:   "Get *widget.Slider Step value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//step?: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//step?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//step?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Step))
			return resObj
		},
	},
	"ptr-widget-slider//tapped": {
		Doc:   "(*widget.Slider).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//tapped: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//typed-key": {
		Doc:   "(*widget.Slider).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//typed-key: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//typed-rune": {
		Doc:   "(*widget.Slider).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//typed-rune: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-slider//unbind": {
		Doc:   "(*widget.Slider).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//unbind: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//unbind: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//unbind: arg 1: expected native")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-widget-slider//value!": {
		Doc:   "Set *widget.Slider Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//value!: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//value!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//value!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//value!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"ptr-widget-slider//value?": {
		Doc:   "Get *widget.Slider Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//value?: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//value?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//value?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"ptr-widget-slider//visible": {
		Doc:   "(*widget.Slider).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//visible: arg 1: expected native of type *widget.Slider")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-slider//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-slider//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-table-cell-id//col!": {
		Doc:   "Set *widget.TableCellID Col value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table-cell-id//col!: arg 1: expected native of type *widget.TableCellID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table-cell-id//col!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table-cell-id//col!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Col = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table-cell-id//col!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-table-cell-id//col?": {
		Doc:   "Get *widget.TableCellID Col value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table-cell-id//col?: arg 1: expected native of type *widget.TableCellID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table-cell-id//col?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table-cell-id//col?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Col))
			return resObj
		},
	},
	"ptr-widget-table-cell-id//row!": {
		Doc:   "Set *widget.TableCellID Row value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table-cell-id//row!: arg 1: expected native of type *widget.TableCellID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table-cell-id//row!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table-cell-id//row!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Row = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table-cell-id//row!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-table-cell-id//row?": {
		Doc:   "Get *widget.TableCellID Row value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table-cell-id//row?: arg 1: expected native of type *widget.TableCellID")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table-cell-id//row?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table-cell-id//row?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Row))
			return resObj
		},
	},
	"ptr-widget-table//create-cell!": {
		Doc:   "Set *widget.Table CreateCell value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-cell!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-cell!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//create-cell!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-cell!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateCell = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-cell!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateCell = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//create-cell!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-table//create-cell?": {
		Doc:   "Get *widget.Table CreateCell value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-cell?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-cell?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//create-cell?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateCell, "func()_(fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-table//create-header!": {
		Doc:   "Set *widget.Table CreateHeader value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-header!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-header!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//create-header!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-header!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateHeader = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-header!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateHeader = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//create-header!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-table//create-header?": {
		Doc:   "Get *widget.Table CreateHeader value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-header?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-header?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//create-header?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateHeader, "func()_(fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-table//create-renderer": {
		Doc:   "(*widget.Table).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-renderer: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-table//cursor": {
		Doc:   "(*widget.Table).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//cursor: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//cursor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//cursor: arg 1: expected native")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-table//drag-end": {
		Doc:   "(*widget.Table).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//drag-end: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//drag-end: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//drag-end: arg 1: expected native")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"ptr-widget-table//dragged": {
		Doc:   "(*widget.Table).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//dragged: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//dragged: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//dragged: arg 1: expected native")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//dragged: arg 2: expected native of type *fyne.DragEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//dragged: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//dragged: arg 2: expected native")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//extend-base-widget": {
		Doc:   "(*widget.Table).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//extend-base-widget: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//focus-gained": {
		Doc:   "(*widget.Table).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//focus-gained: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-table//focus-lost": {
		Doc:   "(*widget.Table).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//focus-lost: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-table//hidden!": {
		Doc:   "Set *widget.Table Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//hidden!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-table//hidden?": {
		Doc:   "Get *widget.Table Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//hidden?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-table//hide": {
		Doc:   "(*widget.Table).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//hide: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-table//length!": {
		Doc:   "Set *widget.Table Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//length!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//length!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//length!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Length, ok = v.Value.(func() (int, int))
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//length!: arg 2: expected native of type func() (int, int)")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//length!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-table//length?": {
		Doc:   "Get *widget.Table Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//length?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//length?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//length?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int_int)")
			return resObj
		},
	},
	"ptr-widget-table//min-size": {
		Doc:   "(*widget.Table).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//min-size: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-table//mouse-down": {
		Doc:   "(*widget.Table).MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-down: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//mouse-down: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-down: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//mouse-down: arg 2: expected native")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//mouse-in": {
		Doc:   "(*widget.Table).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-in: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-in: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//mouse-in: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-in: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-in: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//mouse-in: arg 2: expected native")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//mouse-moved": {
		Doc:   "(*widget.Table).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-moved: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-moved: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//mouse-moved: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-moved: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-moved: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//mouse-moved: arg 2: expected native")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//mouse-out": {
		Doc:   "(*widget.Table).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-out: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-out: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//mouse-out: arg 1: expected native")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-widget-table//mouse-up": {
		Doc:   "(*widget.Table).MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-up: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//mouse-up: arg 1: expected native")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-up: arg 2: expected native of type *desktop.MouseEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//mouse-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//mouse-up: arg 2: expected native")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//move": {
		Doc:   "(*widget.Table).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//move: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//on-selected!": {
		Doc:   "Set *widget.Table OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-selected!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 widget.TableCellID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-table//on-selected?": {
		Doc:   "Get *widget.Table OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-selected?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(widget-table-cell-id)")
			return resObj
		},
	},
	"ptr-widget-table//on-unselected!": {
		Doc:   "Set *widget.Table OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-unselected!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-unselected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 widget.TableCellID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-table//on-unselected?": {
		Doc:   "Get *widget.Table OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-unselected?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//on-unselected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(widget-table-cell-id)")
			return resObj
		},
	},
	"ptr-widget-table//position": {
		Doc:   "(*widget.Table).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//position: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-table//refresh": {
		Doc:   "(*widget.Table).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//refresh: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-table//refresh-item": {
		Doc:   "(*widget.Table).RefreshItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//refresh-item: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//refresh-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//refresh-item: arg 1: expected native")
			}
			var arg1Val widget.TableCellID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//refresh-item: arg 2: expected native of type widget.TableCellID")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//refresh-item: arg 2: expected native")
			}
			arg0Val.RefreshItem(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//resize": {
		Doc:   "(*widget.Table).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//resize: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//scroll-to": {
		Doc:   "(*widget.Table).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//scroll-to: arg 1: expected native")
			}
			var arg1Val widget.TableCellID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to: arg 2: expected native of type widget.TableCellID")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//scroll-to: arg 2: expected native")
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//scroll-to-bottom": {
		Doc:   "(*widget.Table).ScrollToBottom",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to-bottom: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to-bottom: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//scroll-to-bottom: arg 1: expected native")
			}
			arg0Val.ScrollToBottom()
			return arg0
		},
	},
	"ptr-widget-table//scroll-to-leading": {
		Doc:   "(*widget.Table).ScrollToLeading",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to-leading: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to-leading: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//scroll-to-leading: arg 1: expected native")
			}
			arg0Val.ScrollToLeading()
			return arg0
		},
	},
	"ptr-widget-table//scroll-to-top": {
		Doc:   "(*widget.Table).ScrollToTop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to-top: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to-top: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//scroll-to-top: arg 1: expected native")
			}
			arg0Val.ScrollToTop()
			return arg0
		},
	},
	"ptr-widget-table//scroll-to-trailing": {
		Doc:   "(*widget.Table).ScrollToTrailing",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to-trailing: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//scroll-to-trailing: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//scroll-to-trailing: arg 1: expected native")
			}
			arg0Val.ScrollToTrailing()
			return arg0
		},
	},
	"ptr-widget-table//select": {
		Doc:   "(*widget.Table).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//select: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//select: arg 1: expected native")
			}
			var arg1Val widget.TableCellID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//select: arg 2: expected native of type widget.TableCellID")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//select: arg 2: expected native")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//set-column-width": {
		Doc:   "(*widget.Table).SetColumnWidth",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//set-column-width: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//set-column-width: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//set-column-width: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//set-column-width: arg 2: expected integer")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//set-column-width: arg 3: expected decimal")
			}
			arg0Val.SetColumnWidth(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-table//set-row-height": {
		Doc:   "(*widget.Table).SetRowHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//set-row-height: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//set-row-height: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//set-row-height: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//set-row-height: arg 2: expected integer")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//set-row-height: arg 3: expected decimal")
			}
			arg0Val.SetRowHeight(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-table//show": {
		Doc:   "(*widget.Table).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-table//show-header-column!": {
		Doc:   "Set *widget.Table ShowHeaderColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show-header-column!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show-header-column!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//show-header-column!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowHeaderColumn = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//show-header-column!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-table//show-header-column?": {
		Doc:   "Get *widget.Table ShowHeaderColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show-header-column?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show-header-column?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//show-header-column?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowHeaderColumn))
			return resObj
		},
	},
	"ptr-widget-table//show-header-row!": {
		Doc:   "Set *widget.Table ShowHeaderRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show-header-row!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show-header-row!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//show-header-row!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowHeaderRow = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//show-header-row!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-table//show-header-row?": {
		Doc:   "Get *widget.Table ShowHeaderRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show-header-row?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//show-header-row?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//show-header-row?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowHeaderRow))
			return resObj
		},
	},
	"ptr-widget-table//size": {
		Doc:   "(*widget.Table).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//size: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-table//sticky-column-count!": {
		Doc:   "Set *widget.Table StickyColumnCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//sticky-column-count!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//sticky-column-count!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//sticky-column-count!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StickyColumnCount = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//sticky-column-count!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-table//sticky-column-count?": {
		Doc:   "Get *widget.Table StickyColumnCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//sticky-column-count?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//sticky-column-count?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//sticky-column-count?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StickyColumnCount))
			return resObj
		},
	},
	"ptr-widget-table//sticky-row-count!": {
		Doc:   "Set *widget.Table StickyRowCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//sticky-row-count!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//sticky-row-count!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//sticky-row-count!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StickyRowCount = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//sticky-row-count!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-table//sticky-row-count?": {
		Doc:   "Get *widget.Table StickyRowCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//sticky-row-count?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//sticky-row-count?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//sticky-row-count?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StickyRowCount))
			return resObj
		},
	},
	"ptr-widget-table//tapped": {
		Doc:   "(*widget.Table).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//tapped: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//tapped: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//tapped: arg 1: expected native")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//tapped: arg 2: expected native of type *fyne.PointEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//tapped: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//tapped: arg 2: expected native")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//touch-cancel": {
		Doc:   "(*widget.Table).TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-cancel: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-cancel: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//touch-cancel: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-cancel: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-cancel: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//touch-cancel: arg 2: expected native")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//touch-down": {
		Doc:   "(*widget.Table).TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-down: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-down: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//touch-down: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-down: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-down: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//touch-down: arg 2: expected native")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//touch-up": {
		Doc:   "(*widget.Table).TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-up: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//touch-up: arg 1: expected native")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-up: arg 2: expected native of type *mobile.TouchEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//touch-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//touch-up: arg 2: expected native")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//typed-key": {
		Doc:   "(*widget.Table).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//typed-key: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//typed-rune": {
		Doc:   "(*widget.Table).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//typed-rune: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//unselect": {
		Doc:   "(*widget.Table).Unselect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//unselect: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//unselect: arg 1: expected native")
			}
			var arg1Val widget.TableCellID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//unselect: arg 2: expected native of type widget.TableCellID")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//unselect: arg 2: expected native")
			}
			arg0Val.Unselect(arg1Val)
			return arg0
		},
	},
	"ptr-widget-table//unselect-all": {
		Doc:   "(*widget.Table).UnselectAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//unselect-all: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//unselect-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//unselect-all: arg 1: expected native")
			}
			arg0Val.UnselectAll()
			return arg0
		},
	},
	"ptr-widget-table//update-cell!": {
		Doc:   "Set *widget.Table UpdateCell value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-cell!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-cell!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//update-cell!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-cell!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.UpdateCell = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-cell!: arg 2: expected integer to be 0 or nil")
				}
				self.UpdateCell = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//update-cell!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-table//update-cell?": {
		Doc:   "Get *widget.Table UpdateCell value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-cell?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-cell?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//update-cell?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateCell, "func(widget-table-cell-id_fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-table//update-header!": {
		Doc:   "Set *widget.Table UpdateHeader value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-header!: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-header!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//update-header!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-header!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.UpdateHeader = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-header!: arg 2: expected integer to be 0 or nil")
				}
				self.UpdateHeader = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//update-header!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-table//update-header?": {
		Doc:   "Get *widget.Table UpdateHeader value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-header?: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//update-header?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//update-header?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateHeader, "func(widget-table-cell-id_fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-table//visible": {
		Doc:   "(*widget.Table).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//visible: arg 1: expected native of type *widget.Table")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-table//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-table//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-text-grid-cell//rune!": {
		Doc:   "Set *widget.TextGridCell Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//rune!: arg 1: expected native of type *widget.TextGridCell")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//rune!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-cell//rune!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//rune!: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-cell//rune!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-text-grid-cell//rune?": {
		Doc:   "Get *widget.TextGridCell Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//rune?: arg 1: expected native of type *widget.TextGridCell")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//rune?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-cell//rune?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"ptr-widget-text-grid-cell//style!": {
		Doc:   "Set *widget.TextGridCell Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//style!: arg 1: expected native of type *widget.TextGridCell")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-cell//style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//style!: arg 2: expected native of type widget.TextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//style!: arg 2: expected integer to be 0 or nil")
				}
				self.Style = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-cell//style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-text-grid-cell//style?": {
		Doc:   "Get *widget.TextGridCell Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//style?: arg 1: expected native of type *widget.TextGridCell")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-cell//style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-cell//style?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Style)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Style, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Style, "widget-text-grid-style")
				}
			}
			return resObj
		},
	},
	"ptr-widget-text-grid-row//cells!": {
		Doc:   "Set *widget.TextGridRow Cells value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//cells!: arg 1: expected native of type *widget.TextGridRow")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//cells!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-row//cells!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cells = make([]widget.TextGridCell, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Cells[i], ok = v.Value.(widget.TextGridCell)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-text-grid-row//cells!: arg 2: block item: expected native of type widget.TextGridCell")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-text-grid-row//cells!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Cells, ok = v.Value.([]widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//cells!: arg 2: expected native of type []widget.TextGridCell")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//cells!: arg 2: expected integer to be 0 or nil")
				}
				self.Cells = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-row//cells!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-text-grid-row//cells?": {
		Doc:   "Get *widget.TextGridRow Cells value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//cells?: arg 1: expected native of type *widget.TextGridRow")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//cells?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-row//cells?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cells))
				for i, it := range self.Cells {
					items[i] = *env.NewNative(ps.Idx, it, "widget-text-grid-cell")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-text-grid-row//style!": {
		Doc:   "Set *widget.TextGridRow Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//style!: arg 1: expected native of type *widget.TextGridRow")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-row//style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//style!: arg 2: expected native of type widget.TextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//style!: arg 2: expected integer to be 0 or nil")
				}
				self.Style = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-row//style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-text-grid-row//style?": {
		Doc:   "Get *widget.TextGridRow Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//style?: arg 1: expected native of type *widget.TextGridRow")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid-row//style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid-row//style?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Style)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Style, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Style, "widget-text-grid-style")
				}
			}
			return resObj
		},
	},
	"ptr-widget-text-grid//create-renderer": {
		Doc:   "(*widget.TextGrid).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//create-renderer: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-text-grid//extend-base-widget": {
		Doc:   "(*widget.TextGrid).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//extend-base-widget: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-text-grid//hidden!": {
		Doc:   "Set *widget.TextGrid Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//hidden!: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-text-grid//hidden?": {
		Doc:   "Get *widget.TextGrid Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//hidden?: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-text-grid//hide": {
		Doc:   "(*widget.TextGrid).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//hide: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-text-grid//min-size": {
		Doc:   "(*widget.TextGrid).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//min-size: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-text-grid//move": {
		Doc:   "(*widget.TextGrid).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//move: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-text-grid//position": {
		Doc:   "(*widget.TextGrid).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//position: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-text-grid//refresh": {
		Doc:   "(*widget.TextGrid).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//refresh: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-text-grid//resize": {
		Doc:   "(*widget.TextGrid).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//resize: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-text-grid//row": {
		Doc:   "(*widget.TextGrid).Row",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//row: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//row: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//row: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//row: arg 2: expected integer")
			}
			res0 := arg0Val.Row(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-text-grid-row")
			return res0Obj
		},
	},
	"ptr-widget-text-grid//row-text": {
		Doc:   "(*widget.TextGrid).RowText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//row-text: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//row-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//row-text: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//row-text: arg 2: expected integer")
			}
			res0 := arg0Val.RowText(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-text-grid//rows!": {
		Doc:   "Set *widget.TextGrid Rows value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//rows!: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//rows!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//rows!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Rows = make([]widget.TextGridRow, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Rows[i], ok = v.Value.(widget.TextGridRow)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-text-grid//rows!: arg 2: block item: expected native of type widget.TextGridRow")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-text-grid//rows!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Rows, ok = v.Value.([]widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//rows!: arg 2: expected native of type []widget.TextGridRow")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//rows!: arg 2: expected integer to be 0 or nil")
				}
				self.Rows = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//rows!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-text-grid//rows?": {
		Doc:   "Get *widget.TextGrid Rows value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//rows?: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//rows?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//rows?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Rows))
				for i, it := range self.Rows {
					items[i] = *env.NewNative(ps.Idx, it, "widget-text-grid-row")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-text-grid//set-cell": {
		Doc:   "(*widget.TextGrid).SetCell",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-cell: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-cell: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-cell: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-cell: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-cell: arg 3: expected integer")
			}
			var arg3Val widget.TextGridCell
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-cell: arg 4: expected native of type widget.TextGridCell")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-cell: arg 4: expected native")
			}
			arg0Val.SetCell(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-widget-text-grid//set-row": {
		Doc:   "(*widget.TextGrid).SetRow",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-row: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-row: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-row: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-row: arg 2: expected integer")
			}
			var arg2Val widget.TextGridRow
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-row: arg 3: expected native of type widget.TextGridRow")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-row: arg 3: expected native")
			}
			arg0Val.SetRow(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-text-grid//set-row-style": {
		Doc:   "(*widget.TextGrid).SetRowStyle",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-row-style: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-row-style: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-row-style: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-row-style: arg 2: expected integer")
			}
			var arg2Val widget.TextGridStyle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-row-style: arg 3: expected native of type widget.TextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-row-style: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-row-style: arg 3: expected native")
			}
			arg0Val.SetRowStyle(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-text-grid//set-rune": {
		Doc:   "(*widget.TextGrid).SetRune",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-rune: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-rune: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-rune: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-rune: arg 3: expected integer")
			}
			var arg3Val rune
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-rune: arg 4: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-rune: arg 4: expected native")
			}
			arg0Val.SetRune(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-widget-text-grid//set-style": {
		Doc:   "(*widget.TextGrid).SetStyle",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-style: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-style: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-style: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-style: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-style: arg 3: expected integer")
			}
			var arg3Val widget.TextGridStyle
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-style: arg 4: expected native of type widget.TextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-style: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-style: arg 4: expected native")
			}
			arg0Val.SetStyle(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-widget-text-grid//set-text": {
		Doc:   "(*widget.TextGrid).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-text: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-widget-text-grid//show": {
		Doc:   "(*widget.TextGrid).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-text-grid//show-line-numbers!": {
		Doc:   "Set *widget.TextGrid ShowLineNumbers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show-line-numbers!: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show-line-numbers!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//show-line-numbers!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowLineNumbers = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//show-line-numbers!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-text-grid//show-line-numbers?": {
		Doc:   "Get *widget.TextGrid ShowLineNumbers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show-line-numbers?: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show-line-numbers?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//show-line-numbers?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowLineNumbers))
			return resObj
		},
	},
	"ptr-widget-text-grid//show-whitespace!": {
		Doc:   "Set *widget.TextGrid ShowWhitespace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show-whitespace!: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show-whitespace!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//show-whitespace!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowWhitespace = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//show-whitespace!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-text-grid//show-whitespace?": {
		Doc:   "Get *widget.TextGrid ShowWhitespace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show-whitespace?: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//show-whitespace?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//show-whitespace?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowWhitespace))
			return resObj
		},
	},
	"ptr-widget-text-grid//size": {
		Doc:   "(*widget.TextGrid).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//size: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-text-grid//tab-width!": {
		Doc:   "Set *widget.TextGrid TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//tab-width!: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//tab-width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//tab-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//tab-width!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-text-grid//tab-width?": {
		Doc:   "Get *widget.TextGrid TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//tab-width?: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//tab-width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//tab-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"ptr-widget-text-grid//text": {
		Doc:   "(*widget.TextGrid).Text",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//text: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//text: arg 1: expected native")
			}
			res0 := arg0Val.Text()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-text-grid//visible": {
		Doc:   "(*widget.TextGrid).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//visible: arg 1: expected native of type *widget.TextGrid")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-grid//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-grid//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-text-segment//inline": {
		Doc:   "(*widget.TextSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//inline: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//inline: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//inline: arg 1: expected native")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-text-segment//select": {
		Doc:   "(*widget.TextSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//select: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//select: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//select: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//select: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//select: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//select: arg 3: expected native")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-widget-text-segment//selected-text": {
		Doc:   "(*widget.TextSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//selected-text: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-text-segment//style!": {
		Doc:   "Set *widget.TextSegment Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//style!: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//style!: arg 2: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-text-segment//style?": {
		Doc:   "Get *widget.TextSegment Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//style?: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "widget-rich-text-style")
			return resObj
		},
	},
	"ptr-widget-text-segment//text!": {
		Doc:   "Set *widget.TextSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//text!: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"ptr-widget-text-segment//text?": {
		Doc:   "Get *widget.TextSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//text?: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-widget-text-segment//textual": {
		Doc:   "(*widget.TextSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//textual: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//textual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//textual: arg 1: expected native")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-widget-text-segment//unselect": {
		Doc:   "(*widget.TextSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//unselect: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//unselect: arg 1: expected native")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-widget-text-segment//update": {
		Doc:   "(*widget.TextSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//update: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//update: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//update: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//update: arg 2: expected native")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-widget-text-segment//visual": {
		Doc:   "(*widget.TextSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//visual: arg 1: expected native of type *widget.TextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-text-segment//visual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-text-segment//visual: arg 1: expected native")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-toolbar-action//icon!": {
		Doc:   "Set *widget.ToolbarAction Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//icon!: arg 1: expected native of type *widget.ToolbarAction")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//icon!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-action//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-action//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-toolbar-action//icon?": {
		Doc:   "Get *widget.ToolbarAction Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//icon?: arg 1: expected native of type *widget.ToolbarAction")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//icon?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-action//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"ptr-widget-toolbar-action//on-activated!": {
		Doc:   "Set *widget.ToolbarAction OnActivated value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//on-activated!: arg 1: expected native of type *widget.ToolbarAction")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//on-activated!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-action//on-activated!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//on-activated!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnActivated = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//on-activated!: arg 2: expected integer to be 0 or nil")
				}
				self.OnActivated = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-action//on-activated!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-toolbar-action//on-activated?": {
		Doc:   "Get *widget.ToolbarAction OnActivated value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//on-activated?: arg 1: expected native of type *widget.ToolbarAction")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//on-activated?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-action//on-activated?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnActivated, "func()")
			return resObj
		},
	},
	"ptr-widget-toolbar-action//set-icon": {
		Doc:   "(*widget.ToolbarAction).SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//set-icon: arg 1: expected native of type *widget.ToolbarAction")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//set-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-action//set-icon: arg 1: expected native")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//set-icon: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//set-icon: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-action//set-icon: arg 2: expected native")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"ptr-widget-toolbar-action//toolbar-object": {
		Doc:   "(*widget.ToolbarAction).ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//toolbar-object: arg 1: expected native of type *widget.ToolbarAction")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-action//toolbar-object: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-action//toolbar-object: arg 1: expected native")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-toolbar-separator//toolbar-object": {
		Doc:   "(*widget.ToolbarSeparator).ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarSeparator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarSeparator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-separator//toolbar-object: arg 1: expected native of type *widget.ToolbarSeparator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-separator//toolbar-object: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-separator//toolbar-object: arg 1: expected native")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-toolbar-spacer//toolbar-object": {
		Doc:   "(*widget.ToolbarSpacer).ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarSpacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarSpacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-spacer//toolbar-object: arg 1: expected native of type *widget.ToolbarSpacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar-spacer//toolbar-object: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar-spacer//toolbar-object: arg 1: expected native")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-toolbar//append": {
		Doc:   "(*widget.Toolbar).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//append: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//append: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//append: arg 1: expected native")
			}
			var arg1Val widget.ToolbarItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ToolbarItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//append: arg 2: expected native of type widget.ToolbarItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//append: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//append: arg 2: expected native")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-widget-toolbar//create-renderer": {
		Doc:   "(*widget.Toolbar).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//create-renderer: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-toolbar//extend-base-widget": {
		Doc:   "(*widget.Toolbar).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//extend-base-widget: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-toolbar//hidden!": {
		Doc:   "Set *widget.Toolbar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//hidden!: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-toolbar//hidden?": {
		Doc:   "Get *widget.Toolbar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//hidden?: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-toolbar//hide": {
		Doc:   "(*widget.Toolbar).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//hide: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-toolbar//items!": {
		Doc:   "Set *widget.Toolbar Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//items!: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//items!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.ToolbarItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.ToolbarItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-toolbar//items!: arg 2: block item: expected native of type widget.ToolbarItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("ptr-widget-toolbar//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("ptr-widget-toolbar//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.ToolbarItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//items!: arg 2: expected native of type []widget.ToolbarItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"ptr-widget-toolbar//items?": {
		Doc:   "Get *widget.Toolbar Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//items?: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//items?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-toolbar-item")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-widget-toolbar//min-size": {
		Doc:   "(*widget.Toolbar).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//min-size: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-toolbar//move": {
		Doc:   "(*widget.Toolbar).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//move: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-toolbar//position": {
		Doc:   "(*widget.Toolbar).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//position: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-toolbar//prepend": {
		Doc:   "(*widget.Toolbar).Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//prepend: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//prepend: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//prepend: arg 1: expected native")
			}
			var arg1Val widget.ToolbarItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ToolbarItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//prepend: arg 2: expected native of type widget.ToolbarItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//prepend: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//prepend: arg 2: expected native")
			}
			arg0Val.Prepend(arg1Val)
			return arg0
		},
	},
	"ptr-widget-toolbar//refresh": {
		Doc:   "(*widget.Toolbar).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//refresh: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-toolbar//resize": {
		Doc:   "(*widget.Toolbar).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//resize: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-toolbar//show": {
		Doc:   "(*widget.Toolbar).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//show: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-toolbar//size": {
		Doc:   "(*widget.Toolbar).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//size: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-toolbar//visible": {
		Doc:   "(*widget.Toolbar).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//visible: arg 1: expected native of type *widget.Toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-toolbar//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-toolbar//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-tree//child-ui-ds!": {
		Doc:   "Set *widget.Tree ChildUIDs value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//child-ui-ds!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//child-ui-ds!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//child-ui-ds!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//child-ui-ds!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.ChildUIDs = func(arg0 widget.TreeNodeID) []widget.TreeNodeID {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res []widget.TreeNodeID
					switch v := ps.Res.(type) {
					case env.Block:
						res = make([]widget.TreeNodeID, len(v.Series.S))
						for i, it := range v.Series.S {
							{
								nat, natOk := it.(env.Native)
								var natValOk bool
								var natVal widget.TreeNodeID
								if natOk {
									natVal, natValOk = nat.Value.(widget.TreeNodeID)
								}
								if natOk && natValOk {
									res[i] = natVal
								} else {
									var u string
									if v, ok := it.(env.String); ok {
										u = string(v.Value)
									} else {
										// TODO: Cannot return error from function
									}
									res[i] = widget.TreeNodeID(u)
								}
							}
						}
					case env.Native:
						var ok bool
						res, ok = v.Value.([]widget.TreeNodeID)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//child-ui-ds!: arg 2: expected integer to be 0 or nil")
				}
				self.ChildUIDs = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//child-ui-ds!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-tree//child-ui-ds?": {
		Doc:   "Get *widget.Tree ChildUIDs value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//child-ui-ds?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//child-ui-ds?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//child-ui-ds?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildUIDs, "func(widget-tree-node-id)_(arr-widget-tree-node-id)")
			return resObj
		},
	},
	"ptr-widget-tree//close-all-branches": {
		Doc:   "(*widget.Tree).CloseAllBranches",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//close-all-branches: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//close-all-branches: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//close-all-branches: arg 1: expected native")
			}
			arg0Val.CloseAllBranches()
			return arg0
		},
	},
	"ptr-widget-tree//close-branch": {
		Doc:   "(*widget.Tree).CloseBranch",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//close-branch: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//close-branch: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//close-branch: arg 1: expected native")
			}
			var arg1Val widget.TreeNodeID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.TreeNodeID
				if natOk {
					natVal, natValOk = nat.Value.(widget.TreeNodeID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-tree//close-branch: arg 2: expected string")
					}
					arg1Val = widget.TreeNodeID(u)
				}
			}
			arg0Val.CloseBranch(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//create-node!": {
		Doc:   "Set *widget.Tree CreateNode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//create-node!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//create-node!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//create-node!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//create-node!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.CreateNode = func(arg0 bool) fyne.CanvasObject {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//create-node!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateNode = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//create-node!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-tree//create-node?": {
		Doc:   "Get *widget.Tree CreateNode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//create-node?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//create-node?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//create-node?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateNode, "func(bool)_(fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-tree//create-renderer": {
		Doc:   "(*widget.Tree).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//create-renderer: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//create-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//create-renderer: arg 1: expected native")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"ptr-widget-tree//extend-base-widget": {
		Doc:   "(*widget.Tree).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//extend-base-widget: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//extend-base-widget: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//extend-base-widget: arg 1: expected native")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//extend-base-widget: arg 2: expected native of type fyne.Widget")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//extend-base-widget: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//extend-base-widget: arg 2: expected native")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//focus-gained": {
		Doc:   "(*widget.Tree).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//focus-gained: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//focus-gained: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//focus-gained: arg 1: expected native")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-widget-tree//focus-lost": {
		Doc:   "(*widget.Tree).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//focus-lost: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//focus-lost: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//focus-lost: arg 1: expected native")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-widget-tree//hidden!": {
		Doc:   "Set *widget.Tree Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//hidden!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//hidden!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"ptr-widget-tree//hidden?": {
		Doc:   "Get *widget.Tree Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//hidden?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//hidden?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-widget-tree//hide": {
		Doc:   "(*widget.Tree).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//hide: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//hide: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//hide: arg 1: expected native")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-widget-tree//is-branch!": {
		Doc:   "Set *widget.Tree IsBranch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//is-branch!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//is-branch!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//is-branch!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//is-branch!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.IsBranch = func(arg0 widget.TreeNodeID) bool {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//is-branch!: arg 2: expected integer to be 0 or nil")
				}
				self.IsBranch = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//is-branch!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-tree//is-branch-open": {
		Doc:   "(*widget.Tree).IsBranchOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//is-branch-open: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//is-branch-open: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//is-branch-open: arg 1: expected native")
			}
			var arg1Val widget.TreeNodeID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.TreeNodeID
				if natOk {
					natVal, natValOk = nat.Value.(widget.TreeNodeID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-tree//is-branch-open: arg 2: expected string")
					}
					arg1Val = widget.TreeNodeID(u)
				}
			}
			res0 := arg0Val.IsBranchOpen(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-widget-tree//is-branch?": {
		Doc:   "Get *widget.Tree IsBranch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//is-branch?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//is-branch?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//is-branch?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.IsBranch, "func(widget-tree-node-id)_(bool)")
			return resObj
		},
	},
	"ptr-widget-tree//min-size": {
		Doc:   "(*widget.Tree).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//min-size: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//min-size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//min-size: arg 1: expected native")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-tree//move": {
		Doc:   "(*widget.Tree).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//move: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//move: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//move: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//move: arg 2: expected native")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//on-branch-closed!": {
		Doc:   "Set *widget.Tree OnBranchClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-closed!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-closed!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-branch-closed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-closed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnBranchClosed = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-closed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnBranchClosed = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-branch-closed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-tree//on-branch-closed?": {
		Doc:   "Get *widget.Tree OnBranchClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-closed?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-closed?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-branch-closed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnBranchClosed, "func(widget-tree-node-id)")
			return resObj
		},
	},
	"ptr-widget-tree//on-branch-opened!": {
		Doc:   "Set *widget.Tree OnBranchOpened value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-opened!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-opened!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-branch-opened!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-opened!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnBranchOpened = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-opened!: arg 2: expected integer to be 0 or nil")
				}
				self.OnBranchOpened = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-branch-opened!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-tree//on-branch-opened?": {
		Doc:   "Get *widget.Tree OnBranchOpened value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-opened?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-branch-opened?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-branch-opened?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnBranchOpened, "func(widget-tree-node-id)")
			return resObj
		},
	},
	"ptr-widget-tree//on-selected!": {
		Doc:   "Set *widget.Tree OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-selected!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-tree//on-selected?": {
		Doc:   "Get *widget.Tree OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-selected?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(widget-tree-node-id)")
			return resObj
		},
	},
	"ptr-widget-tree//on-unselected!": {
		Doc:   "Set *widget.Tree OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-unselected!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-unselected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"ptr-widget-tree//on-unselected?": {
		Doc:   "Get *widget.Tree OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-unselected?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//on-unselected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(widget-tree-node-id)")
			return resObj
		},
	},
	"ptr-widget-tree//open-all-branches": {
		Doc:   "(*widget.Tree).OpenAllBranches",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//open-all-branches: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//open-all-branches: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//open-all-branches: arg 1: expected native")
			}
			arg0Val.OpenAllBranches()
			return arg0
		},
	},
	"ptr-widget-tree//open-branch": {
		Doc:   "(*widget.Tree).OpenBranch",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//open-branch: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//open-branch: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//open-branch: arg 1: expected native")
			}
			var arg1Val widget.TreeNodeID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.TreeNodeID
				if natOk {
					natVal, natValOk = nat.Value.(widget.TreeNodeID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-tree//open-branch: arg 2: expected string")
					}
					arg1Val = widget.TreeNodeID(u)
				}
			}
			arg0Val.OpenBranch(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//position": {
		Doc:   "(*widget.Tree).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//position: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//position: arg 1: expected native")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"ptr-widget-tree//refresh": {
		Doc:   "(*widget.Tree).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//refresh: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//refresh: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//refresh: arg 1: expected native")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-widget-tree//refresh-item": {
		Doc:   "(*widget.Tree).RefreshItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//refresh-item: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//refresh-item: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//refresh-item: arg 1: expected native")
			}
			var arg1Val widget.TreeNodeID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.TreeNodeID
				if natOk {
					natVal, natValOk = nat.Value.(widget.TreeNodeID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-tree//refresh-item: arg 2: expected string")
					}
					arg1Val = widget.TreeNodeID(u)
				}
			}
			arg0Val.RefreshItem(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//resize": {
		Doc:   "(*widget.Tree).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//resize: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//resize: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//resize: arg 1: expected native")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//resize: arg 2: expected native of type fyne.Size")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//resize: arg 2: expected native")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//root!": {
		Doc:   "Set *widget.Tree Root value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//root!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//root!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//root!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.TreeNodeID
				if natOk {
					natVal, natValOk = nat.Value.(widget.TreeNodeID)
				}
				if natOk && natValOk {
					self.Root = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-tree//root!: arg 2: expected string")
					}
					self.Root = widget.TreeNodeID(u)
				}
			}
			return arg0
		},
	},
	"ptr-widget-tree//root?": {
		Doc:   "Get *widget.Tree Root value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//root?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//root?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//root?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.Root))
			return resObj
		},
	},
	"ptr-widget-tree//scroll-to": {
		Doc:   "(*widget.Tree).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//scroll-to: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//scroll-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//scroll-to: arg 1: expected native")
			}
			var arg1Val widget.TreeNodeID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.TreeNodeID
				if natOk {
					natVal, natValOk = nat.Value.(widget.TreeNodeID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-tree//scroll-to: arg 2: expected string")
					}
					arg1Val = widget.TreeNodeID(u)
				}
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//scroll-to-bottom": {
		Doc:   "(*widget.Tree).ScrollToBottom",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//scroll-to-bottom: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//scroll-to-bottom: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//scroll-to-bottom: arg 1: expected native")
			}
			arg0Val.ScrollToBottom()
			return arg0
		},
	},
	"ptr-widget-tree//scroll-to-top": {
		Doc:   "(*widget.Tree).ScrollToTop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//scroll-to-top: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//scroll-to-top: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//scroll-to-top: arg 1: expected native")
			}
			arg0Val.ScrollToTop()
			return arg0
		},
	},
	"ptr-widget-tree//select": {
		Doc:   "(*widget.Tree).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//select: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//select: arg 1: expected native")
			}
			var arg1Val widget.TreeNodeID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.TreeNodeID
				if natOk {
					natVal, natValOk = nat.Value.(widget.TreeNodeID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-tree//select: arg 2: expected string")
					}
					arg1Val = widget.TreeNodeID(u)
				}
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//show": {
		Doc:   "(*widget.Tree).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//show: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//show: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//show: arg 1: expected native")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-widget-tree//size": {
		Doc:   "(*widget.Tree).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//size: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"ptr-widget-tree//toggle-branch": {
		Doc:   "(*widget.Tree).ToggleBranch",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//toggle-branch: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//toggle-branch: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//toggle-branch: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//toggle-branch: arg 2: expected string")
			}
			arg0Val.ToggleBranch(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//typed-key": {
		Doc:   "(*widget.Tree).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//typed-key: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//typed-key: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//typed-key: arg 1: expected native")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//typed-key: arg 2: expected native of type *fyne.KeyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//typed-key: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//typed-key: arg 2: expected native")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//typed-rune": {
		Doc:   "(*widget.Tree).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//typed-rune: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//typed-rune: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//typed-rune: arg 1: expected native")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//typed-rune: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//typed-rune: arg 2: expected native")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//unselect": {
		Doc:   "(*widget.Tree).Unselect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//unselect: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//unselect: arg 1: expected native")
			}
			var arg1Val widget.TreeNodeID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.TreeNodeID
				if natOk {
					natVal, natValOk = nat.Value.(widget.TreeNodeID)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("ptr-widget-tree//unselect: arg 2: expected string")
					}
					arg1Val = widget.TreeNodeID(u)
				}
			}
			arg0Val.Unselect(arg1Val)
			return arg0
		},
	},
	"ptr-widget-tree//unselect-all": {
		Doc:   "(*widget.Tree).UnselectAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//unselect-all: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//unselect-all: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//unselect-all: arg 1: expected native")
			}
			arg0Val.UnselectAll()
			return arg0
		},
	},
	"ptr-widget-tree//update-node!": {
		Doc:   "Set *widget.Tree UpdateNode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//update-node!: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//update-node!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//update-node!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.UpdateNode, ok = v.Value.(func(widget.TreeNodeID, bool, fyne.CanvasObject))
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//update-node!: arg 2: expected native of type func(widget.TreeNodeID, bool, fyne.CanvasObject)")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//update-node!: arg 2: expected native")
			}
			return arg0
		},
	},
	"ptr-widget-tree//update-node?": {
		Doc:   "Get *widget.Tree UpdateNode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//update-node?: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//update-node?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//update-node?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateNode, "func(widget-tree-node-id_bool_fyne-canvas-object)")
			return resObj
		},
	},
	"ptr-widget-tree//visible": {
		Doc:   "(*widget.Tree).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//visible: arg 1: expected native of type *widget.Tree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("ptr-widget-tree//visible: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("ptr-widget-tree//visible: arg 1: expected native")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"repository-copyable-repository//copy": {
		Doc:   "repository.CopyableRepository.Copy",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.CopyableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.CopyableRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-copyable-repository//copy: arg 1: expected native of type repository.CopyableRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-copyable-repository//copy: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-copyable-repository//copy: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-copyable-repository//copy: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-copyable-repository//copy: arg 2: expected native")
			}
			var arg2Val fyne.URI
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-copyable-repository//copy: arg 3: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-copyable-repository//copy: arg 3: expected native")
			}
			res0 := arg0Val.Copy(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-custom-uri-repository//parse-uri": {
		Doc:   "repository.CustomURIRepository.ParseURI",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.CustomURIRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.CustomURIRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-custom-uri-repository//parse-uri: arg 1: expected native of type repository.CustomURIRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-custom-uri-repository//parse-uri: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-custom-uri-repository//parse-uri: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("repository-custom-uri-repository//parse-uri: arg 2: expected string")
			}
			res0, res1 := arg0Val.ParseURI(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-for-scheme": {
		Doc:   "repository.ForScheme",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("repository-for-scheme: arg 1: expected string")
			}
			res0, res1 := repository.ForScheme(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "repository-repository")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-for-uri": {
		Doc:   "repository.ForURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-for-uri: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-for-uri: arg 1: expected native")
			}
			res0, res1 := repository.ForURI(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "repository-repository")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-generic-child": {
		Doc:   "repository.GenericChild",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-generic-child: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-generic-child: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("repository-generic-child: arg 2: expected string")
			}
			res0, res1 := repository.GenericChild(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-generic-copy": {
		Doc:   "repository.GenericCopy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-generic-copy: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-generic-copy: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-generic-copy: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-generic-copy: arg 2: expected native")
			}
			res0 := repository.GenericCopy(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-generic-move": {
		Doc:   "repository.GenericMove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-generic-move: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-generic-move: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-generic-move: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-generic-move: arg 2: expected native")
			}
			res0 := repository.GenericMove(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-generic-parent": {
		Doc:   "repository.GenericParent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-generic-parent: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-generic-parent: arg 1: expected native")
			}
			res0, res1 := repository.GenericParent(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-hierarchical-repository//child": {
		Doc:   "repository.HierarchicalRepository.Child",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.HierarchicalRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.HierarchicalRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-hierarchical-repository//child: arg 1: expected native of type repository.HierarchicalRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-hierarchical-repository//child: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-hierarchical-repository//child: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-hierarchical-repository//child: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-hierarchical-repository//child: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("repository-hierarchical-repository//child: arg 3: expected string")
			}
			res0, res1 := arg0Val.Child(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-hierarchical-repository//parent": {
		Doc:   "repository.HierarchicalRepository.Parent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.HierarchicalRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.HierarchicalRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-hierarchical-repository//parent: arg 1: expected native of type repository.HierarchicalRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-hierarchical-repository//parent: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-hierarchical-repository//parent: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-hierarchical-repository//parent: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-hierarchical-repository//parent: arg 2: expected native")
			}
			res0, res1 := arg0Val.Parent(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-listable-repository//can-list": {
		Doc:   "repository.ListableRepository.CanList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.ListableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.ListableRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-listable-repository//can-list: arg 1: expected native of type repository.ListableRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-listable-repository//can-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-listable-repository//can-list: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-listable-repository//can-list: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-listable-repository//can-list: arg 2: expected native")
			}
			res0, res1 := arg0Val.CanList(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-listable-repository//create-listable": {
		Doc:   "repository.ListableRepository.CreateListable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.ListableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.ListableRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-listable-repository//create-listable: arg 1: expected native of type repository.ListableRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-listable-repository//create-listable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-listable-repository//create-listable: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-listable-repository//create-listable: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-listable-repository//create-listable: arg 2: expected native")
			}
			res0 := arg0Val.CreateListable(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-listable-repository//list": {
		Doc:   "repository.ListableRepository.List",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.ListableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.ListableRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-listable-repository//list: arg 1: expected native of type repository.ListableRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-listable-repository//list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-listable-repository//list: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-listable-repository//list: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-listable-repository//list: arg 2: expected native")
			}
			res0, res1 := arg0Val.List(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "fyne-uri")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-movable-repository//move": {
		Doc:   "repository.MovableRepository.Move",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.MovableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.MovableRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-movable-repository//move: arg 1: expected native of type repository.MovableRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-movable-repository//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-movable-repository//move: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-movable-repository//move: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-movable-repository//move: arg 2: expected native")
			}
			var arg2Val fyne.URI
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-movable-repository//move: arg 3: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-movable-repository//move: arg 3: expected native")
			}
			res0 := arg0Val.Move(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-file-uri": {
		Doc:   "repository.NewFileURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("repository-file-uri: arg 1: expected string")
			}
			res0 := repository.NewFileURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			return res0Obj
		},
	},
	"repository-parse-uri": {
		Doc:   "repository.ParseURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("repository-parse-uri: arg 1: expected string")
			}
			res0, res1 := repository.ParseURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-register": {
		Doc:   "repository.Register",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("repository-register: arg 1: expected string")
			}
			var arg1Val repository.Repository
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(repository.Repository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-register: arg 2: expected native of type repository.Repository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-register: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-register: arg 2: expected native")
			}
			repository.Register(arg0Val, arg1Val)
			return nil
		},
	},
	"repository-repository//can-read": {
		Doc:   "repository.Repository.CanRead",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-repository//can-read: arg 1: expected native of type repository.Repository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-repository//can-read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-repository//can-read: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-repository//can-read: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-repository//can-read: arg 2: expected native")
			}
			res0, res1 := arg0Val.CanRead(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-repository//destroy": {
		Doc:   "repository.Repository.Destroy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-repository//destroy: arg 1: expected native of type repository.Repository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-repository//destroy: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-repository//destroy: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("repository-repository//destroy: arg 2: expected string")
			}
			arg0Val.Destroy(arg1Val)
			return arg0
		},
	},
	"repository-repository//exists": {
		Doc:   "repository.Repository.Exists",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-repository//exists: arg 1: expected native of type repository.Repository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-repository//exists: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-repository//exists: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-repository//exists: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-repository//exists: arg 2: expected native")
			}
			res0, res1 := arg0Val.Exists(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-repository//reader": {
		Doc:   "repository.Repository.Reader",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-repository//reader: arg 1: expected native of type repository.Repository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-repository//reader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-repository//reader: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-repository//reader: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-repository//reader: arg 2: expected native")
			}
			res0, res1 := arg0Val.Reader(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-writable-repository//can-write": {
		Doc:   "repository.WritableRepository.CanWrite",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.WritableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.WritableRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-writable-repository//can-write: arg 1: expected native of type repository.WritableRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-writable-repository//can-write: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-writable-repository//can-write: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-writable-repository//can-write: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-writable-repository//can-write: arg 2: expected native")
			}
			res0, res1 := arg0Val.CanWrite(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-writable-repository//delete": {
		Doc:   "repository.WritableRepository.Delete",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.WritableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.WritableRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-writable-repository//delete: arg 1: expected native of type repository.WritableRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-writable-repository//delete: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-writable-repository//delete: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-writable-repository//delete: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-writable-repository//delete: arg 2: expected native")
			}
			res0 := arg0Val.Delete(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-writable-repository//writer": {
		Doc:   "repository.WritableRepository.Writer",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.WritableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.WritableRepository)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-writable-repository//writer: arg 1: expected native of type repository.WritableRepository")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("repository-writable-repository//writer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("repository-writable-repository//writer: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("repository-writable-repository//writer: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("repository-writable-repository//writer: arg 2: expected native")
			}
			res0, res1 := arg0Val.Writer(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"software-render": {
		Doc:   "software.Render",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("software-render: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("software-render: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("software-render: arg 1: expected native")
			}
			var arg1Val fyne.Theme
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("software-render: arg 2: expected native of type fyne.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("software-render: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("software-render: arg 2: expected native")
			}
			res0 := software.Render(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"software-render-canvas": {
		Doc:   "software.RenderCanvas",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("software-render-canvas: arg 1: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("software-render-canvas: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("software-render-canvas: arg 1: expected native")
			}
			var arg1Val fyne.Theme
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("software-render-canvas: arg 2: expected native of type fyne.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("software-render-canvas: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("software-render-canvas: arg 2: expected native")
			}
			res0 := software.RenderCanvas(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"storage-can-list": {
		Doc:   "storage.CanList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-can-list: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-can-list: arg 1: expected native")
			}
			res0, res1 := storage.CanList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-can-read": {
		Doc:   "storage.CanRead",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-can-read: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-can-read: arg 1: expected native")
			}
			res0, res1 := storage.CanRead(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-can-write": {
		Doc:   "storage.CanWrite",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-can-write: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-can-write: arg 1: expected native")
			}
			res0, res1 := storage.CanWrite(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-child": {
		Doc:   "storage.Child",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-child: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-child: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("storage-child: arg 2: expected string")
			}
			res0, res1 := storage.Child(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-copy": {
		Doc:   "storage.Copy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-copy: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-copy: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-copy: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-copy: arg 2: expected native")
			}
			res0 := storage.Copy(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"storage-create-listable": {
		Doc:   "storage.CreateListable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-create-listable: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-create-listable: arg 1: expected native")
			}
			res0 := storage.CreateListable(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"storage-delete": {
		Doc:   "storage.Delete",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-delete: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-delete: arg 1: expected native")
			}
			res0 := storage.Delete(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"storage-exists": {
		Doc:   "storage.Exists",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-exists: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-exists: arg 1: expected native")
			}
			res0, res1 := storage.Exists(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-extension-file-filter//extensions!": {
		Doc:   "Set storage.ExtensionFileFilter Extensions value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.ExtensionFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-extension-file-filter//extensions!: arg 1: expected native of type storage.ExtensionFileFilter")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-extension-file-filter//extensions!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Extensions = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Extensions[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("storage-extension-file-filter//extensions!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Extensions, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-extension-file-filter//extensions!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("storage-extension-file-filter//extensions!: arg 2: expected integer to be 0 or nil")
				}
				self.Extensions = nil
			default:
				ps.FailureFlag = true
				return env.NewError("storage-extension-file-filter//extensions!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"storage-extension-file-filter//extensions?": {
		Doc:   "Get storage.ExtensionFileFilter Extensions value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.ExtensionFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-extension-file-filter//extensions?: arg 1: expected native of type storage.ExtensionFileFilter")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-extension-file-filter//extensions?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Extensions))
				for i, it := range self.Extensions {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"storage-file-filter//matches": {
		Doc:   "storage.FileFilter.Matches",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val storage.FileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(storage.FileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-file-filter//matches: arg 1: expected native of type storage.FileFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("storage-file-filter//matches: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("storage-file-filter//matches: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-file-filter//matches: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-file-filter//matches: arg 2: expected native")
			}
			res0 := arg0Val.Matches(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"storage-list": {
		Doc:   "storage.List",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-list: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-list: arg 1: expected native")
			}
			res0, res1 := storage.List(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "fyne-uri")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-lister-for-uri": {
		Doc:   "storage.ListerForURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-lister-for-uri: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-lister-for-uri: arg 1: expected native")
			}
			res0, res1 := storage.ListerForURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-listable-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-load-resource-from-uri": {
		Doc:   "storage.LoadResourceFromURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-load-resource-from-uri: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-load-resource-from-uri: arg 1: expected native")
			}
			res0, res1 := storage.LoadResourceFromURI(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-mime-type-file-filter//mime-types!": {
		Doc:   "Set storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.MimeTypeFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-mime-type-file-filter//mime-types!: arg 1: expected native of type storage.MimeTypeFileFilter")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-mime-type-file-filter//mime-types!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.MimeTypes = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.MimeTypes[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("storage-mime-type-file-filter//mime-types!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.MimeTypes, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-mime-type-file-filter//mime-types!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("storage-mime-type-file-filter//mime-types!: arg 2: expected integer to be 0 or nil")
				}
				self.MimeTypes = nil
			default:
				ps.FailureFlag = true
				return env.NewError("storage-mime-type-file-filter//mime-types!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"storage-mime-type-file-filter//mime-types?": {
		Doc:   "Get storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.MimeTypeFileFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-mime-type-file-filter//mime-types?: arg 1: expected native of type storage.MimeTypeFileFilter")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-mime-type-file-filter//mime-types?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.MimeTypes))
				for i, it := range self.MimeTypes {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"storage-move": {
		Doc:   "storage.Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-move: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-move: arg 1: expected native")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-move: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-move: arg 2: expected native")
			}
			res0 := storage.Move(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"storage-extension-file-filter": {
		Doc:   "storage.NewExtensionFileFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("storage-extension-file-filter: arg 1: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-extension-file-filter: arg 1: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("storage-extension-file-filter: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("storage-extension-file-filter: arg 1: expected block, native or nil")
			}
			res0 := storage.NewExtensionFileFilter(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "storage-file-filter")
				}
			}
			return res0Obj
		},
	},
	"storage-file-uri": {
		Doc:   "storage.NewFileURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("storage-file-uri: arg 1: expected string")
			}
			res0 := storage.NewFileURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			return res0Obj
		},
	},
	"storage-mime-type-file-filter": {
		Doc:   "storage.NewMimeTypeFileFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("storage-mime-type-file-filter: arg 1: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-mime-type-file-filter: arg 1: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("storage-mime-type-file-filter: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("storage-mime-type-file-filter: arg 1: expected block, native or nil")
			}
			res0 := storage.NewMimeTypeFileFilter(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "storage-file-filter")
				}
			}
			return res0Obj
		},
	},
	"storage-uri": {
		Doc:   "storage.NewURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("storage-uri: arg 1: expected string")
			}
			res0 := storage.NewURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			return res0Obj
		},
	},
	"storage-open-file-from-uri": {
		Doc:   "storage.OpenFileFromURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-open-file-from-uri: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-open-file-from-uri: arg 1: expected native")
			}
			res0, res1 := storage.OpenFileFromURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-parent": {
		Doc:   "storage.Parent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-parent: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-parent: arg 1: expected native")
			}
			res0, res1 := storage.Parent(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-parse-uri": {
		Doc:   "storage.ParseURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("storage-parse-uri: arg 1: expected string")
			}
			res0, res1 := storage.ParseURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-reader": {
		Doc:   "storage.Reader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-reader: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-reader: arg 1: expected native")
			}
			res0, res1 := storage.Reader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-save-file-to-uri": {
		Doc:   "storage.SaveFileToURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-save-file-to-uri: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-save-file-to-uri: arg 1: expected native")
			}
			res0, res1 := storage.SaveFileToURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-writer": {
		Doc:   "storage.Writer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("storage-writer: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("storage-writer: arg 1: expected native")
			}
			res0, res1 := storage.Writer(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"account-icon": {
		Doc:   "theme.AccountIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.AccountIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"background-color": {
		Doc:   "theme.BackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"broken-image-icon": {
		Doc:   "theme.BrokenImageIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.BrokenImageIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"button-color": {
		Doc:   "theme.ButtonColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"cancel-icon": {
		Doc:   "theme.CancelIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CancelIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"caption-text-size": {
		Doc:   "theme.CaptionTextSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CaptionTextSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"check-button-checked-icon": {
		Doc:   "theme.CheckButtonCheckedIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CheckButtonCheckedIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"check-button-icon": {
		Doc:   "theme.CheckButtonIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CheckButtonIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"color-achromatic-icon": {
		Doc:   "theme.ColorAchromaticIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ColorAchromaticIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"color-chromatic-icon": {
		Doc:   "theme.ColorChromaticIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ColorChromaticIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"color-name-background": {
		Doc:   "Get theme.ColorNameBackground value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameBackground))
			return resObj
		},
	},
	"color-name-button": {
		Doc:   "Get theme.ColorNameButton value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameButton))
			return resObj
		},
	},
	"color-name-disabled": {
		Doc:   "Get theme.ColorNameDisabled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameDisabled))
			return resObj
		},
	},
	"color-name-disabled-button": {
		Doc:   "Get theme.ColorNameDisabledButton value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameDisabledButton))
			return resObj
		},
	},
	"color-name-error": {
		Doc:   "Get theme.ColorNameError value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameError))
			return resObj
		},
	},
	"color-name-focus": {
		Doc:   "Get theme.ColorNameFocus value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameFocus))
			return resObj
		},
	},
	"color-name-foreground": {
		Doc:   "Get theme.ColorNameForeground value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameForeground))
			return resObj
		},
	},
	"color-name-header-background": {
		Doc:   "Get theme.ColorNameHeaderBackground value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameHeaderBackground))
			return resObj
		},
	},
	"color-name-hover": {
		Doc:   "Get theme.ColorNameHover value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameHover))
			return resObj
		},
	},
	"color-name-hyperlink": {
		Doc:   "Get theme.ColorNameHyperlink value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameHyperlink))
			return resObj
		},
	},
	"color-name-input-background": {
		Doc:   "Get theme.ColorNameInputBackground value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameInputBackground))
			return resObj
		},
	},
	"color-name-input-border": {
		Doc:   "Get theme.ColorNameInputBorder value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameInputBorder))
			return resObj
		},
	},
	"color-name-menu-background": {
		Doc:   "Get theme.ColorNameMenuBackground value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameMenuBackground))
			return resObj
		},
	},
	"color-name-overlay-background": {
		Doc:   "Get theme.ColorNameOverlayBackground value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameOverlayBackground))
			return resObj
		},
	},
	"color-name-place-holder": {
		Doc:   "Get theme.ColorNamePlaceHolder value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNamePlaceHolder))
			return resObj
		},
	},
	"color-name-pressed": {
		Doc:   "Get theme.ColorNamePressed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNamePressed))
			return resObj
		},
	},
	"color-name-primary": {
		Doc:   "Get theme.ColorNamePrimary value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNamePrimary))
			return resObj
		},
	},
	"color-name-scroll-bar": {
		Doc:   "Get theme.ColorNameScrollBar value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameScrollBar))
			return resObj
		},
	},
	"color-name-selection": {
		Doc:   "Get theme.ColorNameSelection value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameSelection))
			return resObj
		},
	},
	"color-name-separator": {
		Doc:   "Get theme.ColorNameSeparator value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameSeparator))
			return resObj
		},
	},
	"color-name-shadow": {
		Doc:   "Get theme.ColorNameShadow value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameShadow))
			return resObj
		},
	},
	"color-name-success": {
		Doc:   "Get theme.ColorNameSuccess value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameSuccess))
			return resObj
		},
	},
	"color-name-warning": {
		Doc:   "Get theme.ColorNameWarning value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.ColorNameWarning))
			return resObj
		},
	},
	"color-palette-icon": {
		Doc:   "theme.ColorPaletteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ColorPaletteIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"computer-icon": {
		Doc:   "theme.ComputerIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ComputerIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"confirm-icon": {
		Doc:   "theme.ConfirmIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ConfirmIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"content-add-icon": {
		Doc:   "theme.ContentAddIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentAddIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"content-clear-icon": {
		Doc:   "theme.ContentClearIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentClearIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"content-copy-icon": {
		Doc:   "theme.ContentCopyIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentCopyIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"content-cut-icon": {
		Doc:   "theme.ContentCutIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentCutIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"content-paste-icon": {
		Doc:   "theme.ContentPasteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentPasteIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"content-redo-icon": {
		Doc:   "theme.ContentRedoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentRedoIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"content-remove-icon": {
		Doc:   "theme.ContentRemoveIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentRemoveIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"content-undo-icon": {
		Doc:   "theme.ContentUndoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentUndoIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"dark-theme": {
		Doc:   "theme.DarkTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DarkTheme()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
				}
			}
			return res0Obj
		},
	},
	"default-emoji-font": {
		Doc:   "theme.DefaultEmojiFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultEmojiFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"default-symbol-font": {
		Doc:   "theme.DefaultSymbolFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultSymbolFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"default-text-bold-font": {
		Doc:   "theme.DefaultTextBoldFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextBoldFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"default-text-bold-italic-font": {
		Doc:   "theme.DefaultTextBoldItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextBoldItalicFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"default-text-font": {
		Doc:   "theme.DefaultTextFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"default-text-italic-font": {
		Doc:   "theme.DefaultTextItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextItalicFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"default-text-monospace-font": {
		Doc:   "theme.DefaultTextMonospaceFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextMonospaceFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"default-theme": {
		Doc:   "theme.DefaultTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTheme()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
				}
			}
			return res0Obj
		},
	},
	"delete-icon": {
		Doc:   "theme.DeleteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DeleteIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"disabled-button-color": {
		Doc:   "theme.DisabledButtonColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DisabledButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"disabled-color": {
		Doc:   "theme.DisabledColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DisabledColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"disabled-text-color": {
		Doc:   "theme.DisabledTextColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DisabledTextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"document-create-icon": {
		Doc:   "theme.DocumentCreateIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentCreateIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"document-icon": {
		Doc:   "theme.DocumentIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"document-print-icon": {
		Doc:   "theme.DocumentPrintIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentPrintIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"document-save-icon": {
		Doc:   "theme.DocumentSaveIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentSaveIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"download-icon": {
		Doc:   "theme.DownloadIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DownloadIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"error-color": {
		Doc:   "theme.ErrorColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ErrorColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"error-icon": {
		Doc:   "theme.ErrorIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ErrorIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"file-application-icon": {
		Doc:   "theme.FileApplicationIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileApplicationIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"file-audio-icon": {
		Doc:   "theme.FileAudioIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileAudioIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"theme-file-icon": {
		Doc:   "theme.FileIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"file-image-icon": {
		Doc:   "theme.FileImageIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileImageIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"file-text-icon": {
		Doc:   "theme.FileTextIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileTextIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"file-video-icon": {
		Doc:   "theme.FileVideoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileVideoIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"focus-color": {
		Doc:   "theme.FocusColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FocusColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"folder-icon": {
		Doc:   "theme.FolderIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FolderIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"folder-new-icon": {
		Doc:   "theme.FolderNewIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FolderNewIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"folder-open-icon": {
		Doc:   "theme.FolderOpenIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FolderOpenIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"foreground-color": {
		Doc:   "theme.ForegroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ForegroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"from-json": {
		Doc:   "theme.FromJSON",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("from-json: arg 1: expected string")
			}
			res0, res1 := theme.FromJSON(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"from-json-reader": {
		Doc:   "theme.FromJSONReader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("from-json-reader: arg 1: expected native of type io.Reader")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("from-json-reader: arg 1: expected native")
			}
			res0, res1 := theme.FromJSONReader(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
				}
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"from-legacy": {
		Doc:   "theme.FromLegacy",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("from-legacy: arg 1: expected native of type fyne.LegacyTheme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("from-legacy: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("from-legacy: arg 1: expected native")
			}
			res0 := theme.FromLegacy(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
				}
			}
			return res0Obj
		},
	},
	"fyne-logo": {
		Doc:   "theme.FyneLogo",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FyneLogo()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"grid-icon": {
		Doc:   "theme.GridIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.GridIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"header-background-color": {
		Doc:   "theme.HeaderBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HeaderBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"help-icon": {
		Doc:   "theme.HelpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HelpIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"history-icon": {
		Doc:   "theme.HistoryIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HistoryIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"home-icon": {
		Doc:   "theme.HomeIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HomeIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"hover-color": {
		Doc:   "theme.HoverColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HoverColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"hyperlink-color": {
		Doc:   "theme.HyperlinkColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HyperlinkColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"icon-inline-size": {
		Doc:   "theme.IconInlineSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.IconInlineSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"icon-name-account": {
		Doc:   "Get theme.IconNameAccount value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameAccount))
			return resObj
		},
	},
	"icon-name-arrow-drop-down": {
		Doc:   "Get theme.IconNameArrowDropDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameArrowDropDown))
			return resObj
		},
	},
	"icon-name-arrow-drop-up": {
		Doc:   "Get theme.IconNameArrowDropUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameArrowDropUp))
			return resObj
		},
	},
	"icon-name-broken-image": {
		Doc:   "Get theme.IconNameBrokenImage value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameBrokenImage))
			return resObj
		},
	},
	"icon-name-cancel": {
		Doc:   "Get theme.IconNameCancel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameCancel))
			return resObj
		},
	},
	"icon-name-check-button": {
		Doc:   "Get theme.IconNameCheckButton value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameCheckButton))
			return resObj
		},
	},
	"icon-name-check-button-checked": {
		Doc:   "Get theme.IconNameCheckButtonChecked value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameCheckButtonChecked))
			return resObj
		},
	},
	"icon-name-color-achromatic": {
		Doc:   "Get theme.IconNameColorAchromatic value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameColorAchromatic))
			return resObj
		},
	},
	"icon-name-color-chromatic": {
		Doc:   "Get theme.IconNameColorChromatic value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameColorChromatic))
			return resObj
		},
	},
	"icon-name-color-palette": {
		Doc:   "Get theme.IconNameColorPalette value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameColorPalette))
			return resObj
		},
	},
	"icon-name-computer": {
		Doc:   "Get theme.IconNameComputer value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameComputer))
			return resObj
		},
	},
	"icon-name-confirm": {
		Doc:   "Get theme.IconNameConfirm value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameConfirm))
			return resObj
		},
	},
	"icon-name-content-add": {
		Doc:   "Get theme.IconNameContentAdd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameContentAdd))
			return resObj
		},
	},
	"icon-name-content-clear": {
		Doc:   "Get theme.IconNameContentClear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameContentClear))
			return resObj
		},
	},
	"icon-name-content-copy": {
		Doc:   "Get theme.IconNameContentCopy value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameContentCopy))
			return resObj
		},
	},
	"icon-name-content-cut": {
		Doc:   "Get theme.IconNameContentCut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameContentCut))
			return resObj
		},
	},
	"icon-name-content-paste": {
		Doc:   "Get theme.IconNameContentPaste value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameContentPaste))
			return resObj
		},
	},
	"icon-name-content-redo": {
		Doc:   "Get theme.IconNameContentRedo value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameContentRedo))
			return resObj
		},
	},
	"icon-name-content-remove": {
		Doc:   "Get theme.IconNameContentRemove value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameContentRemove))
			return resObj
		},
	},
	"icon-name-content-undo": {
		Doc:   "Get theme.IconNameContentUndo value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameContentUndo))
			return resObj
		},
	},
	"icon-name-delete": {
		Doc:   "Get theme.IconNameDelete value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameDelete))
			return resObj
		},
	},
	"icon-name-document": {
		Doc:   "Get theme.IconNameDocument value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameDocument))
			return resObj
		},
	},
	"icon-name-document-create": {
		Doc:   "Get theme.IconNameDocumentCreate value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameDocumentCreate))
			return resObj
		},
	},
	"icon-name-document-print": {
		Doc:   "Get theme.IconNameDocumentPrint value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameDocumentPrint))
			return resObj
		},
	},
	"icon-name-document-save": {
		Doc:   "Get theme.IconNameDocumentSave value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameDocumentSave))
			return resObj
		},
	},
	"icon-name-download": {
		Doc:   "Get theme.IconNameDownload value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameDownload))
			return resObj
		},
	},
	"icon-name-error": {
		Doc:   "Get theme.IconNameError value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameError))
			return resObj
		},
	},
	"icon-name-file": {
		Doc:   "Get theme.IconNameFile value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameFile))
			return resObj
		},
	},
	"icon-name-file-application": {
		Doc:   "Get theme.IconNameFileApplication value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameFileApplication))
			return resObj
		},
	},
	"icon-name-file-audio": {
		Doc:   "Get theme.IconNameFileAudio value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameFileAudio))
			return resObj
		},
	},
	"icon-name-file-image": {
		Doc:   "Get theme.IconNameFileImage value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameFileImage))
			return resObj
		},
	},
	"icon-name-file-text": {
		Doc:   "Get theme.IconNameFileText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameFileText))
			return resObj
		},
	},
	"icon-name-file-video": {
		Doc:   "Get theme.IconNameFileVideo value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameFileVideo))
			return resObj
		},
	},
	"icon-name-folder": {
		Doc:   "Get theme.IconNameFolder value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameFolder))
			return resObj
		},
	},
	"icon-name-folder-new": {
		Doc:   "Get theme.IconNameFolderNew value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameFolderNew))
			return resObj
		},
	},
	"icon-name-folder-open": {
		Doc:   "Get theme.IconNameFolderOpen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameFolderOpen))
			return resObj
		},
	},
	"icon-name-grid": {
		Doc:   "Get theme.IconNameGrid value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameGrid))
			return resObj
		},
	},
	"icon-name-help": {
		Doc:   "Get theme.IconNameHelp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameHelp))
			return resObj
		},
	},
	"icon-name-history": {
		Doc:   "Get theme.IconNameHistory value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameHistory))
			return resObj
		},
	},
	"icon-name-home": {
		Doc:   "Get theme.IconNameHome value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameHome))
			return resObj
		},
	},
	"icon-name-info": {
		Doc:   "Get theme.IconNameInfo value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameInfo))
			return resObj
		},
	},
	"icon-name-list": {
		Doc:   "Get theme.IconNameList value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameList))
			return resObj
		},
	},
	"icon-name-login": {
		Doc:   "Get theme.IconNameLogin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameLogin))
			return resObj
		},
	},
	"icon-name-logout": {
		Doc:   "Get theme.IconNameLogout value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameLogout))
			return resObj
		},
	},
	"icon-name-mail-attachment": {
		Doc:   "Get theme.IconNameMailAttachment value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMailAttachment))
			return resObj
		},
	},
	"icon-name-mail-compose": {
		Doc:   "Get theme.IconNameMailCompose value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMailCompose))
			return resObj
		},
	},
	"icon-name-mail-forward": {
		Doc:   "Get theme.IconNameMailForward value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMailForward))
			return resObj
		},
	},
	"icon-name-mail-reply": {
		Doc:   "Get theme.IconNameMailReply value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMailReply))
			return resObj
		},
	},
	"icon-name-mail-reply-all": {
		Doc:   "Get theme.IconNameMailReplyAll value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMailReplyAll))
			return resObj
		},
	},
	"icon-name-mail-send": {
		Doc:   "Get theme.IconNameMailSend value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMailSend))
			return resObj
		},
	},
	"icon-name-media-fast-forward": {
		Doc:   "Get theme.IconNameMediaFastForward value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaFastForward))
			return resObj
		},
	},
	"icon-name-media-fast-rewind": {
		Doc:   "Get theme.IconNameMediaFastRewind value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaFastRewind))
			return resObj
		},
	},
	"icon-name-media-music": {
		Doc:   "Get theme.IconNameMediaMusic value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaMusic))
			return resObj
		},
	},
	"icon-name-media-pause": {
		Doc:   "Get theme.IconNameMediaPause value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaPause))
			return resObj
		},
	},
	"icon-name-media-photo": {
		Doc:   "Get theme.IconNameMediaPhoto value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaPhoto))
			return resObj
		},
	},
	"icon-name-media-play": {
		Doc:   "Get theme.IconNameMediaPlay value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaPlay))
			return resObj
		},
	},
	"icon-name-media-record": {
		Doc:   "Get theme.IconNameMediaRecord value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaRecord))
			return resObj
		},
	},
	"icon-name-media-replay": {
		Doc:   "Get theme.IconNameMediaReplay value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaReplay))
			return resObj
		},
	},
	"icon-name-media-skip-next": {
		Doc:   "Get theme.IconNameMediaSkipNext value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaSkipNext))
			return resObj
		},
	},
	"icon-name-media-skip-previous": {
		Doc:   "Get theme.IconNameMediaSkipPrevious value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaSkipPrevious))
			return resObj
		},
	},
	"icon-name-media-stop": {
		Doc:   "Get theme.IconNameMediaStop value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaStop))
			return resObj
		},
	},
	"icon-name-media-video": {
		Doc:   "Get theme.IconNameMediaVideo value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMediaVideo))
			return resObj
		},
	},
	"icon-name-menu": {
		Doc:   "Get theme.IconNameMenu value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMenu))
			return resObj
		},
	},
	"icon-name-menu-expand": {
		Doc:   "Get theme.IconNameMenuExpand value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMenuExpand))
			return resObj
		},
	},
	"icon-name-more-horizontal": {
		Doc:   "Get theme.IconNameMoreHorizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMoreHorizontal))
			return resObj
		},
	},
	"icon-name-more-vertical": {
		Doc:   "Get theme.IconNameMoreVertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMoreVertical))
			return resObj
		},
	},
	"icon-name-move-down": {
		Doc:   "Get theme.IconNameMoveDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMoveDown))
			return resObj
		},
	},
	"icon-name-move-up": {
		Doc:   "Get theme.IconNameMoveUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameMoveUp))
			return resObj
		},
	},
	"icon-name-navigate-back": {
		Doc:   "Get theme.IconNameNavigateBack value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameNavigateBack))
			return resObj
		},
	},
	"icon-name-navigate-next": {
		Doc:   "Get theme.IconNameNavigateNext value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameNavigateNext))
			return resObj
		},
	},
	"icon-name-question": {
		Doc:   "Get theme.IconNameQuestion value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameQuestion))
			return resObj
		},
	},
	"icon-name-radio-button": {
		Doc:   "Get theme.IconNameRadioButton value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameRadioButton))
			return resObj
		},
	},
	"icon-name-radio-button-checked": {
		Doc:   "Get theme.IconNameRadioButtonChecked value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameRadioButtonChecked))
			return resObj
		},
	},
	"icon-name-search": {
		Doc:   "Get theme.IconNameSearch value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameSearch))
			return resObj
		},
	},
	"icon-name-search-replace": {
		Doc:   "Get theme.IconNameSearchReplace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameSearchReplace))
			return resObj
		},
	},
	"icon-name-settings": {
		Doc:   "Get theme.IconNameSettings value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameSettings))
			return resObj
		},
	},
	"icon-name-storage": {
		Doc:   "Get theme.IconNameStorage value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameStorage))
			return resObj
		},
	},
	"icon-name-upload": {
		Doc:   "Get theme.IconNameUpload value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameUpload))
			return resObj
		},
	},
	"icon-name-view-full-screen": {
		Doc:   "Get theme.IconNameViewFullScreen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameViewFullScreen))
			return resObj
		},
	},
	"icon-name-view-refresh": {
		Doc:   "Get theme.IconNameViewRefresh value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameViewRefresh))
			return resObj
		},
	},
	"icon-name-view-restore": {
		Doc:   "Get theme.IconNameViewRestore value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameViewRestore))
			return resObj
		},
	},
	"icon-name-view-zoom-fit": {
		Doc:   "Get theme.IconNameViewZoomFit value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameViewZoomFit))
			return resObj
		},
	},
	"icon-name-view-zoom-in": {
		Doc:   "Get theme.IconNameViewZoomIn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameViewZoomIn))
			return resObj
		},
	},
	"icon-name-view-zoom-out": {
		Doc:   "Get theme.IconNameViewZoomOut value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameViewZoomOut))
			return resObj
		},
	},
	"icon-name-visibility": {
		Doc:   "Get theme.IconNameVisibility value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameVisibility))
			return resObj
		},
	},
	"icon-name-visibility-off": {
		Doc:   "Get theme.IconNameVisibilityOff value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameVisibilityOff))
			return resObj
		},
	},
	"icon-name-volume-down": {
		Doc:   "Get theme.IconNameVolumeDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameVolumeDown))
			return resObj
		},
	},
	"icon-name-volume-mute": {
		Doc:   "Get theme.IconNameVolumeMute value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameVolumeMute))
			return resObj
		},
	},
	"icon-name-volume-up": {
		Doc:   "Get theme.IconNameVolumeUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameVolumeUp))
			return resObj
		},
	},
	"icon-name-warning": {
		Doc:   "Get theme.IconNameWarning value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.IconNameWarning))
			return resObj
		},
	},
	"info-icon": {
		Doc:   "theme.InfoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InfoIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"inner-padding": {
		Doc:   "theme.InnerPadding",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InnerPadding()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"input-background-color": {
		Doc:   "theme.InputBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"input-border-color": {
		Doc:   "theme.InputBorderColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputBorderColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"input-border-size": {
		Doc:   "theme.InputBorderSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputBorderSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"input-radius-size": {
		Doc:   "theme.InputRadiusSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputRadiusSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"light-theme": {
		Doc:   "theme.LightTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LightTheme()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
				}
			}
			return res0Obj
		},
	},
	"line-spacing": {
		Doc:   "theme.LineSpacing",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LineSpacing()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"list-icon": {
		Doc:   "theme.ListIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ListIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"login-icon": {
		Doc:   "theme.LoginIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LoginIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"logout-icon": {
		Doc:   "theme.LogoutIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LogoutIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"mail-attachment-icon": {
		Doc:   "theme.MailAttachmentIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailAttachmentIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"mail-compose-icon": {
		Doc:   "theme.MailComposeIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailComposeIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"mail-forward-icon": {
		Doc:   "theme.MailForwardIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailForwardIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"mail-reply-all-icon": {
		Doc:   "theme.MailReplyAllIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailReplyAllIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"mail-reply-icon": {
		Doc:   "theme.MailReplyIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailReplyIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"mail-send-icon": {
		Doc:   "theme.MailSendIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailSendIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-fast-forward-icon": {
		Doc:   "theme.MediaFastForwardIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaFastForwardIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-fast-rewind-icon": {
		Doc:   "theme.MediaFastRewindIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaFastRewindIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-music-icon": {
		Doc:   "theme.MediaMusicIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaMusicIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-pause-icon": {
		Doc:   "theme.MediaPauseIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaPauseIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-photo-icon": {
		Doc:   "theme.MediaPhotoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaPhotoIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-play-icon": {
		Doc:   "theme.MediaPlayIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaPlayIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-record-icon": {
		Doc:   "theme.MediaRecordIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaRecordIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-replay-icon": {
		Doc:   "theme.MediaReplayIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaReplayIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-skip-next-icon": {
		Doc:   "theme.MediaSkipNextIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaSkipNextIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-skip-previous-icon": {
		Doc:   "theme.MediaSkipPreviousIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaSkipPreviousIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-stop-icon": {
		Doc:   "theme.MediaStopIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaStopIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"media-video-icon": {
		Doc:   "theme.MediaVideoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaVideoIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"menu-background-color": {
		Doc:   "theme.MenuBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"menu-drop-down-icon": {
		Doc:   "theme.MenuDropDownIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuDropDownIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"menu-drop-up-icon": {
		Doc:   "theme.MenuDropUpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuDropUpIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"menu-expand-icon": {
		Doc:   "theme.MenuExpandIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuExpandIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"menu-icon": {
		Doc:   "theme.MenuIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"more-horizontal-icon": {
		Doc:   "theme.MoreHorizontalIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoreHorizontalIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"more-vertical-icon": {
		Doc:   "theme.MoreVerticalIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoreVerticalIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"move-down-icon": {
		Doc:   "theme.MoveDownIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoveDownIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"move-up-icon": {
		Doc:   "theme.MoveUpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoveUpIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"navigate-back-icon": {
		Doc:   "theme.NavigateBackIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.NavigateBackIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"navigate-next-icon": {
		Doc:   "theme.NavigateNextIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.NavigateNextIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"colored-resource": {
		Doc:   "theme.NewColoredResource",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("colored-resource: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("colored-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("colored-resource: arg 1: expected native")
			}
			var arg1Val fyne.ThemeColorName
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeColorName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeColorName)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("colored-resource: arg 2: expected string")
					}
					arg1Val = fyne.ThemeColorName(u)
				}
			}
			res0 := theme.NewColoredResource(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-theme-themed-resource")
			return res0Obj
		},
	},
	"disabled-resource": {
		Doc:   "theme.NewDisabledResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("disabled-resource: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("disabled-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("disabled-resource: arg 1: expected native")
			}
			res0 := theme.NewDisabledResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-theme-disabled-resource")
			return res0Obj
		},
	},
	"error-themed-resource": {
		Doc:   "theme.NewErrorThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("error-themed-resource: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("error-themed-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("error-themed-resource: arg 1: expected native")
			}
			res0 := theme.NewErrorThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-theme-error-themed-resource")
			return res0Obj
		},
	},
	"inverted-themed-resource": {
		Doc:   "theme.NewInvertedThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("inverted-themed-resource: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("inverted-themed-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("inverted-themed-resource: arg 1: expected native")
			}
			res0 := theme.NewInvertedThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-theme-inverted-themed-resource")
			return res0Obj
		},
	},
	"primary-themed-resource": {
		Doc:   "theme.NewPrimaryThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("primary-themed-resource: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("primary-themed-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("primary-themed-resource: arg 1: expected native")
			}
			res0 := theme.NewPrimaryThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-theme-primary-themed-resource")
			return res0Obj
		},
	},
	"success-themed-resource": {
		Doc:   "theme.NewSuccessThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("success-themed-resource: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("success-themed-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("success-themed-resource: arg 1: expected native")
			}
			res0 := theme.NewSuccessThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-theme-themed-resource")
			return res0Obj
		},
	},
	"themed-resource": {
		Doc:   "theme.NewThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("themed-resource: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("themed-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("themed-resource: arg 1: expected native")
			}
			res0 := theme.NewThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-theme-themed-resource")
			return res0Obj
		},
	},
	"warning-themed-resource": {
		Doc:   "theme.NewWarningThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("warning-themed-resource: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("warning-themed-resource: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("warning-themed-resource: arg 1: expected native")
			}
			res0 := theme.NewWarningThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-theme-themed-resource")
			return res0Obj
		},
	},
	"overlay-background-color": {
		Doc:   "theme.OverlayBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.OverlayBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"padding": {
		Doc:   "theme.Padding",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.Padding()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"place-holder-color": {
		Doc:   "theme.PlaceHolderColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PlaceHolderColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"pressed-color": {
		Doc:   "theme.PressedColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PressedColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"primary-color": {
		Doc:   "theme.PrimaryColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PrimaryColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"primary-color-named": {
		Doc:   "theme.PrimaryColorNamed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("primary-color-named: arg 1: expected string")
			}
			res0 := theme.PrimaryColorNamed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"primary-color-names": {
		Doc:   "theme.PrimaryColorNames",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PrimaryColorNames()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"question-icon": {
		Doc:   "theme.QuestionIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.QuestionIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"radio-button-checked-icon": {
		Doc:   "theme.RadioButtonCheckedIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.RadioButtonCheckedIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"radio-button-icon": {
		Doc:   "theme.RadioButtonIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.RadioButtonIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"scroll-bar-color": {
		Doc:   "theme.ScrollBarColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ScrollBarColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"scroll-bar-size": {
		Doc:   "theme.ScrollBarSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ScrollBarSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"scroll-bar-small-size": {
		Doc:   "theme.ScrollBarSmallSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ScrollBarSmallSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"search-icon": {
		Doc:   "theme.SearchIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SearchIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"search-replace-icon": {
		Doc:   "theme.SearchReplaceIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SearchReplaceIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"selection-color": {
		Doc:   "theme.SelectionColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SelectionColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"selection-radius-size": {
		Doc:   "theme.SelectionRadiusSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SelectionRadiusSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"separator-color": {
		Doc:   "theme.SeparatorColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SeparatorColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"separator-thickness-size": {
		Doc:   "theme.SeparatorThicknessSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SeparatorThicknessSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"settings-icon": {
		Doc:   "theme.SettingsIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SettingsIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"shadow-color": {
		Doc:   "theme.ShadowColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ShadowColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"size-name-caption-text": {
		Doc:   "Get theme.SizeNameCaptionText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameCaptionText))
			return resObj
		},
	},
	"size-name-heading-text": {
		Doc:   "Get theme.SizeNameHeadingText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameHeadingText))
			return resObj
		},
	},
	"size-name-inline-icon": {
		Doc:   "Get theme.SizeNameInlineIcon value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameInlineIcon))
			return resObj
		},
	},
	"size-name-inner-padding": {
		Doc:   "Get theme.SizeNameInnerPadding value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameInnerPadding))
			return resObj
		},
	},
	"size-name-input-border": {
		Doc:   "Get theme.SizeNameInputBorder value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameInputBorder))
			return resObj
		},
	},
	"size-name-input-radius": {
		Doc:   "Get theme.SizeNameInputRadius value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameInputRadius))
			return resObj
		},
	},
	"size-name-line-spacing": {
		Doc:   "Get theme.SizeNameLineSpacing value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameLineSpacing))
			return resObj
		},
	},
	"size-name-padding": {
		Doc:   "Get theme.SizeNamePadding value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNamePadding))
			return resObj
		},
	},
	"size-name-scroll-bar": {
		Doc:   "Get theme.SizeNameScrollBar value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameScrollBar))
			return resObj
		},
	},
	"size-name-scroll-bar-small": {
		Doc:   "Get theme.SizeNameScrollBarSmall value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameScrollBarSmall))
			return resObj
		},
	},
	"size-name-selection-radius": {
		Doc:   "Get theme.SizeNameSelectionRadius value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameSelectionRadius))
			return resObj
		},
	},
	"size-name-separator-thickness": {
		Doc:   "Get theme.SizeNameSeparatorThickness value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameSeparatorThickness))
			return resObj
		},
	},
	"size-name-sub-heading-text": {
		Doc:   "Get theme.SizeNameSubHeadingText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameSubHeadingText))
			return resObj
		},
	},
	"size-name-text": {
		Doc:   "Get theme.SizeNameText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(theme.SizeNameText))
			return resObj
		},
	},
	"storage-icon": {
		Doc:   "theme.StorageIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.StorageIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"success-color": {
		Doc:   "theme.SuccessColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SuccessColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"symbol-font": {
		Doc:   "theme.SymbolFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SymbolFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"text-bold-font": {
		Doc:   "theme.TextBoldFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextBoldFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"text-bold-italic-font": {
		Doc:   "theme.TextBoldItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextBoldItalicFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"text-color": {
		Doc:   "theme.TextColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"text-font": {
		Doc:   "theme.TextFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"text-heading-size": {
		Doc:   "theme.TextHeadingSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextHeadingSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text-italic-font": {
		Doc:   "theme.TextItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextItalicFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"text-monospace-font": {
		Doc:   "theme.TextMonospaceFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextMonospaceFont()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"text-size": {
		Doc:   "theme.TextSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text-sub-heading-size": {
		Doc:   "theme.TextSubHeadingSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextSubHeadingSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-themed-resource//color-name!": {
		Doc:   "Set theme.ThemedResource ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(theme.ThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("theme-themed-resource//color-name!: arg 1: expected native of type theme.ThemedResource")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("theme-themed-resource//color-name!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeColorName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeColorName)
				}
				if natOk && natValOk {
					self.ColorName = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("theme-themed-resource//color-name!: arg 2: expected string")
					}
					self.ColorName = fyne.ThemeColorName(u)
				}
			}
			return arg0
		},
	},
	"theme-themed-resource//color-name?": {
		Doc:   "Get theme.ThemedResource ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(theme.ThemedResource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("theme-themed-resource//color-name?: arg 1: expected native of type theme.ThemedResource")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("theme-themed-resource//color-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.ColorName))
			return resObj
		},
	},
	"upload-icon": {
		Doc:   "theme.UploadIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.UploadIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"variant-dark": {
		Doc:   "Get theme.VariantDark value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(theme.VariantDark)))
			return resObj
		},
	},
	"variant-light": {
		Doc:   "Get theme.VariantLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(theme.VariantLight)))
			return resObj
		},
	},
	"view-full-screen-icon": {
		Doc:   "theme.ViewFullScreenIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ViewFullScreenIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"view-refresh-icon": {
		Doc:   "theme.ViewRefreshIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ViewRefreshIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"view-restore-icon": {
		Doc:   "theme.ViewRestoreIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ViewRestoreIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"visibility-icon": {
		Doc:   "theme.VisibilityIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VisibilityIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"visibility-off-icon": {
		Doc:   "theme.VisibilityOffIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VisibilityOffIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"volume-down-icon": {
		Doc:   "theme.VolumeDownIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VolumeDownIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"volume-mute-icon": {
		Doc:   "theme.VolumeMuteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VolumeMuteIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"volume-up-icon": {
		Doc:   "theme.VolumeUpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VolumeUpIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"warning-color": {
		Doc:   "theme.WarningColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.WarningColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"warning-icon": {
		Doc:   "theme.WarningIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.WarningIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"zoom-fit-icon": {
		Doc:   "theme.ZoomFitIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ZoomFitIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"zoom-in-icon": {
		Doc:   "theme.ZoomInIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ZoomInIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"zoom-out-icon": {
		Doc:   "theme.ZoomOutIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ZoomOutIcon()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
				}
			}
			return res0Obj
		},
	},
	"validation-all-strings": {
		Doc:   "validation.NewAllStrings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.StringValidator
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.StringValidator, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal fyne.StringValidator
						if natOk {
							natVal, natValOk = nat.Value.(fyne.StringValidator)
						}
						if natOk && natValOk {
							arg0Val[i] = natVal
						} else {
							var u func(string) error
							switch fn := it.(type) {
							case env.Function:
								if fn.Argsn != 1 {
									ps.FailureFlag = true
									return env.NewError("validation-all-strings: arg 1: block item: function has invalid number of arguments (expected 1)")
								}
								u = func(arg0 string) error {
									var arg0Val env.Object
									arg0Val = *env.NewString(arg0)
									evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
									var res error
									switch v := ps.Res.(type) {
									case env.String:
										res = errors.New(v.Value)
									case env.Error:
										res = errors.New(v.Print(*ps.Idx))
									case env.Integer:
										if v.Value != 0 {
											// TODO: Cannot return error from function
										}
										res = nil
									default:
										// TODO: Cannot return error from function
									}
									return res
								}
							case env.Integer:
								if fn.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("validation-all-strings: arg 1: block item: expected integer to be 0 or nil")
								}
								u = nil
							default:
								ps.FailureFlag = true
								return env.NewError("validation-all-strings: arg 1: block item: expected function or nil")
							}
							arg0Val[i] = fyne.StringValidator(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.StringValidator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("validation-all-strings: arg 1: expected native of type []fyne.StringValidator")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("validation-all-strings: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("validation-all-strings: arg 1: expected block, native or nil")
			}
			res0 := validation.NewAllStrings(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, (func(string) error)(res0), "func(string)_(error)")
			return res0Obj
		},
	},
	"validation-regexp": {
		Doc:   "validation.NewRegexp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("validation-regexp: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("validation-regexp: arg 2: expected string")
			}
			res0 := validation.NewRegexp(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, (func(string) error)(res0), "func(string)_(error)")
			return res0Obj
		},
	},
	"validation-time": {
		Doc:   "validation.NewTime",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("validation-time: arg 1: expected string")
			}
			res0 := validation.NewTime(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, (func(string) error)(res0), "func(string)_(error)")
			return res0Obj
		},
	},
	"widget-accordion-item//detail!": {
		Doc:   "Set widget.AccordionItem Detail value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion-item//detail!: arg 1: expected native of type widget.AccordionItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion-item//detail!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Detail, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion-item//detail!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-accordion-item//detail!: arg 2: expected integer to be 0 or nil")
				}
				self.Detail = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion-item//detail!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-accordion-item//detail?": {
		Doc:   "Get widget.AccordionItem Detail value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion-item//detail?: arg 1: expected native of type widget.AccordionItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion-item//detail?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Detail)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Detail, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Detail, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"widget-accordion-item//open!": {
		Doc:   "Set widget.AccordionItem Open value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion-item//open!: arg 1: expected native of type widget.AccordionItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion-item//open!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Open = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-accordion-item//open!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-accordion-item//open?": {
		Doc:   "Get widget.AccordionItem Open value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion-item//open?: arg 1: expected native of type widget.AccordionItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion-item//open?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Open))
			return resObj
		},
	},
	"widget-accordion-item//title!": {
		Doc:   "Set widget.AccordionItem Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion-item//title!: arg 1: expected native of type widget.AccordionItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion-item//title!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-accordion-item//title!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-accordion-item//title?": {
		Doc:   "Get widget.AccordionItem Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion-item//title?: arg 1: expected native of type widget.AccordionItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion-item//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"widget-accordion//hidden!": {
		Doc:   "Set widget.Accordion Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion//hidden!: arg 1: expected native of type widget.Accordion")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-accordion//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-accordion//hidden?": {
		Doc:   "Get widget.Accordion Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion//hidden?: arg 1: expected native of type widget.Accordion")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-accordion//items!": {
		Doc:   "Set widget.Accordion Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion//items!: arg 1: expected native of type widget.Accordion")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.AccordionItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.AccordionItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-accordion//items!: arg 2: block item: expected native of type *widget.AccordionItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-accordion//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-accordion//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion//items!: arg 2: expected native of type []*widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-accordion//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-accordion//items?": {
		Doc:   "Get widget.Accordion Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion//items?: arg 1: expected native of type widget.Accordion")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-widget-accordion-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-accordion//multi-open!": {
		Doc:   "Set widget.Accordion MultiOpen value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion//multi-open!: arg 1: expected native of type widget.Accordion")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion//multi-open!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiOpen = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-accordion//multi-open!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-accordion//multi-open?": {
		Doc:   "Get widget.Accordion MultiOpen value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-accordion//multi-open?: arg 1: expected native of type widget.Accordion")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-accordion//multi-open?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiOpen))
			return resObj
		},
	},
	"widget-base-widget//hidden!": {
		Doc:   "Set widget.BaseWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-base-widget//hidden!: arg 1: expected native of type widget.BaseWidget")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-base-widget//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-base-widget//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-base-widget//hidden?": {
		Doc:   "Get widget.BaseWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.BaseWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-base-widget//hidden?: arg 1: expected native of type widget.BaseWidget")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-base-widget//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"button-align-center": {
		Doc:   "Get widget.ButtonAlignCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.ButtonAlignCenter)))
			return resObj
		},
	},
	"button-align-leading": {
		Doc:   "Get widget.ButtonAlignLeading value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.ButtonAlignLeading)))
			return resObj
		},
	},
	"button-align-trailing": {
		Doc:   "Get widget.ButtonAlignTrailing value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.ButtonAlignTrailing)))
			return resObj
		},
	},
	"button-icon-leading-text": {
		Doc:   "Get widget.ButtonIconLeadingText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.ButtonIconLeadingText)))
			return resObj
		},
	},
	"button-icon-trailing-text": {
		Doc:   "Get widget.ButtonIconTrailingText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.ButtonIconTrailingText)))
			return resObj
		},
	},
	"widget-button//alignment!": {
		Doc:   "Set widget.Button Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//alignment!: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.ButtonAlign
				if natOk {
					natVal, natValOk = nat.Value.(widget.ButtonAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-button//alignment!: arg 2: expected integer")
					}
					self.Alignment = widget.ButtonAlign(u)
				}
			}
			return arg0
		},
	},
	"widget-button//alignment?": {
		Doc:   "Get widget.Button Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//alignment?: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"widget-button//hidden!": {
		Doc:   "Set widget.Button Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//hidden!: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-button//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-button//hidden?": {
		Doc:   "Get widget.Button Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//hidden?: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-button//icon!": {
		Doc:   "Set widget.Button Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//icon!: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-button//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-button//icon-placement!": {
		Doc:   "Set widget.Button IconPlacement value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//icon-placement!: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//icon-placement!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.ButtonIconPlacement
				if natOk {
					natVal, natValOk = nat.Value.(widget.ButtonIconPlacement)
				}
				if natOk && natValOk {
					self.IconPlacement = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-button//icon-placement!: arg 2: expected integer")
					}
					self.IconPlacement = widget.ButtonIconPlacement(u)
				}
			}
			return arg0
		},
	},
	"widget-button//icon-placement?": {
		Doc:   "Get widget.Button IconPlacement value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//icon-placement?: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//icon-placement?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.IconPlacement)))
			return resObj
		},
	},
	"widget-button//icon?": {
		Doc:   "Get widget.Button Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//icon?: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"widget-button//importance!": {
		Doc:   "Set widget.Button Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//importance!: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//importance!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.Importance
				if natOk {
					natVal, natValOk = nat.Value.(widget.Importance)
				}
				if natOk && natValOk {
					self.Importance = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-button//importance!: arg 2: expected integer")
					}
					self.Importance = widget.Importance(u)
				}
			}
			return arg0
		},
	},
	"widget-button//importance?": {
		Doc:   "Get widget.Button Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//importance?: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//importance?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Importance)))
			return resObj
		},
	},
	"widget-button//on-tapped!": {
		Doc:   "Set widget.Button OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//on-tapped!: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//on-tapped!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-button//on-tapped!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-button//on-tapped!: arg 2: expected integer to be 0 or nil")
				}
				self.OnTapped = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//on-tapped!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-button//on-tapped?": {
		Doc:   "Get widget.Button OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//on-tapped?: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//on-tapped?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"widget-button//text!": {
		Doc:   "Set widget.Button Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//text!: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-button//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-button//text?": {
		Doc:   "Get widget.Button Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-button//text?: arg 1: expected native of type widget.Button")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-button//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-card//content!": {
		Doc:   "Set widget.Card Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//content!: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//content!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//content!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-card//content!: arg 2: expected integer to be 0 or nil")
				}
				self.Content = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//content!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-card//content?": {
		Doc:   "Get widget.Card Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//content?: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//content?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Content)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Content, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"widget-card//hidden!": {
		Doc:   "Set widget.Card Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//hidden!: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-card//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-card//hidden?": {
		Doc:   "Get widget.Card Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//hidden?: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-card//image!": {
		Doc:   "Set widget.Card Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//image!: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//image!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*canvas.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//image!: arg 2: expected native of type *canvas.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-card//image!: arg 2: expected integer to be 0 or nil")
				}
				self.Image = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//image!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-card//image?": {
		Doc:   "Get widget.Card Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//image?: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//image?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-canvas-image")
			return resObj
		},
	},
	"widget-card//subtitle!": {
		Doc:   "Set widget.Card Subtitle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//subtitle!: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//subtitle!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Subtitle = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-card//subtitle!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-card//subtitle?": {
		Doc:   "Get widget.Card Subtitle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//subtitle?: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//subtitle?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Subtitle)
			return resObj
		},
	},
	"widget-card//title!": {
		Doc:   "Set widget.Card Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//title!: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//title!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-card//title!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-card//title?": {
		Doc:   "Get widget.Card Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-card//title?: arg 1: expected native of type widget.Card")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-card//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"widget-check-group//hidden!": {
		Doc:   "Set widget.CheckGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//hidden!: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-check-group//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-check-group//hidden?": {
		Doc:   "Get widget.CheckGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//hidden?: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-check-group//horizontal!": {
		Doc:   "Set widget.CheckGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//horizontal!: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//horizontal!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-check-group//horizontal!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-check-group//horizontal?": {
		Doc:   "Get widget.CheckGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//horizontal?: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//horizontal?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"widget-check-group//on-changed!": {
		Doc:   "Set widget.CheckGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//on-changed!: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 []string) {
					var arg0Val env.Object
					{
						items := make([]env.Object, len(arg0))
						for i, it := range arg0 {
							items[i] = *env.NewString(it)
						}
						arg0Val = *env.NewBlock(*env.NewTSeries(items))
					}
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-check-group//on-changed?": {
		Doc:   "Get widget.CheckGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//on-changed?: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(arr-string)")
			return resObj
		},
	},
	"widget-check-group//options!": {
		Doc:   "Set widget.CheckGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//options!: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//options!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-check-group//options!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//options!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//options!: arg 2: expected integer to be 0 or nil")
				}
				self.Options = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//options!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-check-group//options?": {
		Doc:   "Get widget.CheckGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//options?: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//options?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-check-group//required!": {
		Doc:   "Set widget.CheckGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//required!: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//required!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-check-group//required!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-check-group//required?": {
		Doc:   "Get widget.CheckGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//required?: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//required?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"widget-check-group//selected!": {
		Doc:   "Set widget.CheckGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//selected!: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//selected!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Selected = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Selected[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-check-group//selected!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Selected, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//selected!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//selected!: arg 2: expected integer to be 0 or nil")
				}
				self.Selected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//selected!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-check-group//selected?": {
		Doc:   "Get widget.CheckGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check-group//selected?: arg 1: expected native of type widget.CheckGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check-group//selected?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Selected))
				for i, it := range self.Selected {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-check//checked!": {
		Doc:   "Set widget.Check Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check//checked!: arg 1: expected native of type widget.Check")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check//checked!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-check//checked!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-check//checked?": {
		Doc:   "Get widget.Check Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check//checked?: arg 1: expected native of type widget.Check")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check//checked?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"widget-check//hidden!": {
		Doc:   "Set widget.Check Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check//hidden!: arg 1: expected native of type widget.Check")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-check//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-check//hidden?": {
		Doc:   "Get widget.Check Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check//hidden?: arg 1: expected native of type widget.Check")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-check//on-changed!": {
		Doc:   "Set widget.Check OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check//on-changed!: arg 1: expected native of type widget.Check")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-check//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-check//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-check//on-changed?": {
		Doc:   "Get widget.Check OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check//on-changed?: arg 1: expected native of type widget.Check")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(bool)")
			return resObj
		},
	},
	"widget-check//text!": {
		Doc:   "Set widget.Check Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check//text!: arg 1: expected native of type widget.Check")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-check//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-check//text?": {
		Doc:   "Get widget.Check Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-check//text?: arg 1: expected native of type widget.Check")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-check//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-custom-text-grid-style//bg-color!": {
		Doc:   "Set widget.CustomTextGridStyle BGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-custom-text-grid-style//bg-color!: arg 1: expected native of type widget.CustomTextGridStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-custom-text-grid-style//bg-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.BGColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-custom-text-grid-style//bg-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-custom-text-grid-style//bg-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-custom-text-grid-style//bg-color?": {
		Doc:   "Get widget.CustomTextGridStyle BGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-custom-text-grid-style//bg-color?: arg 1: expected native of type widget.CustomTextGridStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-custom-text-grid-style//bg-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.BGColor, "color-color")
			return resObj
		},
	},
	"widget-custom-text-grid-style//fg-color!": {
		Doc:   "Set widget.CustomTextGridStyle FGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-custom-text-grid-style//fg-color!: arg 1: expected native of type widget.CustomTextGridStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-custom-text-grid-style//fg-color!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FGColor, ok = v.Value.(color.Color)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-custom-text-grid-style//fg-color!: arg 2: expected native of type color.Color")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-custom-text-grid-style//fg-color!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-custom-text-grid-style//fg-color?": {
		Doc:   "Get widget.CustomTextGridStyle FGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-custom-text-grid-style//fg-color?: arg 1: expected native of type widget.CustomTextGridStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-custom-text-grid-style//fg-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FGColor, "color-color")
			return resObj
		},
	},
	"danger-importance": {
		Doc:   "Get widget.DangerImportance value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.DangerImportance)))
			return resObj
		},
	},
	"widget-disableable-widget//hidden!": {
		Doc:   "Set widget.DisableableWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-disableable-widget//hidden!: arg 1: expected native of type widget.DisableableWidget")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-disableable-widget//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-disableable-widget//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-disableable-widget//hidden?": {
		Doc:   "Get widget.DisableableWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.DisableableWidget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-disableable-widget//hidden?: arg 1: expected native of type widget.DisableableWidget")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-disableable-widget//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-entry//action-item!": {
		Doc:   "Set widget.Entry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//action-item!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//action-item!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//action-item!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-entry//action-item!: arg 2: expected integer to be 0 or nil")
				}
				self.ActionItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//action-item!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-entry//action-item?": {
		Doc:   "Get widget.Entry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//action-item?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//action-item?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.ActionItem)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.ActionItem, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.ActionItem, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"widget-entry//cursor-column!": {
		Doc:   "Set widget.Entry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//cursor-column!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//cursor-column!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-entry//cursor-column!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-entry//cursor-column?": {
		Doc:   "Get widget.Entry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//cursor-column?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//cursor-column?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"widget-entry//cursor-row!": {
		Doc:   "Set widget.Entry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//cursor-row!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//cursor-row!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-entry//cursor-row!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-entry//cursor-row?": {
		Doc:   "Get widget.Entry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//cursor-row?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//cursor-row?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"widget-entry//hidden!": {
		Doc:   "Set widget.Entry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//hidden!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-entry//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-entry//hidden?": {
		Doc:   "Get widget.Entry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//hidden?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-entry//multi-line!": {
		Doc:   "Set widget.Entry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//multi-line!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//multi-line!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-entry//multi-line!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-entry//multi-line?": {
		Doc:   "Get widget.Entry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//multi-line?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//multi-line?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"widget-entry//on-changed!": {
		Doc:   "Set widget.Entry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-changed!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-entry//on-changed?": {
		Doc:   "Get widget.Entry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-changed?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"widget-entry//on-cursor-changed!": {
		Doc:   "Set widget.Entry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-cursor-changed!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//on-cursor-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-cursor-changed!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-cursor-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnCursorChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//on-cursor-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-entry//on-cursor-changed?": {
		Doc:   "Get widget.Entry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-cursor-changed?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//on-cursor-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "func()")
			return resObj
		},
	},
	"widget-entry//on-submitted!": {
		Doc:   "Set widget.Entry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-submitted!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//on-submitted!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-submitted!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-submitted!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSubmitted = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//on-submitted!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-entry//on-submitted?": {
		Doc:   "Get widget.Entry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//on-submitted?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//on-submitted?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "func(string)")
			return resObj
		},
	},
	"widget-entry//password!": {
		Doc:   "Set widget.Entry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//password!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//password!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-entry//password!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-entry//password?": {
		Doc:   "Get widget.Entry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//password?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//password?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"widget-entry//place-holder!": {
		Doc:   "Set widget.Entry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//place-holder!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//place-holder!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-entry//place-holder!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-entry//place-holder?": {
		Doc:   "Get widget.Entry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//place-holder?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//place-holder?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"widget-entry//scroll!": {
		Doc:   "Set widget.Entry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//scroll!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//scroll!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var rOut, rIn reflect.Value
				if natOk {
					// HACK: self.Scroll, natValOk = widget_1.ScrollDirection(u)
					rOut = reflect.ValueOf(&self.Scroll).Elem()
					rIn = reflect.ValueOf(nat.Value)
					natValOk = rIn.CanConvert(rOut.Type())
				}
				if natOk && natValOk {
					rOut.Set(rIn.Convert(rOut.Type()))
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-entry//scroll!: arg 2: expected integer")
					}
					// HACK: self.Scroll = widget_1.ScrollDirection(u)
					rOut := reflect.ValueOf(&self.Scroll).Elem()
					rIn := reflect.ValueOf(u)
					rOut.Set(rIn.Convert(rOut.Type()))
				}
			}
			return arg0
		},
	},
	"widget-entry//scroll?": {
		Doc:   "Get widget.Entry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//scroll?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//scroll?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Scroll)))
			return resObj
		},
	},
	"widget-entry//text!": {
		Doc:   "Set widget.Entry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//text!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-entry//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-entry//text-style!": {
		Doc:   "Set widget.Entry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//text-style!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-entry//text-style?": {
		Doc:   "Get widget.Entry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//text-style?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-entry//text?": {
		Doc:   "Get widget.Entry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//text?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-entry//validator!": {
		Doc:   "Set widget.Entry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//validator!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//validator!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.StringValidator
				if natOk {
					natVal, natValOk = nat.Value.(fyne.StringValidator)
				}
				if natOk && natValOk {
					self.Validator = natVal
				} else {
					var u func(string) error
					switch fn := arg1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("widget-entry//validator!: arg 2: function has invalid number of arguments (expected 1)")
						}
						u = func(arg0 string) error {
							var arg0Val env.Object
							arg0Val = *env.NewString(arg0)
							evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
							var res error
							switch v := ps.Res.(type) {
							case env.String:
								res = errors.New(v.Value)
							case env.Error:
								res = errors.New(v.Print(*ps.Idx))
							case env.Integer:
								if v.Value != 0 {
									// TODO: Cannot return error from function
								}
								res = nil
							default:
								// TODO: Cannot return error from function
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-entry//validator!: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-entry//validator!: arg 2: expected function or nil")
					}
					self.Validator = fyne.StringValidator(u)
				}
			}
			return arg0
		},
	},
	"widget-entry//validator?": {
		Doc:   "Get widget.Entry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//validator?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//validator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, (func(string) error)(self.Validator), "func(string)_(error)")
			return resObj
		},
	},
	"widget-entry//wrapping!": {
		Doc:   "Set widget.Entry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//wrapping!: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-entry//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"widget-entry//wrapping?": {
		Doc:   "Get widget.Entry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-entry//wrapping?: arg 1: expected native of type widget.Entry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-entry//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"widget-file-icon//hidden!": {
		Doc:   "Set widget.FileIcon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-file-icon//hidden!: arg 1: expected native of type widget.FileIcon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-file-icon//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-file-icon//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-file-icon//hidden?": {
		Doc:   "Get widget.FileIcon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-file-icon//hidden?: arg 1: expected native of type widget.FileIcon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-file-icon//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-file-icon//selected!": {
		Doc:   "Set widget.FileIcon Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-file-icon//selected!: arg 1: expected native of type widget.FileIcon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-file-icon//selected!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Selected = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-file-icon//selected!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-file-icon//selected?": {
		Doc:   "Get widget.FileIcon Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-file-icon//selected?: arg 1: expected native of type widget.FileIcon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-file-icon//selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Selected))
			return resObj
		},
	},
	"widget-file-icon//uri!": {
		Doc:   "Set widget.FileIcon URI value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-file-icon//uri!: arg 1: expected native of type widget.FileIcon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-file-icon//uri!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URI, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-file-icon//uri!: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-file-icon//uri!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-file-icon//uri?": {
		Doc:   "Get widget.FileIcon URI value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-file-icon//uri?: arg 1: expected native of type widget.FileIcon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-file-icon//uri?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URI, "fyne-uri")
			return resObj
		},
	},
	"widget-form-item//hint-text!": {
		Doc:   "Set widget.FormItem HintText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form-item//hint-text!: arg 1: expected native of type widget.FormItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form-item//hint-text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.HintText = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-form-item//hint-text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-form-item//hint-text?": {
		Doc:   "Get widget.FormItem HintText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form-item//hint-text?: arg 1: expected native of type widget.FormItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form-item//hint-text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.HintText)
			return resObj
		},
	},
	"widget-form-item//text!": {
		Doc:   "Set widget.FormItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form-item//text!: arg 1: expected native of type widget.FormItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form-item//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-form-item//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-form-item//text?": {
		Doc:   "Get widget.FormItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form-item//text?: arg 1: expected native of type widget.FormItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form-item//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-form-item//widget!": {
		Doc:   "Set widget.FormItem Widget value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form-item//widget!: arg 1: expected native of type widget.FormItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form-item//widget!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Widget, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form-item//widget!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-form-item//widget!: arg 2: expected integer to be 0 or nil")
				}
				self.Widget = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form-item//widget!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-form-item//widget?": {
		Doc:   "Get widget.FormItem Widget value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form-item//widget?: arg 1: expected native of type widget.FormItem")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form-item//widget?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Widget)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Widget, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Widget, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"widget-form//cancel-text!": {
		Doc:   "Set widget.Form CancelText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//cancel-text!: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//cancel-text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.CancelText = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-form//cancel-text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-form//cancel-text?": {
		Doc:   "Get widget.Form CancelText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//cancel-text?: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//cancel-text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CancelText)
			return resObj
		},
	},
	"widget-form//hidden!": {
		Doc:   "Set widget.Form Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//hidden!: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-form//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-form//hidden?": {
		Doc:   "Get widget.Form Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//hidden?: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-form//items!": {
		Doc:   "Set widget.Form Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//items!: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.FormItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.FormItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-form//items!: arg 2: block item: expected native of type *widget.FormItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-form//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-form//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//items!: arg 2: expected native of type []*widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-form//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-form//items?": {
		Doc:   "Get widget.Form Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//items?: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-widget-form-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-form//on-cancel!": {
		Doc:   "Set widget.Form OnCancel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//on-cancel!: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//on-cancel!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-form//on-cancel!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnCancel = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-form//on-cancel!: arg 2: expected integer to be 0 or nil")
				}
				self.OnCancel = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//on-cancel!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-form//on-cancel?": {
		Doc:   "Get widget.Form OnCancel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//on-cancel?: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//on-cancel?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCancel, "func()")
			return resObj
		},
	},
	"widget-form//on-submit!": {
		Doc:   "Set widget.Form OnSubmit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//on-submit!: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//on-submit!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-form//on-submit!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnSubmit = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-form//on-submit!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSubmit = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//on-submit!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-form//on-submit?": {
		Doc:   "Get widget.Form OnSubmit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//on-submit?: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//on-submit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmit, "func()")
			return resObj
		},
	},
	"widget-form//submit-text!": {
		Doc:   "Set widget.Form SubmitText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//submit-text!: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//submit-text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.SubmitText = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-form//submit-text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-form//submit-text?": {
		Doc:   "Get widget.Form SubmitText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-form//submit-text?: arg 1: expected native of type widget.Form")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-form//submit-text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.SubmitText)
			return resObj
		},
	},
	"widget-grid-wrap//create-item!": {
		Doc:   "Set widget.GridWrap CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//create-item!: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//create-item!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//create-item!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//create-item!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//create-item!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-grid-wrap//create-item?": {
		Doc:   "Get widget.GridWrap CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//create-item?: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//create-item?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "func()_(fyne-canvas-object)")
			return resObj
		},
	},
	"widget-grid-wrap//hidden!": {
		Doc:   "Set widget.GridWrap Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//hidden!: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-grid-wrap//hidden?": {
		Doc:   "Get widget.GridWrap Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//hidden?: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-grid-wrap//length!": {
		Doc:   "Set widget.GridWrap Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//length!: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//length!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//length!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//length!: arg 2: expected integer to be 0 or nil")
				}
				self.Length = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//length!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-grid-wrap//length?": {
		Doc:   "Get widget.GridWrap Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//length?: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//length?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int)")
			return resObj
		},
	},
	"widget-grid-wrap//on-selected!": {
		Doc:   "Set widget.GridWrap OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//on-selected!: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-grid-wrap//on-selected?": {
		Doc:   "Get widget.GridWrap OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//on-selected?: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(widget-grid-wrap-item-id)")
			return resObj
		},
	},
	"widget-grid-wrap//on-unselected!": {
		Doc:   "Set widget.GridWrap OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//on-unselected!: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-grid-wrap//on-unselected?": {
		Doc:   "Get widget.GridWrap OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//on-unselected?: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(widget-grid-wrap-item-id)")
			return resObj
		},
	},
	"widget-grid-wrap//update-item!": {
		Doc:   "Set widget.GridWrap UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//update-item!: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//update-item!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//update-item!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.UpdateItem = func(arg0 widget.GridWrapItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//update-item!: arg 2: expected integer to be 0 or nil")
				}
				self.UpdateItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//update-item!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-grid-wrap//update-item?": {
		Doc:   "Get widget.GridWrap UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-grid-wrap//update-item?: arg 1: expected native of type widget.GridWrap")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-grid-wrap//update-item?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "func(widget-grid-wrap-item-id_fyne-canvas-object)")
			return resObj
		},
	},
	"high-importance": {
		Doc:   "Get widget.HighImportance value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.HighImportance)))
			return resObj
		},
	},
	"horizontal": {
		Doc:   "Get widget.Horizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.Horizontal)))
			return resObj
		},
	},
	"widget-hyperlink-segment//alignment!": {
		Doc:   "Set widget.HyperlinkSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//alignment!: arg 1: expected native of type widget.HyperlinkSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-hyperlink-segment//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"widget-hyperlink-segment//alignment?": {
		Doc:   "Get widget.HyperlinkSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//alignment?: arg 1: expected native of type widget.HyperlinkSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"widget-hyperlink-segment//on-tapped!": {
		Doc:   "Set widget.HyperlinkSegment OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//on-tapped!: arg 1: expected native of type widget.HyperlinkSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//on-tapped!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//on-tapped!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//on-tapped!: arg 2: expected integer to be 0 or nil")
				}
				self.OnTapped = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//on-tapped!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment//on-tapped?": {
		Doc:   "Get widget.HyperlinkSegment OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//on-tapped?: arg 1: expected native of type widget.HyperlinkSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//on-tapped?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"widget-hyperlink-segment//text!": {
		Doc:   "Set widget.HyperlinkSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//text!: arg 1: expected native of type widget.HyperlinkSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment//text?": {
		Doc:   "Get widget.HyperlinkSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//text?: arg 1: expected native of type widget.HyperlinkSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-hyperlink-segment//url!": {
		Doc:   "Set widget.HyperlinkSegment URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//url!: arg 1: expected native of type widget.HyperlinkSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//url!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//url!: arg 2: expected native of type *url.URL")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//url!: arg 2: expected integer to be 0 or nil")
				}
				self.URL = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//url!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment//url?": {
		Doc:   "Get widget.HyperlinkSegment URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink-segment//url?: arg 1: expected native of type widget.HyperlinkSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink-segment//url?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "ptr-url-url")
			return resObj
		},
	},
	"widget-hyperlink//alignment!": {
		Doc:   "Set widget.Hyperlink Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//alignment!: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-hyperlink//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"widget-hyperlink//alignment?": {
		Doc:   "Get widget.Hyperlink Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//alignment?: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"widget-hyperlink//hidden!": {
		Doc:   "Set widget.Hyperlink Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//hidden!: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-hyperlink//hidden?": {
		Doc:   "Get widget.Hyperlink Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//hidden?: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-hyperlink//on-tapped!": {
		Doc:   "Set widget.Hyperlink OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//on-tapped!: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//on-tapped!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//on-tapped!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//on-tapped!: arg 2: expected integer to be 0 or nil")
				}
				self.OnTapped = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//on-tapped!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-hyperlink//on-tapped?": {
		Doc:   "Get widget.Hyperlink OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//on-tapped?: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//on-tapped?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"widget-hyperlink//text!": {
		Doc:   "Set widget.Hyperlink Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//text!: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-hyperlink//text-style!": {
		Doc:   "Set widget.Hyperlink TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//text-style!: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-hyperlink//text-style?": {
		Doc:   "Get widget.Hyperlink TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//text-style?: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-hyperlink//text?": {
		Doc:   "Get widget.Hyperlink Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//text?: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-hyperlink//url!": {
		Doc:   "Set widget.Hyperlink URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//url!: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//url!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//url!: arg 2: expected native of type *url.URL")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//url!: arg 2: expected integer to be 0 or nil")
				}
				self.URL = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//url!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-hyperlink//url?": {
		Doc:   "Get widget.Hyperlink URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//url?: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//url?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "ptr-url-url")
			return resObj
		},
	},
	"widget-hyperlink//wrapping!": {
		Doc:   "Set widget.Hyperlink Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//wrapping!: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-hyperlink//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"widget-hyperlink//wrapping?": {
		Doc:   "Get widget.Hyperlink Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-hyperlink//wrapping?: arg 1: expected native of type widget.Hyperlink")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-hyperlink//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"widget-icon//hidden!": {
		Doc:   "Set widget.Icon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-icon//hidden!: arg 1: expected native of type widget.Icon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-icon//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-icon//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-icon//hidden?": {
		Doc:   "Get widget.Icon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-icon//hidden?: arg 1: expected native of type widget.Icon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-icon//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-icon//resource!": {
		Doc:   "Set widget.Icon Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-icon//resource!: arg 1: expected native of type widget.Icon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-icon//resource!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-icon//resource!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-icon//resource!: arg 2: expected integer to be 0 or nil")
				}
				self.Resource = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-icon//resource!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-icon//resource?": {
		Doc:   "Get widget.Icon Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-icon//resource?: arg 1: expected native of type widget.Icon")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-icon//resource?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Resource)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Resource, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Resource, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"widget-image-segment//alignment!": {
		Doc:   "Set widget.ImageSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-image-segment//alignment!: arg 1: expected native of type widget.ImageSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-image-segment//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-image-segment//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"widget-image-segment//alignment?": {
		Doc:   "Get widget.ImageSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-image-segment//alignment?: arg 1: expected native of type widget.ImageSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-image-segment//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"widget-image-segment//source!": {
		Doc:   "Set widget.ImageSegment Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-image-segment//source!: arg 1: expected native of type widget.ImageSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-image-segment//source!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-image-segment//source!: arg 2: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-image-segment//source!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-image-segment//source?": {
		Doc:   "Get widget.ImageSegment Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-image-segment//source?: arg 1: expected native of type widget.ImageSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-image-segment//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "fyne-uri")
			return resObj
		},
	},
	"widget-image-segment//title!": {
		Doc:   "Set widget.ImageSegment Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-image-segment//title!: arg 1: expected native of type widget.ImageSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-image-segment//title!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-image-segment//title!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-image-segment//title?": {
		Doc:   "Get widget.ImageSegment Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-image-segment//title?: arg 1: expected native of type widget.ImageSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-image-segment//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"widget-label//alignment!": {
		Doc:   "Set widget.Label Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//alignment!: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-label//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"widget-label//alignment?": {
		Doc:   "Get widget.Label Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//alignment?: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"widget-label//hidden!": {
		Doc:   "Set widget.Label Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//hidden!: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-label//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-label//hidden?": {
		Doc:   "Get widget.Label Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//hidden?: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-label//importance!": {
		Doc:   "Set widget.Label Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//importance!: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//importance!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.Importance
				if natOk {
					natVal, natValOk = nat.Value.(widget.Importance)
				}
				if natOk && natValOk {
					self.Importance = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-label//importance!: arg 2: expected integer")
					}
					self.Importance = widget.Importance(u)
				}
			}
			return arg0
		},
	},
	"widget-label//importance?": {
		Doc:   "Get widget.Label Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//importance?: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//importance?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Importance)))
			return resObj
		},
	},
	"widget-label//text!": {
		Doc:   "Set widget.Label Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//text!: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-label//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-label//text-style!": {
		Doc:   "Set widget.Label TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//text-style!: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-label//text-style?": {
		Doc:   "Get widget.Label TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//text-style?: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-label//text?": {
		Doc:   "Get widget.Label Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//text?: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-label//truncation!": {
		Doc:   "Set widget.Label Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//truncation!: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//truncation!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextTruncation
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextTruncation)
				}
				if natOk && natValOk {
					self.Truncation = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-label//truncation!: arg 2: expected integer")
					}
					self.Truncation = fyne.TextTruncation(u)
				}
			}
			return arg0
		},
	},
	"widget-label//truncation?": {
		Doc:   "Get widget.Label Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//truncation?: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//truncation?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Truncation)))
			return resObj
		},
	},
	"widget-label//wrapping!": {
		Doc:   "Set widget.Label Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//wrapping!: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-label//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"widget-label//wrapping?": {
		Doc:   "Get widget.Label Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-label//wrapping?: arg 1: expected native of type widget.Label")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-label//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"widget-list-segment//items!": {
		Doc:   "Set widget.ListSegment Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list-segment//items!: arg 1: expected native of type widget.ListSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list-segment//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-list-segment//items!: arg 2: block item: expected native of type widget.RichTextSegment")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-list-segment//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-list-segment//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list-segment//items!: arg 2: expected native of type []widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-list-segment//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list-segment//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-list-segment//items?": {
		Doc:   "Get widget.ListSegment Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list-segment//items?: arg 1: expected native of type widget.ListSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list-segment//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-rich-text-segment")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-list-segment//ordered!": {
		Doc:   "Set widget.ListSegment Ordered value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list-segment//ordered!: arg 1: expected native of type widget.ListSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list-segment//ordered!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Ordered = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-list-segment//ordered!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-list-segment//ordered?": {
		Doc:   "Get widget.ListSegment Ordered value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list-segment//ordered?: arg 1: expected native of type widget.ListSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list-segment//ordered?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Ordered))
			return resObj
		},
	},
	"widget-list//create-item!": {
		Doc:   "Set widget.List CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//create-item!: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//create-item!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-list//create-item!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-list//create-item!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//create-item!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-list//create-item?": {
		Doc:   "Get widget.List CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//create-item?: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//create-item?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "func()_(fyne-canvas-object)")
			return resObj
		},
	},
	"widget-list//hidden!": {
		Doc:   "Set widget.List Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//hidden!: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-list//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-list//hidden?": {
		Doc:   "Get widget.List Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//hidden?: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-list//length!": {
		Doc:   "Set widget.List Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//length!: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//length!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-list//length!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-list//length!: arg 2: expected integer to be 0 or nil")
				}
				self.Length = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//length!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-list//length?": {
		Doc:   "Get widget.List Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//length?: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//length?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int)")
			return resObj
		},
	},
	"widget-list//on-selected!": {
		Doc:   "Set widget.List OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//on-selected!: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-list//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 widget.ListItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-list//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-list//on-selected?": {
		Doc:   "Get widget.List OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//on-selected?: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(widget-list-item-id)")
			return resObj
		},
	},
	"widget-list//on-unselected!": {
		Doc:   "Set widget.List OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//on-unselected!: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-list//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 widget.ListItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-list//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-list//on-unselected?": {
		Doc:   "Get widget.List OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//on-unselected?: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(widget-list-item-id)")
			return resObj
		},
	},
	"widget-list//update-item!": {
		Doc:   "Set widget.List UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//update-item!: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//update-item!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("widget-list//update-item!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.UpdateItem = func(arg0 widget.ListItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-list//update-item!: arg 2: expected integer to be 0 or nil")
				}
				self.UpdateItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//update-item!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-list//update-item?": {
		Doc:   "Get widget.List UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-list//update-item?: arg 1: expected native of type widget.List")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-list//update-item?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "func(widget-list-item-id_fyne-canvas-object)")
			return resObj
		},
	},
	"low-importance": {
		Doc:   "Get widget.LowImportance value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.LowImportance)))
			return resObj
		},
	},
	"medium-importance": {
		Doc:   "Get widget.MediumImportance value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.MediumImportance)))
			return resObj
		},
	},
	"widget-menu//hidden!": {
		Doc:   "Set widget.Menu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-menu//hidden!: arg 1: expected native of type widget.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-menu//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-menu//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-menu//hidden?": {
		Doc:   "Get widget.Menu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-menu//hidden?: arg 1: expected native of type widget.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-menu//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-menu//items!": {
		Doc:   "Set widget.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-menu//items!: arg 1: expected native of type widget.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-menu//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-menu//items!: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-menu//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-menu//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-menu//items!: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-menu//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-menu//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-menu//items?": {
		Doc:   "Get widget.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-menu//items?: arg 1: expected native of type widget.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-menu//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-canvas-object")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-menu//on-dismiss!": {
		Doc:   "Set widget.Menu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-menu//on-dismiss!: arg 1: expected native of type widget.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-menu//on-dismiss!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-menu//on-dismiss!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-menu//on-dismiss!: arg 2: expected integer to be 0 or nil")
				}
				self.OnDismiss = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-menu//on-dismiss!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-menu//on-dismiss?": {
		Doc:   "Get widget.Menu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-menu//on-dismiss?: arg 1: expected native of type widget.Menu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-menu//on-dismiss?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "func()")
			return resObj
		},
	},
	"accordion": {
		Doc:   "widget.NewAccordion",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*widget.AccordionItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*widget.AccordionItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*widget.AccordionItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("accordion: arg 1: block item: expected native of type *widget.AccordionItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("accordion: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("accordion: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*widget.AccordionItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("accordion: arg 1: expected native of type []*widget.AccordionItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("accordion: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("accordion: arg 1: expected block, native or nil")
			}
			res0 := widget.NewAccordion(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-accordion")
			return res0Obj
		},
	},
	"accordion-item": {
		Doc:   "widget.NewAccordionItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("accordion-item: arg 1: expected string")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("accordion-item: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("accordion-item: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("accordion-item: arg 2: expected native")
			}
			res0 := widget.NewAccordionItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-accordion-item")
			return res0Obj
		},
	},
	"button": {
		Doc:   "widget.NewButton",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("button: arg 1: expected string")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("button: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("button: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("button: arg 2: expected function or nil")
			}
			res0 := widget.NewButton(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-button")
			return res0Obj
		},
	},
	"button-with-icon": {
		Doc:   "widget.NewButtonWithIcon",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("button-with-icon: arg 1: expected string")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("button-with-icon: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("button-with-icon: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("button-with-icon: arg 2: expected native")
			}
			var arg2Val func()
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("button-with-icon: arg 3: function has invalid number of arguments (expected 0)")
				}
				arg2Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("button-with-icon: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("button-with-icon: arg 3: expected function or nil")
			}
			res0 := widget.NewButtonWithIcon(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-button")
			return res0Obj
		},
	},
	"card": {
		Doc:   "widget.NewCard",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("card: arg 1: expected string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("card: arg 2: expected string")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("card: arg 3: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("card: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("card: arg 3: expected native")
			}
			res0 := widget.NewCard(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-card")
			return res0Obj
		},
	},
	"check": {
		Doc:   "widget.NewCheck",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("check: arg 1: expected string")
			}
			var arg1Val func(bool)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("check: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("check: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("check: arg 2: expected function or nil")
			}
			res0 := widget.NewCheck(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-check")
			return res0Obj
		},
	},
	"check-group": {
		Doc:   "widget.NewCheckGroup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("check-group: arg 1: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("check-group: arg 1: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("check-group: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("check-group: arg 1: expected block, native or nil")
			}
			var arg1Val func([]string)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("check-group: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 []string) {
					var arg0Val env.Object
					{
						items := make([]env.Object, len(arg0))
						for i, it := range arg0 {
							items[i] = *env.NewString(it)
						}
						arg0Val = *env.NewBlock(*env.NewTSeries(items))
					}
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("check-group: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("check-group: arg 2: expected function or nil")
			}
			res0 := widget.NewCheckGroup(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-check-group")
			return res0Obj
		},
	},
	"check-with-data": {
		Doc:   "widget.NewCheckWithData",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("check-with-data: arg 1: expected string")
			}
			var arg1Val binding.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("check-with-data: arg 2: expected native of type binding.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("check-with-data: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("check-with-data: arg 2: expected native")
			}
			res0 := widget.NewCheckWithData(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-check")
			return res0Obj
		},
	},
	"entry": {
		Doc:   "widget.NewEntry",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewEntry()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-entry")
			return res0Obj
		},
	},
	"entry-with-data": {
		Doc:   "widget.NewEntryWithData",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("entry-with-data: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("entry-with-data: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("entry-with-data: arg 1: expected native")
			}
			res0 := widget.NewEntryWithData(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-entry")
			return res0Obj
		},
	},
	"file-icon": {
		Doc:   "widget.NewFileIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("file-icon: arg 1: expected native of type fyne.URI")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("file-icon: arg 1: expected native")
			}
			res0 := widget.NewFileIcon(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-file-icon")
			return res0Obj
		},
	},
	"form": {
		Doc:   "widget.NewForm",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*widget.FormItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*widget.FormItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*widget.FormItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("form: arg 1: block item: expected native of type *widget.FormItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("form: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("form: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*widget.FormItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("form: arg 1: expected native of type []*widget.FormItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("form: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("form: arg 1: expected block, native or nil")
			}
			res0 := widget.NewForm(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-form")
			return res0Obj
		},
	},
	"form-item": {
		Doc:   "widget.NewFormItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("form-item: arg 1: expected string")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("form-item: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("form-item: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("form-item: arg 2: expected native")
			}
			res0 := widget.NewFormItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-form-item")
			return res0Obj
		},
	},
	"grid-wrap": {
		Doc:   "widget.NewGridWrap",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func() int
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap: arg 1: function has invalid number of arguments (expected 0)")
				}
				arg0Val = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("grid-wrap: arg 1: expected function or nil")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("grid-wrap: arg 2: expected function or nil")
			}
			var arg2Val func(widget.GridWrapItemID, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap: arg 3: function has invalid number of arguments (expected 2)")
				}
				arg2Val = func(arg0 widget.GridWrapItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("grid-wrap: arg 3: expected function or nil")
			}
			res0 := widget.NewGridWrap(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-grid-wrap")
			return res0Obj
		},
	},
	"grid-wrap-with-data": {
		Doc:   "widget.NewGridWrapWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("grid-wrap-with-data: arg 1: expected native of type binding.DataList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap-with-data: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("grid-wrap-with-data: arg 1: expected native")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap-with-data: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap-with-data: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("grid-wrap-with-data: arg 2: expected function or nil")
			}
			var arg2Val func(binding.DataItem, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap-with-data: arg 3: function has invalid number of arguments (expected 2)")
				}
				arg2Val = func(arg0 binding.DataItem, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					{
						typ := reflect.TypeOf(arg0)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
						} else {
							arg0Val = *env.NewNative(ps.Idx, arg0, "binding-data-item")
						}
					}
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("grid-wrap-with-data: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("grid-wrap-with-data: arg 3: expected function or nil")
			}
			res0 := widget.NewGridWrapWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-grid-wrap")
			return res0Obj
		},
	},
	"hyperlink": {
		Doc:   "widget.NewHyperlink",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("hyperlink: arg 1: expected string")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("hyperlink: arg 2: expected native of type *url.URL")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("hyperlink: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("hyperlink: arg 2: expected native")
			}
			res0 := widget.NewHyperlink(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-hyperlink")
			return res0Obj
		},
	},
	"hyperlink-with-style": {
		Doc:   "widget.NewHyperlinkWithStyle",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("hyperlink-with-style: arg 1: expected string")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("hyperlink-with-style: arg 2: expected native of type *url.URL")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("hyperlink-with-style: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("hyperlink-with-style: arg 2: expected native")
			}
			var arg2Val fyne.TextAlign
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					arg2Val = natVal
				} else {
					var u int
					if v, ok := arg2.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("hyperlink-with-style: arg 3: expected integer")
					}
					arg2Val = fyne.TextAlign(u)
				}
			}
			var arg3Val fyne.TextStyle
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("hyperlink-with-style: arg 4: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("hyperlink-with-style: arg 4: expected native")
			}
			res0 := widget.NewHyperlinkWithStyle(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-hyperlink")
			return res0Obj
		},
	},
	"icon": {
		Doc:   "widget.NewIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("icon: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("icon: arg 1: expected native")
			}
			res0 := widget.NewIcon(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-icon")
			return res0Obj
		},
	},
	"label": {
		Doc:   "widget.NewLabel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("label: arg 1: expected string")
			}
			res0 := widget.NewLabel(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-label")
			return res0Obj
		},
	},
	"label-with-data": {
		Doc:   "widget.NewLabelWithData",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("label-with-data: arg 1: expected native of type binding.String")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("label-with-data: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("label-with-data: arg 1: expected native")
			}
			res0 := widget.NewLabelWithData(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-label")
			return res0Obj
		},
	},
	"label-with-style": {
		Doc:   "widget.NewLabelWithStyle",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("label-with-style: arg 1: expected string")
			}
			var arg1Val fyne.TextAlign
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("label-with-style: arg 2: expected integer")
					}
					arg1Val = fyne.TextAlign(u)
				}
			}
			var arg2Val fyne.TextStyle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("label-with-style: arg 3: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("label-with-style: arg 3: expected native")
			}
			res0 := widget.NewLabelWithStyle(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-label")
			return res0Obj
		},
	},
	"list": {
		Doc:   "widget.NewList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func() int
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("list: arg 1: function has invalid number of arguments (expected 0)")
				}
				arg0Val = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("list: arg 1: expected function or nil")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("list: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("list: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("list: arg 2: expected function or nil")
			}
			var arg2Val func(widget.ListItemID, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("list: arg 3: function has invalid number of arguments (expected 2)")
				}
				arg2Val = func(arg0 widget.ListItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(int(arg0)))
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("list: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("list: arg 3: expected function or nil")
			}
			res0 := widget.NewList(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-list")
			return res0Obj
		},
	},
	"list-with-data": {
		Doc:   "widget.NewListWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("list-with-data: arg 1: expected native of type binding.DataList")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("list-with-data: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("list-with-data: arg 1: expected native")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("list-with-data: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("list-with-data: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("list-with-data: arg 2: expected function or nil")
			}
			var arg2Val func(binding.DataItem, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("list-with-data: arg 3: function has invalid number of arguments (expected 2)")
				}
				arg2Val = func(arg0 binding.DataItem, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					{
						typ := reflect.TypeOf(arg0)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg0Val = *env.NewNative(ps.Idx, arg0, typRyeName)
						} else {
							arg0Val = *env.NewNative(ps.Idx, arg0, "binding-data-item")
						}
					}
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("list-with-data: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("list-with-data: arg 3: expected function or nil")
			}
			res0 := widget.NewListWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-list")
			return res0Obj
		},
	},
	"widget-menu": {
		Doc:   "widget.NewMenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-menu: arg 1: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-menu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-menu: arg 1: expected native")
			}
			res0 := widget.NewMenu(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-menu")
			return res0Obj
		},
	},
	"modal-pop-up": {
		Doc:   "widget.NewModalPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("modal-pop-up: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("modal-pop-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("modal-pop-up: arg 1: expected native")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("modal-pop-up: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("modal-pop-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("modal-pop-up: arg 2: expected native")
			}
			res0 := widget.NewModalPopUp(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-pop-up")
			return res0Obj
		},
	},
	"multi-line-entry": {
		Doc:   "widget.NewMultiLineEntry",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewMultiLineEntry()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-entry")
			return res0Obj
		},
	},
	"password-entry": {
		Doc:   "widget.NewPasswordEntry",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewPasswordEntry()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-entry")
			return res0Obj
		},
	},
	"pop-up": {
		Doc:   "widget.NewPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("pop-up: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("pop-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("pop-up: arg 1: expected native")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("pop-up: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("pop-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("pop-up: arg 2: expected native")
			}
			res0 := widget.NewPopUp(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-pop-up")
			return res0Obj
		},
	},
	"pop-up-menu": {
		Doc:   "widget.NewPopUpMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("pop-up-menu: arg 1: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("pop-up-menu: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("pop-up-menu: arg 1: expected native")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("pop-up-menu: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("pop-up-menu: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("pop-up-menu: arg 2: expected native")
			}
			res0 := widget.NewPopUpMenu(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-pop-up-menu")
			return res0Obj
		},
	},
	"progress-bar": {
		Doc:   "widget.NewProgressBar",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewProgressBar()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-progress-bar")
			return res0Obj
		},
	},
	"progress-bar-infinite": {
		Doc:   "widget.NewProgressBarInfinite",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewProgressBarInfinite()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-progress-bar-infinite")
			return res0Obj
		},
	},
	"progress-bar-with-data": {
		Doc:   "widget.NewProgressBarWithData",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("progress-bar-with-data: arg 1: expected native of type binding.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("progress-bar-with-data: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("progress-bar-with-data: arg 1: expected native")
			}
			res0 := widget.NewProgressBarWithData(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-progress-bar")
			return res0Obj
		},
	},
	"radio-group": {
		Doc:   "widget.NewRadioGroup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("radio-group: arg 1: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("radio-group: arg 1: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("radio-group: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("radio-group: arg 1: expected block, native or nil")
			}
			var arg1Val func(string)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("radio-group: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("radio-group: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("radio-group: arg 2: expected function or nil")
			}
			res0 := widget.NewRadioGroup(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-radio-group")
			return res0Obj
		},
	},
	"rich-text": {
		Doc:   "widget.NewRichText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("rich-text: arg 1: block item: expected native of type widget.RichTextSegment")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("rich-text: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("rich-text: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("rich-text: arg 1: expected native of type []widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("rich-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("rich-text: arg 1: expected block, native or nil")
			}
			res0 := widget.NewRichText(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-rich-text")
			return res0Obj
		},
	},
	"rich-text-from-markdown": {
		Doc:   "widget.NewRichTextFromMarkdown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("rich-text-from-markdown: arg 1: expected string")
			}
			res0 := widget.NewRichTextFromMarkdown(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-rich-text")
			return res0Obj
		},
	},
	"rich-text-with-text": {
		Doc:   "widget.NewRichTextWithText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("rich-text-with-text: arg 1: expected string")
			}
			res0 := widget.NewRichTextWithText(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-rich-text")
			return res0Obj
		},
	},
	"select": {
		Doc:   "widget.NewSelect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("select: arg 1: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("select: arg 1: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("select: arg 1: expected block, native or nil")
			}
			var arg1Val func(string)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("select: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("select: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("select: arg 2: expected function or nil")
			}
			res0 := widget.NewSelect(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-select")
			return res0Obj
		},
	},
	"select-entry": {
		Doc:   "widget.NewSelectEntry",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("select-entry: arg 1: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("select-entry: arg 1: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("select-entry: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("select-entry: arg 1: expected block, native or nil")
			}
			res0 := widget.NewSelectEntry(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-select-entry")
			return res0Obj
		},
	},
	"separator": {
		Doc:   "widget.NewSeparator",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewSeparator()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-separator")
			return res0Obj
		},
	},
	"simple-renderer": {
		Doc:   "widget.NewSimpleRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("simple-renderer: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("simple-renderer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("simple-renderer: arg 1: expected native")
			}
			res0 := widget.NewSimpleRenderer(arg0Val)
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
				}
			}
			return res0Obj
		},
	},
	"slider": {
		Doc:   "widget.NewSlider",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float64
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("slider: arg 1: expected decimal")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("slider: arg 2: expected decimal")
			}
			res0 := widget.NewSlider(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-slider")
			return res0Obj
		},
	},
	"slider-with-data": {
		Doc:   "widget.NewSliderWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float64
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("slider-with-data: arg 1: expected decimal")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("slider-with-data: arg 2: expected decimal")
			}
			var arg2Val binding.Float
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(binding.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("slider-with-data: arg 3: expected native of type binding.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("slider-with-data: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("slider-with-data: arg 3: expected native")
			}
			res0 := widget.NewSliderWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-slider")
			return res0Obj
		},
	},
	"table": {
		Doc:   "widget.NewTable",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func() (int, int)
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(func() (int, int))
				if !ok {
					ps.FailureFlag = true
					return env.NewError("table: arg 1: expected native of type func() (int, int)")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("table: arg 1: expected native")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("table: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("table: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("table: arg 2: expected function or nil")
			}
			var arg2Val func(widget.TableCellID, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("table: arg 3: function has invalid number of arguments (expected 2)")
				}
				arg2Val = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("table: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("table: arg 3: expected function or nil")
			}
			res0 := widget.NewTable(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-table")
			return res0Obj
		},
	},
	"table-with-headers": {
		Doc:   "widget.NewTableWithHeaders",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func() (int, int)
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(func() (int, int))
				if !ok {
					ps.FailureFlag = true
					return env.NewError("table-with-headers: arg 1: expected native of type func() (int, int)")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("table-with-headers: arg 1: expected native")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("table-with-headers: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("table-with-headers: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("table-with-headers: arg 2: expected function or nil")
			}
			var arg2Val func(widget.TableCellID, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("table-with-headers: arg 3: function has invalid number of arguments (expected 2)")
				}
				arg2Val = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("table-with-headers: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("table-with-headers: arg 3: expected function or nil")
			}
			res0 := widget.NewTableWithHeaders(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-table")
			return res0Obj
		},
	},
	"text-grid": {
		Doc:   "widget.NewTextGrid",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewTextGrid()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-text-grid")
			return res0Obj
		},
	},
	"text-grid-from-string": {
		Doc:   "widget.NewTextGridFromString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("text-grid-from-string: arg 1: expected string")
			}
			res0 := widget.NewTextGridFromString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-text-grid")
			return res0Obj
		},
	},
	"toolbar": {
		Doc:   "widget.NewToolbar",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []widget.ToolbarItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]widget.ToolbarItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(widget.ToolbarItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("toolbar: arg 1: block item: expected native of type widget.ToolbarItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("toolbar: arg 1: block item: expected integer to be 0 or nil")
						}
						arg0Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("toolbar: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]widget.ToolbarItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("toolbar: arg 1: expected native of type []widget.ToolbarItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("toolbar: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("toolbar: arg 1: expected block, native or nil")
			}
			res0 := widget.NewToolbar(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-toolbar")
			return res0Obj
		},
	},
	"toolbar-action": {
		Doc:   "widget.NewToolbarAction",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("toolbar-action: arg 1: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("toolbar-action: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("toolbar-action: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("toolbar-action: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("toolbar-action: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("toolbar-action: arg 2: expected function or nil")
			}
			res0 := widget.NewToolbarAction(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-toolbar-action")
			return res0Obj
		},
	},
	"toolbar-separator": {
		Doc:   "widget.NewToolbarSeparator",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewToolbarSeparator()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-toolbar-separator")
			return res0Obj
		},
	},
	"toolbar-spacer": {
		Doc:   "widget.NewToolbarSpacer",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewToolbarSpacer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-toolbar-spacer")
			return res0Obj
		},
	},
	"tree": {
		Doc:   "widget.NewTree",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(widget.TreeNodeID) []widget.TreeNodeID
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("tree: arg 1: function has invalid number of arguments (expected 1)")
				}
				arg0Val = func(arg0 widget.TreeNodeID) []widget.TreeNodeID {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res []widget.TreeNodeID
					switch v := ps.Res.(type) {
					case env.Block:
						res = make([]widget.TreeNodeID, len(v.Series.S))
						for i, it := range v.Series.S {
							{
								nat, natOk := it.(env.Native)
								var natValOk bool
								var natVal widget.TreeNodeID
								if natOk {
									natVal, natValOk = nat.Value.(widget.TreeNodeID)
								}
								if natOk && natValOk {
									res[i] = natVal
								} else {
									var u string
									if v, ok := it.(env.String); ok {
										u = string(v.Value)
									} else {
										// TODO: Cannot return error from function
									}
									res[i] = widget.TreeNodeID(u)
								}
							}
						}
					case env.Native:
						var ok bool
						res, ok = v.Value.([]widget.TreeNodeID)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("tree: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("tree: arg 1: expected function or nil")
			}
			var arg1Val func(widget.TreeNodeID) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("tree: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 widget.TreeNodeID) bool {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("tree: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("tree: arg 2: expected function or nil")
			}
			var arg2Val func(bool) fyne.CanvasObject
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("tree: arg 3: function has invalid number of arguments (expected 1)")
				}
				arg2Val = func(arg0 bool) fyne.CanvasObject {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("tree: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("tree: arg 3: expected function or nil")
			}
			var arg3Val func(widget.TreeNodeID, bool, fyne.CanvasObject)
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(func(widget.TreeNodeID, bool, fyne.CanvasObject))
				if !ok {
					ps.FailureFlag = true
					return env.NewError("tree: arg 4: expected native of type func(widget.TreeNodeID, bool, fyne.CanvasObject)")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("tree: arg 4: expected native")
			}
			res0 := widget.NewTree(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-tree")
			return res0Obj
		},
	},
	"tree-with-data": {
		Doc:   "widget.NewTreeWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataTree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("tree-with-data: arg 1: expected native of type binding.DataTree")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("tree-with-data: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("tree-with-data: arg 1: expected native")
			}
			var arg1Val func(bool) fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("tree-with-data: arg 2: function has invalid number of arguments (expected 1)")
				}
				arg1Val = func(arg0 bool) fyne.CanvasObject {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("tree-with-data: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("tree-with-data: arg 2: expected function or nil")
			}
			var arg2Val func(binding.DataItem, bool, fyne.CanvasObject)
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(func(binding.DataItem, bool, fyne.CanvasObject))
				if !ok {
					ps.FailureFlag = true
					return env.NewError("tree-with-data: arg 3: expected native of type func(binding.DataItem, bool, fyne.CanvasObject)")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("tree-with-data: arg 3: expected native")
			}
			res0 := widget.NewTreeWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-tree")
			return res0Obj
		},
	},
	"tree-with-strings": {
		Doc:   "widget.NewTreeWithStrings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val map[string][]string
			switch v := arg0.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					ps.FailureFlag = true
					return env.NewError("tree-with-strings: arg 1: expected block to have length of multiple of 2")
				}
				arg0Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("tree-with-strings: arg 1: map key: expected string")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("tree-with-strings: arg 1: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("tree-with-strings: arg 1: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("tree-with-strings: arg 1: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("tree-with-strings: arg 1: map value: expected block, native or nil")
					}
					arg0Val[mapK] = mapV
				}
			case env.Dict:
				arg0Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								ps.FailureFlag = true
								return env.NewError("tree-with-strings: arg 1: map value: block item: expected string")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("tree-with-strings: arg 1: map value: expected native of type []string")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("tree-with-strings: arg 1: map value: expected integer to be 0 or nil")
						}
						mapV = nil
					default:
						ps.FailureFlag = true
						return env.NewError("tree-with-strings: arg 1: map value: expected block, native or nil")
					}
					arg0Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(map[string][]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("tree-with-strings: arg 1: expected native of type map[string][]string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("tree-with-strings: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("tree-with-strings: arg 1: expected native, block, dict or nil")
			}
			res0 := widget.NewTreeWithStrings(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-widget-tree")
			return res0Obj
		},
	},
	"widget-paragraph-segment//texts!": {
		Doc:   "Set widget.ParagraphSegment Texts value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-paragraph-segment//texts!: arg 1: expected native of type widget.ParagraphSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-paragraph-segment//texts!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Texts = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Texts[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-paragraph-segment//texts!: arg 2: block item: expected native of type widget.RichTextSegment")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-paragraph-segment//texts!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Texts[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-paragraph-segment//texts!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Texts, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-paragraph-segment//texts!: arg 2: expected native of type []widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-paragraph-segment//texts!: arg 2: expected integer to be 0 or nil")
				}
				self.Texts = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-paragraph-segment//texts!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-paragraph-segment//texts?": {
		Doc:   "Get widget.ParagraphSegment Texts value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ParagraphSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-paragraph-segment//texts?: arg 1: expected native of type widget.ParagraphSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-paragraph-segment//texts?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Texts))
				for i, it := range self.Texts {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-rich-text-segment")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-pop-up-menu//hidden!": {
		Doc:   "Set widget.PopUpMenu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//hidden!: arg 1: expected native of type widget.PopUpMenu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up-menu//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-pop-up-menu//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-pop-up-menu//hidden?": {
		Doc:   "Get widget.PopUpMenu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//hidden?: arg 1: expected native of type widget.PopUpMenu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up-menu//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-pop-up-menu//items!": {
		Doc:   "Set widget.PopUpMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//items!: arg 1: expected native of type widget.PopUpMenu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up-menu//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-pop-up-menu//items!: arg 2: block item: expected native of type fyne.CanvasObject")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-pop-up-menu//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-pop-up-menu//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//items!: arg 2: expected native of type []fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up-menu//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-pop-up-menu//items?": {
		Doc:   "Get widget.PopUpMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//items?: arg 1: expected native of type widget.PopUpMenu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up-menu//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "fyne-canvas-object")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-pop-up-menu//on-dismiss!": {
		Doc:   "Set widget.PopUpMenu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//on-dismiss!: arg 1: expected native of type widget.PopUpMenu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up-menu//on-dismiss!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//on-dismiss!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//on-dismiss!: arg 2: expected integer to be 0 or nil")
				}
				self.OnDismiss = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up-menu//on-dismiss!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-pop-up-menu//on-dismiss?": {
		Doc:   "Get widget.PopUpMenu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up-menu//on-dismiss?: arg 1: expected native of type widget.PopUpMenu")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up-menu//on-dismiss?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "func()")
			return resObj
		},
	},
	"widget-pop-up//canvas!": {
		Doc:   "Set widget.PopUp Canvas value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//canvas!: arg 1: expected native of type widget.PopUp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up//canvas!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Canvas, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//canvas!: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//canvas!: arg 2: expected integer to be 0 or nil")
				}
				self.Canvas = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up//canvas!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-pop-up//canvas?": {
		Doc:   "Get widget.PopUp Canvas value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//canvas?: arg 1: expected native of type widget.PopUp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up//canvas?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Canvas)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Canvas, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Canvas, "fyne-canvas")
				}
			}
			return resObj
		},
	},
	"widget-pop-up//content!": {
		Doc:   "Set widget.PopUp Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//content!: arg 1: expected native of type widget.PopUp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up//content!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//content!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//content!: arg 2: expected integer to be 0 or nil")
				}
				self.Content = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up//content!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-pop-up//content?": {
		Doc:   "Get widget.PopUp Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//content?: arg 1: expected native of type widget.PopUp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up//content?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Content)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Content, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"widget-pop-up//hidden!": {
		Doc:   "Set widget.PopUp Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//hidden!: arg 1: expected native of type widget.PopUp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-pop-up//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-pop-up//hidden?": {
		Doc:   "Get widget.PopUp Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-pop-up//hidden?: arg 1: expected native of type widget.PopUp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-pop-up//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-progress-bar-infinite//hidden!": {
		Doc:   "Set widget.ProgressBarInfinite Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar-infinite//hidden!: arg 1: expected native of type widget.ProgressBarInfinite")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar-infinite//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar-infinite//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-progress-bar-infinite//hidden?": {
		Doc:   "Get widget.ProgressBarInfinite Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBarInfinite)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar-infinite//hidden?: arg 1: expected native of type widget.ProgressBarInfinite")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar-infinite//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-progress-bar//hidden!": {
		Doc:   "Set widget.ProgressBar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//hidden!: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-progress-bar//hidden?": {
		Doc:   "Get widget.ProgressBar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//hidden?: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-progress-bar//max!": {
		Doc:   "Set widget.ProgressBar Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//max!: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//max!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//max!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"widget-progress-bar//max?": {
		Doc:   "Get widget.ProgressBar Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//max?: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//max?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"widget-progress-bar//min!": {
		Doc:   "Set widget.ProgressBar Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//min!: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//min!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//min!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"widget-progress-bar//min?": {
		Doc:   "Get widget.ProgressBar Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//min?: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//min?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"widget-progress-bar//text-formatter!": {
		Doc:   "Set widget.ProgressBar TextFormatter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//text-formatter!: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//text-formatter!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//text-formatter!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.TextFormatter = func() string {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res string
					if v, ok := ps.Res.(env.String); ok {
						res = string(v.Value)
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//text-formatter!: arg 2: expected integer to be 0 or nil")
				}
				self.TextFormatter = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//text-formatter!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-progress-bar//text-formatter?": {
		Doc:   "Get widget.ProgressBar TextFormatter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//text-formatter?: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//text-formatter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextFormatter, "func()_(string)")
			return resObj
		},
	},
	"widget-progress-bar//value!": {
		Doc:   "Set widget.ProgressBar Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//value!: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//value!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//value!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"widget-progress-bar//value?": {
		Doc:   "Get widget.ProgressBar Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-progress-bar//value?: arg 1: expected native of type widget.ProgressBar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-progress-bar//value?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"widget-radio-group//hidden!": {
		Doc:   "Set widget.RadioGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//hidden!: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-radio-group//hidden?": {
		Doc:   "Get widget.RadioGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//hidden?: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-radio-group//horizontal!": {
		Doc:   "Set widget.RadioGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//horizontal!: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//horizontal!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//horizontal!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-radio-group//horizontal?": {
		Doc:   "Get widget.RadioGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//horizontal?: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//horizontal?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"widget-radio-group//on-changed!": {
		Doc:   "Set widget.RadioGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//on-changed!: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-radio-group//on-changed?": {
		Doc:   "Get widget.RadioGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//on-changed?: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"widget-radio-group//options!": {
		Doc:   "Set widget.RadioGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//options!: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//options!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-radio-group//options!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//options!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//options!: arg 2: expected integer to be 0 or nil")
				}
				self.Options = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//options!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-radio-group//options?": {
		Doc:   "Get widget.RadioGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//options?: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//options?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-radio-group//required!": {
		Doc:   "Set widget.RadioGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//required!: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//required!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//required!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-radio-group//required?": {
		Doc:   "Get widget.RadioGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//required?: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//required?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"widget-radio-group//selected!": {
		Doc:   "Set widget.RadioGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//selected!: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//selected!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//selected!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-radio-group//selected?": {
		Doc:   "Get widget.RadioGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-radio-group//selected?: arg 1: expected native of type widget.RadioGroup")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-radio-group//selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"widget-rich-text-block//segments": {
		Doc:   "widget.RichTextBlock.Segments",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextBlock
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextBlock)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-block//segments: arg 1: expected native of type widget.RichTextBlock")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-block//segments: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-block//segments: arg 1: expected native")
			}
			res0 := arg0Val.Segments()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-rich-text-segment")
						}
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"widget-rich-text-segment//inline": {
		Doc:   "widget.RichTextSegment.Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//inline: arg 1: expected native of type widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//inline: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//inline: arg 1: expected native")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-rich-text-segment//select": {
		Doc:   "widget.RichTextSegment.Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//select: arg 1: expected native of type widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//select: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//select: arg 1: expected native")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//select: arg 2: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//select: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//select: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//select: arg 3: expected native")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-rich-text-segment//selected-text": {
		Doc:   "widget.RichTextSegment.SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//selected-text: arg 1: expected native of type widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-rich-text-segment//textual": {
		Doc:   "widget.RichTextSegment.Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//textual: arg 1: expected native of type widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//textual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//textual: arg 1: expected native")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-rich-text-segment//unselect": {
		Doc:   "widget.RichTextSegment.Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//unselect: arg 1: expected native of type widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//unselect: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//unselect: arg 1: expected native")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"widget-rich-text-segment//update": {
		Doc:   "widget.RichTextSegment.Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//update: arg 1: expected native of type widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//update: arg 1: expected native")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//update: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//update: arg 2: expected native")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"widget-rich-text-segment//visual": {
		Doc:   "widget.RichTextSegment.Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//visual: arg 1: expected native of type widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-segment//visual: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-segment//visual: arg 1: expected native")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"widget-rich-text-style//alignment!": {
		Doc:   "Set widget.RichTextStyle Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//alignment!: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-rich-text-style//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"widget-rich-text-style//alignment?": {
		Doc:   "Get widget.RichTextStyle Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//alignment?: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"widget-rich-text-style//color-name!": {
		Doc:   "Set widget.RichTextStyle ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//color-name!: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//color-name!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeColorName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeColorName)
				}
				if natOk && natValOk {
					self.ColorName = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-rich-text-style//color-name!: arg 2: expected string")
					}
					self.ColorName = fyne.ThemeColorName(u)
				}
			}
			return arg0
		},
	},
	"widget-rich-text-style//color-name?": {
		Doc:   "Get widget.RichTextStyle ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//color-name?: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//color-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.ColorName))
			return resObj
		},
	},
	"widget-rich-text-style//inline!": {
		Doc:   "Set widget.RichTextStyle Inline value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//inline!: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//inline!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Inline = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//inline!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-rich-text-style//inline?": {
		Doc:   "Get widget.RichTextStyle Inline value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//inline?: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//inline?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Inline))
			return resObj
		},
	},
	"widget-rich-text-style//size-name!": {
		Doc:   "Set widget.RichTextStyle SizeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//size-name!: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//size-name!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.ThemeSizeName
				if natOk {
					natVal, natValOk = nat.Value.(fyne.ThemeSizeName)
				}
				if natOk && natValOk {
					self.SizeName = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-rich-text-style//size-name!: arg 2: expected string")
					}
					self.SizeName = fyne.ThemeSizeName(u)
				}
			}
			return arg0
		},
	},
	"widget-rich-text-style//size-name?": {
		Doc:   "Get widget.RichTextStyle SizeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//size-name?: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//size-name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.SizeName))
			return resObj
		},
	},
	"widget-rich-text-style//text-style!": {
		Doc:   "Set widget.RichTextStyle TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//text-style!: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-rich-text-style//text-style?": {
		Doc:   "Get widget.RichTextStyle TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text-style//text-style?: arg 1: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text-style//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-rich-text//hidden!": {
		Doc:   "Set widget.RichText Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//hidden!: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-rich-text//hidden?": {
		Doc:   "Get widget.RichText Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//hidden?: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-rich-text//scroll!": {
		Doc:   "Set widget.RichText Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//scroll!: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//scroll!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var rOut, rIn reflect.Value
				if natOk {
					// HACK: self.Scroll, natValOk = widget_1.ScrollDirection(u)
					rOut = reflect.ValueOf(&self.Scroll).Elem()
					rIn = reflect.ValueOf(nat.Value)
					natValOk = rIn.CanConvert(rOut.Type())
				}
				if natOk && natValOk {
					rOut.Set(rIn.Convert(rOut.Type()))
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-rich-text//scroll!: arg 2: expected integer")
					}
					// HACK: self.Scroll = widget_1.ScrollDirection(u)
					rOut := reflect.ValueOf(&self.Scroll).Elem()
					rIn := reflect.ValueOf(u)
					rOut.Set(rIn.Convert(rOut.Type()))
				}
			}
			return arg0
		},
	},
	"widget-rich-text//scroll?": {
		Doc:   "Get widget.RichText Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//scroll?: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//scroll?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Scroll)))
			return resObj
		},
	},
	"widget-rich-text//segments!": {
		Doc:   "Set widget.RichText Segments value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//segments!: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//segments!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Segments = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Segments[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-rich-text//segments!: arg 2: block item: expected native of type widget.RichTextSegment")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-rich-text//segments!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Segments[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-rich-text//segments!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Segments, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//segments!: arg 2: expected native of type []widget.RichTextSegment")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//segments!: arg 2: expected integer to be 0 or nil")
				}
				self.Segments = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//segments!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-rich-text//segments?": {
		Doc:   "Get widget.RichText Segments value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//segments?: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//segments?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Segments))
				for i, it := range self.Segments {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-rich-text-segment")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-rich-text//truncation!": {
		Doc:   "Set widget.RichText Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//truncation!: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//truncation!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextTruncation
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextTruncation)
				}
				if natOk && natValOk {
					self.Truncation = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-rich-text//truncation!: arg 2: expected integer")
					}
					self.Truncation = fyne.TextTruncation(u)
				}
			}
			return arg0
		},
	},
	"widget-rich-text//truncation?": {
		Doc:   "Get widget.RichText Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//truncation?: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//truncation?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Truncation)))
			return resObj
		},
	},
	"widget-rich-text//wrapping!": {
		Doc:   "Set widget.RichText Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//wrapping!: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-rich-text//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"widget-rich-text//wrapping?": {
		Doc:   "Get widget.RichText Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-rich-text//wrapping?: arg 1: expected native of type widget.RichText")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-rich-text//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"widget-select-entry//action-item!": {
		Doc:   "Set widget.SelectEntry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//action-item!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//action-item!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//action-item!: arg 2: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//action-item!: arg 2: expected integer to be 0 or nil")
				}
				self.ActionItem = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//action-item!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-select-entry//action-item?": {
		Doc:   "Get widget.SelectEntry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//action-item?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//action-item?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.ActionItem)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.ActionItem, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.ActionItem, "fyne-canvas-object")
				}
			}
			return resObj
		},
	},
	"widget-select-entry//cursor-column!": {
		Doc:   "Set widget.SelectEntry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//cursor-column!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//cursor-column!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//cursor-column!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-select-entry//cursor-column?": {
		Doc:   "Get widget.SelectEntry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//cursor-column?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//cursor-column?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"widget-select-entry//cursor-row!": {
		Doc:   "Set widget.SelectEntry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//cursor-row!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//cursor-row!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//cursor-row!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-select-entry//cursor-row?": {
		Doc:   "Get widget.SelectEntry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//cursor-row?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//cursor-row?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"widget-select-entry//hidden!": {
		Doc:   "Set widget.SelectEntry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//hidden!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-select-entry//hidden?": {
		Doc:   "Get widget.SelectEntry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//hidden?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-select-entry//multi-line!": {
		Doc:   "Set widget.SelectEntry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//multi-line!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//multi-line!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//multi-line!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-select-entry//multi-line?": {
		Doc:   "Get widget.SelectEntry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//multi-line?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//multi-line?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"widget-select-entry//on-changed!": {
		Doc:   "Set widget.SelectEntry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-changed!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-select-entry//on-changed?": {
		Doc:   "Get widget.SelectEntry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-changed?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"widget-select-entry//on-cursor-changed!": {
		Doc:   "Set widget.SelectEntry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-cursor-changed!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//on-cursor-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-cursor-changed!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-cursor-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnCursorChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//on-cursor-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-select-entry//on-cursor-changed?": {
		Doc:   "Get widget.SelectEntry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-cursor-changed?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//on-cursor-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "func()")
			return resObj
		},
	},
	"widget-select-entry//on-submitted!": {
		Doc:   "Set widget.SelectEntry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-submitted!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//on-submitted!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-submitted!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-submitted!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSubmitted = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//on-submitted!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-select-entry//on-submitted?": {
		Doc:   "Get widget.SelectEntry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//on-submitted?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//on-submitted?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "func(string)")
			return resObj
		},
	},
	"widget-select-entry//password!": {
		Doc:   "Set widget.SelectEntry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//password!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//password!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//password!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-select-entry//password?": {
		Doc:   "Get widget.SelectEntry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//password?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//password?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"widget-select-entry//place-holder!": {
		Doc:   "Set widget.SelectEntry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//place-holder!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//place-holder!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//place-holder!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-select-entry//place-holder?": {
		Doc:   "Get widget.SelectEntry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//place-holder?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//place-holder?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"widget-select-entry//scroll!": {
		Doc:   "Set widget.SelectEntry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//scroll!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//scroll!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var rOut, rIn reflect.Value
				if natOk {
					// HACK: self.Scroll, natValOk = widget_1.ScrollDirection(u)
					rOut = reflect.ValueOf(&self.Scroll).Elem()
					rIn = reflect.ValueOf(nat.Value)
					natValOk = rIn.CanConvert(rOut.Type())
				}
				if natOk && natValOk {
					rOut.Set(rIn.Convert(rOut.Type()))
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-select-entry//scroll!: arg 2: expected integer")
					}
					// HACK: self.Scroll = widget_1.ScrollDirection(u)
					rOut := reflect.ValueOf(&self.Scroll).Elem()
					rIn := reflect.ValueOf(u)
					rOut.Set(rIn.Convert(rOut.Type()))
				}
			}
			return arg0
		},
	},
	"widget-select-entry//scroll?": {
		Doc:   "Get widget.SelectEntry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//scroll?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//scroll?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Scroll)))
			return resObj
		},
	},
	"widget-select-entry//text!": {
		Doc:   "Set widget.SelectEntry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//text!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-select-entry//text-style!": {
		Doc:   "Set widget.SelectEntry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//text-style!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//text-style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//text-style!: arg 2: expected native of type fyne.TextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//text-style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-select-entry//text-style?": {
		Doc:   "Get widget.SelectEntry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//text-style?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//text-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-select-entry//text?": {
		Doc:   "Get widget.SelectEntry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//text?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-select-entry//validator!": {
		Doc:   "Set widget.SelectEntry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//validator!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//validator!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.StringValidator
				if natOk {
					natVal, natValOk = nat.Value.(fyne.StringValidator)
				}
				if natOk && natValOk {
					self.Validator = natVal
				} else {
					var u func(string) error
					switch fn := arg1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("widget-select-entry//validator!: arg 2: function has invalid number of arguments (expected 1)")
						}
						u = func(arg0 string) error {
							var arg0Val env.Object
							arg0Val = *env.NewString(arg0)
							evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
							var res error
							switch v := ps.Res.(type) {
							case env.String:
								res = errors.New(v.Value)
							case env.Error:
								res = errors.New(v.Print(*ps.Idx))
							case env.Integer:
								if v.Value != 0 {
									// TODO: Cannot return error from function
								}
								res = nil
							default:
								// TODO: Cannot return error from function
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-select-entry//validator!: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-select-entry//validator!: arg 2: expected function or nil")
					}
					self.Validator = fyne.StringValidator(u)
				}
			}
			return arg0
		},
	},
	"widget-select-entry//validator?": {
		Doc:   "Get widget.SelectEntry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//validator?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//validator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, (func(string) error)(self.Validator), "func(string)_(error)")
			return resObj
		},
	},
	"widget-select-entry//wrapping!": {
		Doc:   "Set widget.SelectEntry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//wrapping!: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//wrapping!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextWrap
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextWrap)
				}
				if natOk && natValOk {
					self.Wrapping = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-select-entry//wrapping!: arg 2: expected integer")
					}
					self.Wrapping = fyne.TextWrap(u)
				}
			}
			return arg0
		},
	},
	"widget-select-entry//wrapping?": {
		Doc:   "Get widget.SelectEntry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select-entry//wrapping?: arg 1: expected native of type widget.SelectEntry")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select-entry//wrapping?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Wrapping)))
			return resObj
		},
	},
	"widget-select//alignment!": {
		Doc:   "Set widget.Select Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//alignment!: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//alignment!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal fyne.TextAlign
				if natOk {
					natVal, natValOk = nat.Value.(fyne.TextAlign)
				}
				if natOk && natValOk {
					self.Alignment = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-select//alignment!: arg 2: expected integer")
					}
					self.Alignment = fyne.TextAlign(u)
				}
			}
			return arg0
		},
	},
	"widget-select//alignment?": {
		Doc:   "Get widget.Select Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//alignment?: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Alignment)))
			return resObj
		},
	},
	"widget-select//hidden!": {
		Doc:   "Set widget.Select Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//hidden!: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-select//hidden?": {
		Doc:   "Get widget.Select Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//hidden?: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-select//on-changed!": {
		Doc:   "Set widget.Select OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//on-changed!: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-select//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-select//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-select//on-changed?": {
		Doc:   "Get widget.Select OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//on-changed?: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"widget-select//options!": {
		Doc:   "Set widget.Select Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//options!: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//options!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-select//options!: arg 2: block item: expected string")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//options!: arg 2: expected native of type []string")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-select//options!: arg 2: expected integer to be 0 or nil")
				}
				self.Options = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//options!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-select//options?": {
		Doc:   "Get widget.Select Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//options?: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//options?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-select//place-holder!": {
		Doc:   "Set widget.Select PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//place-holder!: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//place-holder!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select//place-holder!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-select//place-holder?": {
		Doc:   "Get widget.Select PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//place-holder?: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//place-holder?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"widget-select//selected!": {
		Doc:   "Set widget.Select Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//selected!: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//selected!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-select//selected!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-select//selected?": {
		Doc:   "Get widget.Select Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-select//selected?: arg 1: expected native of type widget.Select")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-select//selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"widget-separator//hidden!": {
		Doc:   "Set widget.Separator Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-separator//hidden!: arg 1: expected native of type widget.Separator")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-separator//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-separator//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-separator//hidden?": {
		Doc:   "Get widget.Separator Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Separator)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-separator//hidden?: arg 1: expected native of type widget.Separator")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-separator//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"show-modal-pop-up": {
		Doc:   "widget.ShowModalPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-modal-pop-up: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-modal-pop-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-modal-pop-up: arg 1: expected native")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-modal-pop-up: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-modal-pop-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-modal-pop-up: arg 2: expected native")
			}
			widget.ShowModalPopUp(arg0Val, arg1Val)
			return nil
		},
	},
	"show-pop-up": {
		Doc:   "widget.ShowPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up: arg 1: expected native")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up: arg 2: expected native")
			}
			widget.ShowPopUp(arg0Val, arg1Val)
			return nil
		},
	},
	"show-pop-up-at-position": {
		Doc:   "widget.ShowPopUpAtPosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-position: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-at-position: arg 1: expected native")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-position: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-position: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-at-position: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-position: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-at-position: arg 3: expected native")
			}
			widget.ShowPopUpAtPosition(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"show-pop-up-at-relative-position": {
		Doc:   "widget.ShowPopUpAtRelativePosition",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-relative-position: arg 1: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-relative-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-at-relative-position: arg 1: expected native")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-relative-position: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-relative-position: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-at-relative-position: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-relative-position: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-at-relative-position: arg 3: expected native")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-relative-position: arg 4: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-at-relative-position: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-at-relative-position: arg 4: expected native")
			}
			widget.ShowPopUpAtRelativePosition(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"show-pop-up-menu-at-position": {
		Doc:   "widget.ShowPopUpMenuAtPosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-position: arg 1: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-menu-at-position: arg 1: expected native")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-position: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-position: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-menu-at-position: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-position: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-menu-at-position: arg 3: expected native")
			}
			widget.ShowPopUpMenuAtPosition(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"show-pop-up-menu-at-relative-position": {
		Doc:   "widget.ShowPopUpMenuAtRelativePosition",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-relative-position: arg 1: expected native of type *fyne.Menu")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-relative-position: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-menu-at-relative-position: arg 1: expected native")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-relative-position: arg 2: expected native of type fyne.Canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-relative-position: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-menu-at-relative-position: arg 2: expected native")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-relative-position: arg 3: expected native of type fyne.Position")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-menu-at-relative-position: arg 3: expected native")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-relative-position: arg 4: expected native of type fyne.CanvasObject")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("show-pop-up-menu-at-relative-position: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("show-pop-up-menu-at-relative-position: arg 4: expected native")
			}
			widget.ShowPopUpMenuAtRelativePosition(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"widget-slider//hidden!": {
		Doc:   "Set widget.Slider Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//hidden!: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-slider//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-slider//hidden?": {
		Doc:   "Get widget.Slider Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//hidden?: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-slider//max!": {
		Doc:   "Set widget.Slider Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//max!: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//max!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-slider//max!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"widget-slider//max?": {
		Doc:   "Get widget.Slider Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//max?: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//max?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"widget-slider//min!": {
		Doc:   "Set widget.Slider Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//min!: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//min!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-slider//min!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"widget-slider//min?": {
		Doc:   "Get widget.Slider Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//min?: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//min?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"widget-slider//on-change-ended!": {
		Doc:   "Set widget.Slider OnChangeEnded value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//on-change-ended!: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//on-change-ended!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-slider//on-change-ended!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChangeEnded = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-slider//on-change-ended!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChangeEnded = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//on-change-ended!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-slider//on-change-ended?": {
		Doc:   "Get widget.Slider OnChangeEnded value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//on-change-ended?: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//on-change-ended?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChangeEnded, "func(float-64)")
			return resObj
		},
	},
	"widget-slider//on-changed!": {
		Doc:   "Set widget.Slider OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//on-changed!: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//on-changed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-slider//on-changed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnChanged = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-slider//on-changed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnChanged = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//on-changed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-slider//on-changed?": {
		Doc:   "Get widget.Slider OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//on-changed?: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//on-changed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(float-64)")
			return resObj
		},
	},
	"widget-slider//orientation!": {
		Doc:   "Set widget.Slider Orientation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//orientation!: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//orientation!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.Orientation
				if natOk {
					natVal, natValOk = nat.Value.(widget.Orientation)
				}
				if natOk && natValOk {
					self.Orientation = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-slider//orientation!: arg 2: expected integer")
					}
					self.Orientation = widget.Orientation(u)
				}
			}
			return arg0
		},
	},
	"widget-slider//orientation?": {
		Doc:   "Get widget.Slider Orientation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//orientation?: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//orientation?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Orientation)))
			return resObj
		},
	},
	"widget-slider//step!": {
		Doc:   "Set widget.Slider Step value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//step!: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//step!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Step = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-slider//step!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"widget-slider//step?": {
		Doc:   "Get widget.Slider Step value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//step?: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//step?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Step))
			return resObj
		},
	},
	"widget-slider//value!": {
		Doc:   "Set widget.Slider Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//value!: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//value!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-slider//value!: arg 2: expected decimal")
			}
			return arg0
		},
	},
	"widget-slider//value?": {
		Doc:   "Get widget.Slider Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-slider//value?: arg 1: expected native of type widget.Slider")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-slider//value?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"success-importance": {
		Doc:   "Get widget.SuccessImportance value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.SuccessImportance)))
			return resObj
		},
	},
	"widget-table-cell-id//col!": {
		Doc:   "Set widget.TableCellID Col value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table-cell-id//col!: arg 1: expected native of type widget.TableCellID")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table-cell-id//col!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Col = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-table-cell-id//col!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-table-cell-id//col?": {
		Doc:   "Get widget.TableCellID Col value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table-cell-id//col?: arg 1: expected native of type widget.TableCellID")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table-cell-id//col?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Col))
			return resObj
		},
	},
	"widget-table-cell-id//row!": {
		Doc:   "Set widget.TableCellID Row value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table-cell-id//row!: arg 1: expected native of type widget.TableCellID")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table-cell-id//row!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Row = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-table-cell-id//row!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-table-cell-id//row?": {
		Doc:   "Get widget.TableCellID Row value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table-cell-id//row?: arg 1: expected native of type widget.TableCellID")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table-cell-id//row?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Row))
			return resObj
		},
	},
	"widget-table//create-cell!": {
		Doc:   "Set widget.Table CreateCell value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//create-cell!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//create-cell!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-table//create-cell!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateCell = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-table//create-cell!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateCell = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//create-cell!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-table//create-cell?": {
		Doc:   "Get widget.Table CreateCell value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//create-cell?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//create-cell?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateCell, "func()_(fyne-canvas-object)")
			return resObj
		},
	},
	"widget-table//create-header!": {
		Doc:   "Set widget.Table CreateHeader value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//create-header!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//create-header!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-table//create-header!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.CreateHeader = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-table//create-header!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateHeader = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//create-header!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-table//create-header?": {
		Doc:   "Get widget.Table CreateHeader value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//create-header?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//create-header?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateHeader, "func()_(fyne-canvas-object)")
			return resObj
		},
	},
	"widget-table//hidden!": {
		Doc:   "Set widget.Table Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//hidden!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-table//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-table//hidden?": {
		Doc:   "Get widget.Table Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//hidden?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-table//length!": {
		Doc:   "Set widget.Table Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//length!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//length!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Length, ok = v.Value.(func() (int, int))
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//length!: arg 2: expected native of type func() (int, int)")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//length!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-table//length?": {
		Doc:   "Get widget.Table Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//length?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//length?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int_int)")
			return resObj
		},
	},
	"widget-table//on-selected!": {
		Doc:   "Set widget.Table OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//on-selected!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-table//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 widget.TableCellID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-table//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-table//on-selected?": {
		Doc:   "Get widget.Table OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//on-selected?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(widget-table-cell-id)")
			return resObj
		},
	},
	"widget-table//on-unselected!": {
		Doc:   "Set widget.Table OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//on-unselected!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-table//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 widget.TableCellID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-table//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-table//on-unselected?": {
		Doc:   "Get widget.Table OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//on-unselected?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(widget-table-cell-id)")
			return resObj
		},
	},
	"widget-table//show-header-column!": {
		Doc:   "Set widget.Table ShowHeaderColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//show-header-column!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//show-header-column!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowHeaderColumn = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-table//show-header-column!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-table//show-header-column?": {
		Doc:   "Get widget.Table ShowHeaderColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//show-header-column?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//show-header-column?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowHeaderColumn))
			return resObj
		},
	},
	"widget-table//show-header-row!": {
		Doc:   "Set widget.Table ShowHeaderRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//show-header-row!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//show-header-row!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowHeaderRow = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-table//show-header-row!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-table//show-header-row?": {
		Doc:   "Get widget.Table ShowHeaderRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//show-header-row?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//show-header-row?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowHeaderRow))
			return resObj
		},
	},
	"widget-table//sticky-column-count!": {
		Doc:   "Set widget.Table StickyColumnCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//sticky-column-count!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//sticky-column-count!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StickyColumnCount = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-table//sticky-column-count!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-table//sticky-column-count?": {
		Doc:   "Get widget.Table StickyColumnCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//sticky-column-count?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//sticky-column-count?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StickyColumnCount))
			return resObj
		},
	},
	"widget-table//sticky-row-count!": {
		Doc:   "Set widget.Table StickyRowCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//sticky-row-count!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//sticky-row-count!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StickyRowCount = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-table//sticky-row-count!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-table//sticky-row-count?": {
		Doc:   "Get widget.Table StickyRowCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//sticky-row-count?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//sticky-row-count?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StickyRowCount))
			return resObj
		},
	},
	"widget-table//update-cell!": {
		Doc:   "Set widget.Table UpdateCell value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//update-cell!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//update-cell!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("widget-table//update-cell!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.UpdateCell = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-table//update-cell!: arg 2: expected integer to be 0 or nil")
				}
				self.UpdateCell = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//update-cell!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-table//update-cell?": {
		Doc:   "Get widget.Table UpdateCell value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//update-cell?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//update-cell?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateCell, "func(widget-table-cell-id_fyne-canvas-object)")
			return resObj
		},
	},
	"widget-table//update-header!": {
		Doc:   "Set widget.Table UpdateHeader value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//update-header!: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//update-header!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					ps.FailureFlag = true
					return env.NewError("widget-table//update-header!: arg 2: function has invalid number of arguments (expected 2)")
				}
				self.UpdateHeader = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-table-cell-id")
					{
						typ := reflect.TypeOf(arg1)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							arg1Val = *env.NewNative(ps.Idx, arg1, typRyeName)
						} else {
							arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
						}
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-table//update-header!: arg 2: expected integer to be 0 or nil")
				}
				self.UpdateHeader = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//update-header!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-table//update-header?": {
		Doc:   "Get widget.Table UpdateHeader value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-table//update-header?: arg 1: expected native of type widget.Table")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-table//update-header?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateHeader, "func(widget-table-cell-id_fyne-canvas-object)")
			return resObj
		},
	},
	"widget-text-grid-cell//rune!": {
		Doc:   "Set widget.TextGridCell Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-cell//rune!: arg 1: expected native of type widget.TextGridCell")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-cell//rune!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-cell//rune!: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-cell//rune!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-text-grid-cell//rune?": {
		Doc:   "Get widget.TextGridCell Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-cell//rune?: arg 1: expected native of type widget.TextGridCell")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-cell//rune?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"widget-text-grid-cell//style!": {
		Doc:   "Set widget.TextGridCell Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-cell//style!: arg 1: expected native of type widget.TextGridCell")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-cell//style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-cell//style!: arg 2: expected native of type widget.TextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-cell//style!: arg 2: expected integer to be 0 or nil")
				}
				self.Style = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-cell//style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-text-grid-cell//style?": {
		Doc:   "Get widget.TextGridCell Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-cell//style?: arg 1: expected native of type widget.TextGridCell")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-cell//style?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Style)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Style, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Style, "widget-text-grid-style")
				}
			}
			return resObj
		},
	},
	"widget-text-grid-row//cells!": {
		Doc:   "Set widget.TextGridRow Cells value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-row//cells!: arg 1: expected native of type widget.TextGridRow")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-row//cells!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cells = make([]widget.TextGridCell, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Cells[i], ok = v.Value.(widget.TextGridCell)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-text-grid-row//cells!: arg 2: block item: expected native of type widget.TextGridCell")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("widget-text-grid-row//cells!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Cells, ok = v.Value.([]widget.TextGridCell)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-row//cells!: arg 2: expected native of type []widget.TextGridCell")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-row//cells!: arg 2: expected integer to be 0 or nil")
				}
				self.Cells = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-row//cells!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-text-grid-row//cells?": {
		Doc:   "Get widget.TextGridRow Cells value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-row//cells?: arg 1: expected native of type widget.TextGridRow")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-row//cells?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cells))
				for i, it := range self.Cells {
					items[i] = *env.NewNative(ps.Idx, it, "widget-text-grid-cell")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-text-grid-row//style!": {
		Doc:   "Set widget.TextGridRow Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-row//style!: arg 1: expected native of type widget.TextGridRow")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-row//style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-row//style!: arg 2: expected native of type widget.TextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-row//style!: arg 2: expected integer to be 0 or nil")
				}
				self.Style = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-row//style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-text-grid-row//style?": {
		Doc:   "Get widget.TextGridRow Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-row//style?: arg 1: expected native of type widget.TextGridRow")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-row//style?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Style)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Style, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Style, "widget-text-grid-style")
				}
			}
			return resObj
		},
	},
	"text-grid-style-default": {
		Doc:   "Get widget.TextGridStyleDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(widget.TextGridStyleDefault)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, widget.TextGridStyleDefault, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, widget.TextGridStyleDefault, "widget-text-grid-style")
				}
			}
			return resObj
		},
	},
	"text-grid-style-whitespace": {
		Doc:   "Get widget.TextGridStyleWhitespace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			{
				typ := reflect.TypeOf(widget.TextGridStyleWhitespace)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, widget.TextGridStyleWhitespace, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, widget.TextGridStyleWhitespace, "widget-text-grid-style")
				}
			}
			return resObj
		},
	},
	"widget-text-grid-style//background-color": {
		Doc:   "widget.TextGridStyle.BackgroundColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.TextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-style//background-color: arg 1: expected native of type widget.TextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-style//background-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-style//background-color: arg 1: expected native")
			}
			res0 := arg0Val.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"widget-text-grid-style//text-color": {
		Doc:   "widget.TextGridStyle.TextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.TextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-style//text-color: arg 1: expected native of type widget.TextGridStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid-style//text-color: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid-style//text-color: arg 1: expected native")
			}
			res0 := arg0Val.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"widget-text-grid//hidden!": {
		Doc:   "Set widget.TextGrid Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//hidden!: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-text-grid//hidden?": {
		Doc:   "Get widget.TextGrid Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//hidden?: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-text-grid//rows!": {
		Doc:   "Set widget.TextGrid Rows value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//rows!: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//rows!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Rows = make([]widget.TextGridRow, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Rows[i], ok = v.Value.(widget.TextGridRow)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-text-grid//rows!: arg 2: block item: expected native of type widget.TextGridRow")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("widget-text-grid//rows!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Rows, ok = v.Value.([]widget.TextGridRow)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//rows!: arg 2: expected native of type []widget.TextGridRow")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//rows!: arg 2: expected integer to be 0 or nil")
				}
				self.Rows = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//rows!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-text-grid//rows?": {
		Doc:   "Get widget.TextGrid Rows value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//rows?: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//rows?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Rows))
				for i, it := range self.Rows {
					items[i] = *env.NewNative(ps.Idx, it, "widget-text-grid-row")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-text-grid//show-line-numbers!": {
		Doc:   "Set widget.TextGrid ShowLineNumbers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//show-line-numbers!: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//show-line-numbers!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowLineNumbers = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//show-line-numbers!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-text-grid//show-line-numbers?": {
		Doc:   "Get widget.TextGrid ShowLineNumbers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//show-line-numbers?: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//show-line-numbers?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowLineNumbers))
			return resObj
		},
	},
	"widget-text-grid//show-whitespace!": {
		Doc:   "Set widget.TextGrid ShowWhitespace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//show-whitespace!: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//show-whitespace!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowWhitespace = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//show-whitespace!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-text-grid//show-whitespace?": {
		Doc:   "Get widget.TextGrid ShowWhitespace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//show-whitespace?: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//show-whitespace?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowWhitespace))
			return resObj
		},
	},
	"widget-text-grid//tab-width!": {
		Doc:   "Set widget.TextGrid TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//tab-width!: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//tab-width!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//tab-width!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-text-grid//tab-width?": {
		Doc:   "Get widget.TextGrid TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-grid//tab-width?: arg 1: expected native of type widget.TextGrid")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-grid//tab-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"widget-text-segment//style!": {
		Doc:   "Set widget.TextSegment Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-segment//style!: arg 1: expected native of type widget.TextSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-segment//style!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-segment//style!: arg 2: expected native of type widget.RichTextStyle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-segment//style!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-text-segment//style?": {
		Doc:   "Get widget.TextSegment Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-segment//style?: arg 1: expected native of type widget.TextSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-segment//style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "widget-rich-text-style")
			return resObj
		},
	},
	"widget-text-segment//text!": {
		Doc:   "Set widget.TextSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-segment//text!: arg 1: expected native of type widget.TextSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-segment//text!: arg 1: expected native")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-text-segment//text!: arg 2: expected string")
			}
			return arg0
		},
	},
	"widget-text-segment//text?": {
		Doc:   "Get widget.TextSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-text-segment//text?: arg 1: expected native of type widget.TextSegment")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-text-segment//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-toolbar-action//icon!": {
		Doc:   "Set widget.ToolbarAction Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-action//icon!: arg 1: expected native of type widget.ToolbarAction")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar-action//icon!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-action//icon!: arg 2: expected native of type fyne.Resource")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-action//icon!: arg 2: expected integer to be 0 or nil")
				}
				self.Icon = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar-action//icon!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-toolbar-action//icon?": {
		Doc:   "Get widget.ToolbarAction Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-action//icon?: arg 1: expected native of type widget.ToolbarAction")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar-action//icon?: arg 1: expected native")
			}
			var resObj env.Object
			{
				typ := reflect.TypeOf(self.Icon)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					resObj = *env.NewNative(ps.Idx, self.Icon, typRyeName)
				} else {
					resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
				}
			}
			return resObj
		},
	},
	"widget-toolbar-action//on-activated!": {
		Doc:   "Set widget.ToolbarAction OnActivated value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-action//on-activated!: arg 1: expected native of type widget.ToolbarAction")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar-action//on-activated!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-action//on-activated!: arg 2: function has invalid number of arguments (expected 0)")
				}
				self.OnActivated = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-action//on-activated!: arg 2: expected integer to be 0 or nil")
				}
				self.OnActivated = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar-action//on-activated!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-toolbar-action//on-activated?": {
		Doc:   "Get widget.ToolbarAction OnActivated value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-action//on-activated?: arg 1: expected native of type widget.ToolbarAction")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar-action//on-activated?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnActivated, "func()")
			return resObj
		},
	},
	"widget-toolbar-item//toolbar-object": {
		Doc:   "widget.ToolbarItem.ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.ToolbarItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.ToolbarItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-item//toolbar-object: arg 1: expected native of type widget.ToolbarItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar-item//toolbar-object: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar-item//toolbar-object: arg 1: expected native")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			{
				typ := reflect.TypeOf(res0)
				var typPfx string
				if typ.Kind() == reflect.Pointer {
					typPfx = "*"
					typ = typ.Elem()
				}
				typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
				if ok {
					res0Obj = *env.NewNative(ps.Idx, res0, typRyeName)
				} else {
					res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
				}
			}
			return res0Obj
		},
	},
	"widget-toolbar//hidden!": {
		Doc:   "Set widget.Toolbar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar//hidden!: arg 1: expected native of type widget.Toolbar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-toolbar//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-toolbar//hidden?": {
		Doc:   "Get widget.Toolbar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar//hidden?: arg 1: expected native of type widget.Toolbar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-toolbar//items!": {
		Doc:   "Set widget.Toolbar Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar//items!: arg 1: expected native of type widget.Toolbar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar//items!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.ToolbarItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.ToolbarItem)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-toolbar//items!: arg 2: block item: expected native of type widget.ToolbarItem")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("widget-toolbar//items!: arg 2: block item: expected integer to be 0 or nil")
						}
						self.Items[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("widget-toolbar//items!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.ToolbarItem)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar//items!: arg 2: expected native of type []widget.ToolbarItem")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar//items!: arg 2: expected integer to be 0 or nil")
				}
				self.Items = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar//items!: arg 2: expected block, native or nil")
			}
			return arg0
		},
	},
	"widget-toolbar//items?": {
		Doc:   "Get widget.Toolbar Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-toolbar//items?: arg 1: expected native of type widget.Toolbar")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-toolbar//items?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					{
						typ := reflect.TypeOf(it)
						var typPfx string
						if typ.Kind() == reflect.Pointer {
							typPfx = "*"
							typ = typ.Elem()
						}
						typRyeName, ok := ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
						if ok {
							items[i] = *env.NewNative(ps.Idx, it, typRyeName)
						} else {
							items[i] = *env.NewNative(ps.Idx, it, "widget-toolbar-item")
						}
					}
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"widget-tree//child-ui-ds!": {
		Doc:   "Set widget.Tree ChildUIDs value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//child-ui-ds!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//child-ui-ds!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//child-ui-ds!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.ChildUIDs = func(arg0 widget.TreeNodeID) []widget.TreeNodeID {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res []widget.TreeNodeID
					switch v := ps.Res.(type) {
					case env.Block:
						res = make([]widget.TreeNodeID, len(v.Series.S))
						for i, it := range v.Series.S {
							{
								nat, natOk := it.(env.Native)
								var natValOk bool
								var natVal widget.TreeNodeID
								if natOk {
									natVal, natValOk = nat.Value.(widget.TreeNodeID)
								}
								if natOk && natValOk {
									res[i] = natVal
								} else {
									var u string
									if v, ok := it.(env.String); ok {
										u = string(v.Value)
									} else {
										// TODO: Cannot return error from function
									}
									res[i] = widget.TreeNodeID(u)
								}
							}
						}
					case env.Native:
						var ok bool
						res, ok = v.Value.([]widget.TreeNodeID)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//child-ui-ds!: arg 2: expected integer to be 0 or nil")
				}
				self.ChildUIDs = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//child-ui-ds!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-tree//child-ui-ds?": {
		Doc:   "Get widget.Tree ChildUIDs value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//child-ui-ds?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//child-ui-ds?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildUIDs, "func(widget-tree-node-id)_(arr-widget-tree-node-id)")
			return resObj
		},
	},
	"widget-tree//create-node!": {
		Doc:   "Set widget.Tree CreateNode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//create-node!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//create-node!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//create-node!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.CreateNode = func(arg0 bool) fyne.CanvasObject {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Cannot return error from function
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Cannot return error from function
						}
						res = nil
					default:
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//create-node!: arg 2: expected integer to be 0 or nil")
				}
				self.CreateNode = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//create-node!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-tree//create-node?": {
		Doc:   "Get widget.Tree CreateNode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//create-node?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//create-node?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateNode, "func(bool)_(fyne-canvas-object)")
			return resObj
		},
	},
	"widget-tree//hidden!": {
		Doc:   "Set widget.Tree Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//hidden!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//hidden!: arg 1: expected native")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("widget-tree//hidden!: arg 2: expected integer")
			}
			return arg0
		},
	},
	"widget-tree//hidden?": {
		Doc:   "Get widget.Tree Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//hidden?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//hidden?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-tree//is-branch!": {
		Doc:   "Set widget.Tree IsBranch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//is-branch!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//is-branch!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//is-branch!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.IsBranch = func(arg0 widget.TreeNodeID) bool {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						// TODO: Cannot return error from function
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//is-branch!: arg 2: expected integer to be 0 or nil")
				}
				self.IsBranch = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//is-branch!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-tree//is-branch?": {
		Doc:   "Get widget.Tree IsBranch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//is-branch?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//is-branch?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.IsBranch, "func(widget-tree-node-id)_(bool)")
			return resObj
		},
	},
	"widget-tree//on-branch-closed!": {
		Doc:   "Set widget.Tree OnBranchClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-branch-closed!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-branch-closed!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-branch-closed!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnBranchClosed = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-branch-closed!: arg 2: expected integer to be 0 or nil")
				}
				self.OnBranchClosed = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-branch-closed!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-tree//on-branch-closed?": {
		Doc:   "Get widget.Tree OnBranchClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-branch-closed?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-branch-closed?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnBranchClosed, "func(widget-tree-node-id)")
			return resObj
		},
	},
	"widget-tree//on-branch-opened!": {
		Doc:   "Set widget.Tree OnBranchOpened value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-branch-opened!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-branch-opened!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-branch-opened!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnBranchOpened = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-branch-opened!: arg 2: expected integer to be 0 or nil")
				}
				self.OnBranchOpened = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-branch-opened!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-tree//on-branch-opened?": {
		Doc:   "Get widget.Tree OnBranchOpened value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-branch-opened?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-branch-opened?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnBranchOpened, "func(widget-tree-node-id)")
			return resObj
		},
	},
	"widget-tree//on-selected!": {
		Doc:   "Set widget.Tree OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-selected!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-selected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-selected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnSelected = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-selected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnSelected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-selected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-tree//on-selected?": {
		Doc:   "Get widget.Tree OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-selected?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(widget-tree-node-id)")
			return resObj
		},
	},
	"widget-tree//on-unselected!": {
		Doc:   "Set widget.Tree OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-unselected!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-unselected!: arg 1: expected native")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-unselected!: arg 2: function has invalid number of arguments (expected 1)")
				}
				self.OnUnselected = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewString(string(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-unselected!: arg 2: expected integer to be 0 or nil")
				}
				self.OnUnselected = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-unselected!: arg 2: expected function or nil")
			}
			return arg0
		},
	},
	"widget-tree//on-unselected?": {
		Doc:   "Get widget.Tree OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//on-unselected?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//on-unselected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(widget-tree-node-id)")
			return resObj
		},
	},
	"widget-tree//root!": {
		Doc:   "Set widget.Tree Root value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//root!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//root!: arg 1: expected native")
			}
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.TreeNodeID
				if natOk {
					natVal, natValOk = nat.Value.(widget.TreeNodeID)
				}
				if natOk && natValOk {
					self.Root = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("widget-tree//root!: arg 2: expected string")
					}
					self.Root = widget.TreeNodeID(u)
				}
			}
			return arg0
		},
	},
	"widget-tree//root?": {
		Doc:   "Get widget.Tree Root value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//root?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//root?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.Root))
			return resObj
		},
	},
	"widget-tree//update-node!": {
		Doc:   "Set widget.Tree UpdateNode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//update-node!: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//update-node!: arg 1: expected native")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.UpdateNode, ok = v.Value.(func(widget.TreeNodeID, bool, fyne.CanvasObject))
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//update-node!: arg 2: expected native of type func(widget.TreeNodeID, bool, fyne.CanvasObject)")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//update-node!: arg 2: expected native")
			}
			return arg0
		},
	},
	"widget-tree//update-node?": {
		Doc:   "Get widget.Tree UpdateNode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-tree//update-node?: arg 1: expected native of type widget.Tree")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("widget-tree//update-node?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateNode, "func(widget-tree-node-id_bool_fyne-canvas-object)")
			return resObj
		},
	},
	"vertical": {
		Doc:   "Get widget.Vertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.Vertical)))
			return resObj
		},
	},
	"warning-importance": {
		Doc:   "Get widget.WarningImportance value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(widget.WarningImportance)))
			return resObj
		},
	},
}
