//go:build b_fynegen

// Code generated by generator/generate. DO NOT EDIT.

package fynegen

import (
	"errors"
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/data/binding"
	"fyne.io/fyne/v2/data/validation"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/driver"
	"fyne.io/fyne/v2/driver/desktop"
	"fyne.io/fyne/v2/driver/mobile"
	"fyne.io/fyne/v2/driver/software"
	"fyne.io/fyne/v2/layout"
	"fyne.io/fyne/v2/storage"
	"fyne.io/fyne/v2/storage/repository"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/tools/playground"
	"fyne.io/fyne/v2/widget"
	"github.com/refaktor/rye/env"
	"github.com/refaktor/rye/evaldo"
	"image"
	"image/color"
	"io"
	"net/url"
	"time"
)

// Force-use evaldo and env packages since tracking them would be too complicated
var _ = evaldo.BuiltinNames
var _ = env.Object(nil)

func boolToInt64(x bool) int64 {
	var res int64
	if x {
		res = 1
	}
	return res
}

var Builtins_fynegen = map[string]*env.Builtin{
	"nil": {
		Doc: "nil value for go types",
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			return *env.NewInteger(0)
		},
	},
	"accordion": {
		Doc:   "widget.NewAccordion",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*widget.AccordionItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*widget.AccordionItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*widget.AccordionItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "accordion")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "accordion")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "accordion")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "accordion")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "accordion")
			}
			res0 := widget.NewAccordion(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-accordion")
			return res0Obj
		},
	},
	"accordion-item": {
		Doc:   "widget.NewAccordionItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "accordion-item")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "accordion-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "accordion-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "accordion-item")
			}
			res0 := widget.NewAccordionItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-accordion-item")
			return res0Obj
		},
	},
	"accordion-item//detail!": {
		Doc:   "Set widget.AccordionItem Detail value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//detail!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//detail!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Detail, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "accordion-item//detail!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "accordion-item//detail!")
				}
				self.Detail = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "accordion-item//detail!")
			}
			return arg0
		},
	},
	"accordion-item//detail?": {
		Doc:   "Get widget.AccordionItem Detail value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//detail?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//detail?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Detail, "canvas-object")
			return resObj
		},
	},
	"accordion-item//open!": {
		Doc:   "Set widget.AccordionItem Open value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//open!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//open!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Open = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "accordion-item//open!")
			}
			return arg0
		},
	},
	"accordion-item//open?": {
		Doc:   "Get widget.AccordionItem Open value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//open?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//open?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Open))
			return resObj
		},
	},
	"accordion-item//title!": {
		Doc:   "Set widget.AccordionItem Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//title!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "accordion-item//title!")
			}
			return arg0
		},
	},
	"accordion-item//title?": {
		Doc:   "Get widget.AccordionItem Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//title?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion-item//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"accordion//hidden!": {
		Doc:   "Set widget.Accordion Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "accordion//hidden!")
			}
			return arg0
		},
	},
	"accordion//hidden?": {
		Doc:   "Get widget.Accordion Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"accordion//items!": {
		Doc:   "Set widget.Accordion Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.AccordionItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.AccordionItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "accordion//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "accordion//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "accordion//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "accordion//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "accordion//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "accordion//items!")
			}
			return arg0
		},
	},
	"accordion//items?": {
		Doc:   "Get widget.Accordion Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-accordion-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"accordion//multi-open!": {
		Doc:   "Set widget.Accordion MultiOpen value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//multi-open!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//multi-open!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiOpen = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "accordion//multi-open!")
			}
			return arg0
		},
	},
	"accordion//multi-open?": {
		Doc:   "Get widget.Accordion MultiOpen value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//multi-open?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "accordion//multi-open?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiOpen))
			return resObj
		},
	},
	"account-icon": {
		Doc:   "theme.AccountIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.AccountIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"adaptive-grid": {
		Doc:   "container.NewAdaptiveGrid",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "adaptive-grid")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "adaptive-grid")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "adaptive-grid")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "adaptive-grid")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "adaptive-grid")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "adaptive-grid")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "adaptive-grid")
			}
			res0 := container.NewAdaptiveGrid(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"adaptive-grid-layout": {
		Doc:   "layout.NewAdaptiveGridLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "adaptive-grid-layout")
			}
			res0 := layout.NewAdaptiveGridLayout(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"all-strings": {
		Doc:   "validation.NewAllStrings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.StringValidator
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.StringValidator, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.StringValidator)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "all-strings")
						}
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "all-strings")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "all-strings")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "all-strings")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "all-strings")
			}
			res0 := validation.NewAllStrings(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-validator")
			return res0Obj
		},
	},
	"and": {
		Doc:   "binding.And",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []binding.Bool
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]binding.Bool, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(binding.Bool)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "and")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "and")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "and")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "and")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "and")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "and")
			}
			res0 := binding.And(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool")
			return res0Obj
		},
	},
	"android-context//ctx!": {
		Doc:   "Set driver.AndroidContext Ctx value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//ctx!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//ctx!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Ctx, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "android-context//ctx!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "android-context//ctx!")
			}
			return arg0
		},
	},
	"android-context//ctx?": {
		Doc:   "Get driver.AndroidContext Ctx value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//ctx?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//ctx?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Ctx, "uintptr")
			return resObj
		},
	},
	"android-context//env!": {
		Doc:   "Set driver.AndroidContext Env value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//env!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//env!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Env, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "android-context//env!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "android-context//env!")
			}
			return arg0
		},
	},
	"android-context//env?": {
		Doc:   "Get driver.AndroidContext Env value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//env?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//env?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Env, "uintptr")
			return resObj
		},
	},
	"android-context//vm!": {
		Doc:   "Set driver.AndroidContext VM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//vm!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//vm!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.VM, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "android-context//vm!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "android-context//vm!")
			}
			return arg0
		},
	},
	"android-context//vm?": {
		Doc:   "Get driver.AndroidContext VM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//vm?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "android-context//vm?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.VM, "uintptr")
			return resObj
		},
	},
	"animation": {
		Doc:   "fyne.NewAnimation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val time.Duration
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation")
			}
			var arg1Val func(float32)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "animation")
				}
				arg1Val = func(arg0 float32) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "animation")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "animation")
			}
			res0 := fyne.NewAnimation(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-animation")
			return res0Obj
		},
	},
	"animation//auto-reverse!": {
		Doc:   "Set fyne.Animation AutoReverse value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//auto-reverse!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//auto-reverse!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AutoReverse = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "animation//auto-reverse!")
			}
			return arg0
		},
	},
	"animation//auto-reverse?": {
		Doc:   "Get fyne.Animation AutoReverse value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//auto-reverse?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//auto-reverse?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AutoReverse))
			return resObj
		},
	},
	"animation//curve!": {
		Doc:   "Set fyne.Animation Curve value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//curve!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//curve!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Curve, ok = v.Value.(fyne.AnimationCurve)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "animation//curve!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "animation//curve!")
			}
			return arg0
		},
	},
	"animation//curve?": {
		Doc:   "Get fyne.Animation Curve value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//curve?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//curve?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Curve, "animation-curve")
			return resObj
		},
	},
	"animation//duration!": {
		Doc:   "Set fyne.Animation Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//duration!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//duration!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "animation//duration!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "animation//duration!")
			}
			return arg0
		},
	},
	"animation//duration?": {
		Doc:   "Get fyne.Animation Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//duration?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//duration?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "duration")
			return resObj
		},
	},
	"animation//repeat-count!": {
		Doc:   "Set fyne.Animation RepeatCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//repeat-count!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//repeat-count!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.RepeatCount = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "animation//repeat-count!")
			}
			return arg0
		},
	},
	"animation//repeat-count?": {
		Doc:   "Get fyne.Animation RepeatCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//repeat-count?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//repeat-count?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.RepeatCount))
			return resObj
		},
	},
	"animation//tick!": {
		Doc:   "Set fyne.Animation Tick value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//tick!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//tick!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "animation//tick!")
				}
				self.Tick = func(arg0 float32) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "animation//tick!")
				}
				self.Tick = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "animation//tick!")
			}
			return arg0
		},
	},
	"animation//tick?": {
		Doc:   "Get fyne.Animation Tick value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//tick?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "animation//tick?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Tick, "func(float32)")
			return resObj
		},
	},
	"app": {
		Doc:   "app.New",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := app.New()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "app")
			return res0Obj
		},
	},
	"app-metadata//build!": {
		Doc:   "Set fyne.AppMetadata Build value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//build!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//build!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Build = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "app-metadata//build!")
			}
			return arg0
		},
	},
	"app-metadata//build?": {
		Doc:   "Get fyne.AppMetadata Build value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//build?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//build?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Build))
			return resObj
		},
	},
	"app-metadata//custom!": {
		Doc:   "Set fyne.AppMetadata Custom value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//custom!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//custom!")
			}
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "app-metadata//custom!")
				}
				self.Custom = make(map[string]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "app-metadata//custom!")
					}
					var mapV string
					if v, ok := v.Series.S[i+1].(env.String); ok {
						mapV = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "app-metadata//custom!")
					}
					self.Custom[mapK] = mapV
				}
			case env.Dict:
				self.Custom = make(map[string]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV string
					if v, ok := dictV.(env.String); ok {
						mapV = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "app-metadata//custom!")
					}
					self.Custom[mapK] = mapV
				}
			case env.Native:
				var ok bool
				self.Custom, ok = v.Value.(map[string]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "app-metadata//custom!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "app-metadata//custom!")
				}
				self.Custom = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "app-metadata//custom!")
			}
			return arg0
		},
	},
	"app-metadata//custom?": {
		Doc:   "Get fyne.AppMetadata Custom value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//custom?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//custom?")
			}
			var resObj env.Object
			{
				data := make(map[string]any, len(self.Custom))
				for mKey, mVal := range self.Custom {
					var dVal env.Object
					dVal = *env.NewString(mVal)
					data[mKey] = dVal
				}
				resObj = *env.NewDict(data)
			}
			return resObj
		},
	},
	"app-metadata//icon!": {
		Doc:   "Set fyne.AppMetadata Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//icon!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app-metadata//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app-metadata//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app-metadata//icon!")
			}
			return arg0
		},
	},
	"app-metadata//icon?": {
		Doc:   "Get fyne.AppMetadata Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//icon?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"app-metadata//id!": {
		Doc:   "Set fyne.AppMetadata ID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//id!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//id!")
			}
			if v, ok := arg1.(env.String); ok {
				self.ID = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-metadata//id!")
			}
			return arg0
		},
	},
	"app-metadata//id?": {
		Doc:   "Get fyne.AppMetadata ID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//id?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//id?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ID)
			return resObj
		},
	},
	"app-metadata//name!": {
		Doc:   "Set fyne.AppMetadata Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Name = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-metadata//name!")
			}
			return arg0
		},
	},
	"app-metadata//name?": {
		Doc:   "Get fyne.AppMetadata Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Name)
			return resObj
		},
	},
	"app-metadata//release!": {
		Doc:   "Set fyne.AppMetadata Release value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//release!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//release!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Release = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "app-metadata//release!")
			}
			return arg0
		},
	},
	"app-metadata//release?": {
		Doc:   "Get fyne.AppMetadata Release value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//release?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//release?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Release))
			return resObj
		},
	},
	"app-metadata//version!": {
		Doc:   "Set fyne.AppMetadata Version value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//version!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//version!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Version = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-metadata//version!")
			}
			return arg0
		},
	},
	"app-metadata//version?": {
		Doc:   "Get fyne.AppMetadata Version value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//version?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-metadata//version?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Version)
			return resObj
		},
	},
	"app-tabs": {
		Doc:   "container.NewAppTabs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*container.TabItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "app-tabs")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "app-tabs")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "app-tabs")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "app-tabs")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "app-tabs")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "app-tabs")
			}
			res0 := container.NewAppTabs(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-app-tabs")
			return res0Obj
		},
	},
	"app-tabs//hidden!": {
		Doc:   "Set container.AppTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "app-tabs//hidden!")
			}
			return arg0
		},
	},
	"app-tabs//hidden?": {
		Doc:   "Get container.AppTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"app-tabs//items!": {
		Doc:   "Set container.AppTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "app-tabs//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "app-tabs//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "app-tabs//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "app-tabs//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "app-tabs//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "app-tabs//items!")
			}
			return arg0
		},
	},
	"app-tabs//items?": {
		Doc:   "Get container.AppTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-tab-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"app-tabs//on-changed!": {
		Doc:   "Set container.AppTabs OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "app-tabs//on-changed!")
				}
				self.OnChanged = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "app-tabs//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "app-tabs//on-changed!")
			}
			return arg0
		},
	},
	"app-tabs//on-changed?": {
		Doc:   "Get container.AppTabs OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(ptr-tab-item)")
			return resObj
		},
	},
	"app-tabs//on-selected!": {
		Doc:   "Set container.AppTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "app-tabs//on-selected!")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "app-tabs//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "app-tabs//on-selected!")
			}
			return arg0
		},
	},
	"app-tabs//on-selected?": {
		Doc:   "Get container.AppTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(ptr-tab-item)")
			return resObj
		},
	},
	"app-tabs//on-unselected!": {
		Doc:   "Set container.AppTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-unselected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "app-tabs//on-unselected!")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "app-tabs//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "app-tabs//on-unselected!")
			}
			return arg0
		},
	},
	"app-tabs//on-unselected?": {
		Doc:   "Get container.AppTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-unselected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-tabs//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(ptr-tab-item)")
			return resObj
		},
	},
	"app//cloud-provider": {
		Doc:   "fyne.App.CloudProvider",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//cloud-provider")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//cloud-provider")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//cloud-provider")
			}
			res0 := arg0Val.CloudProvider()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "cloud-provider")
			return res0Obj
		},
	},
	"app//driver": {
		Doc:   "fyne.App.Driver",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//driver")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//driver")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//driver")
			}
			res0 := arg0Val.Driver()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "driver")
			return res0Obj
		},
	},
	"app//icon": {
		Doc:   "fyne.App.Icon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//icon")
			}
			res0 := arg0Val.Icon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"app//lifecycle": {
		Doc:   "fyne.App.Lifecycle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//lifecycle")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//lifecycle")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//lifecycle")
			}
			res0 := arg0Val.Lifecycle()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "lifecycle")
			return res0Obj
		},
	},
	"app//metadata": {
		Doc:   "fyne.App.Metadata",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//metadata")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//metadata")
			}
			res0 := arg0Val.Metadata()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "app-metadata")
			return res0Obj
		},
	},
	"app//open-url": {
		Doc:   "fyne.App.OpenURL",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//open-url")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//open-url")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//open-url")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//open-url")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//open-url")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//open-url")
			}
			res0 := arg0Val.OpenURL(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"app//preferences": {
		Doc:   "fyne.App.Preferences",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//preferences")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//preferences")
			}
			res0 := arg0Val.Preferences()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "preferences")
			return res0Obj
		},
	},
	"app//quit": {
		Doc:   "fyne.App.Quit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//quit")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//quit")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//quit")
			}
			arg0Val.Quit()
			return arg0
		},
	},
	"app//run": {
		Doc:   "fyne.App.Run",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//run")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//run")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//run")
			}
			arg0Val.Run()
			return arg0
		},
	},
	"app//send-notification": {
		Doc:   "fyne.App.SendNotification",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//send-notification")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//send-notification")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//send-notification")
			}
			var arg1Val *fyne.Notification
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//send-notification")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//send-notification")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//send-notification")
			}
			arg0Val.SendNotification(arg1Val)
			return arg0
		},
	},
	"app//set-cloud-provider": {
		Doc:   "fyne.App.SetCloudProvider",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-cloud-provider")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-cloud-provider")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-cloud-provider")
			}
			var arg1Val fyne.CloudProvider
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-cloud-provider")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-cloud-provider")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-cloud-provider")
			}
			arg0Val.SetCloudProvider(arg1Val)
			return arg0
		},
	},
	"app//set-icon": {
		Doc:   "fyne.App.SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-icon")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"app//set-system-tray-icon": {
		Doc:   "desktop.App.SetSystemTrayIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-system-tray-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-system-tray-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-system-tray-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-system-tray-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-system-tray-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-system-tray-icon")
			}
			arg0Val.SetSystemTrayIcon(arg1Val)
			return arg0
		},
	},
	"app//set-system-tray-menu": {
		Doc:   "desktop.App.SetSystemTrayMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-system-tray-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-system-tray-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//set-system-tray-menu")
			}
			var arg1Val *fyne.Menu
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-system-tray-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-system-tray-menu")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "app//set-system-tray-menu")
			}
			arg0Val.SetSystemTrayMenu(arg1Val)
			return arg0
		},
	},
	"app//settings": {
		Doc:   "fyne.App.Settings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//settings")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//settings")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//settings")
			}
			res0 := arg0Val.Settings()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "settings")
			return res0Obj
		},
	},
	"app//storage": {
		Doc:   "fyne.App.Storage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//storage")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//storage")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//storage")
			}
			res0 := arg0Val.Storage()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "storage")
			return res0Obj
		},
	},
	"app//unique-id": {
		Doc:   "fyne.App.UniqueID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//unique-id")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//unique-id")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//unique-id")
			}
			res0 := arg0Val.UniqueID()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"app//window": {
		Doc:   "fyne.App.NewWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app//window")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app//window")
			}
			res0 := arg0Val.NewWindow(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "window")
			return res0Obj
		},
	},
	"background-color": {
		Doc:   "theme.BackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"base-widget//hidden!": {
		Doc:   "Set widget.BaseWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "base-widget//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "base-widget//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "base-widget//hidden!")
			}
			return arg0
		},
	},
	"base-widget//hidden?": {
		Doc:   "Get widget.BaseWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "base-widget//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "base-widget//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"bind-bool": {
		Doc:   "binding.BindBool",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bool")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bool")
			}
			res0 := binding.BindBool(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-bool")
			return res0Obj
		},
	},
	"bind-bool-list": {
		Doc:   "binding.BindBoolList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bool-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bool-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bool-list")
			}
			res0 := binding.BindBoolList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-bool-list")
			return res0Obj
		},
	},
	"bind-bool-tree": {
		Doc:   "binding.BindBoolTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bool-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bool-tree")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bool-tree")
			}
			var arg1Val *map[string]bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-bool-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-bool-tree")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-bool-tree")
			}
			res0 := binding.BindBoolTree(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-bool-tree")
			return res0Obj
		},
	},
	"bind-bytes": {
		Doc:   "binding.BindBytes",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]byte
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bytes")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bytes")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bytes")
			}
			res0 := binding.BindBytes(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-bytes")
			return res0Obj
		},
	},
	"bind-bytes-list": {
		Doc:   "binding.BindBytesList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[][]byte
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[][]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bytes-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bytes-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bytes-list")
			}
			res0 := binding.BindBytesList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-bytes-list")
			return res0Obj
		},
	},
	"bind-bytes-tree": {
		Doc:   "binding.BindBytesTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bytes-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bytes-tree")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-bytes-tree")
			}
			var arg1Val *map[string][]byte
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string][]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-bytes-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-bytes-tree")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-bytes-tree")
			}
			res0 := binding.BindBytesTree(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-bytes-tree")
			return res0Obj
		},
	},
	"bind-float": {
		Doc:   "binding.BindFloat",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *float64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*float64)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-float")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-float")
			}
			res0 := binding.BindFloat(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-float")
			return res0Obj
		},
	},
	"bind-float-list": {
		Doc:   "binding.BindFloatList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]float64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-float-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-float-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-float-list")
			}
			res0 := binding.BindFloatList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-float-list")
			return res0Obj
		},
	},
	"bind-float-tree": {
		Doc:   "binding.BindFloatTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-float-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-float-tree")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-float-tree")
			}
			var arg1Val *map[string]float64
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-float-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-float-tree")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-float-tree")
			}
			res0 := binding.BindFloatTree(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-float-tree")
			return res0Obj
		},
	},
	"bind-int": {
		Doc:   "binding.BindInt",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-int")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-int")
			}
			res0 := binding.BindInt(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-int")
			return res0Obj
		},
	},
	"bind-int-list": {
		Doc:   "binding.BindIntList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-int-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-int-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-int-list")
			}
			res0 := binding.BindIntList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-int-list")
			return res0Obj
		},
	},
	"bind-int-tree": {
		Doc:   "binding.BindIntTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-int-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-int-tree")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-int-tree")
			}
			var arg1Val *map[string]int
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]int)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-int-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-int-tree")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-int-tree")
			}
			res0 := binding.BindIntTree(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-int-tree")
			return res0Obj
		},
	},
	"bind-preference-bool": {
		Doc:   "binding.BindPreferenceBool",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "bind-preference-bool")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-bool")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-bool")
			}
			res0 := binding.BindPreferenceBool(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool")
			return res0Obj
		},
	},
	"bind-preference-float": {
		Doc:   "binding.BindPreferenceFloat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "bind-preference-float")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-float")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-float")
			}
			res0 := binding.BindPreferenceFloat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "float")
			return res0Obj
		},
	},
	"bind-preference-int": {
		Doc:   "binding.BindPreferenceInt",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "bind-preference-int")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-int")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-int")
			}
			res0 := binding.BindPreferenceInt(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "int")
			return res0Obj
		},
	},
	"bind-preference-string": {
		Doc:   "binding.BindPreferenceString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "bind-preference-string")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-string")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-preference-string")
			}
			res0 := binding.BindPreferenceString(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"bind-rune": {
		Doc:   "binding.BindRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*rune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-rune")
			}
			res0 := binding.BindRune(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-rune")
			return res0Obj
		},
	},
	"bind-rune-list": {
		Doc:   "binding.BindRuneList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]rune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-rune-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-rune-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-rune-list")
			}
			res0 := binding.BindRuneList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-rune-list")
			return res0Obj
		},
	},
	"bind-rune-tree": {
		Doc:   "binding.BindRuneTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-rune-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-rune-tree")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-rune-tree")
			}
			var arg1Val *map[string]rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-rune-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-rune-tree")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-rune-tree")
			}
			res0 := binding.BindRuneTree(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-rune-tree")
			return res0Obj
		},
	},
	"bind-string": {
		Doc:   "binding.BindString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-string")
			}
			res0 := binding.BindString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-string")
			return res0Obj
		},
	},
	"bind-string-list": {
		Doc:   "binding.BindStringList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-string-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-string-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-string-list")
			}
			res0 := binding.BindStringList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-string-list")
			return res0Obj
		},
	},
	"bind-string-tree": {
		Doc:   "binding.BindStringTree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-string-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-string-tree")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-string-tree")
			}
			var arg1Val *map[string]string
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-string-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-string-tree")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-string-tree")
			}
			res0 := binding.BindStringTree(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-string-tree")
			return res0Obj
		},
	},
	"bind-uri": {
		Doc:   "binding.BindURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-uri")
			}
			res0 := binding.BindURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-uri")
			return res0Obj
		},
	},
	"bind-uri-tree": {
		Doc:   "binding.BindURITree",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *map[string][]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-uri-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-uri-tree")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bind-uri-tree")
			}
			var arg1Val *map[string]fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*map[string]fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-uri-tree")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-uri-tree")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "bind-uri-tree")
			}
			res0 := binding.BindURITree(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "external-uri-tree")
			return res0Obj
		},
	},
	"bool": {
		Doc:   "binding.NewBool",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBool()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool")
			return res0Obj
		},
	},
	"bool-list": {
		Doc:   "binding.NewBoolList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBoolList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool-list")
			return res0Obj
		},
	},
	"bool-list//append": {
		Doc:   "binding.BoolList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//append")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "bool-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bool-list//get": {
		Doc:   "binding.BoolList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(boolToInt64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"bool-list//get-value": {
		Doc:   "binding.BoolList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "bool-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"bool-list//prepend": {
		Doc:   "binding.BoolList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//prepend")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "bool-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bool-list//set": {
		Doc:   "binding.BoolList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//set")
			}
			var arg1Val []bool
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]bool, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg1Val[i] = v.Value != 0
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bool-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bool-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bool-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bool-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bool-list//set-value": {
		Doc:   "binding.BoolList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "bool-list//set-value")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "bool-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bool-to-string": {
		Doc:   "binding.BoolToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-to-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-to-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-to-string")
			}
			res0 := binding.BoolToString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"bool-to-string-with-format": {
		Doc:   "binding.BoolToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-to-string-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-to-string-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-to-string-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "bool-to-string-with-format")
			}
			res0 := binding.BoolToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"bool-tree": {
		Doc:   "binding.NewBoolTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBoolTree()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool-tree")
			return res0Obj
		},
	},
	"bool-tree//append": {
		Doc:   "binding.BoolTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "bool-tree//append")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "bool-tree//append")
			}
			var arg3Val bool
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.IntegerType}, "bool-tree//append")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bool-tree//get": {
		Doc:   "binding.BoolTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//get")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewInteger(boolToInt64(mVal))
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"bool-tree//get-value": {
		Doc:   "binding.BoolTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//get-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "bool-tree//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"bool-tree//prepend": {
		Doc:   "binding.BoolTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "bool-tree//prepend")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "bool-tree//prepend")
			}
			var arg3Val bool
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.IntegerType}, "bool-tree//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bool-tree//set": {
		Doc:   "binding.BoolTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//set")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
			}
			var arg2Val map[string]bool
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
				}
				arg2Val = make(map[string]bool, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
					}
					var mapV bool
					if v, ok := v.Series.S[i+1].(env.Integer); ok {
						mapV = v.Value != 0
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]bool, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV bool
					if v, ok := dictV.(env.Integer); ok {
						mapV = v.Value != 0
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bool-tree//set")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bool-tree//set-value": {
		Doc:   "binding.BoolTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool-tree//set-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "bool-tree//set-value")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "bool-tree//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bool//get": {
		Doc:   "binding.Bool.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"bool//set": {
		Doc:   "binding.Bool.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bool//set")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "bool//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"border": {
		Doc:   "container.NewBorder",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "border")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "border")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "border")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "border")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "border")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "border")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "border")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "border")
			}
			var arg4Val []fyne.CanvasObject
			switch v := arg4.(type) {
			case env.Block:
				arg4Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg4Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "border")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "border")
						}
						arg4Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "border")
					}
				}
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "border")
				}
				arg4Val = nil
			default:
				return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "border")
			}
			res0 := container.NewBorder(arg0Val, arg1Val, arg2Val, arg3Val, arg4Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"border-layout": {
		Doc:   "layout.NewBorderLayout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "border-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "border-layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "border-layout")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "border-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "border-layout")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "border-layout")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "border-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "border-layout")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "border-layout")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "border-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "border-layout")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "border-layout")
			}
			res0 := layout.NewBorderLayout(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"broken-image-icon": {
		Doc:   "theme.BrokenImageIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.BrokenImageIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"button": {
		Doc:   "widget.NewButton",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "button")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "button")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "button")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "button")
			}
			res0 := widget.NewButton(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-button")
			return res0Obj
		},
	},
	"button-color": {
		Doc:   "theme.ButtonColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"button-with-icon": {
		Doc:   "widget.NewButtonWithIcon",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "button-with-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button-with-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button-with-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button-with-icon")
			}
			var arg2Val func()
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "button-with-icon")
				}
				arg2Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "button-with-icon")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "button-with-icon")
			}
			res0 := widget.NewButtonWithIcon(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-button")
			return res0Obj
		},
	},
	"button//alignment!": {
		Doc:   "Set widget.Button Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(widget.ButtonAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button//alignment!")
			}
			return arg0
		},
	},
	"button//alignment?": {
		Doc:   "Get widget.Button Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "button-align")
			return resObj
		},
	},
	"button//hidden!": {
		Doc:   "Set widget.Button Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "button//hidden!")
			}
			return arg0
		},
	},
	"button//hidden?": {
		Doc:   "Get widget.Button Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"button//icon!": {
		Doc:   "Set widget.Button Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//icon!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button//icon!")
			}
			return arg0
		},
	},
	"button//icon-placement!": {
		Doc:   "Set widget.Button IconPlacement value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//icon-placement!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//icon-placement!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.IconPlacement, ok = v.Value.(widget.ButtonIconPlacement)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button//icon-placement!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button//icon-placement!")
			}
			return arg0
		},
	},
	"button//icon-placement?": {
		Doc:   "Get widget.Button IconPlacement value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//icon-placement?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//icon-placement?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.IconPlacement, "button-icon-placement")
			return resObj
		},
	},
	"button//icon?": {
		Doc:   "Get widget.Button Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//icon?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"button//importance!": {
		Doc:   "Set widget.Button Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//importance!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Importance, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "button//importance!")
			}
			return arg0
		},
	},
	"button//importance?": {
		Doc:   "Get widget.Button Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//importance?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//importance?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Importance, "importance")
			return resObj
		},
	},
	"button//on-tapped!": {
		Doc:   "Set widget.Button OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//on-tapped!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "button//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "button//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "button//on-tapped!")
			}
			return arg0
		},
	},
	"button//on-tapped?": {
		Doc:   "Get widget.Button OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//on-tapped?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"button//text!": {
		Doc:   "Set widget.Button Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "button//text!")
			}
			return arg0
		},
	},
	"button//text?": {
		Doc:   "Get widget.Button Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "button//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"bytes": {
		Doc:   "binding.NewBytes",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBytes()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bytes")
			return res0Obj
		},
	},
	"bytes-list": {
		Doc:   "binding.NewBytesList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBytesList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bytes-list")
			return res0Obj
		},
	},
	"bytes-list//append": {
		Doc:   "binding.BytesList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//append")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//append")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//append")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bytes-list//get": {
		Doc:   "binding.BytesList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					{
						items := make([]env.Object, len(it))
						for i, it := range it {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						items[i] = *env.NewBlock(*env.NewTSeries(items))
					}
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"bytes-list//get-value": {
		Doc:   "binding.BytesList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "bytes-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"bytes-list//prepend": {
		Doc:   "binding.BytesList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//prepend")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//prepend")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//prepend")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//prepend")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bytes-list//set": {
		Doc:   "binding.BytesList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//set")
			}
			var arg1Val [][]byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([][]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Block:
						arg1Val[i] = make([]byte, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								arg1Val[i][i], ok = v.Value.(byte)
								if !ok {
									return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set")
								}
							default:
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set")
							}
						}
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.([]byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([][]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bytes-list//set-value": {
		Doc:   "binding.BytesList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "bytes-list//set-value")
			}
			var arg2Val []byte
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg2Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set-value")
						}
					default:
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set-value")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set-value")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bytes-tree": {
		Doc:   "binding.NewBytesTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBytesTree()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bytes-tree")
			return res0Obj
		},
	},
	"bytes-tree//append": {
		Doc:   "binding.BytesTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "bytes-tree//append")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "bytes-tree//append")
			}
			var arg3Val []byte
			switch v := arg3.(type) {
			case env.Block:
				arg3Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg3Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//append")
						}
					default:
						return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//append")
					}
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//append")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//append")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bytes-tree//get": {
		Doc:   "binding.BytesTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//get")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewNative(ps.Idx, it, "byte")
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"bytes-tree//get-value": {
		Doc:   "binding.BytesTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//get-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "bytes-tree//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"bytes-tree//prepend": {
		Doc:   "binding.BytesTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "bytes-tree//prepend")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "bytes-tree//prepend")
			}
			var arg3Val []byte
			switch v := arg3.(type) {
			case env.Block:
				arg3Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg3Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//prepend")
						}
					default:
						return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//prepend")
					}
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//prepend")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bytes-tree//set": {
		Doc:   "binding.BytesTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//set")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
			}
			var arg2Val map[string][]byte
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
				}
				arg2Val = make(map[string][]byte, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
					}
					var mapV []byte
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]byte, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								mapV[i], ok = v.Value.(byte)
								if !ok {
									return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
								}
							default:
								return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]byte)
						if !ok {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string][]byte, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []byte
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]byte, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								mapV[i], ok = v.Value.(byte)
								if !ok {
									return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
								}
							default:
								return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]byte)
						if !ok {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string][]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "bytes-tree//set")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bytes-tree//set-value": {
		Doc:   "binding.BytesTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes-tree//set-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "bytes-tree//set-value")
			}
			var arg2Val []byte
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg2Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//set-value")
						}
					default:
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//set-value")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//set-value")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "bytes-tree//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"bytes//get": {
		Doc:   "binding.Bytes.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bytes
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bytes)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"bytes//set": {
		Doc:   "binding.Bytes.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bytes
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bytes)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "bytes//set")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes//set")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "bytes//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"can-list": {
		Doc:   "storage.CanList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "can-list")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "can-list")
			}
			res0, res1 := storage.CanList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"can-read": {
		Doc:   "storage.CanRead",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "can-read")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "can-read")
			}
			res0, res1 := storage.CanRead(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"can-write": {
		Doc:   "storage.CanWrite",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "can-write")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "can-write")
			}
			res0, res1 := storage.CanWrite(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"cancel-icon": {
		Doc:   "theme.CancelIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CancelIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"canvas": {
		Doc:   "software.NewCanvas",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := software.NewCanvas()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "windowless-canvas")
			return res0Obj
		},
	},
	"canvas-object//hide": {
		Doc:   "fyne.CanvasObject.Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"canvas-object//min-size": {
		Doc:   "fyne.CanvasObject.MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"canvas-object//move": {
		Doc:   "fyne.CanvasObject.Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-object//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-object//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"canvas-object//position": {
		Doc:   "fyne.CanvasObject.Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"canvas-object//refresh": {
		Doc:   "fyne.CanvasObject.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"canvas-object//resize": {
		Doc:   "fyne.CanvasObject.Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-object//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-object//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"canvas-object//show": {
		Doc:   "fyne.CanvasObject.Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"canvas-object//size": {
		Doc:   "fyne.CanvasObject.Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"canvas-object//visible": {
		Doc:   "fyne.CanvasObject.Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-object//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"canvas//add-shortcut": {
		Doc:   "fyne.Canvas.AddShortcut",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//add-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//add-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//add-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//add-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//add-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//add-shortcut")
			}
			var arg2Val func(fyne.Shortcut)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "canvas//add-shortcut")
				}
				arg2Val = func(arg0 fyne.Shortcut) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "shortcut")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "canvas//add-shortcut")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "canvas//add-shortcut")
			}
			arg0Val.AddShortcut(arg1Val, arg2Val)
			return arg0
		},
	},
	"canvas//capture": {
		Doc:   "fyne.Canvas.Capture",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//capture")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//capture")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//capture")
			}
			res0 := arg0Val.Capture()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image")
			return res0Obj
		},
	},
	"canvas//content": {
		Doc:   "fyne.Canvas.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"canvas//focus": {
		Doc:   "fyne.Canvas.Focus",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focus")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focus")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focus")
			}
			var arg1Val fyne.Focusable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//focus")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//focus")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//focus")
			}
			arg0Val.Focus(arg1Val)
			return arg0
		},
	},
	"canvas//focus-next": {
		Doc:   "fyne.Canvas.FocusNext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focus-next")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focus-next")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focus-next")
			}
			arg0Val.FocusNext()
			return arg0
		},
	},
	"canvas//focus-previous": {
		Doc:   "fyne.Canvas.FocusPrevious",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focus-previous")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focus-previous")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focus-previous")
			}
			arg0Val.FocusPrevious()
			return arg0
		},
	},
	"canvas//focused": {
		Doc:   "fyne.Canvas.Focused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focused")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focused")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//focused")
			}
			res0 := arg0Val.Focused()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "focusable")
			return res0Obj
		},
	},
	"canvas//interactive-area": {
		Doc:   "fyne.Canvas.InteractiveArea",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//interactive-area")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//interactive-area")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//interactive-area")
			}
			res0, res1 := arg0Val.InteractiveArea()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			var res1Obj env.Object
			res1Obj = *env.NewNative(ps.Idx, res1, "size")
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"canvas//on-key-down": {
		Doc:   "desktop.Canvas.OnKeyDown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-key-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-key-down")
			}
			res0 := arg0Val.OnKeyDown()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "func(ptr-key-event)")
			return res0Obj
		},
	},
	"canvas//on-key-up": {
		Doc:   "desktop.Canvas.OnKeyUp",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-key-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-key-up")
			}
			res0 := arg0Val.OnKeyUp()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "func(ptr-key-event)")
			return res0Obj
		},
	},
	"canvas//on-typed-key": {
		Doc:   "fyne.Canvas.OnTypedKey",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-typed-key")
			}
			res0 := arg0Val.OnTypedKey()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "func(ptr-key-event)")
			return res0Obj
		},
	},
	"canvas//on-typed-rune": {
		Doc:   "fyne.Canvas.OnTypedRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//on-typed-rune")
			}
			res0 := arg0Val.OnTypedRune()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "func(rune)")
			return res0Obj
		},
	},
	"canvas//overlays": {
		Doc:   "fyne.Canvas.Overlays",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//overlays")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//overlays")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//overlays")
			}
			res0 := arg0Val.Overlays()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "overlay-stack")
			return res0Obj
		},
	},
	"canvas//pixel-coordinate-for-position": {
		Doc:   "fyne.Canvas.PixelCoordinateForPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//pixel-coordinate-for-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//pixel-coordinate-for-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//pixel-coordinate-for-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//pixel-coordinate-for-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//pixel-coordinate-for-position")
			}
			res0, res1 := arg0Val.PixelCoordinateForPosition(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"canvas//refresh": {
		Doc:   "fyne.Canvas.Refresh",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//refresh")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//refresh")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//refresh")
			}
			arg0Val.Refresh(arg1Val)
			return arg0
		},
	},
	"canvas//remove-shortcut": {
		Doc:   "fyne.Canvas.RemoveShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//remove-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//remove-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//remove-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//remove-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//remove-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//remove-shortcut")
			}
			arg0Val.RemoveShortcut(arg1Val)
			return arg0
		},
	},
	"canvas//scale": {
		Doc:   "fyne.Canvas.Scale",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//scale")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//scale")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//scale")
			}
			res0 := arg0Val.Scale()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"canvas//set-content": {
		Doc:   "fyne.Canvas.SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-content")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//set-content")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas//set-content")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"canvas//set-on-key-down": {
		Doc:   "desktop.Canvas.SetOnKeyDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-key-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-key-down")
			}
			var arg1Val func(*fyne.KeyEvent)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas//set-on-key-down")
				}
				arg1Val = func(arg0 *fyne.KeyEvent) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-key-event")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "canvas//set-on-key-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas//set-on-key-down")
			}
			arg0Val.SetOnKeyDown(arg1Val)
			return arg0
		},
	},
	"canvas//set-on-key-up": {
		Doc:   "desktop.Canvas.SetOnKeyUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-key-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-key-up")
			}
			var arg1Val func(*fyne.KeyEvent)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas//set-on-key-up")
				}
				arg1Val = func(arg0 *fyne.KeyEvent) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-key-event")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "canvas//set-on-key-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas//set-on-key-up")
			}
			arg0Val.SetOnKeyUp(arg1Val)
			return arg0
		},
	},
	"canvas//set-on-typed-key": {
		Doc:   "fyne.Canvas.SetOnTypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-typed-key")
			}
			var arg1Val func(*fyne.KeyEvent)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas//set-on-typed-key")
				}
				arg1Val = func(arg0 *fyne.KeyEvent) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-key-event")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "canvas//set-on-typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas//set-on-typed-key")
			}
			arg0Val.SetOnTypedKey(arg1Val)
			return arg0
		},
	},
	"canvas//set-on-typed-rune": {
		Doc:   "fyne.Canvas.SetOnTypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//set-on-typed-rune")
			}
			var arg1Val func(rune)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas//set-on-typed-rune")
				}
				arg1Val = func(arg0 rune) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "canvas//set-on-typed-rune")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas//set-on-typed-rune")
			}
			arg0Val.SetOnTypedRune(arg1Val)
			return arg0
		},
	},
	"canvas//size": {
		Doc:   "fyne.Canvas.Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"canvas//unfocus": {
		Doc:   "fyne.Canvas.Unfocus",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//unfocus")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//unfocus")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas//unfocus")
			}
			arg0Val.Unfocus()
			return arg0
		},
	},
	"caption-text-size": {
		Doc:   "theme.CaptionTextSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CaptionTextSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"card": {
		Doc:   "widget.NewCard",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "card")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "card")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "card")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "card")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "card")
			}
			res0 := widget.NewCard(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-card")
			return res0Obj
		},
	},
	"card//content!": {
		Doc:   "Set widget.Card Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "card//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "card//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "card//content!")
			}
			return arg0
		},
	},
	"card//content?": {
		Doc:   "Get widget.Card Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "canvas-object")
			return resObj
		},
	},
	"card//hidden!": {
		Doc:   "Set widget.Card Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "card//hidden!")
			}
			return arg0
		},
	},
	"card//hidden?": {
		Doc:   "Get widget.Card Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"card//image!": {
		Doc:   "Set widget.Card Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//image!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//image!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "card//image!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "card//image!")
				}
				self.Image = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "card//image!")
			}
			return arg0
		},
	},
	"card//image?": {
		Doc:   "Get widget.Card Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//image?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//image?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-image")
			return resObj
		},
	},
	"card//subtitle!": {
		Doc:   "Set widget.Card Subtitle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//subtitle!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//subtitle!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Subtitle = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "card//subtitle!")
			}
			return arg0
		},
	},
	"card//subtitle?": {
		Doc:   "Get widget.Card Subtitle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//subtitle?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//subtitle?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Subtitle)
			return resObj
		},
	},
	"card//title!": {
		Doc:   "Set widget.Card Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//title!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "card//title!")
			}
			return arg0
		},
	},
	"card//title?": {
		Doc:   "Get widget.Card Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//title?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "card//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"center": {
		Doc:   "container.NewCenter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "center")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "center")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "center")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "center")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "center")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "center")
			}
			res0 := container.NewCenter(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"center-layout": {
		Doc:   "layout.NewCenterLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewCenterLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"check": {
		Doc:   "widget.NewCheck",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "check")
			}
			var arg1Val func(bool)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "check")
				}
				arg1Val = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "check")
			}
			res0 := widget.NewCheck(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-check")
			return res0Obj
		},
	},
	"check-button-checked-icon": {
		Doc:   "theme.CheckButtonCheckedIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CheckButtonCheckedIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"check-button-icon": {
		Doc:   "theme.CheckButtonIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CheckButtonIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"check-group": {
		Doc:   "widget.NewCheckGroup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "check-group")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "check-group")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "check-group")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "check-group")
			}
			var arg1Val func([]string)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "check-group")
				}
				arg1Val = func(arg0 []string) {
					var arg0Val env.Object
					{
						items := make([]env.Object, len(arg0))
						for i, it := range arg0 {
							items[i] = *env.NewString(it)
						}
						arg0Val = *env.NewBlock(*env.NewTSeries(items))
					}
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "check-group")
			}
			res0 := widget.NewCheckGroup(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-check-group")
			return res0Obj
		},
	},
	"check-group//hidden!": {
		Doc:   "Set widget.CheckGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "check-group//hidden!")
			}
			return arg0
		},
	},
	"check-group//hidden?": {
		Doc:   "Get widget.CheckGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"check-group//horizontal!": {
		Doc:   "Set widget.CheckGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//horizontal!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "check-group//horizontal!")
			}
			return arg0
		},
	},
	"check-group//horizontal?": {
		Doc:   "Get widget.CheckGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//horizontal?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"check-group//on-changed!": {
		Doc:   "Set widget.CheckGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "check-group//on-changed!")
				}
				self.OnChanged = func(arg0 []string) {
					var arg0Val env.Object
					{
						items := make([]env.Object, len(arg0))
						for i, it := range arg0 {
							items[i] = *env.NewString(it)
						}
						arg0Val = *env.NewBlock(*env.NewTSeries(items))
					}
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "check-group//on-changed!")
			}
			return arg0
		},
	},
	"check-group//on-changed?": {
		Doc:   "Get widget.CheckGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(arr-string)")
			return resObj
		},
	},
	"check-group//options!": {
		Doc:   "Set widget.CheckGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//options!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group//options!")
			}
			return arg0
		},
	},
	"check-group//options?": {
		Doc:   "Get widget.CheckGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//options?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//options?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"check-group//required!": {
		Doc:   "Set widget.CheckGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//required!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//required!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "check-group//required!")
			}
			return arg0
		},
	},
	"check-group//required?": {
		Doc:   "Get widget.CheckGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//required?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//required?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"check-group//selected!": {
		Doc:   "Set widget.CheckGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//selected!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Selected = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Selected[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group//selected!")
					}
				}
			case env.Native:
				var ok bool
				self.Selected, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group//selected!")
				}
				self.Selected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check-group//selected!")
			}
			return arg0
		},
	},
	"check-group//selected?": {
		Doc:   "Get widget.CheckGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check-group//selected?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Selected))
				for i, it := range self.Selected {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"check-with-data": {
		Doc:   "widget.NewCheckWithData",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "check-with-data")
			}
			var arg1Val binding.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "check-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "check-with-data")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "check-with-data")
			}
			res0 := widget.NewCheckWithData(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-check")
			return res0Obj
		},
	},
	"check//checked!": {
		Doc:   "Set widget.Check Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//checked!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//checked!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "check//checked!")
			}
			return arg0
		},
	},
	"check//checked?": {
		Doc:   "Get widget.Check Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//checked?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//checked?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"check//hidden!": {
		Doc:   "Set widget.Check Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "check//hidden!")
			}
			return arg0
		},
	},
	"check//hidden?": {
		Doc:   "Get widget.Check Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"check//on-changed!": {
		Doc:   "Set widget.Check OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "check//on-changed!")
				}
				self.OnChanged = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "check//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "check//on-changed!")
			}
			return arg0
		},
	},
	"check//on-changed?": {
		Doc:   "Get widget.Check OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(bool)")
			return resObj
		},
	},
	"check//text!": {
		Doc:   "Set widget.Check Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "check//text!")
			}
			return arg0
		},
	},
	"check//text?": {
		Doc:   "Get widget.Check Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "check//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"child": {
		Doc:   "storage.Child",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "child")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "child")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "child")
			}
			res0, res1 := storage.Child(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"circle": {
		Doc:   "canvas.NewCircle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle")
			}
			res0 := canvas.NewCircle(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-circle")
			return res0Obj
		},
	},
	"circle//fill-color!": {
		Doc:   "Set canvas.Circle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//fill-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "circle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "circle//fill-color!")
			}
			return arg0
		},
	},
	"circle//fill-color?": {
		Doc:   "Get canvas.Circle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//fill-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//fill-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color")
			return resObj
		},
	},
	"circle//hidden!": {
		Doc:   "Set canvas.Circle Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "circle//hidden!")
			}
			return arg0
		},
	},
	"circle//hidden?": {
		Doc:   "Get canvas.Circle Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"circle//position-1!": {
		Doc:   "Set canvas.Circle Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//position-1!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "circle//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "circle//position-1!")
			}
			return arg0
		},
	},
	"circle//position-1?": {
		Doc:   "Get canvas.Circle Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//position-1?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//position-1?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "position")
			return resObj
		},
	},
	"circle//position-2!": {
		Doc:   "Set canvas.Circle Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//position-2!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "circle//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "circle//position-2!")
			}
			return arg0
		},
	},
	"circle//position-2?": {
		Doc:   "Get canvas.Circle Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//position-2?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//position-2?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "position")
			return resObj
		},
	},
	"circle//stroke-color!": {
		Doc:   "Set canvas.Circle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "circle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "circle//stroke-color!")
			}
			return arg0
		},
	},
	"circle//stroke-color?": {
		Doc:   "Get canvas.Circle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//stroke-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color")
			return resObj
		},
	},
	"circle//stroke-width!": {
		Doc:   "Set canvas.Circle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//stroke-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "circle//stroke-width!")
			}
			return arg0
		},
	},
	"circle//stroke-width?": {
		Doc:   "Get canvas.Circle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//stroke-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "circle//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"clipboard//content": {
		Doc:   "fyne.Clipboard.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Clipboard
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "clipboard//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "clipboard//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "clipboard//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"clipboard//set-content": {
		Doc:   "fyne.Clipboard.SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Clipboard
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "clipboard//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "clipboard//set-content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "clipboard//set-content")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "clipboard//set-content")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"cloud-provider-preferences//cloud-preferences": {
		Doc:   "fyne.CloudProviderPreferences.CloudPreferences",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProviderPreferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProviderPreferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider-preferences//cloud-preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider-preferences//cloud-preferences")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider-preferences//cloud-preferences")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider-preferences//cloud-preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider-preferences//cloud-preferences")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider-preferences//cloud-preferences")
			}
			res0 := arg0Val.CloudPreferences(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "preferences")
			return res0Obj
		},
	},
	"cloud-provider-storage//cloud-storage": {
		Doc:   "fyne.CloudProviderStorage.CloudStorage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProviderStorage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProviderStorage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider-storage//cloud-storage")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider-storage//cloud-storage")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider-storage//cloud-storage")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider-storage//cloud-storage")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider-storage//cloud-storage")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider-storage//cloud-storage")
			}
			res0 := arg0Val.CloudStorage(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "storage")
			return res0Obj
		},
	},
	"cloud-provider//cleanup": {
		Doc:   "fyne.CloudProvider.Cleanup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//cleanup")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//cleanup")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//cleanup")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider//cleanup")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider//cleanup")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider//cleanup")
			}
			arg0Val.Cleanup(arg1Val)
			return arg0
		},
	},
	"cloud-provider//provider-description": {
		Doc:   "fyne.CloudProvider.ProviderDescription",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//provider-description")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//provider-description")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//provider-description")
			}
			res0 := arg0Val.ProviderDescription()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"cloud-provider//provider-icon": {
		Doc:   "fyne.CloudProvider.ProviderIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//provider-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//provider-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//provider-icon")
			}
			res0 := arg0Val.ProviderIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"cloud-provider//provider-name": {
		Doc:   "fyne.CloudProvider.ProviderName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//provider-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//provider-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//provider-name")
			}
			res0 := arg0Val.ProviderName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"cloud-provider//setup": {
		Doc:   "fyne.CloudProvider.Setup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//setup")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//setup")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cloud-provider//setup")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider//setup")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider//setup")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "cloud-provider//setup")
			}
			res0 := arg0Val.Setup(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"color-achromatic-icon": {
		Doc:   "theme.ColorAchromaticIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ColorAchromaticIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"color-chromatic-icon": {
		Doc:   "theme.ColorChromaticIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ColorChromaticIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"color-palette-icon": {
		Doc:   "theme.ColorPaletteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ColorPaletteIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"color-picker": {
		Doc:   "dialog.NewColorPicker",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "color-picker")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "color-picker")
			}
			var arg2Val func(color.Color)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "color-picker")
				}
				arg2Val = func(arg0 color.Color) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "color")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "color-picker")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "color-picker")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "color-picker")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "color-picker")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "color-picker")
			}
			res0 := dialog.NewColorPicker(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-color-picker-dialog")
			return res0Obj
		},
	},
	"color-picker-dialog//advanced!": {
		Doc:   "Set dialog.ColorPickerDialog Advanced value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "color-picker-dialog//advanced!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "color-picker-dialog//advanced!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Advanced = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "color-picker-dialog//advanced!")
			}
			return arg0
		},
	},
	"color-picker-dialog//advanced?": {
		Doc:   "Get dialog.ColorPickerDialog Advanced value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "color-picker-dialog//advanced?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "color-picker-dialog//advanced?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Advanced))
			return resObj
		},
	},
	"color-rgba-animation": {
		Doc:   "canvas.NewColorRGBAAnimation",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "color-rgba-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "color-rgba-animation")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "color-rgba-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "color-rgba-animation")
			}
			var arg2Val time.Duration
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "color-rgba-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "color-rgba-animation")
			}
			var arg3Val func(color.Color)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "color-rgba-animation")
				}
				arg3Val = func(arg0 color.Color) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "color")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "color-rgba-animation")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "color-rgba-animation")
			}
			res0 := canvas.NewColorRGBAAnimation(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-animation")
			return res0Obj
		},
	},
	"colored-resource": {
		Doc:   "theme.NewColoredResource",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "colored-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "colored-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "colored-resource")
			}
			var arg1Val fyne.ThemeColorName
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "colored-resource")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "colored-resource")
			}
			res0 := theme.NewColoredResource(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-themed-resource")
			return res0Obj
		},
	},
	"computer-icon": {
		Doc:   "theme.ComputerIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ComputerIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"confirm": {
		Doc:   "dialog.NewConfirm",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "confirm")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "confirm")
			}
			var arg2Val func(bool)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "confirm")
				}
				arg2Val = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "confirm")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "confirm")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "confirm")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "confirm")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "confirm")
			}
			res0 := dialog.NewConfirm(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-confirm-dialog")
			return res0Obj
		},
	},
	"confirm-icon": {
		Doc:   "theme.ConfirmIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ConfirmIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"container": {
		Doc:   "container.New",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
			}
			res0 := container.New(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"container-with-layout": {
		Doc:   "fyne.NewContainerWithLayout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-with-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-with-layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-with-layout")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-with-layout")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-with-layout")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-with-layout")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-with-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-with-layout")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-with-layout")
			}
			res0 := fyne.NewContainerWithLayout(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"container-without-layout": {
		Doc:   "fyne.NewContainerWithoutLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
			}
			res0 := fyne.NewContainerWithoutLayout(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"container//hidden!": {
		Doc:   "Set fyne.Container Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container//hidden!")
			}
			return arg0
		},
	},
	"container//hidden?": {
		Doc:   "Get fyne.Container Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container//layout!": {
		Doc:   "Set fyne.Container Layout value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//layout!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//layout!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Layout, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container//layout!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container//layout!")
				}
				self.Layout = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container//layout!")
			}
			return arg0
		},
	},
	"container//layout?": {
		Doc:   "Get fyne.Container Layout value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//layout?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//layout?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Layout, "layout")
			return resObj
		},
	},
	"container//objects!": {
		Doc:   "Set fyne.Container Objects value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//objects!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//objects!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Objects = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Objects[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container//objects!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container//objects!")
						}
						self.Objects[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container//objects!")
					}
				}
			case env.Native:
				var ok bool
				self.Objects, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container//objects!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container//objects!")
				}
				self.Objects = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container//objects!")
			}
			return arg0
		},
	},
	"container//objects?": {
		Doc:   "Get fyne.Container Objects value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//objects?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container//objects?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Objects))
				for i, it := range self.Objects {
					items[i] = *env.NewNative(ps.Idx, it, "canvas-object")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"content-add-icon": {
		Doc:   "theme.ContentAddIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentAddIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"content-clear-icon": {
		Doc:   "theme.ContentClearIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentClearIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"content-copy-icon": {
		Doc:   "theme.ContentCopyIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentCopyIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"content-cut-icon": {
		Doc:   "theme.ContentCutIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentCutIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"content-paste-icon": {
		Doc:   "theme.ContentPasteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentPasteIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"content-redo-icon": {
		Doc:   "theme.ContentRedoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentRedoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"content-remove-icon": {
		Doc:   "theme.ContentRemoveIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentRemoveIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"content-undo-icon": {
		Doc:   "theme.ContentUndoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentUndoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"copy": {
		Doc:   "storage.Copy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "copy")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "copy")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "copy")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "copy")
			}
			res0 := storage.Copy(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"copyable-repository//copy": {
		Doc:   "repository.CopyableRepository.Copy",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.CopyableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.CopyableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "copyable-repository//copy")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "copyable-repository//copy")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "copyable-repository//copy")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "copyable-repository//copy")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "copyable-repository//copy")
			}
			var arg2Val fyne.URI
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "copyable-repository//copy")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "copyable-repository//copy")
			}
			res0 := arg0Val.Copy(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"create-listable": {
		Doc:   "storage.CreateListable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "create-listable")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "create-listable")
			}
			res0 := storage.CreateListable(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"current-app": {
		Doc:   "fyne.CurrentApp",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := fyne.CurrentApp()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "app")
			return res0Obj
		},
	},
	"current-device": {
		Doc:   "fyne.CurrentDevice",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := fyne.CurrentDevice()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "device")
			return res0Obj
		},
	},
	"cursor//image": {
		Doc:   "desktop.Cursor.Image",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Cursor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Cursor)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cursor//image")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cursor//image")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cursor//image")
			}
			res0, res1, res2 := arg0Val.Image()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
				"3": res2Obj,
			})
		},
	},
	"cursorable//cursor": {
		Doc:   "desktop.Cursorable.Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Cursorable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Cursorable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cursorable//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cursorable//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "cursorable//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "cursor")
			return res0Obj
		},
	},
	"custom": {
		Doc:   "dialog.NewCustom",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "custom")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "custom")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "custom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "custom")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "custom")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "custom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "custom")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "custom")
			}
			res0 := dialog.NewCustom(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-custom-dialog")
			return res0Obj
		},
	},
	"custom-shortcut//modifier!": {
		Doc:   "Set desktop.CustomShortcut Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-shortcut//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-shortcut//modifier!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Modifier, ok = v.Value.(fyne.KeyModifier)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "custom-shortcut//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "custom-shortcut//modifier!")
			}
			return arg0
		},
	},
	"custom-shortcut//modifier?": {
		Doc:   "Get desktop.CustomShortcut Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-shortcut//modifier?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-shortcut//modifier?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Modifier, "key-modifier")
			return resObj
		},
	},
	"custom-text-grid-style//bg-color!": {
		Doc:   "Set widget.CustomTextGridStyle BGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-text-grid-style//bg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-text-grid-style//bg-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.BGColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "custom-text-grid-style//bg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "custom-text-grid-style//bg-color!")
			}
			return arg0
		},
	},
	"custom-text-grid-style//bg-color?": {
		Doc:   "Get widget.CustomTextGridStyle BGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-text-grid-style//bg-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-text-grid-style//bg-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.BGColor, "color")
			return resObj
		},
	},
	"custom-text-grid-style//fg-color!": {
		Doc:   "Set widget.CustomTextGridStyle FGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-text-grid-style//fg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-text-grid-style//fg-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FGColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "custom-text-grid-style//fg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "custom-text-grid-style//fg-color!")
			}
			return arg0
		},
	},
	"custom-text-grid-style//fg-color?": {
		Doc:   "Get widget.CustomTextGridStyle FGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-text-grid-style//fg-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-text-grid-style//fg-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FGColor, "color")
			return resObj
		},
	},
	"custom-uri-repository//parse-uri": {
		Doc:   "repository.CustomURIRepository.ParseURI",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.CustomURIRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.CustomURIRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-uri-repository//parse-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-uri-repository//parse-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "custom-uri-repository//parse-uri")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "custom-uri-repository//parse-uri")
			}
			res0, res1 := arg0Val.ParseURI(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"custom-without-buttons": {
		Doc:   "dialog.NewCustomWithoutButtons",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "custom-without-buttons")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "custom-without-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "custom-without-buttons")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "custom-without-buttons")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "custom-without-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "custom-without-buttons")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "custom-without-buttons")
			}
			res0 := dialog.NewCustomWithoutButtons(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-custom-dialog")
			return res0Obj
		},
	},
	"dark-theme": {
		Doc:   "theme.DarkTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DarkTheme()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme")
			return res0Obj
		},
	},
	"data-item//add-listener": {
		Doc:   "binding.DataItem.AddListener",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-item//add-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-item//add-listener")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-item//add-listener")
			}
			var arg1Val binding.DataListener
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.DataListener)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "data-item//add-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "data-item//add-listener")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "data-item//add-listener")
			}
			arg0Val.AddListener(arg1Val)
			return arg0
		},
	},
	"data-item//remove-listener": {
		Doc:   "binding.DataItem.RemoveListener",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-item//remove-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-item//remove-listener")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-item//remove-listener")
			}
			var arg1Val binding.DataListener
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.DataListener)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "data-item//remove-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "data-item//remove-listener")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "data-item//remove-listener")
			}
			arg0Val.RemoveListener(arg1Val)
			return arg0
		},
	},
	"data-list//get-item": {
		Doc:   "binding.DataList.GetItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-list//get-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-list//get-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-list//get-item")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "data-list//get-item")
			}
			res0, res1 := arg0Val.GetItem(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "data-item")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"data-list//length": {
		Doc:   "binding.DataList.Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-list//length")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-list//length")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-list//length")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"data-listener": {
		Doc:   "binding.NewDataListener",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func()
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "data-listener")
				}
				arg0Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "data-listener")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "data-listener")
			}
			res0 := binding.NewDataListener(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "data-listener")
			return res0Obj
		},
	},
	"data-listener//data-changed": {
		Doc:   "binding.DataListener.DataChanged",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataListener
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataListener)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-listener//data-changed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-listener//data-changed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-listener//data-changed")
			}
			arg0Val.DataChanged()
			return arg0
		},
	},
	"data-map//get-item": {
		Doc:   "binding.DataMap.GetItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataMap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-map//get-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-map//get-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-map//get-item")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "data-map//get-item")
			}
			res0, res1 := arg0Val.GetItem(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "data-item")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"data-map//keys": {
		Doc:   "binding.DataMap.Keys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataMap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-map//keys")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-map//keys")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-map//keys")
			}
			res0 := arg0Val.Keys()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"data-tree//child-i-ds": {
		Doc:   "binding.DataTree.ChildIDs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-tree//child-i-ds")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-tree//child-i-ds")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-tree//child-i-ds")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "data-tree//child-i-ds")
			}
			res0 := arg0Val.ChildIDs(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"data-tree//get-item": {
		Doc:   "binding.DataTree.GetItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-tree//get-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-tree//get-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "data-tree//get-item")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "data-tree//get-item")
			}
			res0, res1 := arg0Val.GetItem(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "data-item")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"default-emoji-font": {
		Doc:   "theme.DefaultEmojiFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultEmojiFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"default-symbol-font": {
		Doc:   "theme.DefaultSymbolFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultSymbolFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"default-text-bold-font": {
		Doc:   "theme.DefaultTextBoldFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextBoldFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"default-text-bold-italic-font": {
		Doc:   "theme.DefaultTextBoldItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextBoldItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"default-text-font": {
		Doc:   "theme.DefaultTextFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"default-text-italic-font": {
		Doc:   "theme.DefaultTextItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"default-text-monospace-font": {
		Doc:   "theme.DefaultTextMonospaceFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextMonospaceFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"default-theme": {
		Doc:   "theme.DefaultTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTheme()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme")
			return res0Obj
		},
	},
	"delete": {
		Doc:   "storage.Delete",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delete")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delete")
			}
			res0 := storage.Delete(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"delete-icon": {
		Doc:   "theme.DeleteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DeleteIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"delta": {
		Doc:   "fyne.NewDelta",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "delta")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "delta")
			}
			res0 := fyne.NewDelta(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "delta")
			return res0Obj
		},
	},
	"delta//components": {
		Doc:   "fyne.Delta.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//components")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//components")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"delta//dx!": {
		Doc:   "Set fyne.Delta DX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//dx!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//dx!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DX = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "delta//dx!")
			}
			return arg0
		},
	},
	"delta//dx?": {
		Doc:   "Get fyne.Delta DX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//dx?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//dx?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DX))
			return resObj
		},
	},
	"delta//dy!": {
		Doc:   "Set fyne.Delta DY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//dy!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//dy!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DY = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "delta//dy!")
			}
			return arg0
		},
	},
	"delta//dy?": {
		Doc:   "Get fyne.Delta DY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//dy?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//dy?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DY))
			return resObj
		},
	},
	"delta//is-zero": {
		Doc:   "fyne.Delta.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//is-zero")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "delta//is-zero")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"device//has-keyboard": {
		Doc:   "fyne.Device.HasKeyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//has-keyboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//has-keyboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//has-keyboard")
			}
			res0 := arg0Val.HasKeyboard()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"device//hide-virtual-keyboard": {
		Doc:   "mobile.Device.HideVirtualKeyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//hide-virtual-keyboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//hide-virtual-keyboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//hide-virtual-keyboard")
			}
			arg0Val.HideVirtualKeyboard()
			return arg0
		},
	},
	"device//is-browser": {
		Doc:   "fyne.Device.IsBrowser",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//is-browser")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//is-browser")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//is-browser")
			}
			res0 := arg0Val.IsBrowser()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"device//is-mobile": {
		Doc:   "fyne.Device.IsMobile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//is-mobile")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//is-mobile")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//is-mobile")
			}
			res0 := arg0Val.IsMobile()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"device//orientation": {
		Doc:   "fyne.Device.Orientation",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//orientation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//orientation")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//orientation")
			}
			res0 := arg0Val.Orientation()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "device-orientation")
			return res0Obj
		},
	},
	"device//show-virtual-keyboard": {
		Doc:   "mobile.Device.ShowVirtualKeyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//show-virtual-keyboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//show-virtual-keyboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//show-virtual-keyboard")
			}
			arg0Val.ShowVirtualKeyboard()
			return arg0
		},
	},
	"device//show-virtual-keyboard-type": {
		Doc:   "mobile.Device.ShowVirtualKeyboardType",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//show-virtual-keyboard-type")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//show-virtual-keyboard-type")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//show-virtual-keyboard-type")
			}
			var arg1Val mobile.KeyboardType
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(mobile.KeyboardType)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "device//show-virtual-keyboard-type")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "device//show-virtual-keyboard-type")
			}
			arg0Val.ShowVirtualKeyboardType(arg1Val)
			return arg0
		},
	},
	"device//system-scale-for-window": {
		Doc:   "fyne.Device.SystemScaleForWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//system-scale-for-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//system-scale-for-window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "device//system-scale-for-window")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "device//system-scale-for-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "device//system-scale-for-window")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "device//system-scale-for-window")
			}
			res0 := arg0Val.SystemScaleForWindow(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"dialog//hide": {
		Doc:   "dialog.Dialog.Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"dialog//min-size": {
		Doc:   "dialog.Dialog.MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"dialog//refresh": {
		Doc:   "dialog.Dialog.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"dialog//resize": {
		Doc:   "dialog.Dialog.Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"dialog//set-dismiss-text": {
		Doc:   "dialog.Dialog.SetDismissText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//set-dismiss-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//set-dismiss-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//set-dismiss-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog//set-dismiss-text")
			}
			arg0Val.SetDismissText(arg1Val)
			return arg0
		},
	},
	"dialog//set-on-closed": {
		Doc:   "dialog.Dialog.SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//set-on-closed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//set-on-closed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//set-on-closed")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "dialog//set-on-closed")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "dialog//set-on-closed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "dialog//set-on-closed")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"dialog//show": {
		Doc:   "dialog.Dialog.Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"disableable-widget//hidden!": {
		Doc:   "Set widget.DisableableWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable-widget//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable-widget//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "disableable-widget//hidden!")
			}
			return arg0
		},
	},
	"disableable-widget//hidden?": {
		Doc:   "Get widget.DisableableWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable-widget//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable-widget//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"disableable//disable": {
		Doc:   "fyne.Disableable.Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Disableable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Disableable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"disableable//disabled": {
		Doc:   "fyne.Disableable.Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Disableable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Disableable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"disableable//enable": {
		Doc:   "fyne.Disableable.Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Disableable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Disableable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disableable//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"disabled-button-color": {
		Doc:   "theme.DisabledButtonColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DisabledButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"disabled-color": {
		Doc:   "theme.DisabledColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DisabledColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"disabled-resource": {
		Doc:   "theme.NewDisabledResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disabled-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disabled-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "disabled-resource")
			}
			res0 := theme.NewDisabledResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-disabled-resource")
			return res0Obj
		},
	},
	"disabled-text-color": {
		Doc:   "theme.DisabledTextColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DisabledTextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"doc-tabs": {
		Doc:   "container.NewDocTabs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*container.TabItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "doc-tabs")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "doc-tabs")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "doc-tabs")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "doc-tabs")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "doc-tabs")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "doc-tabs")
			}
			res0 := container.NewDocTabs(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-doc-tabs")
			return res0Obj
		},
	},
	"doc-tabs//close-intercept!": {
		Doc:   "Set container.DocTabs CloseIntercept value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//close-intercept!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//close-intercept!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//close-intercept!")
				}
				self.CloseIntercept = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//close-intercept!")
				}
				self.CloseIntercept = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//close-intercept!")
			}
			return arg0
		},
	},
	"doc-tabs//close-intercept?": {
		Doc:   "Get container.DocTabs CloseIntercept value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//close-intercept?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//close-intercept?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CloseIntercept, "func(ptr-tab-item)")
			return resObj
		},
	},
	"doc-tabs//create-tab!": {
		Doc:   "Set container.DocTabs CreateTab value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//create-tab!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//create-tab!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//create-tab!")
				}
				self.CreateTab = func() *container.TabItem {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res *container.TabItem
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(*container.TabItem)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//create-tab!")
				}
				self.CreateTab = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//create-tab!")
			}
			return arg0
		},
	},
	"doc-tabs//create-tab?": {
		Doc:   "Get container.DocTabs CreateTab value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//create-tab?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//create-tab?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateTab, "func()_(ptr-tab-item)")
			return resObj
		},
	},
	"doc-tabs//hidden!": {
		Doc:   "Set container.DocTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "doc-tabs//hidden!")
			}
			return arg0
		},
	},
	"doc-tabs//hidden?": {
		Doc:   "Get container.DocTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"doc-tabs//items!": {
		Doc:   "Set container.DocTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//items!")
			}
			return arg0
		},
	},
	"doc-tabs//items?": {
		Doc:   "Get container.DocTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-tab-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"doc-tabs//on-closed!": {
		Doc:   "Set container.DocTabs OnClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-closed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-closed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//on-closed!")
				}
				self.OnClosed = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//on-closed!")
				}
				self.OnClosed = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//on-closed!")
			}
			return arg0
		},
	},
	"doc-tabs//on-closed?": {
		Doc:   "Get container.DocTabs OnClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-closed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-closed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnClosed, "func(ptr-tab-item)")
			return resObj
		},
	},
	"doc-tabs//on-selected!": {
		Doc:   "Set container.DocTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//on-selected!")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//on-selected!")
			}
			return arg0
		},
	},
	"doc-tabs//on-selected?": {
		Doc:   "Get container.DocTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(ptr-tab-item)")
			return resObj
		},
	},
	"doc-tabs//on-unselected!": {
		Doc:   "Set container.DocTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-unselected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//on-unselected!")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "doc-tabs//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "doc-tabs//on-unselected!")
			}
			return arg0
		},
	},
	"doc-tabs//on-unselected?": {
		Doc:   "Get container.DocTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-unselected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "doc-tabs//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(ptr-tab-item)")
			return resObj
		},
	},
	"document-create-icon": {
		Doc:   "theme.DocumentCreateIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentCreateIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"document-icon": {
		Doc:   "theme.DocumentIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"document-print-icon": {
		Doc:   "theme.DocumentPrintIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentPrintIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"document-save-icon": {
		Doc:   "theme.DocumentSaveIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentSaveIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"double-tappable//double-tapped": {
		Doc:   "fyne.DoubleTappable.DoubleTapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.DoubleTappable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.DoubleTappable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "double-tappable//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "double-tappable//double-tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "double-tappable//double-tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "double-tappable//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "double-tappable//double-tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "double-tappable//double-tapped")
			}
			arg0Val.DoubleTapped(arg1Val)
			return arg0
		},
	},
	"download-icon": {
		Doc:   "theme.DownloadIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DownloadIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"drag-event//absolute-position!": {
		Doc:   "Set fyne.DragEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "drag-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "drag-event//absolute-position!")
			}
			return arg0
		},
	},
	"drag-event//absolute-position?": {
		Doc:   "Get fyne.DragEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"drag-event//dragged!": {
		Doc:   "Set fyne.DragEvent Dragged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//dragged!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//dragged!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Dragged, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "drag-event//dragged!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "drag-event//dragged!")
			}
			return arg0
		},
	},
	"drag-event//dragged?": {
		Doc:   "Get fyne.DragEvent Dragged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//dragged?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//dragged?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Dragged, "delta")
			return resObj
		},
	},
	"drag-event//position!": {
		Doc:   "Set fyne.DragEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "drag-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "drag-event//position!")
			}
			return arg0
		},
	},
	"drag-event//position?": {
		Doc:   "Get fyne.DragEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "drag-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"draggable//drag-end": {
		Doc:   "fyne.Draggable.DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Draggable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "draggable//drag-end")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "draggable//drag-end")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "draggable//drag-end")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"draggable//dragged": {
		Doc:   "fyne.Draggable.Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Draggable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "draggable//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "draggable//dragged")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "draggable//dragged")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "draggable//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "draggable//dragged")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "draggable//dragged")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"driver//absolute-position-for-object": {
		Doc:   "fyne.Driver.AbsolutePositionForObject",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//absolute-position-for-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//absolute-position-for-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//absolute-position-for-object")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//absolute-position-for-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//absolute-position-for-object")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//absolute-position-for-object")
			}
			res0 := arg0Val.AbsolutePositionForObject(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"driver//all-windows": {
		Doc:   "fyne.Driver.AllWindows",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//all-windows")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//all-windows")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//all-windows")
			}
			res0 := arg0Val.AllWindows()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "window")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"driver//canvas-for-object": {
		Doc:   "fyne.Driver.CanvasForObject",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//canvas-for-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//canvas-for-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//canvas-for-object")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//canvas-for-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//canvas-for-object")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//canvas-for-object")
			}
			res0 := arg0Val.CanvasForObject(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas")
			return res0Obj
		},
	},
	"driver//create-splash-window": {
		Doc:   "desktop.Driver.CreateSplashWindow",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//create-splash-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//create-splash-window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//create-splash-window")
			}
			res0 := arg0Val.CreateSplashWindow()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "window")
			return res0Obj
		},
	},
	"driver//create-window": {
		Doc:   "fyne.Driver.CreateWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//create-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//create-window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//create-window")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "driver//create-window")
			}
			res0 := arg0Val.CreateWindow(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "window")
			return res0Obj
		},
	},
	"driver//current-key-modifiers": {
		Doc:   "desktop.Driver.CurrentKeyModifiers",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//current-key-modifiers")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//current-key-modifiers")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//current-key-modifiers")
			}
			res0 := arg0Val.CurrentKeyModifiers()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-modifier")
			return res0Obj
		},
	},
	"driver//device": {
		Doc:   "fyne.Driver.Device",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//device")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//device")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//device")
			}
			res0 := arg0Val.Device()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "device")
			return res0Obj
		},
	},
	"driver//go-back": {
		Doc:   "mobile.Driver.GoBack",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//go-back")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//go-back")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//go-back")
			}
			arg0Val.GoBack()
			return arg0
		},
	},
	"driver//quit": {
		Doc:   "fyne.Driver.Quit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//quit")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//quit")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//quit")
			}
			arg0Val.Quit()
			return arg0
		},
	},
	"driver//rendered-text-size": {
		Doc:   "fyne.Driver.RenderedTextSize",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//rendered-text-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//rendered-text-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//rendered-text-size")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "driver//rendered-text-size")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "driver//rendered-text-size")
			}
			var arg3Val fyne.TextStyle
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "driver//rendered-text-size")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "driver//rendered-text-size")
			}
			res0, res1 := arg0Val.RenderedTextSize(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"size":     res0Obj,
				"baseline": res1Obj,
			})
		},
	},
	"driver//run": {
		Doc:   "fyne.Driver.Run",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//run")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//run")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//run")
			}
			arg0Val.Run()
			return arg0
		},
	},
	"driver//start-animation": {
		Doc:   "fyne.Driver.StartAnimation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//start-animation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//start-animation")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//start-animation")
			}
			var arg1Val *fyne.Animation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//start-animation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//start-animation")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//start-animation")
			}
			arg0Val.StartAnimation(arg1Val)
			return arg0
		},
	},
	"driver//stop-animation": {
		Doc:   "fyne.Driver.StopAnimation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//stop-animation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//stop-animation")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver//stop-animation")
			}
			var arg1Val *fyne.Animation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//stop-animation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//stop-animation")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver//stop-animation")
			}
			arg0Val.StopAnimation(arg1Val)
			return arg0
		},
	},
	"entry": {
		Doc:   "widget.NewEntry",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewEntry()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-entry")
			return res0Obj
		},
	},
	"entry-dialog": {
		Doc:   "dialog.NewEntryDialog",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "entry-dialog")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "entry-dialog")
			}
			var arg2Val func(string)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "entry-dialog")
				}
				arg2Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "entry-dialog")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "entry-dialog")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "entry-dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "entry-dialog")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "entry-dialog")
			}
			res0 := dialog.NewEntryDialog(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-entry-dialog")
			return res0Obj
		},
	},
	"entry-with-data": {
		Doc:   "widget.NewEntryWithData",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry-with-data")
			}
			res0 := widget.NewEntryWithData(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-entry")
			return res0Obj
		},
	},
	"entry//action-item!": {
		Doc:   "Set widget.Entry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//action-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//action-item!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//action-item!")
				}
				self.ActionItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//action-item!")
			}
			return arg0
		},
	},
	"entry//action-item?": {
		Doc:   "Get widget.Entry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//action-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//action-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ActionItem, "canvas-object")
			return resObj
		},
	},
	"entry//cursor-column!": {
		Doc:   "Set widget.Entry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//cursor-column!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//cursor-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "entry//cursor-column!")
			}
			return arg0
		},
	},
	"entry//cursor-column?": {
		Doc:   "Get widget.Entry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//cursor-column?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//cursor-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"entry//cursor-row!": {
		Doc:   "Set widget.Entry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//cursor-row!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//cursor-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "entry//cursor-row!")
			}
			return arg0
		},
	},
	"entry//cursor-row?": {
		Doc:   "Get widget.Entry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//cursor-row?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//cursor-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"entry//hidden!": {
		Doc:   "Set widget.Entry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "entry//hidden!")
			}
			return arg0
		},
	},
	"entry//hidden?": {
		Doc:   "Get widget.Entry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"entry//multi-line!": {
		Doc:   "Set widget.Entry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//multi-line!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//multi-line!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "entry//multi-line!")
			}
			return arg0
		},
	},
	"entry//multi-line?": {
		Doc:   "Get widget.Entry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//multi-line?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//multi-line?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"entry//on-changed!": {
		Doc:   "Set widget.Entry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "entry//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "entry//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "entry//on-changed!")
			}
			return arg0
		},
	},
	"entry//on-changed?": {
		Doc:   "Get widget.Entry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"entry//on-cursor-changed!": {
		Doc:   "Set widget.Entry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-cursor-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-cursor-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "entry//on-cursor-changed!")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "entry//on-cursor-changed!")
				}
				self.OnCursorChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "entry//on-cursor-changed!")
			}
			return arg0
		},
	},
	"entry//on-cursor-changed?": {
		Doc:   "Get widget.Entry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-cursor-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-cursor-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "func()")
			return resObj
		},
	},
	"entry//on-submitted!": {
		Doc:   "Set widget.Entry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-submitted!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-submitted!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "entry//on-submitted!")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "entry//on-submitted!")
				}
				self.OnSubmitted = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "entry//on-submitted!")
			}
			return arg0
		},
	},
	"entry//on-submitted?": {
		Doc:   "Get widget.Entry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-submitted?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//on-submitted?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "func(string)")
			return resObj
		},
	},
	"entry//password!": {
		Doc:   "Set widget.Entry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//password!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//password!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "entry//password!")
			}
			return arg0
		},
	},
	"entry//password?": {
		Doc:   "Get widget.Entry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//password?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//password?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"entry//place-holder!": {
		Doc:   "Set widget.Entry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//place-holder!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "entry//place-holder!")
			}
			return arg0
		},
	},
	"entry//place-holder?": {
		Doc:   "Get widget.Entry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//place-holder?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"entry//scroll!": {
		Doc:   "Set widget.Entry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//scroll!")
			}
			return arg0
		},
	},
	"entry//scroll?": {
		Doc:   "Get widget.Entry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//scroll?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "scroll-direction")
			return resObj
		},
	},
	"entry//text!": {
		Doc:   "Set widget.Entry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "entry//text!")
			}
			return arg0
		},
	},
	"entry//text-style!": {
		Doc:   "Set widget.Entry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//text-style!")
			}
			return arg0
		},
	},
	"entry//text-style?": {
		Doc:   "Get widget.Entry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"entry//text?": {
		Doc:   "Get widget.Entry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"entry//validator!": {
		Doc:   "Set widget.Entry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//validator!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Validator, ok = v.Value.(fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//validator!")
			}
			return arg0
		},
	},
	"entry//validator?": {
		Doc:   "Get widget.Entry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//validator?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//validator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Validator, "string-validator")
			return resObj
		},
	},
	"entry//wrapping!": {
		Doc:   "Set widget.Entry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "entry//wrapping!")
			}
			return arg0
		},
	},
	"entry//wrapping?": {
		Doc:   "Get widget.Entry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//wrapping?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "entry//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"error": {
		Doc:   "dialog.NewError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val error
			if v, ok := arg0.(env.Error); ok {
				arg0Val = errors.New(v.Print(*ps.Idx))
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.ErrorType}, "error")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "error")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "error")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "error")
			}
			res0 := dialog.NewError(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog")
			return res0Obj
		},
	},
	"error-color": {
		Doc:   "theme.ErrorColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ErrorColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"error-icon": {
		Doc:   "theme.ErrorIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ErrorIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"error-themed-resource": {
		Doc:   "theme.NewErrorThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "error-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "error-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "error-themed-resource")
			}
			res0 := theme.NewErrorThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-error-themed-resource")
			return res0Obj
		},
	},
	"exists": {
		Doc:   "storage.Exists",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "exists")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "exists")
			}
			res0, res1 := storage.Exists(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"extension-file-filter": {
		Doc:   "storage.NewExtensionFileFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "extension-file-filter")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "extension-file-filter")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "extension-file-filter")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "extension-file-filter")
			}
			res0 := storage.NewExtensionFileFilter(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "file-filter")
			return res0Obj
		},
	},
	"extension-file-filter//extensions!": {
		Doc:   "Set storage.ExtensionFileFilter Extensions value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "extension-file-filter//extensions!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "extension-file-filter//extensions!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Extensions = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Extensions[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "extension-file-filter//extensions!")
					}
				}
			case env.Native:
				var ok bool
				self.Extensions, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "extension-file-filter//extensions!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "extension-file-filter//extensions!")
				}
				self.Extensions = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "extension-file-filter//extensions!")
			}
			return arg0
		},
	},
	"extension-file-filter//extensions?": {
		Doc:   "Get storage.ExtensionFileFilter Extensions value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "extension-file-filter//extensions?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "extension-file-filter//extensions?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Extensions))
				for i, it := range self.Extensions {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"external-bool-list//reload": {
		Doc:   "binding.ExternalBoolList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bool-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bool-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bool-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-bool-tree//reload": {
		Doc:   "binding.ExternalBoolTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bool-tree//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bool-tree//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bool-tree//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-bool//reload": {
		Doc:   "binding.ExternalBool.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bool//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bool//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bool//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-bytes-list//reload": {
		Doc:   "binding.ExternalBytesList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bytes-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bytes-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bytes-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-bytes-tree//reload": {
		Doc:   "binding.ExternalBytesTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBytesTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBytesTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bytes-tree//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bytes-tree//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bytes-tree//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-bytes//reload": {
		Doc:   "binding.ExternalBytes.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBytes
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBytes)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bytes//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bytes//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-bytes//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-float-list//reload": {
		Doc:   "binding.ExternalFloatList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalFloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalFloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-float-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-float-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-float-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-float-tree//reload": {
		Doc:   "binding.ExternalFloatTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalFloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalFloatTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-float-tree//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-float-tree//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-float-tree//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-float//reload": {
		Doc:   "binding.ExternalFloat.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalFloat
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalFloat)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-float//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-float//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-float//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-int-list//reload": {
		Doc:   "binding.ExternalIntList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalIntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalIntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-int-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-int-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-int-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-int-tree//reload": {
		Doc:   "binding.ExternalIntTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalIntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalIntTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-int-tree//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-int-tree//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-int-tree//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-int//reload": {
		Doc:   "binding.ExternalInt.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalInt
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalInt)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-int//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-int//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-int//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-rune-list//reload": {
		Doc:   "binding.ExternalRuneList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalRuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalRuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-rune-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-rune-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-rune-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-rune-tree//reload": {
		Doc:   "binding.ExternalRuneTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalRuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalRuneTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-rune-tree//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-rune-tree//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-rune-tree//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-rune//reload": {
		Doc:   "binding.ExternalRune.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalRune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalRune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-rune//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-rune//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-rune//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-string-list//reload": {
		Doc:   "binding.ExternalStringList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalStringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalStringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-string-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-string-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-string-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-string-tree//reload": {
		Doc:   "binding.ExternalStringTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalStringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalStringTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-string-tree//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-string-tree//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-string-tree//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-string//reload": {
		Doc:   "binding.ExternalString.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalString
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalString)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-string//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-string//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-string//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-untyped-list//reload": {
		Doc:   "binding.ExternalUntypedList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalUntypedList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalUntypedList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-untyped-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-untyped-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-untyped-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-untyped-map//reload": {
		Doc:   "binding.ExternalUntypedMap.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalUntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalUntypedMap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-untyped-map//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-untyped-map//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-untyped-map//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-untyped//reload": {
		Doc:   "binding.ExternalUntyped.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalUntyped
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalUntyped)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-untyped//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-untyped//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-untyped//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-uri-tree//reload": {
		Doc:   "binding.ExternalURITree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalURITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalURITree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-uri-tree//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-uri-tree//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-uri-tree//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"external-uri//reload": {
		Doc:   "binding.ExternalURI.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalURI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalURI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-uri//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-uri//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "external-uri//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"file-application-icon": {
		Doc:   "theme.FileApplicationIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileApplicationIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"file-audio-icon": {
		Doc:   "theme.FileAudioIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileAudioIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"file-filter//matches": {
		Doc:   "storage.FileFilter.Matches",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val storage.FileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(storage.FileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-filter//matches")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-filter//matches")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-filter//matches")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "file-filter//matches")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "file-filter//matches")
			}
			res0 := arg0Val.Matches(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"file-icon": {
		Doc:   "widget.NewFileIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon")
			}
			res0 := widget.NewFileIcon(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-file-icon")
			return res0Obj
		},
	},
	"file-icon//hidden!": {
		Doc:   "Set widget.FileIcon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "file-icon//hidden!")
			}
			return arg0
		},
	},
	"file-icon//hidden?": {
		Doc:   "Get widget.FileIcon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"file-icon//selected!": {
		Doc:   "Set widget.FileIcon Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//selected!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Selected = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "file-icon//selected!")
			}
			return arg0
		},
	},
	"file-icon//selected?": {
		Doc:   "Get widget.FileIcon Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//selected?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Selected))
			return resObj
		},
	},
	"file-icon//uri!": {
		Doc:   "Set widget.FileIcon URI value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//uri!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//uri!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URI, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "file-icon//uri!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "file-icon//uri!")
			}
			return arg0
		},
	},
	"file-icon//uri?": {
		Doc:   "Get widget.FileIcon URI value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//uri?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "file-icon//uri?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URI, "uri")
			return resObj
		},
	},
	"file-image-icon": {
		Doc:   "theme.FileImageIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileImageIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"file-text-icon": {
		Doc:   "theme.FileTextIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileTextIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"file-uri": {
		Doc:   "repository.NewFileURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "file-uri")
			}
			res0 := repository.NewFileURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			return res0Obj
		},
	},
	"file-video-icon": {
		Doc:   "theme.FileVideoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileVideoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"float": {
		Doc:   "binding.NewFloat",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewFloat()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "float")
			return res0Obj
		},
	},
	"float-list": {
		Doc:   "binding.NewFloatList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewFloatList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "float-list")
			return res0Obj
		},
	},
	"float-list//append": {
		Doc:   "binding.FloatList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//append")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "float-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"float-list//get": {
		Doc:   "binding.FloatList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewDecimal(float64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"float-list//get-value": {
		Doc:   "binding.FloatList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "float-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"float-list//prepend": {
		Doc:   "binding.FloatList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//prepend")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "float-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"float-list//set": {
		Doc:   "binding.FloatList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//set")
			}
			var arg1Val []float64
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]float64, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg1Val[i] = float64(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "float-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "float-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "float-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "float-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"float-list//set-value": {
		Doc:   "binding.FloatList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "float-list//set-value")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "float-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"float-to-string": {
		Doc:   "binding.FloatToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-to-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-to-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-to-string")
			}
			res0 := binding.FloatToString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"float-to-string-with-format": {
		Doc:   "binding.FloatToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-to-string-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-to-string-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-to-string-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "float-to-string-with-format")
			}
			res0 := binding.FloatToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"float-tree": {
		Doc:   "binding.NewFloatTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewFloatTree()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "float-tree")
			return res0Obj
		},
	},
	"float-tree//append": {
		Doc:   "binding.FloatTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "float-tree//append")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "float-tree//append")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.DecimalType}, "float-tree//append")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"float-tree//get": {
		Doc:   "binding.FloatTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//get")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewDecimal(float64(mVal))
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"float-tree//get-value": {
		Doc:   "binding.FloatTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//get-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "float-tree//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"float-tree//prepend": {
		Doc:   "binding.FloatTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "float-tree//prepend")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "float-tree//prepend")
			}
			var arg3Val float64
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.DecimalType}, "float-tree//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"float-tree//set": {
		Doc:   "binding.FloatTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//set")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
			}
			var arg2Val map[string]float64
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
				}
				arg2Val = make(map[string]float64, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
					}
					var mapV float64
					if v, ok := v.Series.S[i+1].(env.Decimal); ok {
						mapV = float64(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]float64, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV float64
					if v, ok := dictV.(env.Decimal); ok {
						mapV = float64(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "float-tree//set")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"float-tree//set-value": {
		Doc:   "binding.FloatTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float-tree//set-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "float-tree//set-value")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "float-tree//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"float//get": {
		Doc:   "binding.Float.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"float//set": {
		Doc:   "binding.Float.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "float//set")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "float//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"focus-color": {
		Doc:   "theme.FocusColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FocusColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"focusable//focus-gained": {
		Doc:   "fyne.Focusable.FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"focusable//focus-lost": {
		Doc:   "fyne.Focusable.FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"focusable//typed-key": {
		Doc:   "fyne.Focusable.TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "focusable//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "focusable//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "focusable//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"focusable//typed-rune": {
		Doc:   "fyne.Focusable.TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "focusable//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "focusable//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "focusable//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"folder-icon": {
		Doc:   "theme.FolderIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FolderIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"folder-new-icon": {
		Doc:   "theme.FolderNewIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FolderNewIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"folder-open": {
		Doc:   "dialog.NewFolderOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.ListableURI, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "folder-open")
				}
				arg0Val = func(arg0 fyne.ListableURI, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "listable-uri")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "folder-open")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "folder-open")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "folder-open")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "folder-open")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "folder-open")
			}
			res0 := dialog.NewFolderOpen(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-file-dialog")
			return res0Obj
		},
	},
	"folder-open-icon": {
		Doc:   "theme.FolderOpenIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FolderOpenIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"for-scheme": {
		Doc:   "repository.ForScheme",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "for-scheme")
			}
			res0, res1 := repository.ForScheme(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "repository")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"for-uri": {
		Doc:   "repository.ForURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "for-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "for-uri")
			}
			res0, res1 := repository.ForURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "repository")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"foreground-color": {
		Doc:   "theme.ForegroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ForegroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"form": {
		Doc:   "widget.NewForm",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*widget.FormItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*widget.FormItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*widget.FormItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "form")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "form")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "form")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "form")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "form")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "form")
			}
			res0 := widget.NewForm(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-form")
			return res0Obj
		},
	},
	"form-item": {
		Doc:   "widget.NewFormItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "form-item")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "form-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "form-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "form-item")
			}
			res0 := widget.NewFormItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-form-item")
			return res0Obj
		},
	},
	"form-item//hint-text!": {
		Doc:   "Set widget.FormItem HintText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//hint-text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//hint-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.HintText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "form-item//hint-text!")
			}
			return arg0
		},
	},
	"form-item//hint-text?": {
		Doc:   "Get widget.FormItem HintText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//hint-text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//hint-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.HintText)
			return resObj
		},
	},
	"form-item//text!": {
		Doc:   "Set widget.FormItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "form-item//text!")
			}
			return arg0
		},
	},
	"form-item//text?": {
		Doc:   "Get widget.FormItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"form-item//widget!": {
		Doc:   "Set widget.FormItem Widget value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//widget!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//widget!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Widget, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "form-item//widget!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "form-item//widget!")
				}
				self.Widget = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "form-item//widget!")
			}
			return arg0
		},
	},
	"form-item//widget?": {
		Doc:   "Get widget.FormItem Widget value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//widget?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form-item//widget?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Widget, "canvas-object")
			return resObj
		},
	},
	"form-layout": {
		Doc:   "layout.NewFormLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewFormLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"form//cancel-text!": {
		Doc:   "Set widget.Form CancelText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//cancel-text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//cancel-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CancelText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "form//cancel-text!")
			}
			return arg0
		},
	},
	"form//cancel-text?": {
		Doc:   "Get widget.Form CancelText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//cancel-text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//cancel-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CancelText)
			return resObj
		},
	},
	"form//hidden!": {
		Doc:   "Set widget.Form Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "form//hidden!")
			}
			return arg0
		},
	},
	"form//hidden?": {
		Doc:   "Get widget.Form Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"form//items!": {
		Doc:   "Set widget.Form Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.FormItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.FormItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "form//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "form//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "form//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "form//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "form//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "form//items!")
			}
			return arg0
		},
	},
	"form//items?": {
		Doc:   "Get widget.Form Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-form-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"form//on-cancel!": {
		Doc:   "Set widget.Form OnCancel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//on-cancel!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//on-cancel!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "form//on-cancel!")
				}
				self.OnCancel = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "form//on-cancel!")
				}
				self.OnCancel = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "form//on-cancel!")
			}
			return arg0
		},
	},
	"form//on-cancel?": {
		Doc:   "Get widget.Form OnCancel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//on-cancel?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//on-cancel?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCancel, "func()")
			return resObj
		},
	},
	"form//on-submit!": {
		Doc:   "Set widget.Form OnSubmit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//on-submit!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//on-submit!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "form//on-submit!")
				}
				self.OnSubmit = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "form//on-submit!")
				}
				self.OnSubmit = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "form//on-submit!")
			}
			return arg0
		},
	},
	"form//on-submit?": {
		Doc:   "Get widget.Form OnSubmit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//on-submit?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//on-submit?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmit, "func()")
			return resObj
		},
	},
	"form//submit-text!": {
		Doc:   "Set widget.Form SubmitText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//submit-text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//submit-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.SubmitText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "form//submit-text!")
			}
			return arg0
		},
	},
	"form//submit-text?": {
		Doc:   "Get widget.Form SubmitText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//submit-text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "form//submit-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.SubmitText)
			return resObj
		},
	},
	"from-json": {
		Doc:   "theme.FromJSON",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "from-json")
			}
			res0, res1 := theme.FromJSON(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"from-json-reader": {
		Doc:   "theme.FromJSONReader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "from-json-reader")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "from-json-reader")
			}
			res0, res1 := theme.FromJSONReader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"from-legacy": {
		Doc:   "theme.FromLegacy",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "from-legacy")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "from-legacy")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "from-legacy")
			}
			res0 := theme.FromLegacy(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme")
			return res0Obj
		},
	},
	"fyne-logo": {
		Doc:   "theme.FyneLogo",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FyneLogo()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"generic-child": {
		Doc:   "repository.GenericChild",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "generic-child")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "generic-child")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "generic-child")
			}
			res0, res1 := repository.GenericChild(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"generic-copy": {
		Doc:   "repository.GenericCopy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "generic-copy")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "generic-copy")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "generic-copy")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "generic-copy")
			}
			res0 := repository.GenericCopy(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"generic-move": {
		Doc:   "repository.GenericMove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "generic-move")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "generic-move")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "generic-move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "generic-move")
			}
			res0 := repository.GenericMove(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"generic-parent": {
		Doc:   "repository.GenericParent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "generic-parent")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "generic-parent")
			}
			res0, res1 := repository.GenericParent(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"grid-icon": {
		Doc:   "theme.GridIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.GridIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"grid-layout": {
		Doc:   "layout.NewGridLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "grid-layout")
			}
			res0 := layout.NewGridLayout(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"grid-layout-with-columns": {
		Doc:   "layout.NewGridLayoutWithColumns",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "grid-layout-with-columns")
			}
			res0 := layout.NewGridLayoutWithColumns(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"grid-layout-with-rows": {
		Doc:   "layout.NewGridLayoutWithRows",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "grid-layout-with-rows")
			}
			res0 := layout.NewGridLayoutWithRows(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"grid-with-columns": {
		Doc:   "container.NewGridWithColumns",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "grid-with-columns")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-columns")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-columns")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-columns")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-columns")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-columns")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-columns")
			}
			res0 := container.NewGridWithColumns(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"grid-with-rows": {
		Doc:   "container.NewGridWithRows",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "grid-with-rows")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-rows")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-rows")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-rows")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-rows")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-rows")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-with-rows")
			}
			res0 := container.NewGridWithRows(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"grid-wrap": {
		Doc:   "widget.NewGridWrap",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func() int
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "grid-wrap")
				}
				arg0Val = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "grid-wrap")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "grid-wrap")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-wrap")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap")
			}
			var arg2Val func(widget.GridWrapItemID, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "grid-wrap")
				}
				arg2Val = func(arg0 widget.GridWrapItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "grid-wrap-item-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "grid-wrap")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "grid-wrap")
			}
			res0 := widget.NewGridWrap(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-grid-wrap")
			return res0Obj
		},
	},
	"grid-wrap-layout": {
		Doc:   "layout.NewGridWrapLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap-layout")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap-layout")
			}
			res0 := layout.NewGridWrapLayout(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"grid-wrap-with-data": {
		Doc:   "widget.NewGridWrapWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap-with-data")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap-with-data")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-wrap-with-data")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap-with-data")
			}
			var arg2Val func(binding.DataItem, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "grid-wrap-with-data")
				}
				arg2Val = func(arg0 binding.DataItem, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "data-item")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "grid-wrap-with-data")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "grid-wrap-with-data")
			}
			res0 := widget.NewGridWrapWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-grid-wrap")
			return res0Obj
		},
	},
	"grid-wrap//create-item!": {
		Doc:   "Set widget.GridWrap CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//create-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//create-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//create-item!")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-wrap//create-item!")
				}
				self.CreateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//create-item!")
			}
			return arg0
		},
	},
	"grid-wrap//create-item?": {
		Doc:   "Get widget.GridWrap CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//create-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//create-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "func()_(canvas-object)")
			return resObj
		},
	},
	"grid-wrap//hidden!": {
		Doc:   "Set widget.GridWrap Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "grid-wrap//hidden!")
			}
			return arg0
		},
	},
	"grid-wrap//hidden?": {
		Doc:   "Get widget.GridWrap Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"grid-wrap//length!": {
		Doc:   "Set widget.GridWrap Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//length!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//length!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//length!")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-wrap//length!")
				}
				self.Length = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//length!")
			}
			return arg0
		},
	},
	"grid-wrap//length?": {
		Doc:   "Get widget.GridWrap Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//length?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//length?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int)")
			return resObj
		},
	},
	"grid-wrap//on-selected!": {
		Doc:   "Set widget.GridWrap OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//on-selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//on-selected!")
				}
				self.OnSelected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "grid-wrap-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-wrap//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//on-selected!")
			}
			return arg0
		},
	},
	"grid-wrap//on-selected?": {
		Doc:   "Get widget.GridWrap OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//on-selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(grid-wrap-item-id)")
			return resObj
		},
	},
	"grid-wrap//on-unselected!": {
		Doc:   "Set widget.GridWrap OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//on-unselected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "grid-wrap-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-wrap//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//on-unselected!")
			}
			return arg0
		},
	},
	"grid-wrap//on-unselected?": {
		Doc:   "Get widget.GridWrap OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//on-unselected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(grid-wrap-item-id)")
			return resObj
		},
	},
	"grid-wrap//update-item!": {
		Doc:   "Set widget.GridWrap UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//update-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//update-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//update-item!")
				}
				self.UpdateItem = func(arg0 widget.GridWrapItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "grid-wrap-item-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "grid-wrap//update-item!")
				}
				self.UpdateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "grid-wrap//update-item!")
			}
			return arg0
		},
	},
	"grid-wrap//update-item?": {
		Doc:   "Get widget.GridWrap UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//update-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "grid-wrap//update-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "func(grid-wrap-item-id_canvas-object)")
			return resObj
		},
	},
	"h-box": {
		Doc:   "container.NewHBox",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "h-box")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "h-box")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "h-box")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "h-box")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "h-box")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "h-box")
			}
			res0 := container.NewHBox(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"h-box-layout": {
		Doc:   "layout.NewHBoxLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewHBoxLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"h-scroll": {
		Doc:   "container.NewHScroll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "h-scroll")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "h-scroll")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "h-scroll")
			}
			res0 := container.NewHScroll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-scroll")
			return res0Obj
		},
	},
	"h-split": {
		Doc:   "container.NewHSplit",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "h-split")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "h-split")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "h-split")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "h-split")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "h-split")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "h-split")
			}
			res0 := container.NewHSplit(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-split")
			return res0Obj
		},
	},
	"hardware-key//scan-code!": {
		Doc:   "Set fyne.HardwareKey ScanCode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hardware-key//scan-code!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hardware-key//scan-code!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScanCode = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "hardware-key//scan-code!")
			}
			return arg0
		},
	},
	"hardware-key//scan-code?": {
		Doc:   "Get fyne.HardwareKey ScanCode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hardware-key//scan-code?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hardware-key//scan-code?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.ScanCode))
			return resObj
		},
	},
	"header-background-color": {
		Doc:   "theme.HeaderBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HeaderBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"help-icon": {
		Doc:   "theme.HelpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HelpIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"hierarchical-repository//child": {
		Doc:   "repository.HierarchicalRepository.Child",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.HierarchicalRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.HierarchicalRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hierarchical-repository//child")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hierarchical-repository//child")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hierarchical-repository//child")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hierarchical-repository//child")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hierarchical-repository//child")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "hierarchical-repository//child")
			}
			res0, res1 := arg0Val.Child(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"hierarchical-repository//parent": {
		Doc:   "repository.HierarchicalRepository.Parent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.HierarchicalRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.HierarchicalRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hierarchical-repository//parent")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hierarchical-repository//parent")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hierarchical-repository//parent")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hierarchical-repository//parent")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hierarchical-repository//parent")
			}
			res0, res1 := arg0Val.Parent(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"history-icon": {
		Doc:   "theme.HistoryIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HistoryIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"home-icon": {
		Doc:   "theme.HomeIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HomeIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"horizontal-gradient": {
		Doc:   "canvas.NewHorizontalGradient",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "horizontal-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "horizontal-gradient")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "horizontal-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "horizontal-gradient")
			}
			res0 := canvas.NewHorizontalGradient(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-linear-gradient")
			return res0Obj
		},
	},
	"hover-color": {
		Doc:   "theme.HoverColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HoverColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"hoverable//mouse-in": {
		Doc:   "desktop.Hoverable.MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Hoverable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Hoverable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hoverable//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hoverable//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hoverable//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hoverable//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hoverable//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hoverable//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"hoverable//mouse-moved": {
		Doc:   "desktop.Hoverable.MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Hoverable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Hoverable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hoverable//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hoverable//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hoverable//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hoverable//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hoverable//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hoverable//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"hoverable//mouse-out": {
		Doc:   "desktop.Hoverable.MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Hoverable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Hoverable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hoverable//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hoverable//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hoverable//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"hyperlink": {
		Doc:   "widget.NewHyperlink",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "hyperlink")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink")
			}
			res0 := widget.NewHyperlink(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-hyperlink")
			return res0Obj
		},
	},
	"hyperlink-color": {
		Doc:   "theme.HyperlinkColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HyperlinkColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"hyperlink-segment//alignment!": {
		Doc:   "Set widget.HyperlinkSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink-segment//alignment!")
			}
			return arg0
		},
	},
	"hyperlink-segment//alignment?": {
		Doc:   "Get widget.HyperlinkSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"hyperlink-segment//on-tapped!": {
		Doc:   "Set widget.HyperlinkSegment OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//on-tapped!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "hyperlink-segment//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "hyperlink-segment//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "hyperlink-segment//on-tapped!")
			}
			return arg0
		},
	},
	"hyperlink-segment//on-tapped?": {
		Doc:   "Get widget.HyperlinkSegment OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//on-tapped?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"hyperlink-segment//text!": {
		Doc:   "Set widget.HyperlinkSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "hyperlink-segment//text!")
			}
			return arg0
		},
	},
	"hyperlink-segment//text?": {
		Doc:   "Get widget.HyperlinkSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"hyperlink-segment//url!": {
		Doc:   "Set widget.HyperlinkSegment URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//url!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//url!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink-segment//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink-segment//url!")
				}
				self.URL = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink-segment//url!")
			}
			return arg0
		},
	},
	"hyperlink-segment//url?": {
		Doc:   "Get widget.HyperlinkSegment URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//url?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink-segment//url?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "ptr-url")
			return resObj
		},
	},
	"hyperlink-with-style": {
		Doc:   "widget.NewHyperlinkWithStyle",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "hyperlink-with-style")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink-with-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink-with-style")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink-with-style")
			}
			var arg2Val fyne.TextAlign
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "hyperlink-with-style")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "hyperlink-with-style")
			}
			var arg3Val fyne.TextStyle
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "hyperlink-with-style")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "hyperlink-with-style")
			}
			res0 := widget.NewHyperlinkWithStyle(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-hyperlink")
			return res0Obj
		},
	},
	"hyperlink//alignment!": {
		Doc:   "Set widget.Hyperlink Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink//alignment!")
			}
			return arg0
		},
	},
	"hyperlink//alignment?": {
		Doc:   "Get widget.Hyperlink Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"hyperlink//hidden!": {
		Doc:   "Set widget.Hyperlink Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "hyperlink//hidden!")
			}
			return arg0
		},
	},
	"hyperlink//hidden?": {
		Doc:   "Get widget.Hyperlink Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"hyperlink//on-tapped!": {
		Doc:   "Set widget.Hyperlink OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//on-tapped!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "hyperlink//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "hyperlink//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "hyperlink//on-tapped!")
			}
			return arg0
		},
	},
	"hyperlink//on-tapped?": {
		Doc:   "Get widget.Hyperlink OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//on-tapped?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"hyperlink//text!": {
		Doc:   "Set widget.Hyperlink Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "hyperlink//text!")
			}
			return arg0
		},
	},
	"hyperlink//text-style!": {
		Doc:   "Set widget.Hyperlink TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink//text-style!")
			}
			return arg0
		},
	},
	"hyperlink//text-style?": {
		Doc:   "Get widget.Hyperlink TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"hyperlink//text?": {
		Doc:   "Get widget.Hyperlink Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"hyperlink//url!": {
		Doc:   "Set widget.Hyperlink URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//url!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//url!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink//url!")
				}
				self.URL = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink//url!")
			}
			return arg0
		},
	},
	"hyperlink//url?": {
		Doc:   "Get widget.Hyperlink URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//url?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//url?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "ptr-url")
			return resObj
		},
	},
	"hyperlink//wrapping!": {
		Doc:   "Set widget.Hyperlink Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "hyperlink//wrapping!")
			}
			return arg0
		},
	},
	"hyperlink//wrapping?": {
		Doc:   "Get widget.Hyperlink Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//wrapping?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "hyperlink//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"icon": {
		Doc:   "widget.NewIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon")
			}
			res0 := widget.NewIcon(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-icon")
			return res0Obj
		},
	},
	"icon-inline-size": {
		Doc:   "theme.IconInlineSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.IconInlineSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"icon//hidden!": {
		Doc:   "Set widget.Icon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "icon//hidden!")
			}
			return arg0
		},
	},
	"icon//hidden?": {
		Doc:   "Get widget.Icon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"icon//resource!": {
		Doc:   "Set widget.Icon Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon//resource!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon//resource!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "icon//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "icon//resource!")
				}
				self.Resource = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "icon//resource!")
			}
			return arg0
		},
	},
	"icon//resource?": {
		Doc:   "Get widget.Icon Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon//resource?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "icon//resource?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Resource, "resource")
			return resObj
		},
	},
	"image-from-file": {
		Doc:   "canvas.NewImageFromFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "image-from-file")
			}
			res0 := canvas.NewImageFromFile(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image")
			return res0Obj
		},
	},
	"image-from-image": {
		Doc:   "canvas.NewImageFromImage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-from-image")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-from-image")
			}
			res0 := canvas.NewImageFromImage(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image")
			return res0Obj
		},
	},
	"image-from-reader": {
		Doc:   "canvas.NewImageFromReader",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-from-reader")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-from-reader")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "image-from-reader")
			}
			res0 := canvas.NewImageFromReader(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image")
			return res0Obj
		},
	},
	"image-from-resource": {
		Doc:   "canvas.NewImageFromResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-from-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-from-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-from-resource")
			}
			res0 := canvas.NewImageFromResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image")
			return res0Obj
		},
	},
	"image-from-uri": {
		Doc:   "canvas.NewImageFromURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-from-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-from-uri")
			}
			res0 := canvas.NewImageFromURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-image")
			return res0Obj
		},
	},
	"image-segment//alignment!": {
		Doc:   "Set widget.ImageSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image-segment//alignment!")
			}
			return arg0
		},
	},
	"image-segment//alignment?": {
		Doc:   "Get widget.ImageSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"image-segment//source!": {
		Doc:   "Set widget.ImageSegment Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//source!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//source!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image-segment//source!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image-segment//source!")
			}
			return arg0
		},
	},
	"image-segment//source?": {
		Doc:   "Get widget.ImageSegment Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//source?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//source?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "uri")
			return resObj
		},
	},
	"image-segment//title!": {
		Doc:   "Set widget.ImageSegment Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//title!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "image-segment//title!")
			}
			return arg0
		},
	},
	"image-segment//title?": {
		Doc:   "Get widget.ImageSegment Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//title?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image-segment//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"image//file!": {
		Doc:   "Set canvas.Image File value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//file!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//file!")
			}
			if v, ok := arg1.(env.String); ok {
				self.File = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "image//file!")
			}
			return arg0
		},
	},
	"image//file?": {
		Doc:   "Get canvas.Image File value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//file?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//file?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.File)
			return resObj
		},
	},
	"image//fill-mode!": {
		Doc:   "Set canvas.Image FillMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//fill-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//fill-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillMode, ok = v.Value.(canvas.ImageFill)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image//fill-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image//fill-mode!")
			}
			return arg0
		},
	},
	"image//fill-mode?": {
		Doc:   "Get canvas.Image FillMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//fill-mode?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//fill-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillMode, "image-fill")
			return resObj
		},
	},
	"image//image!": {
		Doc:   "Set canvas.Image Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//image!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//image!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(image.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image//image!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image//image!")
			}
			return arg0
		},
	},
	"image//image?": {
		Doc:   "Get canvas.Image Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//image?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//image?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "image")
			return resObj
		},
	},
	"image//resource!": {
		Doc:   "Set canvas.Image Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//resource!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//resource!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image//resource!")
				}
				self.Resource = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image//resource!")
			}
			return arg0
		},
	},
	"image//resource?": {
		Doc:   "Get canvas.Image Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//resource?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//resource?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Resource, "resource")
			return resObj
		},
	},
	"image//scale-mode!": {
		Doc:   "Set canvas.Image ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//scale-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ScaleMode, ok = v.Value.(canvas.ImageScale)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "image//scale-mode!")
			}
			return arg0
		},
	},
	"image//scale-mode?": {
		Doc:   "Get canvas.Image ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//scale-mode?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//scale-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ScaleMode, "image-scale")
			return resObj
		},
	},
	"image//translucency!": {
		Doc:   "Set canvas.Image Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//translucency!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//translucency!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "image//translucency!")
			}
			return arg0
		},
	},
	"image//translucency?": {
		Doc:   "Get canvas.Image Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//translucency?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "image//translucency?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"info-icon": {
		Doc:   "theme.InfoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InfoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"information": {
		Doc:   "dialog.NewInformation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "information")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "information")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "information")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "information")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "information")
			}
			res0 := dialog.NewInformation(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog")
			return res0Obj
		},
	},
	"inner-padding": {
		Doc:   "theme.InnerPadding",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InnerPadding()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"input-background-color": {
		Doc:   "theme.InputBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"input-border-color": {
		Doc:   "theme.InputBorderColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputBorderColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"input-border-size": {
		Doc:   "theme.InputBorderSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputBorderSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"input-radius-size": {
		Doc:   "theme.InputRadiusSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputRadiusSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"int": {
		Doc:   "binding.NewInt",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewInt()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "int")
			return res0Obj
		},
	},
	"int-list": {
		Doc:   "binding.NewIntList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewIntList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "int-list")
			return res0Obj
		},
	},
	"int-list//append": {
		Doc:   "binding.IntList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//append")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "int-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"int-list//get": {
		Doc:   "binding.IntList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"int-list//get-value": {
		Doc:   "binding.IntList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "int-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"int-list//prepend": {
		Doc:   "binding.IntList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//prepend")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "int-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"int-list//set": {
		Doc:   "binding.IntList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//set")
			}
			var arg1Val []int
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg1Val[i] = int(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "int-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]int)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "int-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "int-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "int-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"int-list//set-value": {
		Doc:   "binding.IntList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "int-list//set-value")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "int-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"int-to-string": {
		Doc:   "binding.IntToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-to-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-to-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-to-string")
			}
			res0 := binding.IntToString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"int-to-string-with-format": {
		Doc:   "binding.IntToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-to-string-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-to-string-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-to-string-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "int-to-string-with-format")
			}
			res0 := binding.IntToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"int-tree": {
		Doc:   "binding.NewIntTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewIntTree()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "int-tree")
			return res0Obj
		},
	},
	"int-tree//append": {
		Doc:   "binding.IntTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "int-tree//append")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "int-tree//append")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.IntegerType}, "int-tree//append")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"int-tree//get": {
		Doc:   "binding.IntTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//get")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewInteger(int64(mVal))
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"int-tree//get-value": {
		Doc:   "binding.IntTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//get-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "int-tree//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"int-tree//prepend": {
		Doc:   "binding.IntTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "int-tree//prepend")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "int-tree//prepend")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.IntegerType}, "int-tree//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"int-tree//set": {
		Doc:   "binding.IntTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//set")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
			}
			var arg2Val map[string]int
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
				}
				arg2Val = make(map[string]int, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
					}
					var mapV int
					if v, ok := v.Series.S[i+1].(env.Integer); ok {
						mapV = int(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]int, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV int
					if v, ok := dictV.(env.Integer); ok {
						mapV = int(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]int)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "int-tree//set")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"int-tree//set-value": {
		Doc:   "binding.IntTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int-tree//set-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "int-tree//set-value")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "int-tree//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"int//get": {
		Doc:   "binding.Int.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"int//set": {
		Doc:   "binding.Int.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "int//set")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "int//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"inverted-themed-resource": {
		Doc:   "theme.NewInvertedThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "inverted-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "inverted-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "inverted-themed-resource")
			}
			res0 := theme.NewInvertedThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-inverted-themed-resource")
			return res0Obj
		},
	},
	"is-horizontal": {
		Doc:   "fyne.IsHorizontal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.DeviceOrientation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.DeviceOrientation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "is-horizontal")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "is-horizontal")
			}
			res0 := fyne.IsHorizontal(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"is-vertical": {
		Doc:   "fyne.IsVertical",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.DeviceOrientation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.DeviceOrientation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "is-vertical")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "is-vertical")
			}
			res0 := fyne.IsVertical(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"key-event//name!": {
		Doc:   "Set fyne.KeyEvent Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "key-event//name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "key-event//name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Name, ok = v.Value.(fyne.KeyName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "key-event//name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "key-event//name!")
			}
			return arg0
		},
	},
	"key-event//name?": {
		Doc:   "Get fyne.KeyEvent Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "key-event//name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "key-event//name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Name, "key-name")
			return resObj
		},
	},
	"key-event//physical!": {
		Doc:   "Set fyne.KeyEvent Physical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "key-event//physical!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "key-event//physical!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Physical, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "key-event//physical!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "key-event//physical!")
			}
			return arg0
		},
	},
	"key-event//physical?": {
		Doc:   "Get fyne.KeyEvent Physical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "key-event//physical?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "key-event//physical?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Physical, "hardware-key")
			return resObj
		},
	},
	"keyboard-shortcut//key": {
		Doc:   "fyne.KeyboardShortcut.Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.KeyboardShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.KeyboardShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "keyboard-shortcut//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "keyboard-shortcut//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "keyboard-shortcut//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-name")
			return res0Obj
		},
	},
	"keyboard-shortcut//mod": {
		Doc:   "fyne.KeyboardShortcut.Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.KeyboardShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.KeyboardShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "keyboard-shortcut//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "keyboard-shortcut//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "keyboard-shortcut//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-modifier")
			return res0Obj
		},
	},
	"label": {
		Doc:   "widget.NewLabel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "label")
			}
			res0 := widget.NewLabel(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-label")
			return res0Obj
		},
	},
	"label-with-data": {
		Doc:   "widget.NewLabelWithData",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label-with-data")
			}
			res0 := widget.NewLabelWithData(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-label")
			return res0Obj
		},
	},
	"label-with-style": {
		Doc:   "widget.NewLabelWithStyle",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "label-with-style")
			}
			var arg1Val fyne.TextAlign
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label-with-style")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label-with-style")
			}
			var arg2Val fyne.TextStyle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "label-with-style")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "label-with-style")
			}
			res0 := widget.NewLabelWithStyle(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-label")
			return res0Obj
		},
	},
	"label//alignment!": {
		Doc:   "Set widget.Label Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//alignment!")
			}
			return arg0
		},
	},
	"label//alignment?": {
		Doc:   "Get widget.Label Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"label//hidden!": {
		Doc:   "Set widget.Label Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "label//hidden!")
			}
			return arg0
		},
	},
	"label//hidden?": {
		Doc:   "Get widget.Label Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"label//importance!": {
		Doc:   "Set widget.Label Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//importance!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Importance, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//importance!")
			}
			return arg0
		},
	},
	"label//importance?": {
		Doc:   "Get widget.Label Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//importance?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//importance?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Importance, "importance")
			return resObj
		},
	},
	"label//text!": {
		Doc:   "Set widget.Label Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "label//text!")
			}
			return arg0
		},
	},
	"label//text-style!": {
		Doc:   "Set widget.Label TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//text-style!")
			}
			return arg0
		},
	},
	"label//text-style?": {
		Doc:   "Get widget.Label TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"label//text?": {
		Doc:   "Get widget.Label Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"label//truncation!": {
		Doc:   "Set widget.Label Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//truncation!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//truncation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Truncation, ok = v.Value.(fyne.TextTruncation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//truncation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//truncation!")
			}
			return arg0
		},
	},
	"label//truncation?": {
		Doc:   "Get widget.Label Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//truncation?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//truncation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Truncation, "text-truncation")
			return resObj
		},
	},
	"label//wrapping!": {
		Doc:   "Set widget.Label Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "label//wrapping!")
			}
			return arg0
		},
	},
	"label//wrapping?": {
		Doc:   "Get widget.Label Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//wrapping?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "label//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"layout//layout": {
		Doc:   "fyne.Layout.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout//layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout//layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout//layout")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//layout")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//layout")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//layout")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//layout")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//layout")
			}
			var arg2Val fyne.Size
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "layout//layout")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "layout//layout")
			}
			arg0Val.Layout(arg1Val, arg2Val)
			return arg0
		},
	},
	"layout//min-size": {
		Doc:   "fyne.Layout.MinSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout//min-size")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//min-size")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//min-size")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//min-size")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//min-size")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "layout//min-size")
			}
			res0 := arg0Val.MinSize(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"legacy-theme//background-color": {
		Doc:   "fyne.LegacyTheme.BackgroundColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//background-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//background-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//background-color")
			}
			res0 := arg0Val.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//button-color": {
		Doc:   "fyne.LegacyTheme.ButtonColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//button-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//button-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//button-color")
			}
			res0 := arg0Val.ButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//disabled-button-color": {
		Doc:   "fyne.LegacyTheme.DisabledButtonColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//disabled-button-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//disabled-button-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//disabled-button-color")
			}
			res0 := arg0Val.DisabledButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//disabled-text-color": {
		Doc:   "fyne.LegacyTheme.DisabledTextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//disabled-text-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//disabled-text-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//disabled-text-color")
			}
			res0 := arg0Val.DisabledTextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//focus-color": {
		Doc:   "fyne.LegacyTheme.FocusColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//focus-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//focus-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//focus-color")
			}
			res0 := arg0Val.FocusColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//hover-color": {
		Doc:   "fyne.LegacyTheme.HoverColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//hover-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//hover-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//hover-color")
			}
			res0 := arg0Val.HoverColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//icon-inline-size": {
		Doc:   "fyne.LegacyTheme.IconInlineSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//icon-inline-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//icon-inline-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//icon-inline-size")
			}
			res0 := arg0Val.IconInlineSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"legacy-theme//padding": {
		Doc:   "fyne.LegacyTheme.Padding",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//padding")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//padding")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//padding")
			}
			res0 := arg0Val.Padding()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"legacy-theme//place-holder-color": {
		Doc:   "fyne.LegacyTheme.PlaceHolderColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//place-holder-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//place-holder-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//place-holder-color")
			}
			res0 := arg0Val.PlaceHolderColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//primary-color": {
		Doc:   "fyne.LegacyTheme.PrimaryColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//primary-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//primary-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//primary-color")
			}
			res0 := arg0Val.PrimaryColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//scroll-bar-color": {
		Doc:   "fyne.LegacyTheme.ScrollBarColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//scroll-bar-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//scroll-bar-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//scroll-bar-color")
			}
			res0 := arg0Val.ScrollBarColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//scroll-bar-size": {
		Doc:   "fyne.LegacyTheme.ScrollBarSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//scroll-bar-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//scroll-bar-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//scroll-bar-size")
			}
			res0 := arg0Val.ScrollBarSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"legacy-theme//scroll-bar-small-size": {
		Doc:   "fyne.LegacyTheme.ScrollBarSmallSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//scroll-bar-small-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//scroll-bar-small-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//scroll-bar-small-size")
			}
			res0 := arg0Val.ScrollBarSmallSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"legacy-theme//shadow-color": {
		Doc:   "fyne.LegacyTheme.ShadowColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//shadow-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//shadow-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//shadow-color")
			}
			res0 := arg0Val.ShadowColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//text-bold-font": {
		Doc:   "fyne.LegacyTheme.TextBoldFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-bold-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-bold-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-bold-font")
			}
			res0 := arg0Val.TextBoldFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"legacy-theme//text-bold-italic-font": {
		Doc:   "fyne.LegacyTheme.TextBoldItalicFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-bold-italic-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-bold-italic-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-bold-italic-font")
			}
			res0 := arg0Val.TextBoldItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"legacy-theme//text-color": {
		Doc:   "fyne.LegacyTheme.TextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-color")
			}
			res0 := arg0Val.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"legacy-theme//text-font": {
		Doc:   "fyne.LegacyTheme.TextFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-font")
			}
			res0 := arg0Val.TextFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"legacy-theme//text-italic-font": {
		Doc:   "fyne.LegacyTheme.TextItalicFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-italic-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-italic-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-italic-font")
			}
			res0 := arg0Val.TextItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"legacy-theme//text-monospace-font": {
		Doc:   "fyne.LegacyTheme.TextMonospaceFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-monospace-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-monospace-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-monospace-font")
			}
			res0 := arg0Val.TextMonospaceFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"legacy-theme//text-size": {
		Doc:   "fyne.LegacyTheme.TextSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "legacy-theme//text-size")
			}
			res0 := arg0Val.TextSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"lifecycle//set-on-entered-foreground": {
		Doc:   "fyne.Lifecycle.SetOnEnteredForeground",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Lifecycle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Lifecycle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-entered-foreground")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-entered-foreground")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-entered-foreground")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "lifecycle//set-on-entered-foreground")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "lifecycle//set-on-entered-foreground")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "lifecycle//set-on-entered-foreground")
			}
			arg0Val.SetOnEnteredForeground(arg1Val)
			return arg0
		},
	},
	"lifecycle//set-on-exited-foreground": {
		Doc:   "fyne.Lifecycle.SetOnExitedForeground",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Lifecycle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Lifecycle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-exited-foreground")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-exited-foreground")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-exited-foreground")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "lifecycle//set-on-exited-foreground")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "lifecycle//set-on-exited-foreground")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "lifecycle//set-on-exited-foreground")
			}
			arg0Val.SetOnExitedForeground(arg1Val)
			return arg0
		},
	},
	"lifecycle//set-on-started": {
		Doc:   "fyne.Lifecycle.SetOnStarted",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Lifecycle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Lifecycle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-started")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-started")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-started")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "lifecycle//set-on-started")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "lifecycle//set-on-started")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "lifecycle//set-on-started")
			}
			arg0Val.SetOnStarted(arg1Val)
			return arg0
		},
	},
	"lifecycle//set-on-stopped": {
		Doc:   "fyne.Lifecycle.SetOnStopped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Lifecycle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Lifecycle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-stopped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-stopped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lifecycle//set-on-stopped")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "lifecycle//set-on-stopped")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "lifecycle//set-on-stopped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "lifecycle//set-on-stopped")
			}
			arg0Val.SetOnStopped(arg1Val)
			return arg0
		},
	},
	"light-theme": {
		Doc:   "theme.LightTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LightTheme()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme")
			return res0Obj
		},
	},
	"line": {
		Doc:   "canvas.NewLine",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line")
			}
			res0 := canvas.NewLine(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-line")
			return res0Obj
		},
	},
	"line-spacing": {
		Doc:   "theme.LineSpacing",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LineSpacing()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"line//hidden!": {
		Doc:   "Set canvas.Line Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "line//hidden!")
			}
			return arg0
		},
	},
	"line//hidden?": {
		Doc:   "Get canvas.Line Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"line//position-1!": {
		Doc:   "Set canvas.Line Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//position-1!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "line//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "line//position-1!")
			}
			return arg0
		},
	},
	"line//position-1?": {
		Doc:   "Get canvas.Line Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//position-1?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//position-1?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "position")
			return resObj
		},
	},
	"line//position-2!": {
		Doc:   "Set canvas.Line Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//position-2!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "line//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "line//position-2!")
			}
			return arg0
		},
	},
	"line//position-2?": {
		Doc:   "Get canvas.Line Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//position-2?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//position-2?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "position")
			return resObj
		},
	},
	"line//stroke-color!": {
		Doc:   "Set canvas.Line StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "line//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "line//stroke-color!")
			}
			return arg0
		},
	},
	"line//stroke-color?": {
		Doc:   "Get canvas.Line StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//stroke-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color")
			return resObj
		},
	},
	"line//stroke-width!": {
		Doc:   "Set canvas.Line StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//stroke-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "line//stroke-width!")
			}
			return arg0
		},
	},
	"line//stroke-width?": {
		Doc:   "Get canvas.Line StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//stroke-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "line//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"linear-gradient": {
		Doc:   "canvas.NewLinearGradient",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "linear-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "linear-gradient")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "linear-gradient")
			}
			res0 := canvas.NewLinearGradient(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-linear-gradient")
			return res0Obj
		},
	},
	"linear-gradient//angle!": {
		Doc:   "Set canvas.LinearGradient Angle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//angle!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//angle!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Angle = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "linear-gradient//angle!")
			}
			return arg0
		},
	},
	"linear-gradient//angle?": {
		Doc:   "Get canvas.LinearGradient Angle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//angle?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//angle?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Angle))
			return resObj
		},
	},
	"linear-gradient//end-color!": {
		Doc:   "Set canvas.LinearGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//end-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "linear-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "linear-gradient//end-color!")
			}
			return arg0
		},
	},
	"linear-gradient//end-color?": {
		Doc:   "Get canvas.LinearGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//end-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//end-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color")
			return resObj
		},
	},
	"linear-gradient//start-color!": {
		Doc:   "Set canvas.LinearGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//start-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "linear-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "linear-gradient//start-color!")
			}
			return arg0
		},
	},
	"linear-gradient//start-color?": {
		Doc:   "Get canvas.LinearGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//start-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "linear-gradient//start-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color")
			return resObj
		},
	},
	"list": {
		Doc:   "storage.List",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list")
			}
			res0, res1 := storage.List(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "uri")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"list-icon": {
		Doc:   "theme.ListIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ListIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"list-segment//items!": {
		Doc:   "Set widget.ListSegment Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-segment//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-segment//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list-segment//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list-segment//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list-segment//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list-segment//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list-segment//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list-segment//items!")
			}
			return arg0
		},
	},
	"list-segment//items?": {
		Doc:   "Get widget.ListSegment Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-segment//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-segment//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "rich-text-segment")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"list-segment//ordered!": {
		Doc:   "Set widget.ListSegment Ordered value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-segment//ordered!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-segment//ordered!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Ordered = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "list-segment//ordered!")
			}
			return arg0
		},
	},
	"list-segment//ordered?": {
		Doc:   "Get widget.ListSegment Ordered value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-segment//ordered?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-segment//ordered?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Ordered))
			return resObj
		},
	},
	"list-with-data": {
		Doc:   "widget.NewListWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list-with-data")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list-with-data")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list-with-data")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list-with-data")
			}
			var arg2Val func(binding.DataItem, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "list-with-data")
				}
				arg2Val = func(arg0 binding.DataItem, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "data-item")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "list-with-data")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "list-with-data")
			}
			res0 := widget.NewListWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-list")
			return res0Obj
		},
	},
	"list//create-item!": {
		Doc:   "Set widget.List CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//create-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//create-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//create-item!")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list//create-item!")
				}
				self.CreateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//create-item!")
			}
			return arg0
		},
	},
	"list//create-item?": {
		Doc:   "Get widget.List CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//create-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//create-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "func()_(canvas-object)")
			return resObj
		},
	},
	"list//hidden!": {
		Doc:   "Set widget.List Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "list//hidden!")
			}
			return arg0
		},
	},
	"list//hidden?": {
		Doc:   "Get widget.List Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"list//length!": {
		Doc:   "Set widget.List Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//length!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//length!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//length!")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list//length!")
				}
				self.Length = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//length!")
			}
			return arg0
		},
	},
	"list//length?": {
		Doc:   "Get widget.List Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//length?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//length?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int)")
			return resObj
		},
	},
	"list//on-selected!": {
		Doc:   "Set widget.List OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//on-selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//on-selected!")
				}
				self.OnSelected = func(arg0 widget.ListItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "list-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//on-selected!")
			}
			return arg0
		},
	},
	"list//on-selected?": {
		Doc:   "Get widget.List OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//on-selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(list-item-id)")
			return resObj
		},
	},
	"list//on-unselected!": {
		Doc:   "Set widget.List OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//on-unselected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.ListItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "list-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//on-unselected!")
			}
			return arg0
		},
	},
	"list//on-unselected?": {
		Doc:   "Get widget.List OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//on-unselected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(list-item-id)")
			return resObj
		},
	},
	"list//update-item!": {
		Doc:   "Set widget.List UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//update-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//update-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//update-item!")
				}
				self.UpdateItem = func(arg0 widget.ListItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "list-item-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "list//update-item!")
				}
				self.UpdateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "list//update-item!")
			}
			return arg0
		},
	},
	"list//update-item?": {
		Doc:   "Get widget.List UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//update-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "list//update-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "func(list-item-id_canvas-object)")
			return resObj
		},
	},
	"listable-repository//can-list": {
		Doc:   "repository.ListableRepository.CanList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.ListableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.ListableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "listable-repository//can-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "listable-repository//can-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "listable-repository//can-list")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "listable-repository//can-list")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "listable-repository//can-list")
			}
			res0, res1 := arg0Val.CanList(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"listable-repository//create-listable": {
		Doc:   "repository.ListableRepository.CreateListable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.ListableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.ListableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "listable-repository//create-listable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "listable-repository//create-listable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "listable-repository//create-listable")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "listable-repository//create-listable")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "listable-repository//create-listable")
			}
			res0 := arg0Val.CreateListable(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"listable-repository//list": {
		Doc:   "repository.ListableRepository.List",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.ListableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.ListableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "listable-repository//list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "listable-repository//list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "listable-repository//list")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "listable-repository//list")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "listable-repository//list")
			}
			res0, res1 := arg0Val.List(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "uri")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"lister-for-uri": {
		Doc:   "storage.ListerForURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lister-for-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "lister-for-uri")
			}
			res0, res1 := storage.ListerForURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "listable-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"load-resource-from-path": {
		Doc:   "fyne.LoadResourceFromPath",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "load-resource-from-path")
			}
			res0, res1 := fyne.LoadResourceFromPath(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"load-resource-from-uri": {
		Doc:   "storage.LoadResourceFromURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "load-resource-from-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "load-resource-from-uri")
			}
			res0, res1 := storage.LoadResourceFromURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"load-resource-from-url-string": {
		Doc:   "fyne.LoadResourceFromURLString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "load-resource-from-url-string")
			}
			res0, res1 := fyne.LoadResourceFromURLString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"log-error": {
		Doc:   "fyne.LogError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "log-error")
			}
			var arg1Val error
			if v, ok := arg1.(env.Error); ok {
				arg1Val = errors.New(v.Print(*ps.Idx))
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.ErrorType}, "log-error")
			}
			fyne.LogError(arg0Val, arg1Val)
			return nil
		},
	},
	"login-icon": {
		Doc:   "theme.LoginIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LoginIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"logout-icon": {
		Doc:   "theme.LogoutIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LogoutIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"mail-attachment-icon": {
		Doc:   "theme.MailAttachmentIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailAttachmentIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"mail-compose-icon": {
		Doc:   "theme.MailComposeIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailComposeIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"mail-forward-icon": {
		Doc:   "theme.MailForwardIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailForwardIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"mail-reply-all-icon": {
		Doc:   "theme.MailReplyAllIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailReplyAllIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"mail-reply-icon": {
		Doc:   "theme.MailReplyIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailReplyIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"mail-send-icon": {
		Doc:   "theme.MailSendIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailSendIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"main-menu": {
		Doc:   "fyne.NewMainMenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*fyne.Menu
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*fyne.Menu, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*fyne.Menu)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "main-menu")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "main-menu")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "main-menu")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "main-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "main-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "main-menu")
			}
			res0 := fyne.NewMainMenu(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-main-menu")
			return res0Obj
		},
	},
	"main-menu//items!": {
		Doc:   "Set fyne.MainMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "main-menu//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "main-menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.Menu, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.Menu)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "main-menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "main-menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "main-menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "main-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "main-menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "main-menu//items!")
			}
			return arg0
		},
	},
	"main-menu//items?": {
		Doc:   "Get fyne.MainMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "main-menu//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "main-menu//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-menu")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"max": {
		Doc:   "container.NewMax",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "max")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "max")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "max")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "max")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "max")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "max")
			}
			res0 := container.NewMax(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"max-layout": {
		Doc:   "layout.NewMaxLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewMaxLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"measure-text": {
		Doc:   "fyne.MeasureText",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "measure-text")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "measure-text")
			}
			var arg2Val fyne.TextStyle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "measure-text")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "measure-text")
			}
			res0 := fyne.MeasureText(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"media-fast-forward-icon": {
		Doc:   "theme.MediaFastForwardIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaFastForwardIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-fast-rewind-icon": {
		Doc:   "theme.MediaFastRewindIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaFastRewindIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-music-icon": {
		Doc:   "theme.MediaMusicIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaMusicIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-pause-icon": {
		Doc:   "theme.MediaPauseIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaPauseIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-photo-icon": {
		Doc:   "theme.MediaPhotoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaPhotoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-play-icon": {
		Doc:   "theme.MediaPlayIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaPlayIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-record-icon": {
		Doc:   "theme.MediaRecordIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaRecordIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-replay-icon": {
		Doc:   "theme.MediaReplayIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaReplayIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-skip-next-icon": {
		Doc:   "theme.MediaSkipNextIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaSkipNextIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-skip-previous-icon": {
		Doc:   "theme.MediaSkipPreviousIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaSkipPreviousIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-stop-icon": {
		Doc:   "theme.MediaStopIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaStopIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"media-video-icon": {
		Doc:   "theme.MediaVideoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaVideoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"menu": {
		Doc:   "fyne.NewMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "menu")
			}
			var arg1Val []*fyne.MenuItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]*fyne.MenuItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(*fyne.MenuItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu")
			}
			res0 := fyne.NewMenu(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-menu")
			return res0Obj
		},
	},
	"menu-background-color": {
		Doc:   "theme.MenuBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"menu-drop-down-icon": {
		Doc:   "theme.MenuDropDownIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuDropDownIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"menu-drop-up-icon": {
		Doc:   "theme.MenuDropUpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuDropUpIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"menu-expand-icon": {
		Doc:   "theme.MenuExpandIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuExpandIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"menu-icon": {
		Doc:   "theme.MenuIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"menu-item": {
		Doc:   "fyne.NewMenuItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "menu-item")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "menu-item")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "menu-item")
			}
			res0 := fyne.NewMenuItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-menu-item")
			return res0Obj
		},
	},
	"menu-item-separator": {
		Doc:   "fyne.NewMenuItemSeparator",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := fyne.NewMenuItemSeparator()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-menu-item")
			return res0Obj
		},
	},
	"menu-item//action!": {
		Doc:   "Set fyne.MenuItem Action value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//action!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//action!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "menu-item//action!")
				}
				self.Action = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu-item//action!")
				}
				self.Action = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "menu-item//action!")
			}
			return arg0
		},
	},
	"menu-item//action?": {
		Doc:   "Get fyne.MenuItem Action value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//action?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//action?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Action, "func()")
			return resObj
		},
	},
	"menu-item//checked!": {
		Doc:   "Set fyne.MenuItem Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//checked!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//checked!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "menu-item//checked!")
			}
			return arg0
		},
	},
	"menu-item//checked?": {
		Doc:   "Get fyne.MenuItem Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//checked?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//checked?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"menu-item//child-menu!": {
		Doc:   "Set fyne.MenuItem ChildMenu value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//child-menu!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//child-menu!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ChildMenu, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "menu-item//child-menu!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "menu-item//child-menu!")
				}
				self.ChildMenu = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "menu-item//child-menu!")
			}
			return arg0
		},
	},
	"menu-item//child-menu?": {
		Doc:   "Get fyne.MenuItem ChildMenu value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//child-menu?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//child-menu?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildMenu, "ptr-menu")
			return resObj
		},
	},
	"menu-item//disabled!": {
		Doc:   "Set fyne.MenuItem Disabled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//disabled!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//disabled!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Disabled = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "menu-item//disabled!")
			}
			return arg0
		},
	},
	"menu-item//disabled?": {
		Doc:   "Get fyne.MenuItem Disabled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//disabled?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//disabled?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Disabled))
			return resObj
		},
	},
	"menu-item//icon!": {
		Doc:   "Set fyne.MenuItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//icon!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "menu-item//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "menu-item//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "menu-item//icon!")
			}
			return arg0
		},
	},
	"menu-item//icon?": {
		Doc:   "Get fyne.MenuItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//icon?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"menu-item//is-quit!": {
		Doc:   "Set fyne.MenuItem IsQuit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//is-quit!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//is-quit!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsQuit = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "menu-item//is-quit!")
			}
			return arg0
		},
	},
	"menu-item//is-quit?": {
		Doc:   "Get fyne.MenuItem IsQuit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//is-quit?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//is-quit?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsQuit))
			return resObj
		},
	},
	"menu-item//is-separator!": {
		Doc:   "Set fyne.MenuItem IsSeparator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//is-separator!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//is-separator!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsSeparator = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "menu-item//is-separator!")
			}
			return arg0
		},
	},
	"menu-item//is-separator?": {
		Doc:   "Get fyne.MenuItem IsSeparator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//is-separator?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//is-separator?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsSeparator))
			return resObj
		},
	},
	"menu-item//label!": {
		Doc:   "Set fyne.MenuItem Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//label!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//label!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "menu-item//label!")
			}
			return arg0
		},
	},
	"menu-item//label?": {
		Doc:   "Get fyne.MenuItem Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//label?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//label?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"menu-item//shortcut!": {
		Doc:   "Set fyne.MenuItem Shortcut value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//shortcut!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//shortcut!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Shortcut, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "menu-item//shortcut!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "menu-item//shortcut!")
				}
				self.Shortcut = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "menu-item//shortcut!")
			}
			return arg0
		},
	},
	"menu-item//shortcut?": {
		Doc:   "Get fyne.MenuItem Shortcut value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//shortcut?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu-item//shortcut?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Shortcut, "shortcut")
			return resObj
		},
	},
	"menu//hidden!": {
		Doc:   "Set widget.Menu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "menu//hidden!")
			}
			return arg0
		},
	},
	"menu//hidden?": {
		Doc:   "Get widget.Menu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"menu//items!": {
		Doc:   "Set fyne.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.MenuItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.MenuItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu//items!")
			}
			return arg0
		},
	},
	"menu//items?": {
		Doc:   "Get fyne.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-menu-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"menu//label!": {
		Doc:   "Set fyne.Menu Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//label!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//label!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "menu//label!")
			}
			return arg0
		},
	},
	"menu//label?": {
		Doc:   "Get fyne.Menu Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//label?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//label?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"menu//on-dismiss!": {
		Doc:   "Set widget.Menu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//on-dismiss!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//on-dismiss!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "menu//on-dismiss!")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "menu//on-dismiss!")
				}
				self.OnDismiss = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "menu//on-dismiss!")
			}
			return arg0
		},
	},
	"menu//on-dismiss?": {
		Doc:   "Get widget.Menu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//on-dismiss?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "menu//on-dismiss?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "func()")
			return resObj
		},
	},
	"mime-type-file-filter": {
		Doc:   "storage.NewMimeTypeFileFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "mime-type-file-filter")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "mime-type-file-filter")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "mime-type-file-filter")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "mime-type-file-filter")
			}
			res0 := storage.NewMimeTypeFileFilter(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "file-filter")
			return res0Obj
		},
	},
	"mime-type-file-filter//mime-types!": {
		Doc:   "Set storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mime-type-file-filter//mime-types!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mime-type-file-filter//mime-types!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.MimeTypes = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.MimeTypes[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "mime-type-file-filter//mime-types!")
					}
				}
			case env.Native:
				var ok bool
				self.MimeTypes, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "mime-type-file-filter//mime-types!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "mime-type-file-filter//mime-types!")
				}
				self.MimeTypes = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "mime-type-file-filter//mime-types!")
			}
			return arg0
		},
	},
	"mime-type-file-filter//mime-types?": {
		Doc:   "Get storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mime-type-file-filter//mime-types?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mime-type-file-filter//mime-types?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.MimeTypes))
				for i, it := range self.MimeTypes {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"min": {
		Doc:   "fyne.Min",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "min")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "min")
			}
			res0 := fyne.Min(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"modal-pop-up": {
		Doc:   "widget.NewModalPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "modal-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "modal-pop-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "modal-pop-up")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "modal-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "modal-pop-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "modal-pop-up")
			}
			res0 := widget.NewModalPopUp(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-pop-up")
			return res0Obj
		},
	},
	"more-horizontal-icon": {
		Doc:   "theme.MoreHorizontalIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoreHorizontalIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"more-vertical-icon": {
		Doc:   "theme.MoreVerticalIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoreVerticalIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"mouse-event//absolute-position!": {
		Doc:   "Set desktop.MouseEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouse-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouse-event//absolute-position!")
			}
			return arg0
		},
	},
	"mouse-event//absolute-position?": {
		Doc:   "Get desktop.MouseEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"mouse-event//button!": {
		Doc:   "Set desktop.MouseEvent Button value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//button!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//button!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Button, ok = v.Value.(desktop.MouseButton)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouse-event//button!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouse-event//button!")
			}
			return arg0
		},
	},
	"mouse-event//button?": {
		Doc:   "Get desktop.MouseEvent Button value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//button?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//button?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Button, "mouse-button")
			return resObj
		},
	},
	"mouse-event//modifier!": {
		Doc:   "Set desktop.MouseEvent Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//modifier!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Modifier, ok = v.Value.(fyne.KeyModifier)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouse-event//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouse-event//modifier!")
			}
			return arg0
		},
	},
	"mouse-event//modifier?": {
		Doc:   "Get desktop.MouseEvent Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//modifier?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//modifier?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Modifier, "key-modifier")
			return resObj
		},
	},
	"mouse-event//position!": {
		Doc:   "Set desktop.MouseEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouse-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouse-event//position!")
			}
			return arg0
		},
	},
	"mouse-event//position?": {
		Doc:   "Get desktop.MouseEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouse-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"mouseable//mouse-down": {
		Doc:   "desktop.Mouseable.MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Mouseable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Mouseable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouseable//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouseable//mouse-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouseable//mouse-down")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouseable//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouseable//mouse-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouseable//mouse-down")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"mouseable//mouse-up": {
		Doc:   "desktop.Mouseable.MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Mouseable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Mouseable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouseable//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouseable//mouse-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mouseable//mouse-up")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouseable//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouseable//mouse-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mouseable//mouse-up")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"movable-repository//move": {
		Doc:   "repository.MovableRepository.Move",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.MovableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.MovableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "movable-repository//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "movable-repository//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "movable-repository//move")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "movable-repository//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "movable-repository//move")
			}
			var arg2Val fyne.URI
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "movable-repository//move")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "movable-repository//move")
			}
			res0 := arg0Val.Move(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"move": {
		Doc:   "storage.Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "move")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "move")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "move")
			}
			res0 := storage.Move(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"move-down-icon": {
		Doc:   "theme.MoveDownIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoveDownIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"move-up-icon": {
		Doc:   "theme.MoveUpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoveUpIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"multi-line-entry": {
		Doc:   "widget.NewMultiLineEntry",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewMultiLineEntry()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-entry")
			return res0Obj
		},
	},
	"navigate-back-icon": {
		Doc:   "theme.NavigateBackIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.NavigateBackIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"navigate-next-icon": {
		Doc:   "theme.NavigateNextIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.NavigateNextIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"not": {
		Doc:   "binding.Not",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "not")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "not")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "not")
			}
			res0 := binding.Not(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool")
			return res0Obj
		},
	},
	"notification": {
		Doc:   "fyne.NewNotification",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "notification")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "notification")
			}
			res0 := fyne.NewNotification(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-notification")
			return res0Obj
		},
	},
	"notification//content!": {
		Doc:   "Set fyne.Notification Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "notification//content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "notification//content!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Content = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "notification//content!")
			}
			return arg0
		},
	},
	"notification//content?": {
		Doc:   "Get fyne.Notification Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "notification//content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "notification//content?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Content)
			return resObj
		},
	},
	"notification//title!": {
		Doc:   "Set fyne.Notification Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "notification//title!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "notification//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "notification//title!")
			}
			return arg0
		},
	},
	"notification//title?": {
		Doc:   "Get fyne.Notification Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "notification//title?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "notification//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"open-file-from-uri": {
		Doc:   "storage.OpenFileFromURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "open-file-from-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "open-file-from-uri")
			}
			res0, res1 := storage.OpenFileFromURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"or": {
		Doc:   "binding.Or",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []binding.Bool
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]binding.Bool, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(binding.Bool)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "or")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "or")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "or")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "or")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "or")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "or")
			}
			res0 := binding.Or(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool")
			return res0Obj
		},
	},
	"overlay-background-color": {
		Doc:   "theme.OverlayBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.OverlayBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"overlay-stack//add": {
		Doc:   "fyne.OverlayStack.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//add")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//add")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "overlay-stack//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "overlay-stack//add")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "overlay-stack//add")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"overlay-stack//list": {
		Doc:   "fyne.OverlayStack.List",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//list")
			}
			res0 := arg0Val.List()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "canvas-object")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"overlay-stack//remove": {
		Doc:   "fyne.OverlayStack.Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//remove")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "overlay-stack//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "overlay-stack//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "overlay-stack//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"overlay-stack//top": {
		Doc:   "fyne.OverlayStack.Top",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//top")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//top")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "overlay-stack//top")
			}
			res0 := arg0Val.Top()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"padded": {
		Doc:   "container.NewPadded",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "padded")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "padded")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "padded")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "padded")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "padded")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "padded")
			}
			res0 := container.NewPadded(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"padded-layout": {
		Doc:   "layout.NewPaddedLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewPaddedLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"padding": {
		Doc:   "theme.Padding",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.Padding()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"paragraph-segment//texts!": {
		Doc:   "Set widget.ParagraphSegment Texts value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "paragraph-segment//texts!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "paragraph-segment//texts!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Texts = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Texts[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "paragraph-segment//texts!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "paragraph-segment//texts!")
						}
						self.Texts[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "paragraph-segment//texts!")
					}
				}
			case env.Native:
				var ok bool
				self.Texts, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "paragraph-segment//texts!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "paragraph-segment//texts!")
				}
				self.Texts = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "paragraph-segment//texts!")
			}
			return arg0
		},
	},
	"paragraph-segment//texts?": {
		Doc:   "Get widget.ParagraphSegment Texts value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "paragraph-segment//texts?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "paragraph-segment//texts?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Texts))
				for i, it := range self.Texts {
					items[i] = *env.NewNative(ps.Idx, it, "rich-text-segment")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"parent": {
		Doc:   "storage.Parent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "parent")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "parent")
			}
			res0, res1 := storage.Parent(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"parse-uri": {
		Doc:   "storage.ParseURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "parse-uri")
			}
			res0, res1 := storage.ParseURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"password-entry": {
		Doc:   "widget.NewPasswordEntry",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewPasswordEntry()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-entry")
			return res0Obj
		},
	},
	"place-holder-color": {
		Doc:   "theme.PlaceHolderColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PlaceHolderColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"point-event//absolute-position!": {
		Doc:   "Set fyne.PointEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "point-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "point-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "point-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "point-event//absolute-position!")
			}
			return arg0
		},
	},
	"point-event//absolute-position?": {
		Doc:   "Get fyne.PointEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "point-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "point-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"point-event//position!": {
		Doc:   "Set fyne.PointEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "point-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "point-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "point-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "point-event//position!")
			}
			return arg0
		},
	},
	"point-event//position?": {
		Doc:   "Get fyne.PointEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "point-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "point-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"pop-up": {
		Doc:   "widget.NewPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up")
			}
			res0 := widget.NewPopUp(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-pop-up")
			return res0Obj
		},
	},
	"pop-up-menu": {
		Doc:   "widget.NewPopUpMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up-menu")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up-menu")
			}
			res0 := widget.NewPopUpMenu(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-pop-up-menu")
			return res0Obj
		},
	},
	"pop-up-menu//hidden!": {
		Doc:   "Set widget.PopUpMenu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "pop-up-menu//hidden!")
			}
			return arg0
		},
	},
	"pop-up-menu//hidden?": {
		Doc:   "Get widget.PopUpMenu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"pop-up-menu//items!": {
		Doc:   "Set widget.PopUpMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "pop-up-menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "pop-up-menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "pop-up-menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "pop-up-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "pop-up-menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "pop-up-menu//items!")
			}
			return arg0
		},
	},
	"pop-up-menu//items?": {
		Doc:   "Get widget.PopUpMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "canvas-object")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"pop-up-menu//on-dismiss!": {
		Doc:   "Set widget.PopUpMenu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//on-dismiss!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//on-dismiss!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "pop-up-menu//on-dismiss!")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "pop-up-menu//on-dismiss!")
				}
				self.OnDismiss = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "pop-up-menu//on-dismiss!")
			}
			return arg0
		},
	},
	"pop-up-menu//on-dismiss?": {
		Doc:   "Get widget.PopUpMenu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//on-dismiss?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up-menu//on-dismiss?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "func()")
			return resObj
		},
	},
	"pop-up//canvas!": {
		Doc:   "Set widget.PopUp Canvas value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//canvas!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//canvas!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Canvas, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up//canvas!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up//canvas!")
				}
				self.Canvas = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up//canvas!")
			}
			return arg0
		},
	},
	"pop-up//canvas?": {
		Doc:   "Get widget.PopUp Canvas value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//canvas?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//canvas?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Canvas, "canvas")
			return resObj
		},
	},
	"pop-up//content!": {
		Doc:   "Set widget.PopUp Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "pop-up//content!")
			}
			return arg0
		},
	},
	"pop-up//content?": {
		Doc:   "Get widget.PopUp Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "canvas-object")
			return resObj
		},
	},
	"pop-up//hidden!": {
		Doc:   "Set widget.PopUp Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "pop-up//hidden!")
			}
			return arg0
		},
	},
	"pop-up//hidden?": {
		Doc:   "Get widget.PopUp Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "pop-up//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"pos": {
		Doc:   "fyne.NewPos",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "pos")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "pos")
			}
			res0 := fyne.NewPos(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"position-animation": {
		Doc:   "canvas.NewPositionAnimation",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position-animation")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "position-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "position-animation")
			}
			var arg2Val time.Duration
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "position-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "position-animation")
			}
			var arg3Val func(fyne.Position)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "position-animation")
				}
				arg3Val = func(arg0 fyne.Position) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "position")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "position-animation")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "position-animation")
			}
			res0 := canvas.NewPositionAnimation(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-animation")
			return res0Obj
		},
	},
	"position//add": {
		Doc:   "fyne.Position.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//add")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//add")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "position//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "position//add")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "position//add")
			}
			res0 := arg0Val.Add(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"position//add-xy": {
		Doc:   "fyne.Position.AddXY",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//add-xy")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//add-xy")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "position//add-xy")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "position//add-xy")
			}
			res0 := arg0Val.AddXY(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"position//components": {
		Doc:   "fyne.Position.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//components")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//components")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"position//is-zero": {
		Doc:   "fyne.Position.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//is-zero")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//is-zero")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"position//subtract": {
		Doc:   "fyne.Position.Subtract",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//subtract")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//subtract")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "position//subtract")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "position//subtract")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "position//subtract")
			}
			res0 := arg0Val.Subtract(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"position//subtract-xy": {
		Doc:   "fyne.Position.SubtractXY",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//subtract-xy")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//subtract-xy")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "position//subtract-xy")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "position//subtract-xy")
			}
			res0 := arg0Val.SubtractXY(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"position//x!": {
		Doc:   "Set fyne.Position X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//x!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//x!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "position//x!")
			}
			return arg0
		},
	},
	"position//x?": {
		Doc:   "Get fyne.Position X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//x?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//x?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"position//y!": {
		Doc:   "Set fyne.Position Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//y!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//y!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "position//y!")
			}
			return arg0
		},
	},
	"position//y?": {
		Doc:   "Get fyne.Position Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//y?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "position//y?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"preferences//add-change-listener": {
		Doc:   "fyne.Preferences.AddChangeListener",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//add-change-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//add-change-listener")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//add-change-listener")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "preferences//add-change-listener")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "preferences//add-change-listener")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "preferences//add-change-listener")
			}
			arg0Val.AddChangeListener(arg1Val)
			return arg0
		},
	},
	"preferences//bool": {
		Doc:   "fyne.Preferences.Bool",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//bool")
			}
			res0 := arg0Val.Bool(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"preferences//bool-list": {
		Doc:   "fyne.Preferences.BoolList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//bool-list")
			}
			res0 := arg0Val.BoolList(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(boolToInt64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"preferences//bool-list-with-fallback": {
		Doc:   "fyne.Preferences.BoolListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool-list-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool-list-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//bool-list-with-fallback")
			}
			var arg2Val []bool
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]bool, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = v.Value != 0
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//bool-list-with-fallback")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//bool-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//bool-list-with-fallback")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//bool-list-with-fallback")
			}
			res0 := arg0Val.BoolListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(boolToInt64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"preferences//bool-with-fallback": {
		Doc:   "fyne.Preferences.BoolWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//bool-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//bool-with-fallback")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "preferences//bool-with-fallback")
			}
			res0 := arg0Val.BoolWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"preferences//change-listeners": {
		Doc:   "fyne.Preferences.ChangeListeners",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//change-listeners")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//change-listeners")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//change-listeners")
			}
			res0 := arg0Val.ChangeListeners()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "func()")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"preferences//float": {
		Doc:   "fyne.Preferences.Float",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//float")
			}
			res0 := arg0Val.Float(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"preferences//float-list": {
		Doc:   "fyne.Preferences.FloatList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//float-list")
			}
			res0 := arg0Val.FloatList(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewDecimal(float64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"preferences//float-list-with-fallback": {
		Doc:   "fyne.Preferences.FloatListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float-list-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float-list-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//float-list-with-fallback")
			}
			var arg2Val []float64
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]float64, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg2Val[i] = float64(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//float-list-with-fallback")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//float-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//float-list-with-fallback")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//float-list-with-fallback")
			}
			res0 := arg0Val.FloatListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewDecimal(float64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"preferences//float-with-fallback": {
		Doc:   "fyne.Preferences.FloatWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//float-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//float-with-fallback")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "preferences//float-with-fallback")
			}
			res0 := arg0Val.FloatWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"preferences//int": {
		Doc:   "fyne.Preferences.Int",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//int")
			}
			res0 := arg0Val.Int(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"preferences//int-list": {
		Doc:   "fyne.Preferences.IntList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//int-list")
			}
			res0 := arg0Val.IntList(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"preferences//int-list-with-fallback": {
		Doc:   "fyne.Preferences.IntListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int-list-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int-list-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//int-list-with-fallback")
			}
			var arg2Val []int
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = int(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//int-list-with-fallback")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]int)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//int-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//int-list-with-fallback")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//int-list-with-fallback")
			}
			res0 := arg0Val.IntListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewInteger(int64(it))
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"preferences//int-with-fallback": {
		Doc:   "fyne.Preferences.IntWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//int-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//int-with-fallback")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "preferences//int-with-fallback")
			}
			res0 := arg0Val.IntWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"preferences//remove-value": {
		Doc:   "fyne.Preferences.RemoveValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//remove-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//remove-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//remove-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//remove-value")
			}
			arg0Val.RemoveValue(arg1Val)
			return arg0
		},
	},
	"preferences//set-bool": {
		Doc:   "fyne.Preferences.SetBool",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-bool")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-bool")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//set-bool")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "preferences//set-bool")
			}
			arg0Val.SetBool(arg1Val, arg2Val)
			return arg0
		},
	},
	"preferences//set-bool-list": {
		Doc:   "fyne.Preferences.SetBoolList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-bool-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-bool-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-bool-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//set-bool-list")
			}
			var arg2Val []bool
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]bool, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = v.Value != 0
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-bool-list")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-bool-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-bool-list")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-bool-list")
			}
			arg0Val.SetBoolList(arg1Val, arg2Val)
			return arg0
		},
	},
	"preferences//set-float": {
		Doc:   "fyne.Preferences.SetFloat",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-float")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-float")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//set-float")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "preferences//set-float")
			}
			arg0Val.SetFloat(arg1Val, arg2Val)
			return arg0
		},
	},
	"preferences//set-float-list": {
		Doc:   "fyne.Preferences.SetFloatList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-float-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-float-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-float-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//set-float-list")
			}
			var arg2Val []float64
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]float64, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg2Val[i] = float64(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-float-list")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-float-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-float-list")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-float-list")
			}
			arg0Val.SetFloatList(arg1Val, arg2Val)
			return arg0
		},
	},
	"preferences//set-int": {
		Doc:   "fyne.Preferences.SetInt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-int")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-int")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//set-int")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "preferences//set-int")
			}
			arg0Val.SetInt(arg1Val, arg2Val)
			return arg0
		},
	},
	"preferences//set-int-list": {
		Doc:   "fyne.Preferences.SetIntList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-int-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-int-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-int-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//set-int-list")
			}
			var arg2Val []int
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = int(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-int-list")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]int)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-int-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-int-list")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-int-list")
			}
			arg0Val.SetIntList(arg1Val, arg2Val)
			return arg0
		},
	},
	"preferences//set-string": {
		Doc:   "fyne.Preferences.SetString",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//set-string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "preferences//set-string")
			}
			arg0Val.SetString(arg1Val, arg2Val)
			return arg0
		},
	},
	"preferences//set-string-list": {
		Doc:   "fyne.Preferences.SetStringList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-string-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-string-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//set-string-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//set-string-list")
			}
			var arg2Val []string
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg2Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-string-list")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-string-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-string-list")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//set-string-list")
			}
			arg0Val.SetStringList(arg1Val, arg2Val)
			return arg0
		},
	},
	"preferences//string": {
		Doc:   "fyne.Preferences.String",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//string")
			}
			res0 := arg0Val.String(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"preferences//string-list": {
		Doc:   "fyne.Preferences.StringList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//string-list")
			}
			res0 := arg0Val.StringList(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"preferences//string-list-with-fallback": {
		Doc:   "fyne.Preferences.StringListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string-list-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string-list-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//string-list-with-fallback")
			}
			var arg2Val []string
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg2Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//string-list-with-fallback")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//string-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//string-list-with-fallback")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "preferences//string-list-with-fallback")
			}
			res0 := arg0Val.StringListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"preferences//string-with-fallback": {
		Doc:   "fyne.Preferences.StringWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "preferences//string-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "preferences//string-with-fallback")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "preferences//string-with-fallback")
			}
			res0 := arg0Val.StringWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"pressed-color": {
		Doc:   "theme.PressedColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PressedColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"primary-color": {
		Doc:   "theme.PrimaryColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PrimaryColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"primary-color-named": {
		Doc:   "theme.PrimaryColorNamed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "primary-color-named")
			}
			res0 := theme.PrimaryColorNamed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"primary-color-names": {
		Doc:   "theme.PrimaryColorNames",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PrimaryColorNames()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"primary-themed-resource": {
		Doc:   "theme.NewPrimaryThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "primary-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "primary-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "primary-themed-resource")
			}
			res0 := theme.NewPrimaryThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-primary-themed-resource")
			return res0Obj
		},
	},
	"progress": {
		Doc:   "dialog.NewProgress",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "progress")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "progress")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "progress")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "progress")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "progress")
			}
			res0 := dialog.NewProgress(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-progress-dialog")
			return res0Obj
		},
	},
	"progress-bar": {
		Doc:   "widget.NewProgressBar",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewProgressBar()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-progress-bar")
			return res0Obj
		},
	},
	"progress-bar-infinite": {
		Doc:   "widget.NewProgressBarInfinite",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewProgressBarInfinite()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-progress-bar-infinite")
			return res0Obj
		},
	},
	"progress-bar-infinite//hidden!": {
		Doc:   "Set widget.ProgressBarInfinite Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar-infinite//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar-infinite//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "progress-bar-infinite//hidden!")
			}
			return arg0
		},
	},
	"progress-bar-infinite//hidden?": {
		Doc:   "Get widget.ProgressBarInfinite Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar-infinite//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar-infinite//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"progress-bar-with-data": {
		Doc:   "widget.NewProgressBarWithData",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar-with-data")
			}
			res0 := widget.NewProgressBarWithData(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-progress-bar")
			return res0Obj
		},
	},
	"progress-bar//hidden!": {
		Doc:   "Set widget.ProgressBar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "progress-bar//hidden!")
			}
			return arg0
		},
	},
	"progress-bar//hidden?": {
		Doc:   "Get widget.ProgressBar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"progress-bar//max!": {
		Doc:   "Set widget.ProgressBar Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//max!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//max!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "progress-bar//max!")
			}
			return arg0
		},
	},
	"progress-bar//max?": {
		Doc:   "Get widget.ProgressBar Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//max?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//max?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"progress-bar//min!": {
		Doc:   "Set widget.ProgressBar Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//min!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//min!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "progress-bar//min!")
			}
			return arg0
		},
	},
	"progress-bar//min?": {
		Doc:   "Get widget.ProgressBar Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//min?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//min?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"progress-bar//text-formatter!": {
		Doc:   "Set widget.ProgressBar TextFormatter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//text-formatter!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//text-formatter!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "progress-bar//text-formatter!")
				}
				self.TextFormatter = func() string {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res string
					if v, ok := ps.Res.(env.String); ok {
						res = string(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "progress-bar//text-formatter!")
				}
				self.TextFormatter = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "progress-bar//text-formatter!")
			}
			return arg0
		},
	},
	"progress-bar//text-formatter?": {
		Doc:   "Get widget.ProgressBar TextFormatter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//text-formatter?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//text-formatter?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextFormatter, "func()_(string)")
			return resObj
		},
	},
	"progress-bar//value!": {
		Doc:   "Set widget.ProgressBar Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//value!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//value!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "progress-bar//value!")
			}
			return arg0
		},
	},
	"progress-bar//value?": {
		Doc:   "Get widget.ProgressBar Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//value?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "progress-bar//value?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"progress-infinite": {
		Doc:   "dialog.NewProgressInfinite",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "progress-infinite")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "progress-infinite")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "progress-infinite")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "progress-infinite")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "progress-infinite")
			}
			res0 := dialog.NewProgressInfinite(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-progress-infinite-dialog")
			return res0Obj
		},
	},
	"ptr-accordion-item//detail!": {
		Doc:   "Set *widget.AccordionItem Detail value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//detail!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//detail!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//detail!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Detail, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion-item//detail!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion-item//detail!")
				}
				self.Detail = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion-item//detail!")
			}
			return arg0
		},
	},
	"ptr-accordion-item//detail?": {
		Doc:   "Get *widget.AccordionItem Detail value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//detail?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//detail?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//detail?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Detail, "canvas-object")
			return resObj
		},
	},
	"ptr-accordion-item//open!": {
		Doc:   "Set *widget.AccordionItem Open value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//open!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//open!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//open!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Open = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-accordion-item//open!")
			}
			return arg0
		},
	},
	"ptr-accordion-item//open?": {
		Doc:   "Get *widget.AccordionItem Open value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//open?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//open?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//open?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Open))
			return resObj
		},
	},
	"ptr-accordion-item//title!": {
		Doc:   "Set *widget.AccordionItem Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//title!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//title!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-accordion-item//title!")
			}
			return arg0
		},
	},
	"ptr-accordion-item//title?": {
		Doc:   "Get *widget.AccordionItem Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//title?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//title?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion-item//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"ptr-accordion//append": {
		Doc:   "(*widget.Accordion).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//append")
			}
			var arg1Val *widget.AccordionItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-accordion//close": {
		Doc:   "(*widget.Accordion).Close",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//close")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//close")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//close")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-accordion//close")
			}
			arg0Val.Close(arg1Val)
			return arg0
		},
	},
	"ptr-accordion//close-all": {
		Doc:   "(*widget.Accordion).CloseAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//close-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//close-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//close-all")
			}
			arg0Val.CloseAll()
			return arg0
		},
	},
	"ptr-accordion//create-renderer": {
		Doc:   "(*widget.Accordion).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-accordion//extend-base-widget": {
		Doc:   "(*widget.Accordion).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-accordion//hidden!": {
		Doc:   "Set *widget.Accordion Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-accordion//hidden!")
			}
			return arg0
		},
	},
	"ptr-accordion//hidden?": {
		Doc:   "Get *widget.Accordion Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-accordion//hide": {
		Doc:   "(*widget.Accordion).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-accordion//items!": {
		Doc:   "Set *widget.Accordion Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.AccordionItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.AccordionItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-accordion//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-accordion//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-accordion//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-accordion//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-accordion//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-accordion//items!")
			}
			return arg0
		},
	},
	"ptr-accordion//items?": {
		Doc:   "Get *widget.Accordion Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-accordion-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-accordion//min-size": {
		Doc:   "(*widget.Accordion).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-accordion//move": {
		Doc:   "(*widget.Accordion).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-accordion//multi-open!": {
		Doc:   "Set *widget.Accordion MultiOpen value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//multi-open!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//multi-open!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//multi-open!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiOpen = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-accordion//multi-open!")
			}
			return arg0
		},
	},
	"ptr-accordion//multi-open?": {
		Doc:   "Get *widget.Accordion MultiOpen value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//multi-open?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//multi-open?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//multi-open?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiOpen))
			return resObj
		},
	},
	"ptr-accordion//open": {
		Doc:   "(*widget.Accordion).Open",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//open")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//open")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//open")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-accordion//open")
			}
			arg0Val.Open(arg1Val)
			return arg0
		},
	},
	"ptr-accordion//open-all": {
		Doc:   "(*widget.Accordion).OpenAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//open-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//open-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//open-all")
			}
			arg0Val.OpenAll()
			return arg0
		},
	},
	"ptr-accordion//position": {
		Doc:   "(*widget.Accordion).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-accordion//refresh": {
		Doc:   "(*widget.Accordion).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-accordion//remove": {
		Doc:   "(*widget.Accordion).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//remove")
			}
			var arg1Val *widget.AccordionItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"ptr-accordion//remove-index": {
		Doc:   "(*widget.Accordion).RemoveIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//remove-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//remove-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//remove-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-accordion//remove-index")
			}
			arg0Val.RemoveIndex(arg1Val)
			return arg0
		},
	},
	"ptr-accordion//resize": {
		Doc:   "(*widget.Accordion).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-accordion//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-accordion//show": {
		Doc:   "(*widget.Accordion).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-accordion//size": {
		Doc:   "(*widget.Accordion).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-accordion//visible": {
		Doc:   "(*widget.Accordion).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-accordion//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-android-context//ctx!": {
		Doc:   "Set *driver.AndroidContext Ctx value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//ctx!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//ctx!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//ctx!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Ctx, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-android-context//ctx!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-android-context//ctx!")
			}
			return arg0
		},
	},
	"ptr-android-context//ctx?": {
		Doc:   "Get *driver.AndroidContext Ctx value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//ctx?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//ctx?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//ctx?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Ctx, "uintptr")
			return resObj
		},
	},
	"ptr-android-context//env!": {
		Doc:   "Set *driver.AndroidContext Env value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//env!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//env!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//env!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Env, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-android-context//env!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-android-context//env!")
			}
			return arg0
		},
	},
	"ptr-android-context//env?": {
		Doc:   "Get *driver.AndroidContext Env value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//env?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//env?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//env?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Env, "uintptr")
			return resObj
		},
	},
	"ptr-android-context//vm!": {
		Doc:   "Set *driver.AndroidContext VM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//vm!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//vm!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//vm!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.VM, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-android-context//vm!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-android-context//vm!")
			}
			return arg0
		},
	},
	"ptr-android-context//vm?": {
		Doc:   "Get *driver.AndroidContext VM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//vm?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//vm?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-android-context//vm?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.VM, "uintptr")
			return resObj
		},
	},
	"ptr-animation//auto-reverse!": {
		Doc:   "Set *fyne.Animation AutoReverse value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//auto-reverse!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//auto-reverse!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//auto-reverse!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AutoReverse = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-animation//auto-reverse!")
			}
			return arg0
		},
	},
	"ptr-animation//auto-reverse?": {
		Doc:   "Get *fyne.Animation AutoReverse value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//auto-reverse?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//auto-reverse?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//auto-reverse?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AutoReverse))
			return resObj
		},
	},
	"ptr-animation//curve!": {
		Doc:   "Set *fyne.Animation Curve value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//curve!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//curve!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//curve!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Curve, ok = v.Value.(fyne.AnimationCurve)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-animation//curve!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-animation//curve!")
			}
			return arg0
		},
	},
	"ptr-animation//curve?": {
		Doc:   "Get *fyne.Animation Curve value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//curve?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//curve?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//curve?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Curve, "animation-curve")
			return resObj
		},
	},
	"ptr-animation//duration!": {
		Doc:   "Set *fyne.Animation Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//duration!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//duration!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//duration!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-animation//duration!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-animation//duration!")
			}
			return arg0
		},
	},
	"ptr-animation//duration?": {
		Doc:   "Get *fyne.Animation Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//duration?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//duration?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//duration?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "duration")
			return resObj
		},
	},
	"ptr-animation//repeat-count!": {
		Doc:   "Set *fyne.Animation RepeatCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//repeat-count!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//repeat-count!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//repeat-count!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.RepeatCount = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-animation//repeat-count!")
			}
			return arg0
		},
	},
	"ptr-animation//repeat-count?": {
		Doc:   "Get *fyne.Animation RepeatCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//repeat-count?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//repeat-count?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//repeat-count?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.RepeatCount))
			return resObj
		},
	},
	"ptr-animation//start": {
		Doc:   "(*fyne.Animation).Start",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//start")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//start")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//start")
			}
			arg0Val.Start()
			return arg0
		},
	},
	"ptr-animation//stop": {
		Doc:   "(*fyne.Animation).Stop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//stop")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//stop")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//stop")
			}
			arg0Val.Stop()
			return arg0
		},
	},
	"ptr-animation//tick!": {
		Doc:   "Set *fyne.Animation Tick value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//tick!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//tick!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//tick!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-animation//tick!")
				}
				self.Tick = func(arg0 float32) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-animation//tick!")
				}
				self.Tick = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-animation//tick!")
			}
			return arg0
		},
	},
	"ptr-animation//tick?": {
		Doc:   "Get *fyne.Animation Tick value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//tick?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//tick?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-animation//tick?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Tick, "func(float32)")
			return resObj
		},
	},
	"ptr-app-metadata//build!": {
		Doc:   "Set *fyne.AppMetadata Build value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//build!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//build!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//build!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Build = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-app-metadata//build!")
			}
			return arg0
		},
	},
	"ptr-app-metadata//build?": {
		Doc:   "Get *fyne.AppMetadata Build value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//build?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//build?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//build?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Build))
			return resObj
		},
	},
	"ptr-app-metadata//custom!": {
		Doc:   "Set *fyne.AppMetadata Custom value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//custom!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//custom!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//custom!")
			}
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "ptr-app-metadata//custom!")
				}
				self.Custom = make(map[string]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "ptr-app-metadata//custom!")
					}
					var mapV string
					if v, ok := v.Series.S[i+1].(env.String); ok {
						mapV = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "ptr-app-metadata//custom!")
					}
					self.Custom[mapK] = mapV
				}
			case env.Dict:
				self.Custom = make(map[string]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV string
					if v, ok := dictV.(env.String); ok {
						mapV = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "ptr-app-metadata//custom!")
					}
					self.Custom[mapK] = mapV
				}
			case env.Native:
				var ok bool
				self.Custom, ok = v.Value.(map[string]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "ptr-app-metadata//custom!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "ptr-app-metadata//custom!")
				}
				self.Custom = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "ptr-app-metadata//custom!")
			}
			return arg0
		},
	},
	"ptr-app-metadata//custom?": {
		Doc:   "Get *fyne.AppMetadata Custom value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//custom?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//custom?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//custom?")
			}
			var resObj env.Object
			{
				data := make(map[string]any, len(self.Custom))
				for mKey, mVal := range self.Custom {
					var dVal env.Object
					dVal = *env.NewString(mVal)
					data[mKey] = dVal
				}
				resObj = *env.NewDict(data)
			}
			return resObj
		},
	},
	"ptr-app-metadata//icon!": {
		Doc:   "Set *fyne.AppMetadata Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//icon!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-metadata//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-metadata//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-metadata//icon!")
			}
			return arg0
		},
	},
	"ptr-app-metadata//icon?": {
		Doc:   "Get *fyne.AppMetadata Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//icon?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//icon?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"ptr-app-metadata//id!": {
		Doc:   "Set *fyne.AppMetadata ID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//id!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//id!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//id!")
			}
			if v, ok := arg1.(env.String); ok {
				self.ID = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-app-metadata//id!")
			}
			return arg0
		},
	},
	"ptr-app-metadata//id?": {
		Doc:   "Get *fyne.AppMetadata ID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//id?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//id?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//id?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ID)
			return resObj
		},
	},
	"ptr-app-metadata//name!": {
		Doc:   "Set *fyne.AppMetadata Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Name = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-app-metadata//name!")
			}
			return arg0
		},
	},
	"ptr-app-metadata//name?": {
		Doc:   "Get *fyne.AppMetadata Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Name)
			return resObj
		},
	},
	"ptr-app-metadata//release!": {
		Doc:   "Set *fyne.AppMetadata Release value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//release!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//release!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//release!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Release = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-app-metadata//release!")
			}
			return arg0
		},
	},
	"ptr-app-metadata//release?": {
		Doc:   "Get *fyne.AppMetadata Release value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//release?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//release?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//release?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Release))
			return resObj
		},
	},
	"ptr-app-metadata//version!": {
		Doc:   "Set *fyne.AppMetadata Version value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//version!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//version!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//version!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Version = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-app-metadata//version!")
			}
			return arg0
		},
	},
	"ptr-app-metadata//version?": {
		Doc:   "Get *fyne.AppMetadata Version value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//version?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//version?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-metadata//version?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Version)
			return resObj
		},
	},
	"ptr-app-tabs//append": {
		Doc:   "(*container.AppTabs).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//append")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//create-renderer": {
		Doc:   "(*container.AppTabs).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-app-tabs//current-tab": {
		Doc:   "(*container.AppTabs).CurrentTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//current-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//current-tab")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//current-tab")
			}
			res0 := arg0Val.CurrentTab()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-tab-item")
			return res0Obj
		},
	},
	"ptr-app-tabs//current-tab-index": {
		Doc:   "(*container.AppTabs).CurrentTabIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//current-tab-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//current-tab-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//current-tab-index")
			}
			res0 := arg0Val.CurrentTabIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-app-tabs//disable-index": {
		Doc:   "(*container.AppTabs).DisableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//disable-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//disable-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//disable-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-app-tabs//disable-index")
			}
			arg0Val.DisableIndex(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//disable-item": {
		Doc:   "(*container.AppTabs).DisableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//disable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//disable-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//disable-item")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//disable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//disable-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//disable-item")
			}
			arg0Val.DisableItem(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//enable-index": {
		Doc:   "(*container.AppTabs).EnableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//enable-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//enable-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//enable-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-app-tabs//enable-index")
			}
			arg0Val.EnableIndex(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//enable-item": {
		Doc:   "(*container.AppTabs).EnableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//enable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//enable-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//enable-item")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//enable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//enable-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//enable-item")
			}
			arg0Val.EnableItem(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//extend-base-widget": {
		Doc:   "(*container.AppTabs).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//hidden!": {
		Doc:   "Set *container.AppTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-app-tabs//hidden!")
			}
			return arg0
		},
	},
	"ptr-app-tabs//hidden?": {
		Doc:   "Get *container.AppTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-app-tabs//hide": {
		Doc:   "(*container.AppTabs).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-app-tabs//items!": {
		Doc:   "Set *container.AppTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//items!")
			}
			return arg0
		},
	},
	"ptr-app-tabs//items?": {
		Doc:   "Get *container.AppTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-tab-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-app-tabs//min-size": {
		Doc:   "(*container.AppTabs).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-app-tabs//move": {
		Doc:   "(*container.AppTabs).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//on-changed!": {
		Doc:   "Set *container.AppTabs OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-app-tabs//on-changed!")
				}
				self.OnChanged = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-app-tabs//on-changed!")
			}
			return arg0
		},
	},
	"ptr-app-tabs//on-changed?": {
		Doc:   "Get *container.AppTabs OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(ptr-tab-item)")
			return resObj
		},
	},
	"ptr-app-tabs//on-selected!": {
		Doc:   "Set *container.AppTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-app-tabs//on-selected!")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-app-tabs//on-selected!")
			}
			return arg0
		},
	},
	"ptr-app-tabs//on-selected?": {
		Doc:   "Get *container.AppTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(ptr-tab-item)")
			return resObj
		},
	},
	"ptr-app-tabs//on-unselected!": {
		Doc:   "Set *container.AppTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-unselected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-unselected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-app-tabs//on-unselected!")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-app-tabs//on-unselected!")
			}
			return arg0
		},
	},
	"ptr-app-tabs//on-unselected?": {
		Doc:   "Get *container.AppTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-unselected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-unselected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(ptr-tab-item)")
			return resObj
		},
	},
	"ptr-app-tabs//position": {
		Doc:   "(*container.AppTabs).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-app-tabs//refresh": {
		Doc:   "(*container.AppTabs).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-app-tabs//remove": {
		Doc:   "(*container.AppTabs).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//remove")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//remove-index": {
		Doc:   "(*container.AppTabs).RemoveIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//remove-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//remove-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//remove-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-app-tabs//remove-index")
			}
			arg0Val.RemoveIndex(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//resize": {
		Doc:   "(*container.AppTabs).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//select": {
		Doc:   "(*container.AppTabs).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//select")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//select")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//select-index": {
		Doc:   "(*container.AppTabs).SelectIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-app-tabs//select-index")
			}
			arg0Val.SelectIndex(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//select-tab": {
		Doc:   "(*container.AppTabs).SelectTab",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select-tab")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select-tab")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//select-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//select-tab")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//select-tab")
			}
			arg0Val.SelectTab(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//select-tab-index": {
		Doc:   "(*container.AppTabs).SelectTabIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select-tab-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select-tab-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//select-tab-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-app-tabs//select-tab-index")
			}
			arg0Val.SelectTabIndex(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//selected": {
		Doc:   "(*container.AppTabs).Selected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//selected")
			}
			res0 := arg0Val.Selected()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-tab-item")
			return res0Obj
		},
	},
	"ptr-app-tabs//selected-index": {
		Doc:   "(*container.AppTabs).SelectedIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//selected-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//selected-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//selected-index")
			}
			res0 := arg0Val.SelectedIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-app-tabs//set-items": {
		Doc:   "(*container.AppTabs).SetItems",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//set-items")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//set-items")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//set-items")
			}
			var arg1Val []*container.TabItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//set-items")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//set-items")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//set-items")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//set-items")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//set-items")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-app-tabs//set-items")
			}
			arg0Val.SetItems(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//set-tab-location": {
		Doc:   "(*container.AppTabs).SetTabLocation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//set-tab-location")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//set-tab-location")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//set-tab-location")
			}
			var arg1Val container.TabLocation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(container.TabLocation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//set-tab-location")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-app-tabs//set-tab-location")
			}
			arg0Val.SetTabLocation(arg1Val)
			return arg0
		},
	},
	"ptr-app-tabs//show": {
		Doc:   "(*container.AppTabs).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-app-tabs//size": {
		Doc:   "(*container.AppTabs).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-app-tabs//visible": {
		Doc:   "(*container.AppTabs).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-app-tabs//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-base-widget//extend-base-widget": {
		Doc:   "(*widget.BaseWidget).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-base-widget//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-base-widget//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-base-widget//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-base-widget//hidden!": {
		Doc:   "Set *widget.BaseWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-base-widget//hidden!")
			}
			return arg0
		},
	},
	"ptr-base-widget//hidden?": {
		Doc:   "Get *widget.BaseWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-base-widget//hide": {
		Doc:   "(*widget.BaseWidget).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-base-widget//min-size": {
		Doc:   "(*widget.BaseWidget).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-base-widget//move": {
		Doc:   "(*widget.BaseWidget).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-base-widget//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-base-widget//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-base-widget//position": {
		Doc:   "(*widget.BaseWidget).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-base-widget//refresh": {
		Doc:   "(*widget.BaseWidget).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-base-widget//resize": {
		Doc:   "(*widget.BaseWidget).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-base-widget//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-base-widget//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-base-widget//show": {
		Doc:   "(*widget.BaseWidget).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-base-widget//size": {
		Doc:   "(*widget.BaseWidget).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-base-widget//visible": {
		Doc:   "(*widget.BaseWidget).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-base-widget//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-button//alignment!": {
		Doc:   "Set *widget.Button Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(widget.ButtonAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//alignment!")
			}
			return arg0
		},
	},
	"ptr-button//alignment?": {
		Doc:   "Get *widget.Button Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "button-align")
			return resObj
		},
	},
	"ptr-button//create-renderer": {
		Doc:   "(*widget.Button).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-button//cursor": {
		Doc:   "(*widget.Button).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "cursor")
			return res0Obj
		},
	},
	"ptr-button//disable": {
		Doc:   "(*widget.Button).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-button//disabled": {
		Doc:   "(*widget.Button).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-button//enable": {
		Doc:   "(*widget.Button).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-button//extend-base-widget": {
		Doc:   "(*widget.Button).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-button//focus-gained": {
		Doc:   "(*widget.Button).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-button//focus-lost": {
		Doc:   "(*widget.Button).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-button//hidden!": {
		Doc:   "Set *widget.Button Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-button//hidden!")
			}
			return arg0
		},
	},
	"ptr-button//hidden?": {
		Doc:   "Get *widget.Button Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-button//hide": {
		Doc:   "(*widget.Button).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-button//icon!": {
		Doc:   "Set *widget.Button Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//icon!")
			}
			return arg0
		},
	},
	"ptr-button//icon-placement!": {
		Doc:   "Set *widget.Button IconPlacement value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon-placement!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon-placement!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon-placement!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.IconPlacement, ok = v.Value.(widget.ButtonIconPlacement)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//icon-placement!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//icon-placement!")
			}
			return arg0
		},
	},
	"ptr-button//icon-placement?": {
		Doc:   "Get *widget.Button IconPlacement value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon-placement?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon-placement?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon-placement?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.IconPlacement, "button-icon-placement")
			return resObj
		},
	},
	"ptr-button//icon?": {
		Doc:   "Get *widget.Button Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"ptr-button//importance!": {
		Doc:   "Set *widget.Button Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//importance!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//importance!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//importance!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Importance, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//importance!")
			}
			return arg0
		},
	},
	"ptr-button//importance?": {
		Doc:   "Get *widget.Button Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//importance?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//importance?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//importance?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Importance, "importance")
			return resObj
		},
	},
	"ptr-button//min-size": {
		Doc:   "(*widget.Button).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-button//mouse-in": {
		Doc:   "(*widget.Button).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-button//mouse-moved": {
		Doc:   "(*widget.Button).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-button//mouse-out": {
		Doc:   "(*widget.Button).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-button//move": {
		Doc:   "(*widget.Button).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-button//on-tapped!": {
		Doc:   "Set *widget.Button OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//on-tapped!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//on-tapped!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-button//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-button//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-button//on-tapped!")
			}
			return arg0
		},
	},
	"ptr-button//on-tapped?": {
		Doc:   "Get *widget.Button OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//on-tapped?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//on-tapped?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"ptr-button//position": {
		Doc:   "(*widget.Button).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-button//refresh": {
		Doc:   "(*widget.Button).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-button//resize": {
		Doc:   "(*widget.Button).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-button//set-icon": {
		Doc:   "(*widget.Button).SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//set-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//set-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//set-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//set-icon")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"ptr-button//set-text": {
		Doc:   "(*widget.Button).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-button//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-button//show": {
		Doc:   "(*widget.Button).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-button//size": {
		Doc:   "(*widget.Button).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-button//tapped": {
		Doc:   "(*widget.Button).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-button//text!": {
		Doc:   "Set *widget.Button Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-button//text!")
			}
			return arg0
		},
	},
	"ptr-button//text?": {
		Doc:   "Get *widget.Button Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-button//typed-key": {
		Doc:   "(*widget.Button).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-button//typed-rune": {
		Doc:   "(*widget.Button).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-button//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-button//visible": {
		Doc:   "(*widget.Button).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-button//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-card//content!": {
		Doc:   "Set *widget.Card Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//content!")
			}
			return arg0
		},
	},
	"ptr-card//content?": {
		Doc:   "Get *widget.Card Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "canvas-object")
			return resObj
		},
	},
	"ptr-card//create-renderer": {
		Doc:   "(*widget.Card).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-card//extend-base-widget": {
		Doc:   "(*widget.Card).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-card//hidden!": {
		Doc:   "Set *widget.Card Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-card//hidden!")
			}
			return arg0
		},
	},
	"ptr-card//hidden?": {
		Doc:   "Get *widget.Card Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-card//hide": {
		Doc:   "(*widget.Card).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-card//image!": {
		Doc:   "Set *widget.Card Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//image!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//image!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//image!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//image!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//image!")
				}
				self.Image = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//image!")
			}
			return arg0
		},
	},
	"ptr-card//image?": {
		Doc:   "Get *widget.Card Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//image?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//image?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//image?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "ptr-image")
			return resObj
		},
	},
	"ptr-card//min-size": {
		Doc:   "(*widget.Card).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-card//move": {
		Doc:   "(*widget.Card).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-card//position": {
		Doc:   "(*widget.Card).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-card//refresh": {
		Doc:   "(*widget.Card).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-card//resize": {
		Doc:   "(*widget.Card).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-card//set-content": {
		Doc:   "(*widget.Card).SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-content")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//set-content")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//set-content")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"ptr-card//set-image": {
		Doc:   "(*widget.Card).SetImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-image")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-image")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-image")
			}
			var arg1Val *canvas.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//set-image")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//set-image")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-card//set-image")
			}
			arg0Val.SetImage(arg1Val)
			return arg0
		},
	},
	"ptr-card//set-sub-title": {
		Doc:   "(*widget.Card).SetSubTitle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-sub-title")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-sub-title")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-sub-title")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-card//set-sub-title")
			}
			arg0Val.SetSubTitle(arg1Val)
			return arg0
		},
	},
	"ptr-card//set-title": {
		Doc:   "(*widget.Card).SetTitle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-title")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-title")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//set-title")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-card//set-title")
			}
			arg0Val.SetTitle(arg1Val)
			return arg0
		},
	},
	"ptr-card//show": {
		Doc:   "(*widget.Card).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-card//size": {
		Doc:   "(*widget.Card).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-card//subtitle!": {
		Doc:   "Set *widget.Card Subtitle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//subtitle!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//subtitle!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//subtitle!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Subtitle = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-card//subtitle!")
			}
			return arg0
		},
	},
	"ptr-card//subtitle?": {
		Doc:   "Get *widget.Card Subtitle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//subtitle?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//subtitle?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//subtitle?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Subtitle)
			return resObj
		},
	},
	"ptr-card//title!": {
		Doc:   "Set *widget.Card Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//title!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//title!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-card//title!")
			}
			return arg0
		},
	},
	"ptr-card//title?": {
		Doc:   "Get *widget.Card Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//title?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//title?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"ptr-card//visible": {
		Doc:   "(*widget.Card).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-card//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-check-group//append": {
		Doc:   "(*widget.CheckGroup).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-check-group//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-check-group//create-renderer": {
		Doc:   "(*widget.CheckGroup).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-check-group//disable": {
		Doc:   "(*widget.CheckGroup).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-check-group//disabled": {
		Doc:   "(*widget.CheckGroup).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-check-group//enable": {
		Doc:   "(*widget.CheckGroup).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-check-group//extend-base-widget": {
		Doc:   "(*widget.CheckGroup).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check-group//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check-group//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check-group//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-check-group//hidden!": {
		Doc:   "Set *widget.CheckGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-check-group//hidden!")
			}
			return arg0
		},
	},
	"ptr-check-group//hidden?": {
		Doc:   "Get *widget.CheckGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-check-group//hide": {
		Doc:   "(*widget.CheckGroup).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-check-group//horizontal!": {
		Doc:   "Set *widget.CheckGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//horizontal!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//horizontal!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-check-group//horizontal!")
			}
			return arg0
		},
	},
	"ptr-check-group//horizontal?": {
		Doc:   "Get *widget.CheckGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//horizontal?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//horizontal?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"ptr-check-group//min-size": {
		Doc:   "(*widget.CheckGroup).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-check-group//move": {
		Doc:   "(*widget.CheckGroup).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check-group//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check-group//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-check-group//on-changed!": {
		Doc:   "Set *widget.CheckGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-check-group//on-changed!")
				}
				self.OnChanged = func(arg0 []string) {
					var arg0Val env.Object
					{
						items := make([]env.Object, len(arg0))
						for i, it := range arg0 {
							items[i] = *env.NewString(it)
						}
						arg0Val = *env.NewBlock(*env.NewTSeries(items))
					}
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-check-group//on-changed!")
			}
			return arg0
		},
	},
	"ptr-check-group//on-changed?": {
		Doc:   "Get *widget.CheckGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(arr-string)")
			return resObj
		},
	},
	"ptr-check-group//options!": {
		Doc:   "Set *widget.CheckGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//options!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//options!")
			}
			return arg0
		},
	},
	"ptr-check-group//options?": {
		Doc:   "Get *widget.CheckGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//options?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//options?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//options?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-check-group//position": {
		Doc:   "(*widget.CheckGroup).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-check-group//refresh": {
		Doc:   "(*widget.CheckGroup).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-check-group//remove": {
		Doc:   "(*widget.CheckGroup).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//remove")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-check-group//remove")
			}
			res0 := arg0Val.Remove(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-check-group//required!": {
		Doc:   "Set *widget.CheckGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//required!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//required!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//required!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-check-group//required!")
			}
			return arg0
		},
	},
	"ptr-check-group//required?": {
		Doc:   "Get *widget.CheckGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//required?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//required?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//required?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"ptr-check-group//resize": {
		Doc:   "(*widget.CheckGroup).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check-group//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check-group//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-check-group//selected!": {
		Doc:   "Set *widget.CheckGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//selected!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Selected = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Selected[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//selected!")
					}
				}
			case env.Native:
				var ok bool
				self.Selected, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//selected!")
				}
				self.Selected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//selected!")
			}
			return arg0
		},
	},
	"ptr-check-group//selected?": {
		Doc:   "Get *widget.CheckGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//selected?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Selected))
				for i, it := range self.Selected {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-check-group//set-selected": {
		Doc:   "(*widget.CheckGroup).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//set-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//set-selected")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//set-selected")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//set-selected")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check-group//set-selected")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"ptr-check-group//show": {
		Doc:   "(*widget.CheckGroup).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-check-group//size": {
		Doc:   "(*widget.CheckGroup).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-check-group//visible": {
		Doc:   "(*widget.CheckGroup).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check-group//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-check//bind": {
		Doc:   "(*widget.Check).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//bind")
			}
			var arg1Val binding.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-check//checked!": {
		Doc:   "Set *widget.Check Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//checked!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//checked!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//checked!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-check//checked!")
			}
			return arg0
		},
	},
	"ptr-check//checked?": {
		Doc:   "Get *widget.Check Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//checked?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//checked?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//checked?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"ptr-check//create-renderer": {
		Doc:   "(*widget.Check).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-check//disable": {
		Doc:   "(*widget.Check).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-check//disabled": {
		Doc:   "(*widget.Check).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-check//enable": {
		Doc:   "(*widget.Check).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-check//extend-base-widget": {
		Doc:   "(*widget.Check).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-check//focus-gained": {
		Doc:   "(*widget.Check).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-check//focus-lost": {
		Doc:   "(*widget.Check).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-check//hidden!": {
		Doc:   "Set *widget.Check Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-check//hidden!")
			}
			return arg0
		},
	},
	"ptr-check//hidden?": {
		Doc:   "Get *widget.Check Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-check//hide": {
		Doc:   "(*widget.Check).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-check//min-size": {
		Doc:   "(*widget.Check).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-check//mouse-in": {
		Doc:   "(*widget.Check).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-check//mouse-moved": {
		Doc:   "(*widget.Check).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-check//mouse-out": {
		Doc:   "(*widget.Check).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-check//move": {
		Doc:   "(*widget.Check).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-check//on-changed!": {
		Doc:   "Set *widget.Check OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-check//on-changed!")
				}
				self.OnChanged = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-check//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-check//on-changed!")
			}
			return arg0
		},
	},
	"ptr-check//on-changed?": {
		Doc:   "Get *widget.Check OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(bool)")
			return resObj
		},
	},
	"ptr-check//position": {
		Doc:   "(*widget.Check).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-check//refresh": {
		Doc:   "(*widget.Check).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-check//resize": {
		Doc:   "(*widget.Check).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-check//set-checked": {
		Doc:   "(*widget.Check).SetChecked",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//set-checked")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//set-checked")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//set-checked")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-check//set-checked")
			}
			arg0Val.SetChecked(arg1Val)
			return arg0
		},
	},
	"ptr-check//set-text": {
		Doc:   "(*widget.Check).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-check//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-check//show": {
		Doc:   "(*widget.Check).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-check//size": {
		Doc:   "(*widget.Check).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-check//tapped": {
		Doc:   "(*widget.Check).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-check//text!": {
		Doc:   "Set *widget.Check Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-check//text!")
			}
			return arg0
		},
	},
	"ptr-check//text?": {
		Doc:   "Get *widget.Check Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-check//typed-key": {
		Doc:   "(*widget.Check).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-check//typed-rune": {
		Doc:   "(*widget.Check).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-check//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-check//unbind": {
		Doc:   "(*widget.Check).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-check//visible": {
		Doc:   "(*widget.Check).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-check//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-circle//fill-color!": {
		Doc:   "Set *canvas.Circle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//fill-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//fill-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//fill-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//fill-color!")
			}
			return arg0
		},
	},
	"ptr-circle//fill-color?": {
		Doc:   "Get *canvas.Circle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//fill-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//fill-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//fill-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color")
			return resObj
		},
	},
	"ptr-circle//hidden!": {
		Doc:   "Set *canvas.Circle Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-circle//hidden!")
			}
			return arg0
		},
	},
	"ptr-circle//hidden?": {
		Doc:   "Get *canvas.Circle Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-circle//hide": {
		Doc:   "(*canvas.Circle).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-circle//min-size": {
		Doc:   "(*canvas.Circle).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-circle//move": {
		Doc:   "(*canvas.Circle).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-circle//position": {
		Doc:   "(*canvas.Circle).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-circle//position-1!": {
		Doc:   "Set *canvas.Circle Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-1!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-1!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-1!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//position-1!")
			}
			return arg0
		},
	},
	"ptr-circle//position-1?": {
		Doc:   "Get *canvas.Circle Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-1?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-1?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-1?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "position")
			return resObj
		},
	},
	"ptr-circle//position-2!": {
		Doc:   "Set *canvas.Circle Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-2!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-2!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-2!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//position-2!")
			}
			return arg0
		},
	},
	"ptr-circle//position-2?": {
		Doc:   "Get *canvas.Circle Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-2?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-2?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//position-2?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "position")
			return resObj
		},
	},
	"ptr-circle//refresh": {
		Doc:   "(*canvas.Circle).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-circle//resize": {
		Doc:   "(*canvas.Circle).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-circle//show": {
		Doc:   "(*canvas.Circle).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-circle//size": {
		Doc:   "(*canvas.Circle).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-circle//stroke-color!": {
		Doc:   "Set *canvas.Circle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-circle//stroke-color!")
			}
			return arg0
		},
	},
	"ptr-circle//stroke-color?": {
		Doc:   "Get *canvas.Circle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color")
			return resObj
		},
	},
	"ptr-circle//stroke-width!": {
		Doc:   "Set *canvas.Circle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-circle//stroke-width!")
			}
			return arg0
		},
	},
	"ptr-circle//stroke-width?": {
		Doc:   "Get *canvas.Circle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"ptr-circle//visible": {
		Doc:   "(*canvas.Circle).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-circle//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-color-picker-dialog//advanced!": {
		Doc:   "Set *dialog.ColorPickerDialog Advanced value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//advanced!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//advanced!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//advanced!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Advanced = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-color-picker-dialog//advanced!")
			}
			return arg0
		},
	},
	"ptr-color-picker-dialog//advanced?": {
		Doc:   "Get *dialog.ColorPickerDialog Advanced value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//advanced?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//advanced?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//advanced?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Advanced))
			return resObj
		},
	},
	"ptr-color-picker-dialog//refresh": {
		Doc:   "(*dialog.ColorPickerDialog).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-color-picker-dialog//set-color": {
		Doc:   "(*dialog.ColorPickerDialog).SetColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//set-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//set-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//set-color")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-color-picker-dialog//set-color")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-color-picker-dialog//set-color")
			}
			arg0Val.SetColor(arg1Val)
			return arg0
		},
	},
	"ptr-color-picker-dialog//show": {
		Doc:   "(*dialog.ColorPickerDialog).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-color-picker-dialog//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-confirm-dialog//set-confirm-importance": {
		Doc:   "(*dialog.ConfirmDialog).SetConfirmImportance",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ConfirmDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ConfirmDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-confirm-dialog//set-confirm-importance")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-confirm-dialog//set-confirm-importance")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-confirm-dialog//set-confirm-importance")
			}
			var arg1Val widget.Importance
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-confirm-dialog//set-confirm-importance")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-confirm-dialog//set-confirm-importance")
			}
			arg0Val.SetConfirmImportance(arg1Val)
			return arg0
		},
	},
	"ptr-confirm-dialog//set-confirm-text": {
		Doc:   "(*dialog.ConfirmDialog).SetConfirmText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ConfirmDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ConfirmDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-confirm-dialog//set-confirm-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-confirm-dialog//set-confirm-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-confirm-dialog//set-confirm-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-confirm-dialog//set-confirm-text")
			}
			arg0Val.SetConfirmText(arg1Val)
			return arg0
		},
	},
	"ptr-container//add": {
		Doc:   "(*fyne.Container).Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//add")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//add")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//add")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//add")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"ptr-container//add-object": {
		Doc:   "(*fyne.Container).AddObject",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//add-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//add-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//add-object")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//add-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//add-object")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//add-object")
			}
			arg0Val.AddObject(arg1Val)
			return arg0
		},
	},
	"ptr-container//hidden!": {
		Doc:   "Set *fyne.Container Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-container//hidden!")
			}
			return arg0
		},
	},
	"ptr-container//hidden?": {
		Doc:   "Get *fyne.Container Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-container//hide": {
		Doc:   "(*fyne.Container).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-container//layout!": {
		Doc:   "Set *fyne.Container Layout value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//layout!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//layout!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//layout!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Layout, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//layout!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//layout!")
				}
				self.Layout = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//layout!")
			}
			return arg0
		},
	},
	"ptr-container//layout?": {
		Doc:   "Get *fyne.Container Layout value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//layout?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//layout?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//layout?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Layout, "layout")
			return resObj
		},
	},
	"ptr-container//min-size": {
		Doc:   "(*fyne.Container).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-container//move": {
		Doc:   "(*fyne.Container).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-container//objects!": {
		Doc:   "Set *fyne.Container Objects value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//objects!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//objects!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//objects!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Objects = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Objects[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-container//objects!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-container//objects!")
						}
						self.Objects[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-container//objects!")
					}
				}
			case env.Native:
				var ok bool
				self.Objects, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-container//objects!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-container//objects!")
				}
				self.Objects = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-container//objects!")
			}
			return arg0
		},
	},
	"ptr-container//objects?": {
		Doc:   "Get *fyne.Container Objects value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//objects?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//objects?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//objects?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Objects))
				for i, it := range self.Objects {
					items[i] = *env.NewNative(ps.Idx, it, "canvas-object")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-container//position": {
		Doc:   "(*fyne.Container).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-container//refresh": {
		Doc:   "(*fyne.Container).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-container//remove": {
		Doc:   "(*fyne.Container).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//remove")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"ptr-container//remove-all": {
		Doc:   "(*fyne.Container).RemoveAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//remove-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//remove-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//remove-all")
			}
			arg0Val.RemoveAll()
			return arg0
		},
	},
	"ptr-container//resize": {
		Doc:   "(*fyne.Container).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-container//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-container//show": {
		Doc:   "(*fyne.Container).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-container//size": {
		Doc:   "(*fyne.Container).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-container//visible": {
		Doc:   "(*fyne.Container).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-container//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-custom-dialog//set-buttons": {
		Doc:   "(*dialog.CustomDialog).SetButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.CustomDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.CustomDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-dialog//set-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-dialog//set-buttons")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-dialog//set-buttons")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-custom-dialog//set-buttons")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-custom-dialog//set-buttons")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-custom-dialog//set-buttons")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-custom-dialog//set-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-custom-dialog//set-buttons")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-custom-dialog//set-buttons")
			}
			arg0Val.SetButtons(arg1Val)
			return arg0
		},
	},
	"ptr-custom-shortcut//key": {
		Doc:   "(*desktop.CustomShortcut).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-name")
			return res0Obj
		},
	},
	"ptr-custom-shortcut//mod": {
		Doc:   "(*desktop.CustomShortcut).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-modifier")
			return res0Obj
		},
	},
	"ptr-custom-shortcut//modifier!": {
		Doc:   "Set *desktop.CustomShortcut Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//modifier!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//modifier!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//modifier!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Modifier, ok = v.Value.(fyne.KeyModifier)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-custom-shortcut//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-custom-shortcut//modifier!")
			}
			return arg0
		},
	},
	"ptr-custom-shortcut//modifier?": {
		Doc:   "Get *desktop.CustomShortcut Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//modifier?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//modifier?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//modifier?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Modifier, "key-modifier")
			return resObj
		},
	},
	"ptr-custom-shortcut//shortcut-name": {
		Doc:   "(*desktop.CustomShortcut).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-shortcut//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-custom-text-grid-style//background-color": {
		Doc:   "(*widget.CustomTextGridStyle).BackgroundColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//background-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//background-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//background-color")
			}
			res0 := arg0Val.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"ptr-custom-text-grid-style//bg-color!": {
		Doc:   "Set *widget.CustomTextGridStyle BGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//bg-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//bg-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//bg-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.BGColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//bg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//bg-color!")
			}
			return arg0
		},
	},
	"ptr-custom-text-grid-style//bg-color?": {
		Doc:   "Get *widget.CustomTextGridStyle BGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//bg-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//bg-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//bg-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.BGColor, "color")
			return resObj
		},
	},
	"ptr-custom-text-grid-style//fg-color!": {
		Doc:   "Set *widget.CustomTextGridStyle FGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//fg-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//fg-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//fg-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FGColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//fg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//fg-color!")
			}
			return arg0
		},
	},
	"ptr-custom-text-grid-style//fg-color?": {
		Doc:   "Get *widget.CustomTextGridStyle FGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//fg-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//fg-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//fg-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FGColor, "color")
			return resObj
		},
	},
	"ptr-custom-text-grid-style//text-color": {
		Doc:   "(*widget.CustomTextGridStyle).TextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//text-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//text-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-custom-text-grid-style//text-color")
			}
			res0 := arg0Val.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"ptr-delta//dx!": {
		Doc:   "Set *fyne.Delta DX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dx!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dx!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dx!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DX = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-delta//dx!")
			}
			return arg0
		},
	},
	"ptr-delta//dx?": {
		Doc:   "Get *fyne.Delta DX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dx?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dx?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dx?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DX))
			return resObj
		},
	},
	"ptr-delta//dy!": {
		Doc:   "Set *fyne.Delta DY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dy!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dy!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dy!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DY = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-delta//dy!")
			}
			return arg0
		},
	},
	"ptr-delta//dy?": {
		Doc:   "Get *fyne.Delta DY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dy?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dy?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-delta//dy?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DY))
			return resObj
		},
	},
	"ptr-disableable-widget//disable": {
		Doc:   "(*widget.DisableableWidget).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-disableable-widget//disabled": {
		Doc:   "(*widget.DisableableWidget).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-disableable-widget//enable": {
		Doc:   "(*widget.DisableableWidget).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-disableable-widget//extend-base-widget": {
		Doc:   "(*widget.DisableableWidget).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-disableable-widget//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-disableable-widget//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-disableable-widget//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-disableable-widget//hidden!": {
		Doc:   "Set *widget.DisableableWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-disableable-widget//hidden!")
			}
			return arg0
		},
	},
	"ptr-disableable-widget//hidden?": {
		Doc:   "Get *widget.DisableableWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-disableable-widget//hide": {
		Doc:   "(*widget.DisableableWidget).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-disableable-widget//min-size": {
		Doc:   "(*widget.DisableableWidget).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-disableable-widget//move": {
		Doc:   "(*widget.DisableableWidget).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-disableable-widget//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-disableable-widget//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-disableable-widget//position": {
		Doc:   "(*widget.DisableableWidget).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-disableable-widget//refresh": {
		Doc:   "(*widget.DisableableWidget).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-disableable-widget//resize": {
		Doc:   "(*widget.DisableableWidget).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-disableable-widget//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-disableable-widget//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-disableable-widget//show": {
		Doc:   "(*widget.DisableableWidget).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-disableable-widget//size": {
		Doc:   "(*widget.DisableableWidget).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-disableable-widget//visible": {
		Doc:   "(*widget.DisableableWidget).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disableable-widget//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-disabled-resource//content": {
		Doc:   "(*theme.DisabledResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.DisabledResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.DisabledResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disabled-resource//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disabled-resource//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disabled-resource//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-disabled-resource//name": {
		Doc:   "(*theme.DisabledResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.DisabledResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.DisabledResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disabled-resource//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disabled-resource//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-disabled-resource//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-doc-tabs//append": {
		Doc:   "(*container.DocTabs).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//append")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//close-intercept!": {
		Doc:   "Set *container.DocTabs CloseIntercept value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//close-intercept!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//close-intercept!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//close-intercept!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//close-intercept!")
				}
				self.CloseIntercept = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//close-intercept!")
				}
				self.CloseIntercept = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//close-intercept!")
			}
			return arg0
		},
	},
	"ptr-doc-tabs//close-intercept?": {
		Doc:   "Get *container.DocTabs CloseIntercept value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//close-intercept?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//close-intercept?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//close-intercept?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CloseIntercept, "func(ptr-tab-item)")
			return resObj
		},
	},
	"ptr-doc-tabs//create-renderer": {
		Doc:   "(*container.DocTabs).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-doc-tabs//create-tab!": {
		Doc:   "Set *container.DocTabs CreateTab value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//create-tab!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//create-tab!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//create-tab!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//create-tab!")
				}
				self.CreateTab = func() *container.TabItem {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res *container.TabItem
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(*container.TabItem)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//create-tab!")
				}
				self.CreateTab = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//create-tab!")
			}
			return arg0
		},
	},
	"ptr-doc-tabs//create-tab?": {
		Doc:   "Get *container.DocTabs CreateTab value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//create-tab?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//create-tab?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//create-tab?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateTab, "func()_(ptr-tab-item)")
			return resObj
		},
	},
	"ptr-doc-tabs//disable-index": {
		Doc:   "(*container.DocTabs).DisableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//disable-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//disable-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//disable-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-doc-tabs//disable-index")
			}
			arg0Val.DisableIndex(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//disable-item": {
		Doc:   "(*container.DocTabs).DisableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//disable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//disable-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//disable-item")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//disable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//disable-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//disable-item")
			}
			arg0Val.DisableItem(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//enable-index": {
		Doc:   "(*container.DocTabs).EnableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//enable-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//enable-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//enable-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-doc-tabs//enable-index")
			}
			arg0Val.EnableIndex(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//enable-item": {
		Doc:   "(*container.DocTabs).EnableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//enable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//enable-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//enable-item")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//enable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//enable-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//enable-item")
			}
			arg0Val.EnableItem(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//extend-base-widget": {
		Doc:   "(*container.DocTabs).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//hidden!": {
		Doc:   "Set *container.DocTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-doc-tabs//hidden!")
			}
			return arg0
		},
	},
	"ptr-doc-tabs//hidden?": {
		Doc:   "Get *container.DocTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-doc-tabs//hide": {
		Doc:   "(*container.DocTabs).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-doc-tabs//items!": {
		Doc:   "Set *container.DocTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//items!")
			}
			return arg0
		},
	},
	"ptr-doc-tabs//items?": {
		Doc:   "Get *container.DocTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-tab-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-doc-tabs//min-size": {
		Doc:   "(*container.DocTabs).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-doc-tabs//move": {
		Doc:   "(*container.DocTabs).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//on-closed!": {
		Doc:   "Set *container.DocTabs OnClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-closed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-closed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-closed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//on-closed!")
				}
				self.OnClosed = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//on-closed!")
				}
				self.OnClosed = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//on-closed!")
			}
			return arg0
		},
	},
	"ptr-doc-tabs//on-closed?": {
		Doc:   "Get *container.DocTabs OnClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-closed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-closed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-closed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnClosed, "func(ptr-tab-item)")
			return resObj
		},
	},
	"ptr-doc-tabs//on-selected!": {
		Doc:   "Set *container.DocTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//on-selected!")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//on-selected!")
			}
			return arg0
		},
	},
	"ptr-doc-tabs//on-selected?": {
		Doc:   "Get *container.DocTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(ptr-tab-item)")
			return resObj
		},
	},
	"ptr-doc-tabs//on-unselected!": {
		Doc:   "Set *container.DocTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-unselected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-unselected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//on-unselected!")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "ptr-tab-item")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-doc-tabs//on-unselected!")
			}
			return arg0
		},
	},
	"ptr-doc-tabs//on-unselected?": {
		Doc:   "Get *container.DocTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-unselected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-unselected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(ptr-tab-item)")
			return resObj
		},
	},
	"ptr-doc-tabs//position": {
		Doc:   "(*container.DocTabs).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-doc-tabs//refresh": {
		Doc:   "(*container.DocTabs).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-doc-tabs//remove": {
		Doc:   "(*container.DocTabs).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//remove")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//remove-index": {
		Doc:   "(*container.DocTabs).RemoveIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//remove-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//remove-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//remove-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-doc-tabs//remove-index")
			}
			arg0Val.RemoveIndex(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//resize": {
		Doc:   "(*container.DocTabs).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//select": {
		Doc:   "(*container.DocTabs).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//select")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//select")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//select")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//select-index": {
		Doc:   "(*container.DocTabs).SelectIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//select-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//select-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//select-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-doc-tabs//select-index")
			}
			arg0Val.SelectIndex(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//selected": {
		Doc:   "(*container.DocTabs).Selected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//selected")
			}
			res0 := arg0Val.Selected()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-tab-item")
			return res0Obj
		},
	},
	"ptr-doc-tabs//selected-index": {
		Doc:   "(*container.DocTabs).SelectedIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//selected-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//selected-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//selected-index")
			}
			res0 := arg0Val.SelectedIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-doc-tabs//set-items": {
		Doc:   "(*container.DocTabs).SetItems",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//set-items")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//set-items")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//set-items")
			}
			var arg1Val []*container.TabItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//set-items")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//set-items")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//set-items")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//set-items")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//set-items")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-doc-tabs//set-items")
			}
			arg0Val.SetItems(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//set-tab-location": {
		Doc:   "(*container.DocTabs).SetTabLocation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//set-tab-location")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//set-tab-location")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//set-tab-location")
			}
			var arg1Val container.TabLocation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(container.TabLocation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//set-tab-location")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-doc-tabs//set-tab-location")
			}
			arg0Val.SetTabLocation(arg1Val)
			return arg0
		},
	},
	"ptr-doc-tabs//show": {
		Doc:   "(*container.DocTabs).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-doc-tabs//size": {
		Doc:   "(*container.DocTabs).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-doc-tabs//visible": {
		Doc:   "(*container.DocTabs).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-doc-tabs//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-drag-event//absolute-position!": {
		Doc:   "Set *fyne.DragEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-drag-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-drag-event//absolute-position!")
			}
			return arg0
		},
	},
	"ptr-drag-event//absolute-position?": {
		Doc:   "Get *fyne.DragEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"ptr-drag-event//dragged!": {
		Doc:   "Set *fyne.DragEvent Dragged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//dragged!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//dragged!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//dragged!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Dragged, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-drag-event//dragged!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-drag-event//dragged!")
			}
			return arg0
		},
	},
	"ptr-drag-event//dragged?": {
		Doc:   "Get *fyne.DragEvent Dragged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//dragged?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//dragged?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//dragged?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Dragged, "delta")
			return resObj
		},
	},
	"ptr-drag-event//position!": {
		Doc:   "Set *fyne.DragEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-drag-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-drag-event//position!")
			}
			return arg0
		},
	},
	"ptr-drag-event//position?": {
		Doc:   "Get *fyne.DragEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-drag-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"ptr-entry-dialog//set-on-closed": {
		Doc:   "(*dialog.EntryDialog).SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//set-on-closed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//set-on-closed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//set-on-closed")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry-dialog//set-on-closed")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-entry-dialog//set-on-closed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry-dialog//set-on-closed")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"ptr-entry-dialog//set-placeholder": {
		Doc:   "(*dialog.EntryDialog).SetPlaceholder",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//set-placeholder")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//set-placeholder")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//set-placeholder")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-entry-dialog//set-placeholder")
			}
			arg0Val.SetPlaceholder(arg1Val)
			return arg0
		},
	},
	"ptr-entry-dialog//set-text": {
		Doc:   "(*dialog.EntryDialog).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-entry-dialog//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-entry-dialog//submit": {
		Doc:   "(*dialog.EntryDialog).Submit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//submit")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//submit")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry-dialog//submit")
			}
			arg0Val.Submit()
			return arg0
		},
	},
	"ptr-entry//accepts-tab": {
		Doc:   "(*widget.Entry).AcceptsTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//accepts-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//accepts-tab")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//accepts-tab")
			}
			res0 := arg0Val.AcceptsTab()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-entry//action-item!": {
		Doc:   "Set *widget.Entry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//action-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//action-item!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//action-item!")
				}
				self.ActionItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//action-item!")
			}
			return arg0
		},
	},
	"ptr-entry//action-item?": {
		Doc:   "Get *widget.Entry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//action-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//action-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//action-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ActionItem, "canvas-object")
			return resObj
		},
	},
	"ptr-entry//append": {
		Doc:   "(*widget.Entry).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-entry//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-entry//bind": {
		Doc:   "(*widget.Entry).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//bind")
			}
			var arg1Val binding.String
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-entry//create-renderer": {
		Doc:   "(*widget.Entry).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-entry//cursor": {
		Doc:   "(*widget.Entry).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "cursor")
			return res0Obj
		},
	},
	"ptr-entry//cursor-column!": {
		Doc:   "Set *widget.Entry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-column!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-column!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-entry//cursor-column!")
			}
			return arg0
		},
	},
	"ptr-entry//cursor-column?": {
		Doc:   "Get *widget.Entry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-column?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-column?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"ptr-entry//cursor-row!": {
		Doc:   "Set *widget.Entry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-row!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-row!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-entry//cursor-row!")
			}
			return arg0
		},
	},
	"ptr-entry//cursor-row?": {
		Doc:   "Get *widget.Entry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-row?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-row?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//cursor-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"ptr-entry//disable": {
		Doc:   "(*widget.Entry).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-entry//disabled": {
		Doc:   "(*widget.Entry).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-entry//double-tapped": {
		Doc:   "(*widget.Entry).DoubleTapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//double-tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//double-tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//double-tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//double-tapped")
			}
			arg0Val.DoubleTapped(arg1Val)
			return arg0
		},
	},
	"ptr-entry//drag-end": {
		Doc:   "(*widget.Entry).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//drag-end")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//drag-end")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//drag-end")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"ptr-entry//dragged": {
		Doc:   "(*widget.Entry).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//dragged")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//dragged")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//dragged")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//dragged")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"ptr-entry//enable": {
		Doc:   "(*widget.Entry).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-entry//extend-base-widget": {
		Doc:   "(*widget.Entry).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-entry//focus-gained": {
		Doc:   "(*widget.Entry).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-entry//focus-lost": {
		Doc:   "(*widget.Entry).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-entry//hidden!": {
		Doc:   "Set *widget.Entry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-entry//hidden!")
			}
			return arg0
		},
	},
	"ptr-entry//hidden?": {
		Doc:   "Get *widget.Entry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-entry//hide": {
		Doc:   "(*widget.Entry).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-entry//key-down": {
		Doc:   "(*widget.Entry).KeyDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//key-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//key-down")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//key-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//key-down")
			}
			arg0Val.KeyDown(arg1Val)
			return arg0
		},
	},
	"ptr-entry//key-up": {
		Doc:   "(*widget.Entry).KeyUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//key-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//key-up")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//key-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//key-up")
			}
			arg0Val.KeyUp(arg1Val)
			return arg0
		},
	},
	"ptr-entry//keyboard": {
		Doc:   "(*widget.Entry).Keyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//keyboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//keyboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//keyboard")
			}
			res0 := arg0Val.Keyboard()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "keyboard-type")
			return res0Obj
		},
	},
	"ptr-entry//min-size": {
		Doc:   "(*widget.Entry).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-entry//mouse-down": {
		Doc:   "(*widget.Entry).MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//mouse-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//mouse-down")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//mouse-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//mouse-down")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"ptr-entry//mouse-up": {
		Doc:   "(*widget.Entry).MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//mouse-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//mouse-up")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//mouse-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//mouse-up")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"ptr-entry//move": {
		Doc:   "(*widget.Entry).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-entry//multi-line!": {
		Doc:   "Set *widget.Entry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//multi-line!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//multi-line!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//multi-line!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-entry//multi-line!")
			}
			return arg0
		},
	},
	"ptr-entry//multi-line?": {
		Doc:   "Get *widget.Entry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//multi-line?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//multi-line?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//multi-line?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"ptr-entry//on-changed!": {
		Doc:   "Set *widget.Entry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-entry//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry//on-changed!")
			}
			return arg0
		},
	},
	"ptr-entry//on-changed?": {
		Doc:   "Get *widget.Entry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"ptr-entry//on-cursor-changed!": {
		Doc:   "Set *widget.Entry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-cursor-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-cursor-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-cursor-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry//on-cursor-changed!")
			}
			return arg0
		},
	},
	"ptr-entry//on-cursor-changed?": {
		Doc:   "Get *widget.Entry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-cursor-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-cursor-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-cursor-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "func()")
			return resObj
		},
	},
	"ptr-entry//on-submitted!": {
		Doc:   "Set *widget.Entry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-submitted!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-submitted!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-submitted!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry//on-submitted!")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-entry//on-submitted!")
				}
				self.OnSubmitted = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry//on-submitted!")
			}
			return arg0
		},
	},
	"ptr-entry//on-submitted?": {
		Doc:   "Get *widget.Entry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-submitted?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-submitted?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//on-submitted?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "func(string)")
			return resObj
		},
	},
	"ptr-entry//password!": {
		Doc:   "Set *widget.Entry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//password!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//password!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//password!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-entry//password!")
			}
			return arg0
		},
	},
	"ptr-entry//password?": {
		Doc:   "Get *widget.Entry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//password?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//password?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//password?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"ptr-entry//place-holder!": {
		Doc:   "Set *widget.Entry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//place-holder!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//place-holder!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-entry//place-holder!")
			}
			return arg0
		},
	},
	"ptr-entry//place-holder?": {
		Doc:   "Get *widget.Entry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//place-holder?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//place-holder?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"ptr-entry//position": {
		Doc:   "(*widget.Entry).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-entry//refresh": {
		Doc:   "(*widget.Entry).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-entry//resize": {
		Doc:   "(*widget.Entry).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-entry//scroll!": {
		Doc:   "Set *widget.Entry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//scroll!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//scroll!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//scroll!")
			}
			return arg0
		},
	},
	"ptr-entry//scroll?": {
		Doc:   "Get *widget.Entry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//scroll?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//scroll?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "scroll-direction")
			return resObj
		},
	},
	"ptr-entry//selected-text": {
		Doc:   "(*widget.Entry).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-entry//set-min-rows-visible": {
		Doc:   "(*widget.Entry).SetMinRowsVisible",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-min-rows-visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-min-rows-visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-min-rows-visible")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-entry//set-min-rows-visible")
			}
			arg0Val.SetMinRowsVisible(arg1Val)
			return arg0
		},
	},
	"ptr-entry//set-on-validation-changed": {
		Doc:   "(*widget.Entry).SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-on-validation-changed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-on-validation-changed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-on-validation-changed")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry//set-on-validation-changed")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-entry//set-on-validation-changed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-entry//set-on-validation-changed")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"ptr-entry//set-place-holder": {
		Doc:   "(*widget.Entry).SetPlaceHolder",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-place-holder")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-place-holder")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-place-holder")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-entry//set-place-holder")
			}
			arg0Val.SetPlaceHolder(arg1Val)
			return arg0
		},
	},
	"ptr-entry//set-text": {
		Doc:   "(*widget.Entry).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-entry//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-entry//set-validation-error": {
		Doc:   "(*widget.Entry).SetValidationError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-validation-error")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-validation-error")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//set-validation-error")
			}
			var arg1Val error
			if v, ok := arg1.(env.Error); ok {
				arg1Val = errors.New(v.Print(*ps.Idx))
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.ErrorType}, "ptr-entry//set-validation-error")
			}
			arg0Val.SetValidationError(arg1Val)
			return arg0
		},
	},
	"ptr-entry//show": {
		Doc:   "(*widget.Entry).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-entry//size": {
		Doc:   "(*widget.Entry).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-entry//tapped": {
		Doc:   "(*widget.Entry).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-entry//tapped-secondary": {
		Doc:   "(*widget.Entry).TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//tapped-secondary")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//tapped-secondary")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//tapped-secondary")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//tapped-secondary")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"ptr-entry//text!": {
		Doc:   "Set *widget.Entry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-entry//text!")
			}
			return arg0
		},
	},
	"ptr-entry//text-style!": {
		Doc:   "Set *widget.Entry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//text-style!")
			}
			return arg0
		},
	},
	"ptr-entry//text-style?": {
		Doc:   "Get *widget.Entry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"ptr-entry//text?": {
		Doc:   "Get *widget.Entry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-entry//touch-cancel": {
		Doc:   "(*widget.Entry).TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//touch-cancel")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//touch-cancel")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//touch-cancel")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//touch-cancel")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"ptr-entry//touch-down": {
		Doc:   "(*widget.Entry).TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//touch-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//touch-down")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//touch-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//touch-down")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"ptr-entry//touch-up": {
		Doc:   "(*widget.Entry).TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//touch-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//touch-up")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//touch-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//touch-up")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"ptr-entry//typed-key": {
		Doc:   "(*widget.Entry).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-entry//typed-rune": {
		Doc:   "(*widget.Entry).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-entry//typed-shortcut": {
		Doc:   "(*widget.Entry).TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//typed-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//typed-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//typed-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//typed-shortcut")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"ptr-entry//unbind": {
		Doc:   "(*widget.Entry).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-entry//validate": {
		Doc:   "(*widget.Entry).Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//validate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//validate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//validate")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-entry//validator!": {
		Doc:   "Set *widget.Entry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//validator!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//validator!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//validator!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Validator, ok = v.Value.(fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//validator!")
			}
			return arg0
		},
	},
	"ptr-entry//validator?": {
		Doc:   "Get *widget.Entry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//validator?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//validator?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//validator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Validator, "string-validator")
			return resObj
		},
	},
	"ptr-entry//visible": {
		Doc:   "(*widget.Entry).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-entry//wrapping!": {
		Doc:   "Set *widget.Entry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//wrapping!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//wrapping!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-entry//wrapping!")
			}
			return arg0
		},
	},
	"ptr-entry//wrapping?": {
		Doc:   "Get *widget.Entry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//wrapping?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//wrapping?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-entry//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"ptr-error-themed-resource//content": {
		Doc:   "(*theme.ErrorThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ErrorThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ErrorThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-error-themed-resource//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-error-themed-resource//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-error-themed-resource//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-error-themed-resource//name": {
		Doc:   "(*theme.ErrorThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ErrorThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ErrorThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-error-themed-resource//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-error-themed-resource//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-error-themed-resource//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-error-themed-resource//original": {
		Doc:   "(*theme.ErrorThemedResource).Original",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ErrorThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ErrorThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-error-themed-resource//original")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-error-themed-resource//original")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-error-themed-resource//original")
			}
			res0 := arg0Val.Original()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"ptr-extension-file-filter//extensions!": {
		Doc:   "Set *storage.ExtensionFileFilter Extensions value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-extension-file-filter//extensions!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-extension-file-filter//extensions!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-extension-file-filter//extensions!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Extensions = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Extensions[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-extension-file-filter//extensions!")
					}
				}
			case env.Native:
				var ok bool
				self.Extensions, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-extension-file-filter//extensions!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-extension-file-filter//extensions!")
				}
				self.Extensions = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-extension-file-filter//extensions!")
			}
			return arg0
		},
	},
	"ptr-extension-file-filter//extensions?": {
		Doc:   "Get *storage.ExtensionFileFilter Extensions value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-extension-file-filter//extensions?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-extension-file-filter//extensions?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-extension-file-filter//extensions?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Extensions))
				for i, it := range self.Extensions {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-extension-file-filter//matches": {
		Doc:   "(*storage.ExtensionFileFilter).Matches",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-extension-file-filter//matches")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-extension-file-filter//matches")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-extension-file-filter//matches")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-extension-file-filter//matches")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-extension-file-filter//matches")
			}
			res0 := arg0Val.Matches(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-file-icon//create-renderer": {
		Doc:   "(*widget.FileIcon).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-file-icon//extend-base-widget": {
		Doc:   "(*widget.FileIcon).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-file-icon//hidden!": {
		Doc:   "Set *widget.FileIcon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-file-icon//hidden!")
			}
			return arg0
		},
	},
	"ptr-file-icon//hidden?": {
		Doc:   "Get *widget.FileIcon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-file-icon//hide": {
		Doc:   "(*widget.FileIcon).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-file-icon//min-size": {
		Doc:   "(*widget.FileIcon).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-file-icon//move": {
		Doc:   "(*widget.FileIcon).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-file-icon//position": {
		Doc:   "(*widget.FileIcon).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-file-icon//refresh": {
		Doc:   "(*widget.FileIcon).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-file-icon//resize": {
		Doc:   "(*widget.FileIcon).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-file-icon//selected!": {
		Doc:   "Set *widget.FileIcon Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//selected!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Selected = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-file-icon//selected!")
			}
			return arg0
		},
	},
	"ptr-file-icon//selected?": {
		Doc:   "Get *widget.FileIcon Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//selected?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Selected))
			return resObj
		},
	},
	"ptr-file-icon//set-selected": {
		Doc:   "(*widget.FileIcon).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//set-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//set-selected")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-file-icon//set-selected")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"ptr-file-icon//set-uri": {
		Doc:   "(*widget.FileIcon).SetURI",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//set-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//set-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//set-uri")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//set-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//set-uri")
			}
			arg0Val.SetURI(arg1Val)
			return arg0
		},
	},
	"ptr-file-icon//show": {
		Doc:   "(*widget.FileIcon).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-file-icon//size": {
		Doc:   "(*widget.FileIcon).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-file-icon//uri!": {
		Doc:   "Set *widget.FileIcon URI value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//uri!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//uri!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//uri!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URI, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//uri!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-file-icon//uri!")
			}
			return arg0
		},
	},
	"ptr-file-icon//uri?": {
		Doc:   "Get *widget.FileIcon URI value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//uri?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//uri?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//uri?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URI, "uri")
			return resObj
		},
	},
	"ptr-file-icon//visible": {
		Doc:   "(*widget.FileIcon).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-file-icon//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-form-dialog//submit": {
		Doc:   "(*dialog.FormDialog).Submit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FormDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FormDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-dialog//submit")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-dialog//submit")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-dialog//submit")
			}
			arg0Val.Submit()
			return arg0
		},
	},
	"ptr-form-item//hint-text!": {
		Doc:   "Set *widget.FormItem HintText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//hint-text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//hint-text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//hint-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.HintText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-form-item//hint-text!")
			}
			return arg0
		},
	},
	"ptr-form-item//hint-text?": {
		Doc:   "Get *widget.FormItem HintText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//hint-text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//hint-text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//hint-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.HintText)
			return resObj
		},
	},
	"ptr-form-item//text!": {
		Doc:   "Set *widget.FormItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-form-item//text!")
			}
			return arg0
		},
	},
	"ptr-form-item//text?": {
		Doc:   "Get *widget.FormItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-form-item//widget!": {
		Doc:   "Set *widget.FormItem Widget value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//widget!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//widget!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//widget!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Widget, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form-item//widget!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form-item//widget!")
				}
				self.Widget = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form-item//widget!")
			}
			return arg0
		},
	},
	"ptr-form-item//widget?": {
		Doc:   "Get *widget.FormItem Widget value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//widget?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//widget?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form-item//widget?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Widget, "canvas-object")
			return resObj
		},
	},
	"ptr-form//append": {
		Doc:   "(*widget.Form).Append",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-form//append")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-form//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-form//append")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-form//append")
			}
			arg0Val.Append(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-form//append-item": {
		Doc:   "(*widget.Form).AppendItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//append-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//append-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//append-item")
			}
			var arg1Val *widget.FormItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//append-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//append-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//append-item")
			}
			arg0Val.AppendItem(arg1Val)
			return arg0
		},
	},
	"ptr-form//cancel-text!": {
		Doc:   "Set *widget.Form CancelText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//cancel-text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//cancel-text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//cancel-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CancelText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-form//cancel-text!")
			}
			return arg0
		},
	},
	"ptr-form//cancel-text?": {
		Doc:   "Get *widget.Form CancelText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//cancel-text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//cancel-text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//cancel-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CancelText)
			return resObj
		},
	},
	"ptr-form//create-renderer": {
		Doc:   "(*widget.Form).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-form//disable": {
		Doc:   "(*widget.Form).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-form//disabled": {
		Doc:   "(*widget.Form).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-form//enable": {
		Doc:   "(*widget.Form).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-form//extend-base-widget": {
		Doc:   "(*widget.Form).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-form//hidden!": {
		Doc:   "Set *widget.Form Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-form//hidden!")
			}
			return arg0
		},
	},
	"ptr-form//hidden?": {
		Doc:   "Get *widget.Form Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-form//hide": {
		Doc:   "(*widget.Form).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-form//items!": {
		Doc:   "Set *widget.Form Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.FormItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.FormItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-form//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-form//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-form//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-form//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-form//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-form//items!")
			}
			return arg0
		},
	},
	"ptr-form//items?": {
		Doc:   "Get *widget.Form Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-form-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-form//min-size": {
		Doc:   "(*widget.Form).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-form//move": {
		Doc:   "(*widget.Form).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-form//on-cancel!": {
		Doc:   "Set *widget.Form OnCancel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-cancel!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-cancel!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-cancel!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-form//on-cancel!")
				}
				self.OnCancel = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-form//on-cancel!")
				}
				self.OnCancel = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-form//on-cancel!")
			}
			return arg0
		},
	},
	"ptr-form//on-cancel?": {
		Doc:   "Get *widget.Form OnCancel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-cancel?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-cancel?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-cancel?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCancel, "func()")
			return resObj
		},
	},
	"ptr-form//on-submit!": {
		Doc:   "Set *widget.Form OnSubmit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-submit!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-submit!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-submit!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-form//on-submit!")
				}
				self.OnSubmit = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-form//on-submit!")
				}
				self.OnSubmit = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-form//on-submit!")
			}
			return arg0
		},
	},
	"ptr-form//on-submit?": {
		Doc:   "Get *widget.Form OnSubmit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-submit?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-submit?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//on-submit?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmit, "func()")
			return resObj
		},
	},
	"ptr-form//position": {
		Doc:   "(*widget.Form).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-form//refresh": {
		Doc:   "(*widget.Form).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-form//resize": {
		Doc:   "(*widget.Form).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-form//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-form//set-on-validation-changed": {
		Doc:   "(*widget.Form).SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//set-on-validation-changed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//set-on-validation-changed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//set-on-validation-changed")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-form//set-on-validation-changed")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-form//set-on-validation-changed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-form//set-on-validation-changed")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"ptr-form//show": {
		Doc:   "(*widget.Form).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-form//size": {
		Doc:   "(*widget.Form).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-form//submit-text!": {
		Doc:   "Set *widget.Form SubmitText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//submit-text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//submit-text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//submit-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.SubmitText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-form//submit-text!")
			}
			return arg0
		},
	},
	"ptr-form//submit-text?": {
		Doc:   "Get *widget.Form SubmitText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//submit-text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//submit-text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//submit-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.SubmitText)
			return resObj
		},
	},
	"ptr-form//validate": {
		Doc:   "(*widget.Form).Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//validate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//validate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//validate")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-form//visible": {
		Doc:   "(*widget.Form).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-form//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-grid-wrap//create-item!": {
		Doc:   "Set *widget.GridWrap CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//create-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//create-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//create-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//create-item!")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-grid-wrap//create-item!")
				}
				self.CreateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//create-item!")
			}
			return arg0
		},
	},
	"ptr-grid-wrap//create-item?": {
		Doc:   "Get *widget.GridWrap CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//create-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//create-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//create-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "func()_(canvas-object)")
			return resObj
		},
	},
	"ptr-grid-wrap//create-renderer": {
		Doc:   "(*widget.GridWrap).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-grid-wrap//extend-base-widget": {
		Doc:   "(*widget.GridWrap).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//focus-gained": {
		Doc:   "(*widget.GridWrap).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-grid-wrap//focus-lost": {
		Doc:   "(*widget.GridWrap).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-grid-wrap//get-scroll-offset": {
		Doc:   "(*widget.GridWrap).GetScrollOffset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//get-scroll-offset")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//get-scroll-offset")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//get-scroll-offset")
			}
			res0 := arg0Val.GetScrollOffset()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-grid-wrap//hidden!": {
		Doc:   "Set *widget.GridWrap Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-grid-wrap//hidden!")
			}
			return arg0
		},
	},
	"ptr-grid-wrap//hidden?": {
		Doc:   "Get *widget.GridWrap Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-grid-wrap//hide": {
		Doc:   "(*widget.GridWrap).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-grid-wrap//length!": {
		Doc:   "Set *widget.GridWrap Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//length!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//length!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//length!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//length!")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-grid-wrap//length!")
				}
				self.Length = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//length!")
			}
			return arg0
		},
	},
	"ptr-grid-wrap//length?": {
		Doc:   "Get *widget.GridWrap Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//length?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//length?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//length?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int)")
			return resObj
		},
	},
	"ptr-grid-wrap//min-size": {
		Doc:   "(*widget.GridWrap).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-grid-wrap//move": {
		Doc:   "(*widget.GridWrap).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//on-selected!": {
		Doc:   "Set *widget.GridWrap OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//on-selected!")
				}
				self.OnSelected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "grid-wrap-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-grid-wrap//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//on-selected!")
			}
			return arg0
		},
	},
	"ptr-grid-wrap//on-selected?": {
		Doc:   "Get *widget.GridWrap OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(grid-wrap-item-id)")
			return resObj
		},
	},
	"ptr-grid-wrap//on-unselected!": {
		Doc:   "Set *widget.GridWrap OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-unselected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-unselected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "grid-wrap-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-grid-wrap//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//on-unselected!")
			}
			return arg0
		},
	},
	"ptr-grid-wrap//on-unselected?": {
		Doc:   "Get *widget.GridWrap OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-unselected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-unselected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(grid-wrap-item-id)")
			return resObj
		},
	},
	"ptr-grid-wrap//position": {
		Doc:   "(*widget.GridWrap).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-grid-wrap//refresh": {
		Doc:   "(*widget.GridWrap).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-grid-wrap//refresh-item": {
		Doc:   "(*widget.GridWrap).RefreshItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//refresh-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//refresh-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//refresh-item")
			}
			var arg1Val widget.GridWrapItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.GridWrapItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//refresh-item")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//refresh-item")
			}
			arg0Val.RefreshItem(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//resize": {
		Doc:   "(*widget.GridWrap).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//scroll-to": {
		Doc:   "(*widget.GridWrap).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to")
			}
			var arg1Val widget.GridWrapItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.GridWrapItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to")
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//scroll-to-bottom": {
		Doc:   "(*widget.GridWrap).ScrollToBottom",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to-bottom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to-bottom")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to-bottom")
			}
			arg0Val.ScrollToBottom()
			return arg0
		},
	},
	"ptr-grid-wrap//scroll-to-offset": {
		Doc:   "(*widget.GridWrap).ScrollToOffset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to-offset")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to-offset")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to-offset")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-grid-wrap//scroll-to-offset")
			}
			arg0Val.ScrollToOffset(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//scroll-to-top": {
		Doc:   "(*widget.GridWrap).ScrollToTop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to-top")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to-top")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//scroll-to-top")
			}
			arg0Val.ScrollToTop()
			return arg0
		},
	},
	"ptr-grid-wrap//select": {
		Doc:   "(*widget.GridWrap).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//select")
			}
			var arg1Val widget.GridWrapItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.GridWrapItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//select")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//show": {
		Doc:   "(*widget.GridWrap).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-grid-wrap//size": {
		Doc:   "(*widget.GridWrap).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-grid-wrap//typed-key": {
		Doc:   "(*widget.GridWrap).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//typed-rune": {
		Doc:   "(*widget.GridWrap).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//unselect": {
		Doc:   "(*widget.GridWrap).Unselect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//unselect")
			}
			var arg1Val widget.GridWrapItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.GridWrapItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//unselect")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-grid-wrap//unselect")
			}
			arg0Val.Unselect(arg1Val)
			return arg0
		},
	},
	"ptr-grid-wrap//unselect-all": {
		Doc:   "(*widget.GridWrap).UnselectAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//unselect-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//unselect-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//unselect-all")
			}
			arg0Val.UnselectAll()
			return arg0
		},
	},
	"ptr-grid-wrap//update-item!": {
		Doc:   "Set *widget.GridWrap UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//update-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//update-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//update-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//update-item!")
				}
				self.UpdateItem = func(arg0 widget.GridWrapItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "grid-wrap-item-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-grid-wrap//update-item!")
				}
				self.UpdateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-grid-wrap//update-item!")
			}
			return arg0
		},
	},
	"ptr-grid-wrap//update-item?": {
		Doc:   "Get *widget.GridWrap UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//update-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//update-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//update-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "func(grid-wrap-item-id_canvas-object)")
			return resObj
		},
	},
	"ptr-grid-wrap//visible": {
		Doc:   "(*widget.GridWrap).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-grid-wrap//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-hardware-key//scan-code!": {
		Doc:   "Set *fyne.HardwareKey ScanCode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hardware-key//scan-code!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hardware-key//scan-code!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hardware-key//scan-code!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScanCode = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-hardware-key//scan-code!")
			}
			return arg0
		},
	},
	"ptr-hardware-key//scan-code?": {
		Doc:   "Get *fyne.HardwareKey ScanCode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hardware-key//scan-code?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hardware-key//scan-code?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hardware-key//scan-code?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.ScanCode))
			return resObj
		},
	},
	"ptr-hyperlink-segment//alignment!": {
		Doc:   "Set *widget.HyperlinkSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//alignment!")
			}
			return arg0
		},
	},
	"ptr-hyperlink-segment//alignment?": {
		Doc:   "Get *widget.HyperlinkSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"ptr-hyperlink-segment//inline": {
		Doc:   "(*widget.HyperlinkSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-hyperlink-segment//on-tapped!": {
		Doc:   "Set *widget.HyperlinkSegment OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//on-tapped!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//on-tapped!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-hyperlink-segment//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-hyperlink-segment//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-hyperlink-segment//on-tapped!")
			}
			return arg0
		},
	},
	"ptr-hyperlink-segment//on-tapped?": {
		Doc:   "Get *widget.HyperlinkSegment OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//on-tapped?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//on-tapped?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"ptr-hyperlink-segment//select": {
		Doc:   "(*widget.HyperlinkSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-hyperlink-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-hyperlink-segment//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-hyperlink-segment//selected-text": {
		Doc:   "(*widget.HyperlinkSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-hyperlink-segment//text!": {
		Doc:   "Set *widget.HyperlinkSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-hyperlink-segment//text!")
			}
			return arg0
		},
	},
	"ptr-hyperlink-segment//text?": {
		Doc:   "Get *widget.HyperlinkSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-hyperlink-segment//textual": {
		Doc:   "(*widget.HyperlinkSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-hyperlink-segment//unselect": {
		Doc:   "(*widget.HyperlinkSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-hyperlink-segment//update": {
		Doc:   "(*widget.HyperlinkSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink-segment//url!": {
		Doc:   "Set *widget.HyperlinkSegment URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//url!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//url!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//url!")
				}
				self.URL = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink-segment//url!")
			}
			return arg0
		},
	},
	"ptr-hyperlink-segment//url?": {
		Doc:   "Get *widget.HyperlinkSegment URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//url?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//url?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//url?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "ptr-url")
			return resObj
		},
	},
	"ptr-hyperlink-segment//visual": {
		Doc:   "(*widget.HyperlinkSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink-segment//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"ptr-hyperlink//alignment!": {
		Doc:   "Set *widget.Hyperlink Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//alignment!")
			}
			return arg0
		},
	},
	"ptr-hyperlink//alignment?": {
		Doc:   "Get *widget.Hyperlink Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"ptr-hyperlink//create-renderer": {
		Doc:   "(*widget.Hyperlink).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-hyperlink//cursor": {
		Doc:   "(*widget.Hyperlink).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "cursor")
			return res0Obj
		},
	},
	"ptr-hyperlink//extend-base-widget": {
		Doc:   "(*widget.Hyperlink).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//focus-gained": {
		Doc:   "(*widget.Hyperlink).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-hyperlink//focus-lost": {
		Doc:   "(*widget.Hyperlink).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-hyperlink//hidden!": {
		Doc:   "Set *widget.Hyperlink Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-hyperlink//hidden!")
			}
			return arg0
		},
	},
	"ptr-hyperlink//hidden?": {
		Doc:   "Get *widget.Hyperlink Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-hyperlink//hide": {
		Doc:   "(*widget.Hyperlink).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-hyperlink//min-size": {
		Doc:   "(*widget.Hyperlink).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-hyperlink//mouse-in": {
		Doc:   "(*widget.Hyperlink).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//mouse-moved": {
		Doc:   "(*widget.Hyperlink).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//mouse-out": {
		Doc:   "(*widget.Hyperlink).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-hyperlink//move": {
		Doc:   "(*widget.Hyperlink).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//on-tapped!": {
		Doc:   "Set *widget.Hyperlink OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//on-tapped!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//on-tapped!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-hyperlink//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-hyperlink//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-hyperlink//on-tapped!")
			}
			return arg0
		},
	},
	"ptr-hyperlink//on-tapped?": {
		Doc:   "Get *widget.Hyperlink OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//on-tapped?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//on-tapped?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "func()")
			return resObj
		},
	},
	"ptr-hyperlink//position": {
		Doc:   "(*widget.Hyperlink).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-hyperlink//refresh": {
		Doc:   "(*widget.Hyperlink).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-hyperlink//resize": {
		Doc:   "(*widget.Hyperlink).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//set-text": {
		Doc:   "(*widget.Hyperlink).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-hyperlink//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//set-url": {
		Doc:   "(*widget.Hyperlink).SetURL",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//set-url")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//set-url")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//set-url")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//set-url")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//set-url")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//set-url")
			}
			arg0Val.SetURL(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//set-url-from-string": {
		Doc:   "(*widget.Hyperlink).SetURLFromString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//set-url-from-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//set-url-from-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//set-url-from-string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-hyperlink//set-url-from-string")
			}
			res0 := arg0Val.SetURLFromString(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-hyperlink//show": {
		Doc:   "(*widget.Hyperlink).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-hyperlink//size": {
		Doc:   "(*widget.Hyperlink).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-hyperlink//tapped": {
		Doc:   "(*widget.Hyperlink).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//text!": {
		Doc:   "Set *widget.Hyperlink Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-hyperlink//text!")
			}
			return arg0
		},
	},
	"ptr-hyperlink//text-style!": {
		Doc:   "Set *widget.Hyperlink TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//text-style!")
			}
			return arg0
		},
	},
	"ptr-hyperlink//text-style?": {
		Doc:   "Get *widget.Hyperlink TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"ptr-hyperlink//text?": {
		Doc:   "Get *widget.Hyperlink Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-hyperlink//typed-key": {
		Doc:   "(*widget.Hyperlink).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//typed-rune": {
		Doc:   "(*widget.Hyperlink).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-hyperlink//url!": {
		Doc:   "Set *widget.Hyperlink URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//url!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//url!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//url!")
				}
				self.URL = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//url!")
			}
			return arg0
		},
	},
	"ptr-hyperlink//url?": {
		Doc:   "Get *widget.Hyperlink URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//url?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//url?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//url?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "ptr-url")
			return resObj
		},
	},
	"ptr-hyperlink//visible": {
		Doc:   "(*widget.Hyperlink).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-hyperlink//wrapping!": {
		Doc:   "Set *widget.Hyperlink Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//wrapping!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//wrapping!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-hyperlink//wrapping!")
			}
			return arg0
		},
	},
	"ptr-hyperlink//wrapping?": {
		Doc:   "Get *widget.Hyperlink Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//wrapping?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//wrapping?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-hyperlink//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"ptr-icon//create-renderer": {
		Doc:   "(*widget.Icon).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-icon//extend-base-widget": {
		Doc:   "(*widget.Icon).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-icon//hidden!": {
		Doc:   "Set *widget.Icon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-icon//hidden!")
			}
			return arg0
		},
	},
	"ptr-icon//hidden?": {
		Doc:   "Get *widget.Icon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-icon//hide": {
		Doc:   "(*widget.Icon).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-icon//min-size": {
		Doc:   "(*widget.Icon).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-icon//move": {
		Doc:   "(*widget.Icon).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-icon//position": {
		Doc:   "(*widget.Icon).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-icon//refresh": {
		Doc:   "(*widget.Icon).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-icon//resize": {
		Doc:   "(*widget.Icon).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-icon//resource!": {
		Doc:   "Set *widget.Icon Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//resource!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//resource!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//resource!")
				}
				self.Resource = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//resource!")
			}
			return arg0
		},
	},
	"ptr-icon//resource?": {
		Doc:   "Get *widget.Icon Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//resource?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//resource?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//resource?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Resource, "resource")
			return resObj
		},
	},
	"ptr-icon//set-resource": {
		Doc:   "(*widget.Icon).SetResource",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//set-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//set-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//set-resource")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//set-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//set-resource")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-icon//set-resource")
			}
			arg0Val.SetResource(arg1Val)
			return arg0
		},
	},
	"ptr-icon//show": {
		Doc:   "(*widget.Icon).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-icon//size": {
		Doc:   "(*widget.Icon).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-icon//visible": {
		Doc:   "(*widget.Icon).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-icon//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-segment//alignment!": {
		Doc:   "Set *widget.ImageSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image-segment//alignment!")
			}
			return arg0
		},
	},
	"ptr-image-segment//alignment?": {
		Doc:   "Get *widget.ImageSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"ptr-image-segment//inline": {
		Doc:   "(*widget.ImageSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-image-segment//select": {
		Doc:   "(*widget.ImageSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image-segment//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-image-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-image-segment//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-image-segment//selected-text": {
		Doc:   "(*widget.ImageSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-image-segment//source!": {
		Doc:   "Set *widget.ImageSegment Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//source!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//source!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//source!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image-segment//source!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image-segment//source!")
			}
			return arg0
		},
	},
	"ptr-image-segment//source?": {
		Doc:   "Get *widget.ImageSegment Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//source?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//source?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//source?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "uri")
			return resObj
		},
	},
	"ptr-image-segment//textual": {
		Doc:   "(*widget.ImageSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-image-segment//title!": {
		Doc:   "Set *widget.ImageSegment Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//title!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//title!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-image-segment//title!")
			}
			return arg0
		},
	},
	"ptr-image-segment//title?": {
		Doc:   "Get *widget.ImageSegment Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//title?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//title?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"ptr-image-segment//unselect": {
		Doc:   "(*widget.ImageSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-image-segment//update": {
		Doc:   "(*widget.ImageSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image-segment//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image-segment//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-image-segment//visual": {
		Doc:   "(*widget.ImageSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image-segment//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"ptr-image//alpha": {
		Doc:   "(*canvas.Image).Alpha",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//alpha")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//alpha")
			}
			res0 := arg0Val.Alpha()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-image//aspect": {
		Doc:   "(*canvas.Image).Aspect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//aspect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//aspect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//aspect")
			}
			res0 := arg0Val.Aspect()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-image//file!": {
		Doc:   "Set *canvas.Image File value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//file!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//file!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//file!")
			}
			if v, ok := arg1.(env.String); ok {
				self.File = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-image//file!")
			}
			return arg0
		},
	},
	"ptr-image//file?": {
		Doc:   "Get *canvas.Image File value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//file?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//file?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//file?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.File)
			return resObj
		},
	},
	"ptr-image//fill-mode!": {
		Doc:   "Set *canvas.Image FillMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//fill-mode!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//fill-mode!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//fill-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillMode, ok = v.Value.(canvas.ImageFill)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//fill-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//fill-mode!")
			}
			return arg0
		},
	},
	"ptr-image//fill-mode?": {
		Doc:   "Get *canvas.Image FillMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//fill-mode?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//fill-mode?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//fill-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillMode, "image-fill")
			return resObj
		},
	},
	"ptr-image//hide": {
		Doc:   "(*canvas.Image).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-image//image!": {
		Doc:   "Set *canvas.Image Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//image!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//image!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//image!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(image.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//image!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//image!")
			}
			return arg0
		},
	},
	"ptr-image//image?": {
		Doc:   "Get *canvas.Image Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//image?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//image?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//image?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "image")
			return resObj
		},
	},
	"ptr-image//min-size": {
		Doc:   "(*canvas.Image).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-image//move": {
		Doc:   "(*canvas.Image).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-image//refresh": {
		Doc:   "(*canvas.Image).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-image//resize": {
		Doc:   "(*canvas.Image).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-image//resource!": {
		Doc:   "Set *canvas.Image Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//resource!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//resource!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//resource!")
				}
				self.Resource = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//resource!")
			}
			return arg0
		},
	},
	"ptr-image//resource?": {
		Doc:   "Get *canvas.Image Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//resource?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//resource?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//resource?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Resource, "resource")
			return resObj
		},
	},
	"ptr-image//scale-mode!": {
		Doc:   "Set *canvas.Image ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//scale-mode!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//scale-mode!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//scale-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ScaleMode, ok = v.Value.(canvas.ImageScale)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-image//scale-mode!")
			}
			return arg0
		},
	},
	"ptr-image//scale-mode?": {
		Doc:   "Get *canvas.Image ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//scale-mode?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//scale-mode?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//scale-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ScaleMode, "image-scale")
			return resObj
		},
	},
	"ptr-image//translucency!": {
		Doc:   "Set *canvas.Image Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//translucency!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//translucency!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//translucency!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-image//translucency!")
			}
			return arg0
		},
	},
	"ptr-image//translucency?": {
		Doc:   "Get *canvas.Image Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//translucency?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//translucency?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-image//translucency?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"ptr-inverted-themed-resource//content": {
		Doc:   "(*theme.InvertedThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.InvertedThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.InvertedThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-inverted-themed-resource//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-inverted-themed-resource//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-inverted-themed-resource//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-inverted-themed-resource//name": {
		Doc:   "(*theme.InvertedThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.InvertedThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.InvertedThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-inverted-themed-resource//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-inverted-themed-resource//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-inverted-themed-resource//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-inverted-themed-resource//original": {
		Doc:   "(*theme.InvertedThemedResource).Original",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.InvertedThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.InvertedThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-inverted-themed-resource//original")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-inverted-themed-resource//original")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-inverted-themed-resource//original")
			}
			res0 := arg0Val.Original()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"ptr-key-event//name!": {
		Doc:   "Set *fyne.KeyEvent Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Name, ok = v.Value.(fyne.KeyName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-key-event//name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-key-event//name!")
			}
			return arg0
		},
	},
	"ptr-key-event//name?": {
		Doc:   "Get *fyne.KeyEvent Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Name, "key-name")
			return resObj
		},
	},
	"ptr-key-event//physical!": {
		Doc:   "Set *fyne.KeyEvent Physical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//physical!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//physical!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//physical!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Physical, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-key-event//physical!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-key-event//physical!")
			}
			return arg0
		},
	},
	"ptr-key-event//physical?": {
		Doc:   "Get *fyne.KeyEvent Physical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//physical?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//physical?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-key-event//physical?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Physical, "hardware-key")
			return resObj
		},
	},
	"ptr-label//alignment!": {
		Doc:   "Set *widget.Label Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//alignment!")
			}
			return arg0
		},
	},
	"ptr-label//alignment?": {
		Doc:   "Get *widget.Label Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"ptr-label//bind": {
		Doc:   "(*widget.Label).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//bind")
			}
			var arg1Val binding.String
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-label//create-renderer": {
		Doc:   "(*widget.Label).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-label//extend-base-widget": {
		Doc:   "(*widget.Label).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-label//hidden!": {
		Doc:   "Set *widget.Label Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-label//hidden!")
			}
			return arg0
		},
	},
	"ptr-label//hidden?": {
		Doc:   "Get *widget.Label Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-label//hide": {
		Doc:   "(*widget.Label).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-label//importance!": {
		Doc:   "Set *widget.Label Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//importance!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//importance!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//importance!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Importance, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//importance!")
			}
			return arg0
		},
	},
	"ptr-label//importance?": {
		Doc:   "Get *widget.Label Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//importance?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//importance?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//importance?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Importance, "importance")
			return resObj
		},
	},
	"ptr-label//min-size": {
		Doc:   "(*widget.Label).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-label//move": {
		Doc:   "(*widget.Label).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-label//position": {
		Doc:   "(*widget.Label).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-label//refresh": {
		Doc:   "(*widget.Label).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-label//resize": {
		Doc:   "(*widget.Label).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-label//set-text": {
		Doc:   "(*widget.Label).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-label//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-label//show": {
		Doc:   "(*widget.Label).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-label//size": {
		Doc:   "(*widget.Label).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-label//text!": {
		Doc:   "Set *widget.Label Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-label//text!")
			}
			return arg0
		},
	},
	"ptr-label//text-style!": {
		Doc:   "Set *widget.Label TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//text-style!")
			}
			return arg0
		},
	},
	"ptr-label//text-style?": {
		Doc:   "Get *widget.Label TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"ptr-label//text?": {
		Doc:   "Get *widget.Label Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-label//truncation!": {
		Doc:   "Set *widget.Label Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//truncation!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//truncation!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//truncation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Truncation, ok = v.Value.(fyne.TextTruncation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//truncation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//truncation!")
			}
			return arg0
		},
	},
	"ptr-label//truncation?": {
		Doc:   "Get *widget.Label Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//truncation?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//truncation?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//truncation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Truncation, "text-truncation")
			return resObj
		},
	},
	"ptr-label//unbind": {
		Doc:   "(*widget.Label).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-label//visible": {
		Doc:   "(*widget.Label).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-label//wrapping!": {
		Doc:   "Set *widget.Label Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//wrapping!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//wrapping!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-label//wrapping!")
			}
			return arg0
		},
	},
	"ptr-label//wrapping?": {
		Doc:   "Get *widget.Label Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//wrapping?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//wrapping?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-label//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"ptr-line//hidden!": {
		Doc:   "Set *canvas.Line Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-line//hidden!")
			}
			return arg0
		},
	},
	"ptr-line//hidden?": {
		Doc:   "Get *canvas.Line Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-line//hide": {
		Doc:   "(*canvas.Line).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-line//min-size": {
		Doc:   "(*canvas.Line).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-line//move": {
		Doc:   "(*canvas.Line).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-line//position": {
		Doc:   "(*canvas.Line).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-line//position-1!": {
		Doc:   "Set *canvas.Line Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-1!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-1!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-1!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//position-1!")
			}
			return arg0
		},
	},
	"ptr-line//position-1?": {
		Doc:   "Get *canvas.Line Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-1?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-1?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-1?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "position")
			return resObj
		},
	},
	"ptr-line//position-2!": {
		Doc:   "Set *canvas.Line Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-2!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-2!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-2!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//position-2!")
			}
			return arg0
		},
	},
	"ptr-line//position-2?": {
		Doc:   "Get *canvas.Line Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-2?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-2?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//position-2?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "position")
			return resObj
		},
	},
	"ptr-line//refresh": {
		Doc:   "(*canvas.Line).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-line//resize": {
		Doc:   "(*canvas.Line).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-line//show": {
		Doc:   "(*canvas.Line).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-line//size": {
		Doc:   "(*canvas.Line).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-line//stroke-color!": {
		Doc:   "Set *canvas.Line StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-line//stroke-color!")
			}
			return arg0
		},
	},
	"ptr-line//stroke-color?": {
		Doc:   "Get *canvas.Line StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color")
			return resObj
		},
	},
	"ptr-line//stroke-width!": {
		Doc:   "Set *canvas.Line StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-line//stroke-width!")
			}
			return arg0
		},
	},
	"ptr-line//stroke-width?": {
		Doc:   "Get *canvas.Line StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"ptr-line//visible": {
		Doc:   "(*canvas.Line).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-line//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-linear-gradient//angle!": {
		Doc:   "Set *canvas.LinearGradient Angle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//angle!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//angle!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//angle!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Angle = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-linear-gradient//angle!")
			}
			return arg0
		},
	},
	"ptr-linear-gradient//angle?": {
		Doc:   "Get *canvas.LinearGradient Angle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//angle?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//angle?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//angle?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Angle))
			return resObj
		},
	},
	"ptr-linear-gradient//end-color!": {
		Doc:   "Set *canvas.LinearGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//end-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//end-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//end-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-linear-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-linear-gradient//end-color!")
			}
			return arg0
		},
	},
	"ptr-linear-gradient//end-color?": {
		Doc:   "Get *canvas.LinearGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//end-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//end-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//end-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color")
			return resObj
		},
	},
	"ptr-linear-gradient//generate": {
		Doc:   "(*canvas.LinearGradient).Generate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//generate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//generate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//generate")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-linear-gradient//generate")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "ptr-linear-gradient//generate")
			}
			res0 := arg0Val.Generate(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image")
			return res0Obj
		},
	},
	"ptr-linear-gradient//hide": {
		Doc:   "(*canvas.LinearGradient).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-linear-gradient//move": {
		Doc:   "(*canvas.LinearGradient).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-linear-gradient//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-linear-gradient//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-linear-gradient//refresh": {
		Doc:   "(*canvas.LinearGradient).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-linear-gradient//start-color!": {
		Doc:   "Set *canvas.LinearGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//start-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//start-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//start-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-linear-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-linear-gradient//start-color!")
			}
			return arg0
		},
	},
	"ptr-linear-gradient//start-color?": {
		Doc:   "Get *canvas.LinearGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//start-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//start-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-linear-gradient//start-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color")
			return resObj
		},
	},
	"ptr-list-segment//inline": {
		Doc:   "(*widget.ListSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-list-segment//items!": {
		Doc:   "Set *widget.ListSegment Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list-segment//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list-segment//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list-segment//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list-segment//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list-segment//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list-segment//items!")
			}
			return arg0
		},
	},
	"ptr-list-segment//items?": {
		Doc:   "Get *widget.ListSegment Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "rich-text-segment")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-list-segment//ordered!": {
		Doc:   "Set *widget.ListSegment Ordered value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//ordered!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//ordered!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//ordered!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Ordered = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-list-segment//ordered!")
			}
			return arg0
		},
	},
	"ptr-list-segment//ordered?": {
		Doc:   "Get *widget.ListSegment Ordered value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//ordered?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//ordered?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//ordered?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Ordered))
			return resObj
		},
	},
	"ptr-list-segment//segments": {
		Doc:   "(*widget.ListSegment).Segments",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//segments")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//segments")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//segments")
			}
			res0 := arg0Val.Segments()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rich-text-segment")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-list-segment//select": {
		Doc:   "(*widget.ListSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list-segment//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-list-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-list-segment//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-list-segment//selected-text": {
		Doc:   "(*widget.ListSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-list-segment//textual": {
		Doc:   "(*widget.ListSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-list-segment//unselect": {
		Doc:   "(*widget.ListSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-list-segment//update": {
		Doc:   "(*widget.ListSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list-segment//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list-segment//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-list-segment//visual": {
		Doc:   "(*widget.ListSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list-segment//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"ptr-list//create-item!": {
		Doc:   "Set *widget.List CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//create-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//create-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//create-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//create-item!")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list//create-item!")
				}
				self.CreateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//create-item!")
			}
			return arg0
		},
	},
	"ptr-list//create-item?": {
		Doc:   "Get *widget.List CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//create-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//create-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//create-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "func()_(canvas-object)")
			return resObj
		},
	},
	"ptr-list//create-renderer": {
		Doc:   "(*widget.List).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-list//extend-base-widget": {
		Doc:   "(*widget.List).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-list//focus-gained": {
		Doc:   "(*widget.List).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-list//focus-lost": {
		Doc:   "(*widget.List).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-list//hidden!": {
		Doc:   "Set *widget.List Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-list//hidden!")
			}
			return arg0
		},
	},
	"ptr-list//hidden?": {
		Doc:   "Get *widget.List Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-list//hide": {
		Doc:   "(*widget.List).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-list//length!": {
		Doc:   "Set *widget.List Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//length!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//length!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//length!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//length!")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list//length!")
				}
				self.Length = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//length!")
			}
			return arg0
		},
	},
	"ptr-list//length?": {
		Doc:   "Get *widget.List Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//length?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//length?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//length?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int)")
			return resObj
		},
	},
	"ptr-list//min-size": {
		Doc:   "(*widget.List).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-list//move": {
		Doc:   "(*widget.List).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-list//on-selected!": {
		Doc:   "Set *widget.List OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//on-selected!")
				}
				self.OnSelected = func(arg0 widget.ListItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "list-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//on-selected!")
			}
			return arg0
		},
	},
	"ptr-list//on-selected?": {
		Doc:   "Get *widget.List OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(list-item-id)")
			return resObj
		},
	},
	"ptr-list//on-unselected!": {
		Doc:   "Set *widget.List OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-unselected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-unselected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.ListItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "list-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//on-unselected!")
			}
			return arg0
		},
	},
	"ptr-list//on-unselected?": {
		Doc:   "Get *widget.List OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-unselected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-unselected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(list-item-id)")
			return resObj
		},
	},
	"ptr-list//position": {
		Doc:   "(*widget.List).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-list//refresh": {
		Doc:   "(*widget.List).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-list//refresh-item": {
		Doc:   "(*widget.List).RefreshItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//refresh-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//refresh-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//refresh-item")
			}
			var arg1Val widget.ListItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ListItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//refresh-item")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//refresh-item")
			}
			arg0Val.RefreshItem(arg1Val)
			return arg0
		},
	},
	"ptr-list//resize": {
		Doc:   "(*widget.List).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-list//scroll-to": {
		Doc:   "(*widget.List).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//scroll-to")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//scroll-to")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//scroll-to")
			}
			var arg1Val widget.ListItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ListItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//scroll-to")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//scroll-to")
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"ptr-list//scroll-to-bottom": {
		Doc:   "(*widget.List).ScrollToBottom",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//scroll-to-bottom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//scroll-to-bottom")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//scroll-to-bottom")
			}
			arg0Val.ScrollToBottom()
			return arg0
		},
	},
	"ptr-list//scroll-to-top": {
		Doc:   "(*widget.List).ScrollToTop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//scroll-to-top")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//scroll-to-top")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//scroll-to-top")
			}
			arg0Val.ScrollToTop()
			return arg0
		},
	},
	"ptr-list//select": {
		Doc:   "(*widget.List).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//select")
			}
			var arg1Val widget.ListItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ListItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//select")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-list//set-item-height": {
		Doc:   "(*widget.List).SetItemHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//set-item-height")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//set-item-height")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//set-item-height")
			}
			var arg1Val widget.ListItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ListItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//set-item-height")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//set-item-height")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "ptr-list//set-item-height")
			}
			arg0Val.SetItemHeight(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-list//show": {
		Doc:   "(*widget.List).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-list//size": {
		Doc:   "(*widget.List).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-list//typed-key": {
		Doc:   "(*widget.List).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-list//typed-rune": {
		Doc:   "(*widget.List).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-list//unselect": {
		Doc:   "(*widget.List).Unselect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//unselect")
			}
			var arg1Val widget.ListItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ListItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//unselect")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-list//unselect")
			}
			arg0Val.Unselect(arg1Val)
			return arg0
		},
	},
	"ptr-list//unselect-all": {
		Doc:   "(*widget.List).UnselectAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//unselect-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//unselect-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//unselect-all")
			}
			arg0Val.UnselectAll()
			return arg0
		},
	},
	"ptr-list//update-item!": {
		Doc:   "Set *widget.List UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//update-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//update-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//update-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//update-item!")
				}
				self.UpdateItem = func(arg0 widget.ListItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "list-item-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-list//update-item!")
				}
				self.UpdateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-list//update-item!")
			}
			return arg0
		},
	},
	"ptr-list//update-item?": {
		Doc:   "Get *widget.List UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//update-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//update-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//update-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "func(list-item-id_canvas-object)")
			return resObj
		},
	},
	"ptr-list//visible": {
		Doc:   "(*widget.List).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-list//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-main-menu//items!": {
		Doc:   "Set *fyne.MainMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-main-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-main-menu//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-main-menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.Menu, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.Menu)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-main-menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-main-menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-main-menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-main-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-main-menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-main-menu//items!")
			}
			return arg0
		},
	},
	"ptr-main-menu//items?": {
		Doc:   "Get *fyne.MainMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-main-menu//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-main-menu//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-main-menu//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-menu")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-main-menu//refresh": {
		Doc:   "(*fyne.MainMenu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-main-menu//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-main-menu//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-main-menu//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-menu-item//action!": {
		Doc:   "Set *fyne.MenuItem Action value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//action!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//action!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//action!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-menu-item//action!")
				}
				self.Action = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-menu-item//action!")
				}
				self.Action = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-menu-item//action!")
			}
			return arg0
		},
	},
	"ptr-menu-item//action?": {
		Doc:   "Get *fyne.MenuItem Action value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//action?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//action?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//action?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Action, "func()")
			return resObj
		},
	},
	"ptr-menu-item//checked!": {
		Doc:   "Set *fyne.MenuItem Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//checked!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//checked!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//checked!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-menu-item//checked!")
			}
			return arg0
		},
	},
	"ptr-menu-item//checked?": {
		Doc:   "Get *fyne.MenuItem Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//checked?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//checked?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//checked?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"ptr-menu-item//child-menu!": {
		Doc:   "Set *fyne.MenuItem ChildMenu value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//child-menu!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//child-menu!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//child-menu!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ChildMenu, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu-item//child-menu!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu-item//child-menu!")
				}
				self.ChildMenu = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu-item//child-menu!")
			}
			return arg0
		},
	},
	"ptr-menu-item//child-menu?": {
		Doc:   "Get *fyne.MenuItem ChildMenu value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//child-menu?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//child-menu?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//child-menu?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildMenu, "ptr-menu")
			return resObj
		},
	},
	"ptr-menu-item//disabled!": {
		Doc:   "Set *fyne.MenuItem Disabled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//disabled!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//disabled!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//disabled!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Disabled = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-menu-item//disabled!")
			}
			return arg0
		},
	},
	"ptr-menu-item//disabled?": {
		Doc:   "Get *fyne.MenuItem Disabled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//disabled?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//disabled?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//disabled?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Disabled))
			return resObj
		},
	},
	"ptr-menu-item//icon!": {
		Doc:   "Set *fyne.MenuItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//icon!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu-item//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu-item//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu-item//icon!")
			}
			return arg0
		},
	},
	"ptr-menu-item//icon?": {
		Doc:   "Get *fyne.MenuItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//icon?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//icon?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"ptr-menu-item//is-quit!": {
		Doc:   "Set *fyne.MenuItem IsQuit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-quit!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-quit!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-quit!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsQuit = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-menu-item//is-quit!")
			}
			return arg0
		},
	},
	"ptr-menu-item//is-quit?": {
		Doc:   "Get *fyne.MenuItem IsQuit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-quit?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-quit?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-quit?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsQuit))
			return resObj
		},
	},
	"ptr-menu-item//is-separator!": {
		Doc:   "Set *fyne.MenuItem IsSeparator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-separator!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-separator!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-separator!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsSeparator = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-menu-item//is-separator!")
			}
			return arg0
		},
	},
	"ptr-menu-item//is-separator?": {
		Doc:   "Get *fyne.MenuItem IsSeparator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-separator?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-separator?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//is-separator?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsSeparator))
			return resObj
		},
	},
	"ptr-menu-item//label!": {
		Doc:   "Set *fyne.MenuItem Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//label!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//label!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//label!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-menu-item//label!")
			}
			return arg0
		},
	},
	"ptr-menu-item//label?": {
		Doc:   "Get *fyne.MenuItem Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//label?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//label?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//label?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"ptr-menu-item//shortcut!": {
		Doc:   "Set *fyne.MenuItem Shortcut value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//shortcut!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//shortcut!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//shortcut!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Shortcut, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu-item//shortcut!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu-item//shortcut!")
				}
				self.Shortcut = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu-item//shortcut!")
			}
			return arg0
		},
	},
	"ptr-menu-item//shortcut?": {
		Doc:   "Get *fyne.MenuItem Shortcut value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//shortcut?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//shortcut?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu-item//shortcut?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Shortcut, "shortcut")
			return resObj
		},
	},
	"ptr-menu//activate-last-submenu": {
		Doc:   "(*widget.Menu).ActivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//activate-last-submenu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//activate-last-submenu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//activate-last-submenu")
			}
			res0 := arg0Val.ActivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-menu//activate-next": {
		Doc:   "(*widget.Menu).ActivateNext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//activate-next")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//activate-next")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//activate-next")
			}
			arg0Val.ActivateNext()
			return arg0
		},
	},
	"ptr-menu//activate-previous": {
		Doc:   "(*widget.Menu).ActivatePrevious",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//activate-previous")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//activate-previous")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//activate-previous")
			}
			arg0Val.ActivatePrevious()
			return arg0
		},
	},
	"ptr-menu//create-renderer": {
		Doc:   "(*widget.Menu).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-menu//deactivate-child": {
		Doc:   "(*widget.Menu).DeactivateChild",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//deactivate-child")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//deactivate-child")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//deactivate-child")
			}
			arg0Val.DeactivateChild()
			return arg0
		},
	},
	"ptr-menu//deactivate-last-submenu": {
		Doc:   "(*widget.Menu).DeactivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//deactivate-last-submenu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//deactivate-last-submenu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//deactivate-last-submenu")
			}
			res0 := arg0Val.DeactivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-menu//dismiss": {
		Doc:   "(*widget.Menu).Dismiss",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//dismiss")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//dismiss")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//dismiss")
			}
			arg0Val.Dismiss()
			return arg0
		},
	},
	"ptr-menu//extend-base-widget": {
		Doc:   "(*widget.Menu).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-menu//hidden!": {
		Doc:   "Set *widget.Menu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-menu//hidden!")
			}
			return arg0
		},
	},
	"ptr-menu//hidden?": {
		Doc:   "Get *widget.Menu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-menu//hide": {
		Doc:   "(*widget.Menu).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-menu//items!": {
		Doc:   "Set *fyne.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.MenuItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.MenuItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-menu//items!")
			}
			return arg0
		},
	},
	"ptr-menu//items?": {
		Doc:   "Get *fyne.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "ptr-menu-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-menu//label!": {
		Doc:   "Set *fyne.Menu Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//label!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//label!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//label!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-menu//label!")
			}
			return arg0
		},
	},
	"ptr-menu//label?": {
		Doc:   "Get *fyne.Menu Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//label?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//label?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//label?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"ptr-menu//min-size": {
		Doc:   "(*widget.Menu).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-menu//move": {
		Doc:   "(*widget.Menu).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-menu//on-dismiss!": {
		Doc:   "Set *widget.Menu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//on-dismiss!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//on-dismiss!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//on-dismiss!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-menu//on-dismiss!")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-menu//on-dismiss!")
				}
				self.OnDismiss = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-menu//on-dismiss!")
			}
			return arg0
		},
	},
	"ptr-menu//on-dismiss?": {
		Doc:   "Get *widget.Menu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//on-dismiss?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//on-dismiss?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//on-dismiss?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "func()")
			return resObj
		},
	},
	"ptr-menu//position": {
		Doc:   "(*widget.Menu).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-menu//refresh": {
		Doc:   "(*fyne.Menu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-menu//resize": {
		Doc:   "(*widget.Menu).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-menu//show": {
		Doc:   "(*widget.Menu).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-menu//size": {
		Doc:   "(*widget.Menu).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-menu//tapped": {
		Doc:   "(*widget.Menu).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-menu//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-menu//trigger-last": {
		Doc:   "(*widget.Menu).TriggerLast",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//trigger-last")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//trigger-last")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//trigger-last")
			}
			arg0Val.TriggerLast()
			return arg0
		},
	},
	"ptr-menu//visible": {
		Doc:   "(*widget.Menu).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-menu//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-mime-type-file-filter//matches": {
		Doc:   "(*storage.MimeTypeFileFilter).Matches",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//matches")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//matches")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//matches")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//matches")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//matches")
			}
			res0 := arg0Val.Matches(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-mime-type-file-filter//mime-types!": {
		Doc:   "Set *storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//mime-types!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//mime-types!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//mime-types!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.MimeTypes = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.MimeTypes[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-mime-type-file-filter//mime-types!")
					}
				}
			case env.Native:
				var ok bool
				self.MimeTypes, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-mime-type-file-filter//mime-types!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-mime-type-file-filter//mime-types!")
				}
				self.MimeTypes = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-mime-type-file-filter//mime-types!")
			}
			return arg0
		},
	},
	"ptr-mime-type-file-filter//mime-types?": {
		Doc:   "Get *storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//mime-types?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//mime-types?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mime-type-file-filter//mime-types?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.MimeTypes))
				for i, it := range self.MimeTypes {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-mouse-event//absolute-position!": {
		Doc:   "Set *desktop.MouseEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mouse-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mouse-event//absolute-position!")
			}
			return arg0
		},
	},
	"ptr-mouse-event//absolute-position?": {
		Doc:   "Get *desktop.MouseEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"ptr-mouse-event//button!": {
		Doc:   "Set *desktop.MouseEvent Button value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//button!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//button!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//button!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Button, ok = v.Value.(desktop.MouseButton)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mouse-event//button!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mouse-event//button!")
			}
			return arg0
		},
	},
	"ptr-mouse-event//button?": {
		Doc:   "Get *desktop.MouseEvent Button value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//button?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//button?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//button?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Button, "mouse-button")
			return resObj
		},
	},
	"ptr-mouse-event//modifier!": {
		Doc:   "Set *desktop.MouseEvent Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//modifier!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//modifier!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//modifier!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Modifier, ok = v.Value.(fyne.KeyModifier)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mouse-event//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mouse-event//modifier!")
			}
			return arg0
		},
	},
	"ptr-mouse-event//modifier?": {
		Doc:   "Get *desktop.MouseEvent Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//modifier?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//modifier?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//modifier?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Modifier, "key-modifier")
			return resObj
		},
	},
	"ptr-mouse-event//position!": {
		Doc:   "Set *desktop.MouseEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mouse-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-mouse-event//position!")
			}
			return arg0
		},
	},
	"ptr-mouse-event//position?": {
		Doc:   "Get *desktop.MouseEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-mouse-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"ptr-notification//content!": {
		Doc:   "Set *fyne.Notification Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//content!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Content = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-notification//content!")
			}
			return arg0
		},
	},
	"ptr-notification//content?": {
		Doc:   "Get *fyne.Notification Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//content?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Content)
			return resObj
		},
	},
	"ptr-notification//title!": {
		Doc:   "Set *fyne.Notification Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//title!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//title!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-notification//title!")
			}
			return arg0
		},
	},
	"ptr-notification//title?": {
		Doc:   "Get *fyne.Notification Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//title?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//title?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-notification//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"ptr-paragraph-segment//inline": {
		Doc:   "(*widget.ParagraphSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-paragraph-segment//segments": {
		Doc:   "(*widget.ParagraphSegment).Segments",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//segments")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//segments")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//segments")
			}
			res0 := arg0Val.Segments()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rich-text-segment")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-paragraph-segment//select": {
		Doc:   "(*widget.ParagraphSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-paragraph-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-paragraph-segment//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-paragraph-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-paragraph-segment//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-paragraph-segment//selected-text": {
		Doc:   "(*widget.ParagraphSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-paragraph-segment//texts!": {
		Doc:   "Set *widget.ParagraphSegment Texts value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//texts!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//texts!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//texts!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Texts = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Texts[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-paragraph-segment//texts!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-paragraph-segment//texts!")
						}
						self.Texts[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-paragraph-segment//texts!")
					}
				}
			case env.Native:
				var ok bool
				self.Texts, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-paragraph-segment//texts!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-paragraph-segment//texts!")
				}
				self.Texts = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-paragraph-segment//texts!")
			}
			return arg0
		},
	},
	"ptr-paragraph-segment//texts?": {
		Doc:   "Get *widget.ParagraphSegment Texts value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//texts?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//texts?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//texts?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Texts))
				for i, it := range self.Texts {
					items[i] = *env.NewNative(ps.Idx, it, "rich-text-segment")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-paragraph-segment//textual": {
		Doc:   "(*widget.ParagraphSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-paragraph-segment//unselect": {
		Doc:   "(*widget.ParagraphSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-paragraph-segment//update": {
		Doc:   "(*widget.ParagraphSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-paragraph-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-paragraph-segment//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-paragraph-segment//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-paragraph-segment//visual": {
		Doc:   "(*widget.ParagraphSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-paragraph-segment//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"ptr-point-event//absolute-position!": {
		Doc:   "Set *fyne.PointEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-point-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-point-event//absolute-position!")
			}
			return arg0
		},
	},
	"ptr-point-event//absolute-position?": {
		Doc:   "Get *fyne.PointEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"ptr-point-event//position!": {
		Doc:   "Set *fyne.PointEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-point-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-point-event//position!")
			}
			return arg0
		},
	},
	"ptr-point-event//position?": {
		Doc:   "Get *fyne.PointEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-point-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"ptr-pop-up-menu//activate-last-submenu": {
		Doc:   "(*widget.PopUpMenu).ActivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//activate-last-submenu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//activate-last-submenu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//activate-last-submenu")
			}
			res0 := arg0Val.ActivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-pop-up-menu//activate-next": {
		Doc:   "(*widget.PopUpMenu).ActivateNext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//activate-next")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//activate-next")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//activate-next")
			}
			arg0Val.ActivateNext()
			return arg0
		},
	},
	"ptr-pop-up-menu//activate-previous": {
		Doc:   "(*widget.PopUpMenu).ActivatePrevious",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//activate-previous")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//activate-previous")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//activate-previous")
			}
			arg0Val.ActivatePrevious()
			return arg0
		},
	},
	"ptr-pop-up-menu//create-renderer": {
		Doc:   "(*widget.PopUpMenu).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-pop-up-menu//deactivate-child": {
		Doc:   "(*widget.PopUpMenu).DeactivateChild",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//deactivate-child")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//deactivate-child")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//deactivate-child")
			}
			arg0Val.DeactivateChild()
			return arg0
		},
	},
	"ptr-pop-up-menu//deactivate-last-submenu": {
		Doc:   "(*widget.PopUpMenu).DeactivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//deactivate-last-submenu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//deactivate-last-submenu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//deactivate-last-submenu")
			}
			res0 := arg0Val.DeactivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-pop-up-menu//dismiss": {
		Doc:   "(*widget.PopUpMenu).Dismiss",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//dismiss")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//dismiss")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//dismiss")
			}
			arg0Val.Dismiss()
			return arg0
		},
	},
	"ptr-pop-up-menu//extend-base-widget": {
		Doc:   "(*widget.PopUpMenu).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up-menu//focus-gained": {
		Doc:   "(*widget.PopUpMenu).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-pop-up-menu//focus-lost": {
		Doc:   "(*widget.PopUpMenu).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-pop-up-menu//hidden!": {
		Doc:   "Set *widget.PopUpMenu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-pop-up-menu//hidden!")
			}
			return arg0
		},
	},
	"ptr-pop-up-menu//hidden?": {
		Doc:   "Get *widget.PopUpMenu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-pop-up-menu//hide": {
		Doc:   "(*widget.PopUpMenu).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-pop-up-menu//items!": {
		Doc:   "Set *widget.PopUpMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-pop-up-menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-pop-up-menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-pop-up-menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-pop-up-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-pop-up-menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-pop-up-menu//items!")
			}
			return arg0
		},
	},
	"ptr-pop-up-menu//items?": {
		Doc:   "Get *widget.PopUpMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "canvas-object")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-pop-up-menu//min-size": {
		Doc:   "(*widget.PopUpMenu).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-pop-up-menu//move": {
		Doc:   "(*widget.PopUpMenu).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up-menu//on-dismiss!": {
		Doc:   "Set *widget.PopUpMenu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//on-dismiss!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//on-dismiss!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//on-dismiss!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-pop-up-menu//on-dismiss!")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-pop-up-menu//on-dismiss!")
				}
				self.OnDismiss = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-pop-up-menu//on-dismiss!")
			}
			return arg0
		},
	},
	"ptr-pop-up-menu//on-dismiss?": {
		Doc:   "Get *widget.PopUpMenu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//on-dismiss?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//on-dismiss?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//on-dismiss?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "func()")
			return resObj
		},
	},
	"ptr-pop-up-menu//position": {
		Doc:   "(*widget.PopUpMenu).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-pop-up-menu//refresh": {
		Doc:   "(*widget.PopUpMenu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-pop-up-menu//resize": {
		Doc:   "(*widget.PopUpMenu).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up-menu//show": {
		Doc:   "(*widget.PopUpMenu).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-pop-up-menu//show-at-position": {
		Doc:   "(*widget.PopUpMenu).ShowAtPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-position")
			}
			arg0Val.ShowAtPosition(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up-menu//show-at-relative-position": {
		Doc:   "(*widget.PopUpMenu).ShowAtRelativePosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-relative-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-relative-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-relative-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-relative-position")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-relative-position")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-pop-up-menu//show-at-relative-position")
			}
			arg0Val.ShowAtRelativePosition(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-pop-up-menu//size": {
		Doc:   "(*widget.PopUpMenu).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-pop-up-menu//tapped": {
		Doc:   "(*widget.PopUpMenu).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up-menu//trigger-last": {
		Doc:   "(*widget.PopUpMenu).TriggerLast",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//trigger-last")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//trigger-last")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//trigger-last")
			}
			arg0Val.TriggerLast()
			return arg0
		},
	},
	"ptr-pop-up-menu//typed-key": {
		Doc:   "(*widget.PopUpMenu).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up-menu//typed-rune": {
		Doc:   "(*widget.PopUpMenu).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up-menu//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up-menu//visible": {
		Doc:   "(*widget.PopUpMenu).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up-menu//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-pop-up//canvas!": {
		Doc:   "Set *widget.PopUp Canvas value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//canvas!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//canvas!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//canvas!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Canvas, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//canvas!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//canvas!")
				}
				self.Canvas = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//canvas!")
			}
			return arg0
		},
	},
	"ptr-pop-up//canvas?": {
		Doc:   "Get *widget.PopUp Canvas value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//canvas?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//canvas?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//canvas?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Canvas, "canvas")
			return resObj
		},
	},
	"ptr-pop-up//content!": {
		Doc:   "Set *widget.PopUp Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//content!")
			}
			return arg0
		},
	},
	"ptr-pop-up//content?": {
		Doc:   "Get *widget.PopUp Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "canvas-object")
			return resObj
		},
	},
	"ptr-pop-up//create-renderer": {
		Doc:   "(*widget.PopUp).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-pop-up//extend-base-widget": {
		Doc:   "(*widget.PopUp).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up//hidden!": {
		Doc:   "Set *widget.PopUp Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-pop-up//hidden!")
			}
			return arg0
		},
	},
	"ptr-pop-up//hidden?": {
		Doc:   "Get *widget.PopUp Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-pop-up//hide": {
		Doc:   "(*widget.PopUp).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-pop-up//min-size": {
		Doc:   "(*widget.PopUp).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-pop-up//move": {
		Doc:   "(*widget.PopUp).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up//position": {
		Doc:   "(*widget.PopUp).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-pop-up//refresh": {
		Doc:   "(*widget.PopUp).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-pop-up//resize": {
		Doc:   "(*widget.PopUp).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up//show": {
		Doc:   "(*widget.PopUp).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-pop-up//show-at-position": {
		Doc:   "(*widget.PopUp).ShowAtPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//show-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//show-at-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//show-at-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//show-at-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//show-at-position")
			}
			arg0Val.ShowAtPosition(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up//show-at-relative-position": {
		Doc:   "(*widget.PopUp).ShowAtRelativePosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//show-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//show-at-relative-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//show-at-relative-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//show-at-relative-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//show-at-relative-position")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-pop-up//show-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-pop-up//show-at-relative-position")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-pop-up//show-at-relative-position")
			}
			arg0Val.ShowAtRelativePosition(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-pop-up//size": {
		Doc:   "(*widget.PopUp).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-pop-up//tapped": {
		Doc:   "(*widget.PopUp).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up//tapped-secondary": {
		Doc:   "(*widget.PopUp).TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//tapped-secondary")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//tapped-secondary")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//tapped-secondary")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-pop-up//tapped-secondary")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"ptr-pop-up//visible": {
		Doc:   "(*widget.PopUp).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-pop-up//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-position//x!": {
		Doc:   "Set *fyne.Position X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//x!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//x!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//x!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-position//x!")
			}
			return arg0
		},
	},
	"ptr-position//x?": {
		Doc:   "Get *fyne.Position X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//x?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//x?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//x?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"ptr-position//y!": {
		Doc:   "Set *fyne.Position Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//y!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//y!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//y!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-position//y!")
			}
			return arg0
		},
	},
	"ptr-position//y?": {
		Doc:   "Get *fyne.Position Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//y?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//y?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-position//y?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"ptr-primary-themed-resource//content": {
		Doc:   "(*theme.PrimaryThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.PrimaryThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.PrimaryThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-primary-themed-resource//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-primary-themed-resource//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-primary-themed-resource//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-primary-themed-resource//name": {
		Doc:   "(*theme.PrimaryThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.PrimaryThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.PrimaryThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-primary-themed-resource//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-primary-themed-resource//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-primary-themed-resource//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-primary-themed-resource//original": {
		Doc:   "(*theme.PrimaryThemedResource).Original",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.PrimaryThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.PrimaryThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-primary-themed-resource//original")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-primary-themed-resource//original")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-primary-themed-resource//original")
			}
			res0 := arg0Val.Original()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"ptr-progress-bar-infinite//create-renderer": {
		Doc:   "(*widget.ProgressBarInfinite).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-progress-bar-infinite//extend-base-widget": {
		Doc:   "(*widget.ProgressBarInfinite).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-progress-bar-infinite//hidden!": {
		Doc:   "Set *widget.ProgressBarInfinite Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-progress-bar-infinite//hidden!")
			}
			return arg0
		},
	},
	"ptr-progress-bar-infinite//hidden?": {
		Doc:   "Get *widget.ProgressBarInfinite Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-progress-bar-infinite//hide": {
		Doc:   "(*widget.ProgressBarInfinite).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-progress-bar-infinite//min-size": {
		Doc:   "(*widget.ProgressBarInfinite).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-progress-bar-infinite//move": {
		Doc:   "(*widget.ProgressBarInfinite).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-progress-bar-infinite//position": {
		Doc:   "(*widget.ProgressBarInfinite).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-progress-bar-infinite//refresh": {
		Doc:   "(*widget.ProgressBarInfinite).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-progress-bar-infinite//resize": {
		Doc:   "(*widget.ProgressBarInfinite).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-progress-bar-infinite//running": {
		Doc:   "(*widget.ProgressBarInfinite).Running",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//running")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//running")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//running")
			}
			res0 := arg0Val.Running()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-progress-bar-infinite//show": {
		Doc:   "(*widget.ProgressBarInfinite).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-progress-bar-infinite//size": {
		Doc:   "(*widget.ProgressBarInfinite).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-progress-bar-infinite//start": {
		Doc:   "(*widget.ProgressBarInfinite).Start",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//start")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//start")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//start")
			}
			arg0Val.Start()
			return arg0
		},
	},
	"ptr-progress-bar-infinite//stop": {
		Doc:   "(*widget.ProgressBarInfinite).Stop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//stop")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//stop")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//stop")
			}
			arg0Val.Stop()
			return arg0
		},
	},
	"ptr-progress-bar-infinite//visible": {
		Doc:   "(*widget.ProgressBarInfinite).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar-infinite//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-progress-bar//bind": {
		Doc:   "(*widget.ProgressBar).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//bind")
			}
			var arg1Val binding.Float
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-progress-bar//create-renderer": {
		Doc:   "(*widget.ProgressBar).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-progress-bar//extend-base-widget": {
		Doc:   "(*widget.ProgressBar).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-progress-bar//hidden!": {
		Doc:   "Set *widget.ProgressBar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-progress-bar//hidden!")
			}
			return arg0
		},
	},
	"ptr-progress-bar//hidden?": {
		Doc:   "Get *widget.ProgressBar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-progress-bar//hide": {
		Doc:   "(*widget.ProgressBar).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-progress-bar//max!": {
		Doc:   "Set *widget.ProgressBar Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//max!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//max!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//max!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-progress-bar//max!")
			}
			return arg0
		},
	},
	"ptr-progress-bar//max?": {
		Doc:   "Get *widget.ProgressBar Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//max?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//max?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//max?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"ptr-progress-bar//min!": {
		Doc:   "Set *widget.ProgressBar Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//min!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//min!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//min!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-progress-bar//min!")
			}
			return arg0
		},
	},
	"ptr-progress-bar//min-size": {
		Doc:   "(*widget.ProgressBar).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-progress-bar//min?": {
		Doc:   "Get *widget.ProgressBar Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//min?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//min?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//min?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"ptr-progress-bar//move": {
		Doc:   "(*widget.ProgressBar).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-progress-bar//position": {
		Doc:   "(*widget.ProgressBar).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-progress-bar//refresh": {
		Doc:   "(*widget.ProgressBar).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-progress-bar//resize": {
		Doc:   "(*widget.ProgressBar).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-progress-bar//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-progress-bar//set-value": {
		Doc:   "(*widget.ProgressBar).SetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//set-value")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-progress-bar//set-value")
			}
			arg0Val.SetValue(arg1Val)
			return arg0
		},
	},
	"ptr-progress-bar//show": {
		Doc:   "(*widget.ProgressBar).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-progress-bar//size": {
		Doc:   "(*widget.ProgressBar).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-progress-bar//text-formatter!": {
		Doc:   "Set *widget.ProgressBar TextFormatter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//text-formatter!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//text-formatter!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//text-formatter!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-progress-bar//text-formatter!")
				}
				self.TextFormatter = func() string {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res string
					if v, ok := ps.Res.(env.String); ok {
						res = string(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-progress-bar//text-formatter!")
				}
				self.TextFormatter = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-progress-bar//text-formatter!")
			}
			return arg0
		},
	},
	"ptr-progress-bar//text-formatter?": {
		Doc:   "Get *widget.ProgressBar TextFormatter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//text-formatter?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//text-formatter?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//text-formatter?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextFormatter, "func()_(string)")
			return resObj
		},
	},
	"ptr-progress-bar//unbind": {
		Doc:   "(*widget.ProgressBar).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-progress-bar//value!": {
		Doc:   "Set *widget.ProgressBar Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//value!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//value!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//value!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-progress-bar//value!")
			}
			return arg0
		},
	},
	"ptr-progress-bar//value?": {
		Doc:   "Get *widget.ProgressBar Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//value?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//value?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//value?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"ptr-progress-bar//visible": {
		Doc:   "(*widget.ProgressBar).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-bar//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-progress-dialog//set-value": {
		Doc:   "(*dialog.ProgressDialog).SetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ProgressDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ProgressDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-dialog//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-dialog//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-dialog//set-value")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-progress-dialog//set-value")
			}
			arg0Val.SetValue(arg1Val)
			return arg0
		},
	},
	"ptr-progress-infinite-dialog//hide": {
		Doc:   "(*dialog.ProgressInfiniteDialog).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ProgressInfiniteDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ProgressInfiniteDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-infinite-dialog//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-infinite-dialog//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-progress-infinite-dialog//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-radial-gradient//center-offset-x!": {
		Doc:   "Set *canvas.RadialGradient CenterOffsetX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-x!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-x!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-x!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetX = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-radial-gradient//center-offset-x!")
			}
			return arg0
		},
	},
	"ptr-radial-gradient//center-offset-x?": {
		Doc:   "Get *canvas.RadialGradient CenterOffsetX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-x?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-x?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-x?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetX))
			return resObj
		},
	},
	"ptr-radial-gradient//center-offset-y!": {
		Doc:   "Set *canvas.RadialGradient CenterOffsetY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-y!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-y!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-y!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetY = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-radial-gradient//center-offset-y!")
			}
			return arg0
		},
	},
	"ptr-radial-gradient//center-offset-y?": {
		Doc:   "Get *canvas.RadialGradient CenterOffsetY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-y?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-y?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//center-offset-y?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetY))
			return resObj
		},
	},
	"ptr-radial-gradient//end-color!": {
		Doc:   "Set *canvas.RadialGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//end-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//end-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//end-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radial-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radial-gradient//end-color!")
			}
			return arg0
		},
	},
	"ptr-radial-gradient//end-color?": {
		Doc:   "Get *canvas.RadialGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//end-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//end-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//end-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color")
			return resObj
		},
	},
	"ptr-radial-gradient//generate": {
		Doc:   "(*canvas.RadialGradient).Generate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//generate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//generate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//generate")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-radial-gradient//generate")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "ptr-radial-gradient//generate")
			}
			res0 := arg0Val.Generate(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image")
			return res0Obj
		},
	},
	"ptr-radial-gradient//hide": {
		Doc:   "(*canvas.RadialGradient).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-radial-gradient//move": {
		Doc:   "(*canvas.RadialGradient).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radial-gradient//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radial-gradient//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-radial-gradient//refresh": {
		Doc:   "(*canvas.RadialGradient).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-radial-gradient//start-color!": {
		Doc:   "Set *canvas.RadialGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//start-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//start-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//start-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radial-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radial-gradient//start-color!")
			}
			return arg0
		},
	},
	"ptr-radial-gradient//start-color?": {
		Doc:   "Get *canvas.RadialGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//start-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//start-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radial-gradient//start-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color")
			return resObj
		},
	},
	"ptr-radio-group//append": {
		Doc:   "(*widget.RadioGroup).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-radio-group//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-radio-group//create-renderer": {
		Doc:   "(*widget.RadioGroup).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-radio-group//disable": {
		Doc:   "(*widget.RadioGroup).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-radio-group//disabled": {
		Doc:   "(*widget.RadioGroup).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-radio-group//enable": {
		Doc:   "(*widget.RadioGroup).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-radio-group//extend-base-widget": {
		Doc:   "(*widget.RadioGroup).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radio-group//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radio-group//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radio-group//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-radio-group//hidden!": {
		Doc:   "Set *widget.RadioGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-radio-group//hidden!")
			}
			return arg0
		},
	},
	"ptr-radio-group//hidden?": {
		Doc:   "Get *widget.RadioGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-radio-group//hide": {
		Doc:   "(*widget.RadioGroup).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-radio-group//horizontal!": {
		Doc:   "Set *widget.RadioGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//horizontal!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//horizontal!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-radio-group//horizontal!")
			}
			return arg0
		},
	},
	"ptr-radio-group//horizontal?": {
		Doc:   "Get *widget.RadioGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//horizontal?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//horizontal?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"ptr-radio-group//min-size": {
		Doc:   "(*widget.RadioGroup).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-radio-group//move": {
		Doc:   "(*widget.RadioGroup).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radio-group//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radio-group//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-radio-group//on-changed!": {
		Doc:   "Set *widget.RadioGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-radio-group//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-radio-group//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-radio-group//on-changed!")
			}
			return arg0
		},
	},
	"ptr-radio-group//on-changed?": {
		Doc:   "Get *widget.RadioGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"ptr-radio-group//options!": {
		Doc:   "Set *widget.RadioGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//options!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-radio-group//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-radio-group//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-radio-group//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-radio-group//options!")
			}
			return arg0
		},
	},
	"ptr-radio-group//options?": {
		Doc:   "Get *widget.RadioGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//options?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//options?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//options?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-radio-group//position": {
		Doc:   "(*widget.RadioGroup).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-radio-group//refresh": {
		Doc:   "(*widget.RadioGroup).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-radio-group//required!": {
		Doc:   "Set *widget.RadioGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//required!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//required!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//required!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-radio-group//required!")
			}
			return arg0
		},
	},
	"ptr-radio-group//required?": {
		Doc:   "Get *widget.RadioGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//required?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//required?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//required?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"ptr-radio-group//resize": {
		Doc:   "(*widget.RadioGroup).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radio-group//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-radio-group//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-radio-group//selected!": {
		Doc:   "Set *widget.RadioGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//selected!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-radio-group//selected!")
			}
			return arg0
		},
	},
	"ptr-radio-group//selected?": {
		Doc:   "Get *widget.RadioGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//selected?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"ptr-radio-group//set-selected": {
		Doc:   "(*widget.RadioGroup).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//set-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//set-selected")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-radio-group//set-selected")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"ptr-radio-group//show": {
		Doc:   "(*widget.RadioGroup).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-radio-group//size": {
		Doc:   "(*widget.RadioGroup).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-radio-group//visible": {
		Doc:   "(*widget.RadioGroup).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-radio-group//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-raster//alpha": {
		Doc:   "(*canvas.Raster).Alpha",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//alpha")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//alpha")
			}
			res0 := arg0Val.Alpha()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"ptr-raster//generator!": {
		Doc:   "Set *canvas.Raster Generator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//generator!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//generator!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//generator!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-raster//generator!")
				}
				self.Generator = func(arg0 int, arg1 int) image.Image {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
					var res image.Image
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(image.Image)
						if !ok {
							// TODO: Invalid type
						}
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-raster//generator!")
				}
				self.Generator = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-raster//generator!")
			}
			return arg0
		},
	},
	"ptr-raster//generator?": {
		Doc:   "Get *canvas.Raster Generator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//generator?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//generator?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//generator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Generator, "func(int_int)_(image)")
			return resObj
		},
	},
	"ptr-raster//hide": {
		Doc:   "(*canvas.Raster).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-raster//move": {
		Doc:   "(*canvas.Raster).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-raster//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-raster//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-raster//refresh": {
		Doc:   "(*canvas.Raster).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-raster//resize": {
		Doc:   "(*canvas.Raster).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-raster//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-raster//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-raster//scale-mode!": {
		Doc:   "Set *canvas.Raster ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//scale-mode!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//scale-mode!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//scale-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ScaleMode, ok = v.Value.(canvas.ImageScale)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-raster//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-raster//scale-mode!")
			}
			return arg0
		},
	},
	"ptr-raster//scale-mode?": {
		Doc:   "Get *canvas.Raster ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//scale-mode?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//scale-mode?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//scale-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ScaleMode, "image-scale")
			return resObj
		},
	},
	"ptr-raster//translucency!": {
		Doc:   "Set *canvas.Raster Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//translucency!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//translucency!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//translucency!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-raster//translucency!")
			}
			return arg0
		},
	},
	"ptr-raster//translucency?": {
		Doc:   "Get *canvas.Raster Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//translucency?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//translucency?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-raster//translucency?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"ptr-rectangle//corner-radius!": {
		Doc:   "Set *canvas.Rectangle CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//corner-radius!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//corner-radius!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//corner-radius!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CornerRadius = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-rectangle//corner-radius!")
			}
			return arg0
		},
	},
	"ptr-rectangle//corner-radius?": {
		Doc:   "Get *canvas.Rectangle CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//corner-radius?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//corner-radius?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//corner-radius?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CornerRadius))
			return resObj
		},
	},
	"ptr-rectangle//fill-color!": {
		Doc:   "Set *canvas.Rectangle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//fill-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//fill-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//fill-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rectangle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rectangle//fill-color!")
			}
			return arg0
		},
	},
	"ptr-rectangle//fill-color?": {
		Doc:   "Get *canvas.Rectangle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//fill-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//fill-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//fill-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color")
			return resObj
		},
	},
	"ptr-rectangle//hide": {
		Doc:   "(*canvas.Rectangle).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-rectangle//move": {
		Doc:   "(*canvas.Rectangle).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rectangle//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rectangle//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-rectangle//refresh": {
		Doc:   "(*canvas.Rectangle).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-rectangle//resize": {
		Doc:   "(*canvas.Rectangle).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rectangle//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rectangle//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-rectangle//stroke-color!": {
		Doc:   "Set *canvas.Rectangle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rectangle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rectangle//stroke-color!")
			}
			return arg0
		},
	},
	"ptr-rectangle//stroke-color?": {
		Doc:   "Get *canvas.Rectangle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color")
			return resObj
		},
	},
	"ptr-rectangle//stroke-width!": {
		Doc:   "Set *canvas.Rectangle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-rectangle//stroke-width!")
			}
			return arg0
		},
	},
	"ptr-rectangle//stroke-width?": {
		Doc:   "Get *canvas.Rectangle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rectangle//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"ptr-rich-text-style//alignment!": {
		Doc:   "Set *widget.RichTextStyle Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text-style//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text-style//alignment!")
			}
			return arg0
		},
	},
	"ptr-rich-text-style//alignment?": {
		Doc:   "Get *widget.RichTextStyle Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"ptr-rich-text-style//color-name!": {
		Doc:   "Set *widget.RichTextStyle ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//color-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//color-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//color-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorName, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text-style//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text-style//color-name!")
			}
			return arg0
		},
	},
	"ptr-rich-text-style//color-name?": {
		Doc:   "Get *widget.RichTextStyle ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//color-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//color-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//color-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorName, "theme-color-name")
			return resObj
		},
	},
	"ptr-rich-text-style//inline!": {
		Doc:   "Set *widget.RichTextStyle Inline value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//inline!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//inline!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//inline!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Inline = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-rich-text-style//inline!")
			}
			return arg0
		},
	},
	"ptr-rich-text-style//inline?": {
		Doc:   "Get *widget.RichTextStyle Inline value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//inline?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//inline?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//inline?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Inline))
			return resObj
		},
	},
	"ptr-rich-text-style//size-name!": {
		Doc:   "Set *widget.RichTextStyle SizeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//size-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//size-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//size-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.SizeName, ok = v.Value.(fyne.ThemeSizeName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text-style//size-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text-style//size-name!")
			}
			return arg0
		},
	},
	"ptr-rich-text-style//size-name?": {
		Doc:   "Get *widget.RichTextStyle SizeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//size-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//size-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//size-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SizeName, "theme-size-name")
			return resObj
		},
	},
	"ptr-rich-text-style//text-style!": {
		Doc:   "Set *widget.RichTextStyle TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text-style//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text-style//text-style!")
			}
			return arg0
		},
	},
	"ptr-rich-text-style//text-style?": {
		Doc:   "Get *widget.RichTextStyle TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text-style//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"ptr-rich-text//create-renderer": {
		Doc:   "(*widget.RichText).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-rich-text//extend-base-widget": {
		Doc:   "(*widget.RichText).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-rich-text//hidden!": {
		Doc:   "Set *widget.RichText Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-rich-text//hidden!")
			}
			return arg0
		},
	},
	"ptr-rich-text//hidden?": {
		Doc:   "Get *widget.RichText Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-rich-text//hide": {
		Doc:   "(*widget.RichText).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-rich-text//min-size": {
		Doc:   "(*widget.RichText).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-rich-text//move": {
		Doc:   "(*widget.RichText).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-rich-text//parse-markdown": {
		Doc:   "(*widget.RichText).ParseMarkdown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//parse-markdown")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//parse-markdown")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//parse-markdown")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-rich-text//parse-markdown")
			}
			arg0Val.ParseMarkdown(arg1Val)
			return arg0
		},
	},
	"ptr-rich-text//position": {
		Doc:   "(*widget.RichText).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-rich-text//refresh": {
		Doc:   "(*widget.RichText).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-rich-text//resize": {
		Doc:   "(*widget.RichText).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-rich-text//scroll!": {
		Doc:   "Set *widget.RichText Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//scroll!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//scroll!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//scroll!")
			}
			return arg0
		},
	},
	"ptr-rich-text//scroll?": {
		Doc:   "Get *widget.RichText Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//scroll?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//scroll?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "scroll-direction")
			return resObj
		},
	},
	"ptr-rich-text//segments!": {
		Doc:   "Set *widget.RichText Segments value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//segments!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//segments!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//segments!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Segments = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Segments[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-rich-text//segments!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-rich-text//segments!")
						}
						self.Segments[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-rich-text//segments!")
					}
				}
			case env.Native:
				var ok bool
				self.Segments, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-rich-text//segments!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-rich-text//segments!")
				}
				self.Segments = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-rich-text//segments!")
			}
			return arg0
		},
	},
	"ptr-rich-text//segments?": {
		Doc:   "Get *widget.RichText Segments value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//segments?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//segments?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//segments?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Segments))
				for i, it := range self.Segments {
					items[i] = *env.NewNative(ps.Idx, it, "rich-text-segment")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-rich-text//show": {
		Doc:   "(*widget.RichText).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-rich-text//size": {
		Doc:   "(*widget.RichText).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-rich-text//string": {
		Doc:   "(*widget.RichText).String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//string")
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-rich-text//truncation!": {
		Doc:   "Set *widget.RichText Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//truncation!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//truncation!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//truncation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Truncation, ok = v.Value.(fyne.TextTruncation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//truncation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//truncation!")
			}
			return arg0
		},
	},
	"ptr-rich-text//truncation?": {
		Doc:   "Get *widget.RichText Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//truncation?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//truncation?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//truncation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Truncation, "text-truncation")
			return resObj
		},
	},
	"ptr-rich-text//visible": {
		Doc:   "(*widget.RichText).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-rich-text//wrapping!": {
		Doc:   "Set *widget.RichText Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//wrapping!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//wrapping!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-rich-text//wrapping!")
			}
			return arg0
		},
	},
	"ptr-rich-text//wrapping?": {
		Doc:   "Get *widget.RichText Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//wrapping?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//wrapping?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-rich-text//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"ptr-scroll-event//absolute-position!": {
		Doc:   "Set *fyne.ScrollEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-scroll-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-scroll-event//absolute-position!")
			}
			return arg0
		},
	},
	"ptr-scroll-event//absolute-position?": {
		Doc:   "Get *fyne.ScrollEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"ptr-scroll-event//position!": {
		Doc:   "Set *fyne.ScrollEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-scroll-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-scroll-event//position!")
			}
			return arg0
		},
	},
	"ptr-scroll-event//position?": {
		Doc:   "Get *fyne.ScrollEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"ptr-scroll-event//scrolled!": {
		Doc:   "Set *fyne.ScrollEvent Scrolled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//scrolled!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//scrolled!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//scrolled!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scrolled, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-scroll-event//scrolled!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-scroll-event//scrolled!")
			}
			return arg0
		},
	},
	"ptr-scroll-event//scrolled?": {
		Doc:   "Get *fyne.ScrollEvent Scrolled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//scrolled?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//scrolled?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-scroll-event//scrolled?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scrolled, "delta")
			return resObj
		},
	},
	"ptr-select-entry//accepts-tab": {
		Doc:   "(*widget.SelectEntry).AcceptsTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//accepts-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//accepts-tab")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//accepts-tab")
			}
			res0 := arg0Val.AcceptsTab()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-select-entry//action-item!": {
		Doc:   "Set *widget.SelectEntry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//action-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//action-item!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//action-item!")
				}
				self.ActionItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//action-item!")
			}
			return arg0
		},
	},
	"ptr-select-entry//action-item?": {
		Doc:   "Get *widget.SelectEntry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//action-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//action-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//action-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ActionItem, "canvas-object")
			return resObj
		},
	},
	"ptr-select-entry//append": {
		Doc:   "(*widget.SelectEntry).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-select-entry//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//bind": {
		Doc:   "(*widget.SelectEntry).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//bind")
			}
			var arg1Val binding.String
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//create-renderer": {
		Doc:   "(*widget.SelectEntry).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-select-entry//cursor": {
		Doc:   "(*widget.SelectEntry).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "cursor")
			return res0Obj
		},
	},
	"ptr-select-entry//cursor-column!": {
		Doc:   "Set *widget.SelectEntry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-column!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-column!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-select-entry//cursor-column!")
			}
			return arg0
		},
	},
	"ptr-select-entry//cursor-column?": {
		Doc:   "Get *widget.SelectEntry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-column?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-column?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"ptr-select-entry//cursor-row!": {
		Doc:   "Set *widget.SelectEntry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-row!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-row!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-select-entry//cursor-row!")
			}
			return arg0
		},
	},
	"ptr-select-entry//cursor-row?": {
		Doc:   "Get *widget.SelectEntry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-row?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-row?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//cursor-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"ptr-select-entry//disable": {
		Doc:   "(*widget.SelectEntry).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-select-entry//disabled": {
		Doc:   "(*widget.SelectEntry).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-select-entry//double-tapped": {
		Doc:   "(*widget.SelectEntry).DoubleTapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//double-tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//double-tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//double-tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//double-tapped")
			}
			arg0Val.DoubleTapped(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//drag-end": {
		Doc:   "(*widget.SelectEntry).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//drag-end")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//drag-end")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//drag-end")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"ptr-select-entry//dragged": {
		Doc:   "(*widget.SelectEntry).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//dragged")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//dragged")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//dragged")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//dragged")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//enable": {
		Doc:   "(*widget.SelectEntry).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-select-entry//extend-base-widget": {
		Doc:   "(*widget.SelectEntry).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//focus-gained": {
		Doc:   "(*widget.SelectEntry).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-select-entry//focus-lost": {
		Doc:   "(*widget.SelectEntry).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-select-entry//hidden!": {
		Doc:   "Set *widget.SelectEntry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-select-entry//hidden!")
			}
			return arg0
		},
	},
	"ptr-select-entry//hidden?": {
		Doc:   "Get *widget.SelectEntry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-select-entry//hide": {
		Doc:   "(*widget.SelectEntry).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-select-entry//key-down": {
		Doc:   "(*widget.SelectEntry).KeyDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//key-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//key-down")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//key-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//key-down")
			}
			arg0Val.KeyDown(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//key-up": {
		Doc:   "(*widget.SelectEntry).KeyUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//key-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//key-up")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//key-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//key-up")
			}
			arg0Val.KeyUp(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//keyboard": {
		Doc:   "(*widget.SelectEntry).Keyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//keyboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//keyboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//keyboard")
			}
			res0 := arg0Val.Keyboard()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "keyboard-type")
			return res0Obj
		},
	},
	"ptr-select-entry//min-size": {
		Doc:   "(*widget.SelectEntry).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-select-entry//mouse-down": {
		Doc:   "(*widget.SelectEntry).MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//mouse-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//mouse-down")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//mouse-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//mouse-down")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//mouse-up": {
		Doc:   "(*widget.SelectEntry).MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//mouse-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//mouse-up")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//mouse-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//mouse-up")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//move": {
		Doc:   "(*widget.SelectEntry).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//multi-line!": {
		Doc:   "Set *widget.SelectEntry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//multi-line!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//multi-line!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//multi-line!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-select-entry//multi-line!")
			}
			return arg0
		},
	},
	"ptr-select-entry//multi-line?": {
		Doc:   "Get *widget.SelectEntry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//multi-line?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//multi-line?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//multi-line?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"ptr-select-entry//on-changed!": {
		Doc:   "Set *widget.SelectEntry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select-entry//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select-entry//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select-entry//on-changed!")
			}
			return arg0
		},
	},
	"ptr-select-entry//on-changed?": {
		Doc:   "Get *widget.SelectEntry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"ptr-select-entry//on-cursor-changed!": {
		Doc:   "Set *widget.SelectEntry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-cursor-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-cursor-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-cursor-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select-entry//on-cursor-changed!")
			}
			return arg0
		},
	},
	"ptr-select-entry//on-cursor-changed?": {
		Doc:   "Get *widget.SelectEntry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-cursor-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-cursor-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-cursor-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "func()")
			return resObj
		},
	},
	"ptr-select-entry//on-submitted!": {
		Doc:   "Set *widget.SelectEntry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-submitted!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-submitted!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-submitted!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select-entry//on-submitted!")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select-entry//on-submitted!")
				}
				self.OnSubmitted = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select-entry//on-submitted!")
			}
			return arg0
		},
	},
	"ptr-select-entry//on-submitted?": {
		Doc:   "Get *widget.SelectEntry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-submitted?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-submitted?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//on-submitted?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "func(string)")
			return resObj
		},
	},
	"ptr-select-entry//password!": {
		Doc:   "Set *widget.SelectEntry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//password!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//password!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//password!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-select-entry//password!")
			}
			return arg0
		},
	},
	"ptr-select-entry//password?": {
		Doc:   "Get *widget.SelectEntry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//password?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//password?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//password?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"ptr-select-entry//place-holder!": {
		Doc:   "Set *widget.SelectEntry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//place-holder!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//place-holder!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-select-entry//place-holder!")
			}
			return arg0
		},
	},
	"ptr-select-entry//place-holder?": {
		Doc:   "Get *widget.SelectEntry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//place-holder?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//place-holder?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"ptr-select-entry//position": {
		Doc:   "(*widget.SelectEntry).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-select-entry//refresh": {
		Doc:   "(*widget.SelectEntry).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-select-entry//resize": {
		Doc:   "(*widget.SelectEntry).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//scroll!": {
		Doc:   "Set *widget.SelectEntry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//scroll!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//scroll!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//scroll!")
			}
			return arg0
		},
	},
	"ptr-select-entry//scroll?": {
		Doc:   "Get *widget.SelectEntry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//scroll?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//scroll?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "scroll-direction")
			return resObj
		},
	},
	"ptr-select-entry//selected-text": {
		Doc:   "(*widget.SelectEntry).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-select-entry//set-min-rows-visible": {
		Doc:   "(*widget.SelectEntry).SetMinRowsVisible",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-min-rows-visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-min-rows-visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-min-rows-visible")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-select-entry//set-min-rows-visible")
			}
			arg0Val.SetMinRowsVisible(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//set-on-validation-changed": {
		Doc:   "(*widget.SelectEntry).SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-on-validation-changed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-on-validation-changed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-on-validation-changed")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select-entry//set-on-validation-changed")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select-entry//set-on-validation-changed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select-entry//set-on-validation-changed")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//set-options": {
		Doc:   "(*widget.SelectEntry).SetOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-options")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-options")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-options")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select-entry//set-options")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select-entry//set-options")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select-entry//set-options")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select-entry//set-options")
			}
			arg0Val.SetOptions(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//set-place-holder": {
		Doc:   "(*widget.SelectEntry).SetPlaceHolder",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-place-holder")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-place-holder")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-place-holder")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-select-entry//set-place-holder")
			}
			arg0Val.SetPlaceHolder(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//set-text": {
		Doc:   "(*widget.SelectEntry).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-select-entry//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//set-validation-error": {
		Doc:   "(*widget.SelectEntry).SetValidationError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-validation-error")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-validation-error")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//set-validation-error")
			}
			var arg1Val error
			if v, ok := arg1.(env.Error); ok {
				arg1Val = errors.New(v.Print(*ps.Idx))
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.ErrorType}, "ptr-select-entry//set-validation-error")
			}
			arg0Val.SetValidationError(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//show": {
		Doc:   "(*widget.SelectEntry).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-select-entry//size": {
		Doc:   "(*widget.SelectEntry).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-select-entry//tapped": {
		Doc:   "(*widget.SelectEntry).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//tapped-secondary": {
		Doc:   "(*widget.SelectEntry).TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//tapped-secondary")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//tapped-secondary")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//tapped-secondary")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//tapped-secondary")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//text!": {
		Doc:   "Set *widget.SelectEntry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-select-entry//text!")
			}
			return arg0
		},
	},
	"ptr-select-entry//text-style!": {
		Doc:   "Set *widget.SelectEntry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//text-style!")
			}
			return arg0
		},
	},
	"ptr-select-entry//text-style?": {
		Doc:   "Get *widget.SelectEntry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"ptr-select-entry//text?": {
		Doc:   "Get *widget.SelectEntry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-select-entry//touch-cancel": {
		Doc:   "(*widget.SelectEntry).TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//touch-cancel")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//touch-cancel")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//touch-cancel")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//touch-cancel")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//touch-down": {
		Doc:   "(*widget.SelectEntry).TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//touch-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//touch-down")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//touch-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//touch-down")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//touch-up": {
		Doc:   "(*widget.SelectEntry).TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//touch-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//touch-up")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//touch-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//touch-up")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//typed-key": {
		Doc:   "(*widget.SelectEntry).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//typed-rune": {
		Doc:   "(*widget.SelectEntry).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//typed-shortcut": {
		Doc:   "(*widget.SelectEntry).TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//typed-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//typed-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//typed-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//typed-shortcut")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"ptr-select-entry//unbind": {
		Doc:   "(*widget.SelectEntry).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-select-entry//validate": {
		Doc:   "(*widget.SelectEntry).Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//validate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//validate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//validate")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"ptr-select-entry//validator!": {
		Doc:   "Set *widget.SelectEntry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//validator!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//validator!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//validator!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Validator, ok = v.Value.(fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//validator!")
			}
			return arg0
		},
	},
	"ptr-select-entry//validator?": {
		Doc:   "Get *widget.SelectEntry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//validator?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//validator?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//validator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Validator, "string-validator")
			return resObj
		},
	},
	"ptr-select-entry//visible": {
		Doc:   "(*widget.SelectEntry).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-select-entry//wrapping!": {
		Doc:   "Set *widget.SelectEntry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//wrapping!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//wrapping!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select-entry//wrapping!")
			}
			return arg0
		},
	},
	"ptr-select-entry//wrapping?": {
		Doc:   "Get *widget.SelectEntry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//wrapping?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//wrapping?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select-entry//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"ptr-select//alignment!": {
		Doc:   "Set *widget.Select Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//alignment!")
			}
			return arg0
		},
	},
	"ptr-select//alignment?": {
		Doc:   "Get *widget.Select Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"ptr-select//clear-selected": {
		Doc:   "(*widget.Select).ClearSelected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//clear-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//clear-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//clear-selected")
			}
			arg0Val.ClearSelected()
			return arg0
		},
	},
	"ptr-select//create-renderer": {
		Doc:   "(*widget.Select).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-select//disable": {
		Doc:   "(*widget.Select).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"ptr-select//disabled": {
		Doc:   "(*widget.Select).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-select//enable": {
		Doc:   "(*widget.Select).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"ptr-select//extend-base-widget": {
		Doc:   "(*widget.Select).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-select//focus-gained": {
		Doc:   "(*widget.Select).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-select//focus-lost": {
		Doc:   "(*widget.Select).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-select//hidden!": {
		Doc:   "Set *widget.Select Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-select//hidden!")
			}
			return arg0
		},
	},
	"ptr-select//hidden?": {
		Doc:   "Get *widget.Select Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-select//hide": {
		Doc:   "(*widget.Select).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-select//min-size": {
		Doc:   "(*widget.Select).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-select//mouse-in": {
		Doc:   "(*widget.Select).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-select//mouse-moved": {
		Doc:   "(*widget.Select).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-select//mouse-out": {
		Doc:   "(*widget.Select).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-select//move": {
		Doc:   "(*widget.Select).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-select//on-changed!": {
		Doc:   "Set *widget.Select OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-select//on-changed!")
			}
			return arg0
		},
	},
	"ptr-select//on-changed?": {
		Doc:   "Get *widget.Select OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"ptr-select//options!": {
		Doc:   "Set *widget.Select Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//options!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select//options!")
			}
			return arg0
		},
	},
	"ptr-select//options?": {
		Doc:   "Get *widget.Select Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//options?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//options?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//options?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-select//place-holder!": {
		Doc:   "Set *widget.Select PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//place-holder!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//place-holder!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-select//place-holder!")
			}
			return arg0
		},
	},
	"ptr-select//place-holder?": {
		Doc:   "Get *widget.Select PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//place-holder?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//place-holder?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"ptr-select//position": {
		Doc:   "(*widget.Select).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-select//refresh": {
		Doc:   "(*widget.Select).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-select//resize": {
		Doc:   "(*widget.Select).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-select//selected!": {
		Doc:   "Set *widget.Select Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//selected!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-select//selected!")
			}
			return arg0
		},
	},
	"ptr-select//selected-index": {
		Doc:   "(*widget.Select).SelectedIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//selected-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//selected-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//selected-index")
			}
			res0 := arg0Val.SelectedIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"ptr-select//selected?": {
		Doc:   "Get *widget.Select Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//selected?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"ptr-select//set-options": {
		Doc:   "(*widget.Select).SetOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//set-options")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//set-options")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//set-options")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select//set-options")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select//set-options")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select//set-options")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-select//set-options")
			}
			arg0Val.SetOptions(arg1Val)
			return arg0
		},
	},
	"ptr-select//set-selected": {
		Doc:   "(*widget.Select).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//set-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//set-selected")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-select//set-selected")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"ptr-select//set-selected-index": {
		Doc:   "(*widget.Select).SetSelectedIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//set-selected-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//set-selected-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//set-selected-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-select//set-selected-index")
			}
			arg0Val.SetSelectedIndex(arg1Val)
			return arg0
		},
	},
	"ptr-select//show": {
		Doc:   "(*widget.Select).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-select//size": {
		Doc:   "(*widget.Select).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-select//tapped": {
		Doc:   "(*widget.Select).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-select//typed-key": {
		Doc:   "(*widget.Select).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-select//typed-rune": {
		Doc:   "(*widget.Select).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-select//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-select//visible": {
		Doc:   "(*widget.Select).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-select//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-separator-segment//inline": {
		Doc:   "(*widget.SeparatorSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-separator-segment//select": {
		Doc:   "(*widget.SeparatorSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator-segment//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-separator-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-separator-segment//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-separator-segment//selected-text": {
		Doc:   "(*widget.SeparatorSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-separator-segment//textual": {
		Doc:   "(*widget.SeparatorSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-separator-segment//unselect": {
		Doc:   "(*widget.SeparatorSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-separator-segment//update": {
		Doc:   "(*widget.SeparatorSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator-segment//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator-segment//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-separator-segment//visual": {
		Doc:   "(*widget.SeparatorSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator-segment//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"ptr-separator//create-renderer": {
		Doc:   "(*widget.Separator).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-separator//extend-base-widget": {
		Doc:   "(*widget.Separator).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-separator//hidden!": {
		Doc:   "Set *widget.Separator Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-separator//hidden!")
			}
			return arg0
		},
	},
	"ptr-separator//hidden?": {
		Doc:   "Get *widget.Separator Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-separator//hide": {
		Doc:   "(*widget.Separator).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-separator//min-size": {
		Doc:   "(*widget.Separator).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-separator//move": {
		Doc:   "(*widget.Separator).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-separator//position": {
		Doc:   "(*widget.Separator).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-separator//refresh": {
		Doc:   "(*widget.Separator).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-separator//resize": {
		Doc:   "(*widget.Separator).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-separator//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-separator//show": {
		Doc:   "(*widget.Separator).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-separator//size": {
		Doc:   "(*widget.Separator).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-separator//visible": {
		Doc:   "(*widget.Separator).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-separator//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-settings-schema//cloud-config!": {
		Doc:   "Set *app.SettingsSchema CloudConfig value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-config!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-config!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-config!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudConfig = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-settings-schema//cloud-config!")
			}
			return arg0
		},
	},
	"ptr-settings-schema//cloud-config?": {
		Doc:   "Get *app.SettingsSchema CloudConfig value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-config?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-config?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-config?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudConfig)
			return resObj
		},
	},
	"ptr-settings-schema//cloud-name!": {
		Doc:   "Set *app.SettingsSchema CloudName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-settings-schema//cloud-name!")
			}
			return arg0
		},
	},
	"ptr-settings-schema//cloud-name?": {
		Doc:   "Get *app.SettingsSchema CloudName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//cloud-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudName)
			return resObj
		},
	},
	"ptr-settings-schema//disable-animations!": {
		Doc:   "Set *app.SettingsSchema DisableAnimations value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//disable-animations!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//disable-animations!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//disable-animations!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.DisableAnimations = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-settings-schema//disable-animations!")
			}
			return arg0
		},
	},
	"ptr-settings-schema//disable-animations?": {
		Doc:   "Get *app.SettingsSchema DisableAnimations value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//disable-animations?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//disable-animations?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//disable-animations?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.DisableAnimations))
			return resObj
		},
	},
	"ptr-settings-schema//primary-color!": {
		Doc:   "Set *app.SettingsSchema PrimaryColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//primary-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//primary-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//primary-color!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PrimaryColor = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-settings-schema//primary-color!")
			}
			return arg0
		},
	},
	"ptr-settings-schema//primary-color?": {
		Doc:   "Get *app.SettingsSchema PrimaryColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//primary-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//primary-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//primary-color?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PrimaryColor)
			return resObj
		},
	},
	"ptr-settings-schema//scale!": {
		Doc:   "Set *app.SettingsSchema Scale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//scale!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//scale!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//scale!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Scale = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-settings-schema//scale!")
			}
			return arg0
		},
	},
	"ptr-settings-schema//scale?": {
		Doc:   "Get *app.SettingsSchema Scale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//scale?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//scale?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//scale?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Scale))
			return resObj
		},
	},
	"ptr-settings-schema//storage-path": {
		Doc:   "(*app.SettingsSchema).StoragePath",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//storage-path")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//storage-path")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//storage-path")
			}
			res0 := arg0Val.StoragePath()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-settings-schema//theme-name!": {
		Doc:   "Set *app.SettingsSchema ThemeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//theme-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//theme-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//theme-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.ThemeName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-settings-schema//theme-name!")
			}
			return arg0
		},
	},
	"ptr-settings-schema//theme-name?": {
		Doc:   "Get *app.SettingsSchema ThemeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//theme-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//theme-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-settings-schema//theme-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ThemeName)
			return resObj
		},
	},
	"ptr-shortcut-copy//clipboard!": {
		Doc:   "Set *fyne.ShortcutCopy Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//clipboard!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-copy//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-copy//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-copy//clipboard!")
			}
			return arg0
		},
	},
	"ptr-shortcut-copy//clipboard?": {
		Doc:   "Get *fyne.ShortcutCopy Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//clipboard?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//clipboard?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "clipboard")
			return resObj
		},
	},
	"ptr-shortcut-copy//key": {
		Doc:   "(*fyne.ShortcutCopy).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-name")
			return res0Obj
		},
	},
	"ptr-shortcut-copy//mod": {
		Doc:   "(*fyne.ShortcutCopy).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-modifier")
			return res0Obj
		},
	},
	"ptr-shortcut-copy//shortcut-name": {
		Doc:   "(*fyne.ShortcutCopy).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-copy//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-shortcut-cut//clipboard!": {
		Doc:   "Set *fyne.ShortcutCut Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//clipboard!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-cut//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-cut//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-cut//clipboard!")
			}
			return arg0
		},
	},
	"ptr-shortcut-cut//clipboard?": {
		Doc:   "Get *fyne.ShortcutCut Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//clipboard?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//clipboard?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "clipboard")
			return resObj
		},
	},
	"ptr-shortcut-cut//key": {
		Doc:   "(*fyne.ShortcutCut).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-name")
			return res0Obj
		},
	},
	"ptr-shortcut-cut//mod": {
		Doc:   "(*fyne.ShortcutCut).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-modifier")
			return res0Obj
		},
	},
	"ptr-shortcut-cut//shortcut-name": {
		Doc:   "(*fyne.ShortcutCut).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-cut//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-shortcut-handler//add-shortcut": {
		Doc:   "(*fyne.ShortcutHandler).AddShortcut",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutHandler
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutHandler)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-handler//add-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-handler//add-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-handler//add-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-handler//add-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-handler//add-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-handler//add-shortcut")
			}
			var arg2Val func(fyne.Shortcut)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "ptr-shortcut-handler//add-shortcut")
				}
				arg2Val = func(arg0 fyne.Shortcut) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "shortcut")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "ptr-shortcut-handler//add-shortcut")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "ptr-shortcut-handler//add-shortcut")
			}
			arg0Val.AddShortcut(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-shortcut-handler//remove-shortcut": {
		Doc:   "(*fyne.ShortcutHandler).RemoveShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutHandler
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutHandler)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-handler//remove-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-handler//remove-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-handler//remove-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-handler//remove-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-handler//remove-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-handler//remove-shortcut")
			}
			arg0Val.RemoveShortcut(arg1Val)
			return arg0
		},
	},
	"ptr-shortcut-handler//typed-shortcut": {
		Doc:   "(*fyne.ShortcutHandler).TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutHandler
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutHandler)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-handler//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-handler//typed-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-handler//typed-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-handler//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-handler//typed-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-handler//typed-shortcut")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"ptr-shortcut-paste//clipboard!": {
		Doc:   "Set *fyne.ShortcutPaste Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//clipboard!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-paste//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-paste//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-shortcut-paste//clipboard!")
			}
			return arg0
		},
	},
	"ptr-shortcut-paste//clipboard?": {
		Doc:   "Get *fyne.ShortcutPaste Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//clipboard?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//clipboard?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "clipboard")
			return resObj
		},
	},
	"ptr-shortcut-paste//key": {
		Doc:   "(*fyne.ShortcutPaste).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-name")
			return res0Obj
		},
	},
	"ptr-shortcut-paste//mod": {
		Doc:   "(*fyne.ShortcutPaste).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-modifier")
			return res0Obj
		},
	},
	"ptr-shortcut-paste//shortcut-name": {
		Doc:   "(*fyne.ShortcutPaste).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-paste//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-shortcut-select-all//key": {
		Doc:   "(*fyne.ShortcutSelectAll).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutSelectAll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutSelectAll)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-select-all//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-select-all//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-select-all//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-name")
			return res0Obj
		},
	},
	"ptr-shortcut-select-all//mod": {
		Doc:   "(*fyne.ShortcutSelectAll).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutSelectAll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutSelectAll)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-select-all//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-select-all//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-select-all//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "key-modifier")
			return res0Obj
		},
	},
	"ptr-shortcut-select-all//shortcut-name": {
		Doc:   "(*fyne.ShortcutSelectAll).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutSelectAll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutSelectAll)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-select-all//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-select-all//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-shortcut-select-all//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-size//height!": {
		Doc:   "Set *fyne.Size Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//height!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//height!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//height!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Height = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-size//height!")
			}
			return arg0
		},
	},
	"ptr-size//height?": {
		Doc:   "Get *fyne.Size Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//height?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//height?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//height?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Height))
			return resObj
		},
	},
	"ptr-size//width!": {
		Doc:   "Set *fyne.Size Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-size//width!")
			}
			return arg0
		},
	},
	"ptr-size//width?": {
		Doc:   "Get *fyne.Size Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-size//width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"ptr-slider//bind": {
		Doc:   "(*widget.Slider).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//bind")
			}
			var arg1Val binding.Float
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"ptr-slider//create-renderer": {
		Doc:   "(*widget.Slider).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-slider//drag-end": {
		Doc:   "(*widget.Slider).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//drag-end")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//drag-end")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//drag-end")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"ptr-slider//dragged": {
		Doc:   "(*widget.Slider).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//dragged")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//dragged")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//dragged")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//dragged")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"ptr-slider//extend-base-widget": {
		Doc:   "(*widget.Slider).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-slider//focus-gained": {
		Doc:   "(*widget.Slider).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-slider//focus-lost": {
		Doc:   "(*widget.Slider).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-slider//hidden!": {
		Doc:   "Set *widget.Slider Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-slider//hidden!")
			}
			return arg0
		},
	},
	"ptr-slider//hidden?": {
		Doc:   "Get *widget.Slider Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-slider//hide": {
		Doc:   "(*widget.Slider).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-slider//max!": {
		Doc:   "Set *widget.Slider Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//max!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//max!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//max!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-slider//max!")
			}
			return arg0
		},
	},
	"ptr-slider//max?": {
		Doc:   "Get *widget.Slider Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//max?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//max?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//max?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"ptr-slider//min!": {
		Doc:   "Set *widget.Slider Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//min!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//min!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//min!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-slider//min!")
			}
			return arg0
		},
	},
	"ptr-slider//min-size": {
		Doc:   "(*widget.Slider).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-slider//min?": {
		Doc:   "Get *widget.Slider Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//min?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//min?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//min?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"ptr-slider//mouse-in": {
		Doc:   "(*widget.Slider).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-slider//mouse-moved": {
		Doc:   "(*widget.Slider).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-slider//mouse-out": {
		Doc:   "(*widget.Slider).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-slider//move": {
		Doc:   "(*widget.Slider).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-slider//on-change-ended!": {
		Doc:   "Set *widget.Slider OnChangeEnded value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-change-ended!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-change-ended!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-change-ended!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-slider//on-change-ended!")
				}
				self.OnChangeEnded = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-slider//on-change-ended!")
				}
				self.OnChangeEnded = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-slider//on-change-ended!")
			}
			return arg0
		},
	},
	"ptr-slider//on-change-ended?": {
		Doc:   "Get *widget.Slider OnChangeEnded value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-change-ended?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-change-ended?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-change-ended?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChangeEnded, "func(float64)")
			return resObj
		},
	},
	"ptr-slider//on-changed!": {
		Doc:   "Set *widget.Slider OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-slider//on-changed!")
				}
				self.OnChanged = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-slider//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-slider//on-changed!")
			}
			return arg0
		},
	},
	"ptr-slider//on-changed?": {
		Doc:   "Get *widget.Slider OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(float64)")
			return resObj
		},
	},
	"ptr-slider//orientation!": {
		Doc:   "Set *widget.Slider Orientation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//orientation!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//orientation!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//orientation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Orientation, ok = v.Value.(widget.Orientation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//orientation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//orientation!")
			}
			return arg0
		},
	},
	"ptr-slider//orientation?": {
		Doc:   "Get *widget.Slider Orientation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//orientation?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//orientation?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//orientation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Orientation, "orientation")
			return resObj
		},
	},
	"ptr-slider//position": {
		Doc:   "(*widget.Slider).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-slider//refresh": {
		Doc:   "(*widget.Slider).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-slider//resize": {
		Doc:   "(*widget.Slider).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-slider//set-value": {
		Doc:   "(*widget.Slider).SetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//set-value")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-slider//set-value")
			}
			arg0Val.SetValue(arg1Val)
			return arg0
		},
	},
	"ptr-slider//show": {
		Doc:   "(*widget.Slider).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-slider//size": {
		Doc:   "(*widget.Slider).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-slider//step!": {
		Doc:   "Set *widget.Slider Step value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//step!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//step!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//step!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Step = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-slider//step!")
			}
			return arg0
		},
	},
	"ptr-slider//step?": {
		Doc:   "Get *widget.Slider Step value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//step?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//step?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//step?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Step))
			return resObj
		},
	},
	"ptr-slider//tapped": {
		Doc:   "(*widget.Slider).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-slider//typed-key": {
		Doc:   "(*widget.Slider).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-slider//typed-rune": {
		Doc:   "(*widget.Slider).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-slider//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-slider//unbind": {
		Doc:   "(*widget.Slider).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"ptr-slider//value!": {
		Doc:   "Set *widget.Slider Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//value!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//value!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//value!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-slider//value!")
			}
			return arg0
		},
	},
	"ptr-slider//value?": {
		Doc:   "Get *widget.Slider Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//value?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//value?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//value?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"ptr-slider//visible": {
		Doc:   "(*widget.Slider).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-slider//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-spacer//expand-horizontal": {
		Doc:   "(*layout.Spacer).ExpandHorizontal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//expand-horizontal")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//expand-horizontal")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//expand-horizontal")
			}
			res0 := arg0Val.ExpandHorizontal()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-spacer//expand-vertical": {
		Doc:   "(*layout.Spacer).ExpandVertical",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//expand-vertical")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//expand-vertical")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//expand-vertical")
			}
			res0 := arg0Val.ExpandVertical()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-spacer//fix-horizontal!": {
		Doc:   "Set *layout.Spacer FixHorizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-horizontal!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-horizontal!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixHorizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-spacer//fix-horizontal!")
			}
			return arg0
		},
	},
	"ptr-spacer//fix-horizontal?": {
		Doc:   "Get *layout.Spacer FixHorizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-horizontal?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-horizontal?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixHorizontal))
			return resObj
		},
	},
	"ptr-spacer//fix-vertical!": {
		Doc:   "Set *layout.Spacer FixVertical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-vertical!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-vertical!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-vertical!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixVertical = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-spacer//fix-vertical!")
			}
			return arg0
		},
	},
	"ptr-spacer//fix-vertical?": {
		Doc:   "Get *layout.Spacer FixVertical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-vertical?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-vertical?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//fix-vertical?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixVertical))
			return resObj
		},
	},
	"ptr-spacer//hide": {
		Doc:   "(*layout.Spacer).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-spacer//min-size": {
		Doc:   "(*layout.Spacer).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-spacer//move": {
		Doc:   "(*layout.Spacer).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-spacer//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-spacer//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-spacer//position": {
		Doc:   "(*layout.Spacer).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-spacer//refresh": {
		Doc:   "(*layout.Spacer).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-spacer//resize": {
		Doc:   "(*layout.Spacer).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-spacer//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-spacer//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-spacer//show": {
		Doc:   "(*layout.Spacer).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-spacer//size": {
		Doc:   "(*layout.Spacer).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-spacer//visible": {
		Doc:   "(*layout.Spacer).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-spacer//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-split//create-renderer": {
		Doc:   "(*container.Split).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-split//extend-base-widget": {
		Doc:   "(*container.Split).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-split//hidden!": {
		Doc:   "Set *container.Split Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-split//hidden!")
			}
			return arg0
		},
	},
	"ptr-split//hidden?": {
		Doc:   "Get *container.Split Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-split//hide": {
		Doc:   "(*container.Split).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-split//horizontal!": {
		Doc:   "Set *container.Split Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//horizontal!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//horizontal!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-split//horizontal!")
			}
			return arg0
		},
	},
	"ptr-split//horizontal?": {
		Doc:   "Get *container.Split Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//horizontal?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//horizontal?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"ptr-split//leading!": {
		Doc:   "Set *container.Split Leading value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//leading!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//leading!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//leading!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Leading, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//leading!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//leading!")
				}
				self.Leading = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//leading!")
			}
			return arg0
		},
	},
	"ptr-split//leading?": {
		Doc:   "Get *container.Split Leading value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//leading?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//leading?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//leading?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Leading, "canvas-object")
			return resObj
		},
	},
	"ptr-split//min-size": {
		Doc:   "(*container.Split).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-split//move": {
		Doc:   "(*container.Split).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-split//offset!": {
		Doc:   "Set *container.Split Offset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//offset!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//offset!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//offset!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Offset = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-split//offset!")
			}
			return arg0
		},
	},
	"ptr-split//offset?": {
		Doc:   "Get *container.Split Offset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//offset?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//offset?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//offset?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Offset))
			return resObj
		},
	},
	"ptr-split//position": {
		Doc:   "(*container.Split).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-split//refresh": {
		Doc:   "(*container.Split).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-split//resize": {
		Doc:   "(*container.Split).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-split//set-offset": {
		Doc:   "(*container.Split).SetOffset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//set-offset")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//set-offset")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//set-offset")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-split//set-offset")
			}
			arg0Val.SetOffset(arg1Val)
			return arg0
		},
	},
	"ptr-split//show": {
		Doc:   "(*container.Split).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-split//size": {
		Doc:   "(*container.Split).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-split//trailing!": {
		Doc:   "Set *container.Split Trailing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//trailing!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//trailing!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//trailing!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Trailing, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//trailing!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//trailing!")
				}
				self.Trailing = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-split//trailing!")
			}
			return arg0
		},
	},
	"ptr-split//trailing?": {
		Doc:   "Get *container.Split Trailing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//trailing?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//trailing?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//trailing?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Trailing, "canvas-object")
			return resObj
		},
	},
	"ptr-split//visible": {
		Doc:   "(*container.Split).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-split//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-static-resource//content": {
		Doc:   "(*fyne.StaticResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-static-resource//go-string": {
		Doc:   "(*fyne.StaticResource).GoString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//go-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//go-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//go-string")
			}
			res0 := arg0Val.GoString()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-static-resource//name": {
		Doc:   "(*fyne.StaticResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-static-resource//static-content!": {
		Doc:   "Set *fyne.StaticResource StaticContent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-content!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.StaticContent = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.StaticContent[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-static-resource//static-content!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-static-resource//static-content!")
					}
				}
			case env.Native:
				var ok bool
				self.StaticContent, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-static-resource//static-content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-static-resource//static-content!")
				}
				self.StaticContent = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-static-resource//static-content!")
			}
			return arg0
		},
	},
	"ptr-static-resource//static-content?": {
		Doc:   "Get *fyne.StaticResource StaticContent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-content?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.StaticContent))
				for i, it := range self.StaticContent {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-static-resource//static-name!": {
		Doc:   "Set *fyne.StaticResource StaticName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.StaticName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-static-resource//static-name!")
			}
			return arg0
		},
	},
	"ptr-static-resource//static-name?": {
		Doc:   "Get *fyne.StaticResource StaticName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-static-resource//static-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.StaticName)
			return resObj
		},
	},
	"ptr-tab-item//content!": {
		Doc:   "Set *container.TabItem Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tab-item//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tab-item//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tab-item//content!")
			}
			return arg0
		},
	},
	"ptr-tab-item//content?": {
		Doc:   "Get *container.TabItem Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "canvas-object")
			return resObj
		},
	},
	"ptr-tab-item//disabled": {
		Doc:   "(*container.TabItem).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-tab-item//icon!": {
		Doc:   "Set *container.TabItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//icon!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tab-item//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tab-item//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tab-item//icon!")
			}
			return arg0
		},
	},
	"ptr-tab-item//icon?": {
		Doc:   "Get *container.TabItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//icon?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//icon?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"ptr-tab-item//text!": {
		Doc:   "Set *container.TabItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-tab-item//text!")
			}
			return arg0
		},
	},
	"ptr-tab-item//text?": {
		Doc:   "Get *container.TabItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tab-item//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-table-cell-id//col!": {
		Doc:   "Set *widget.TableCellID Col value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//col!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//col!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//col!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Col = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-table-cell-id//col!")
			}
			return arg0
		},
	},
	"ptr-table-cell-id//col?": {
		Doc:   "Get *widget.TableCellID Col value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//col?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//col?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//col?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Col))
			return resObj
		},
	},
	"ptr-table-cell-id//row!": {
		Doc:   "Set *widget.TableCellID Row value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//row!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//row!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Row = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-table-cell-id//row!")
			}
			return arg0
		},
	},
	"ptr-table-cell-id//row?": {
		Doc:   "Get *widget.TableCellID Row value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//row?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//row?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table-cell-id//row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Row))
			return resObj
		},
	},
	"ptr-table//create-cell!": {
		Doc:   "Set *widget.Table CreateCell value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-cell!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-cell!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-cell!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//create-cell!")
				}
				self.CreateCell = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-table//create-cell!")
				}
				self.CreateCell = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//create-cell!")
			}
			return arg0
		},
	},
	"ptr-table//create-cell?": {
		Doc:   "Get *widget.Table CreateCell value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-cell?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-cell?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-cell?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateCell, "func()_(canvas-object)")
			return resObj
		},
	},
	"ptr-table//create-header!": {
		Doc:   "Set *widget.Table CreateHeader value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-header!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-header!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-header!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//create-header!")
				}
				self.CreateHeader = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-table//create-header!")
				}
				self.CreateHeader = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//create-header!")
			}
			return arg0
		},
	},
	"ptr-table//create-header?": {
		Doc:   "Get *widget.Table CreateHeader value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-header?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-header?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-header?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateHeader, "func()_(canvas-object)")
			return resObj
		},
	},
	"ptr-table//create-renderer": {
		Doc:   "(*widget.Table).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-table//cursor": {
		Doc:   "(*widget.Table).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "cursor")
			return res0Obj
		},
	},
	"ptr-table//drag-end": {
		Doc:   "(*widget.Table).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//drag-end")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//drag-end")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//drag-end")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"ptr-table//dragged": {
		Doc:   "(*widget.Table).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//dragged")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//dragged")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//dragged")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//dragged")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"ptr-table//extend-base-widget": {
		Doc:   "(*widget.Table).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-table//focus-gained": {
		Doc:   "(*widget.Table).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-table//focus-lost": {
		Doc:   "(*widget.Table).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-table//hidden!": {
		Doc:   "Set *widget.Table Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-table//hidden!")
			}
			return arg0
		},
	},
	"ptr-table//hidden?": {
		Doc:   "Get *widget.Table Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-table//hide": {
		Doc:   "(*widget.Table).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-table//length!": {
		Doc:   "Set *widget.Table Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//length!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//length!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//length!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Length, ok = v.Value.(func() (int, int))
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//length!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//length!")
			}
			return arg0
		},
	},
	"ptr-table//length?": {
		Doc:   "Get *widget.Table Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//length?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//length?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//length?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int_int)")
			return resObj
		},
	},
	"ptr-table//min-size": {
		Doc:   "(*widget.Table).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-table//mouse-down": {
		Doc:   "(*widget.Table).MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-down")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-down")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"ptr-table//mouse-in": {
		Doc:   "(*widget.Table).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"ptr-table//mouse-moved": {
		Doc:   "(*widget.Table).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"ptr-table//mouse-out": {
		Doc:   "(*widget.Table).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"ptr-table//mouse-up": {
		Doc:   "(*widget.Table).MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//mouse-up")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//mouse-up")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"ptr-table//move": {
		Doc:   "(*widget.Table).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-table//on-selected!": {
		Doc:   "Set *widget.Table OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//on-selected!")
				}
				self.OnSelected = func(arg0 widget.TableCellID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-table//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//on-selected!")
			}
			return arg0
		},
	},
	"ptr-table//on-selected?": {
		Doc:   "Get *widget.Table OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(table-cell-id)")
			return resObj
		},
	},
	"ptr-table//on-unselected!": {
		Doc:   "Set *widget.Table OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-unselected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-unselected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.TableCellID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-table//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//on-unselected!")
			}
			return arg0
		},
	},
	"ptr-table//on-unselected?": {
		Doc:   "Get *widget.Table OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-unselected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-unselected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(table-cell-id)")
			return resObj
		},
	},
	"ptr-table//position": {
		Doc:   "(*widget.Table).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-table//refresh": {
		Doc:   "(*widget.Table).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-table//refresh-item": {
		Doc:   "(*widget.Table).RefreshItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//refresh-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//refresh-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//refresh-item")
			}
			var arg1Val widget.TableCellID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//refresh-item")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//refresh-item")
			}
			arg0Val.RefreshItem(arg1Val)
			return arg0
		},
	},
	"ptr-table//resize": {
		Doc:   "(*widget.Table).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-table//scroll-to": {
		Doc:   "(*widget.Table).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to")
			}
			var arg1Val widget.TableCellID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//scroll-to")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//scroll-to")
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"ptr-table//scroll-to-bottom": {
		Doc:   "(*widget.Table).ScrollToBottom",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-bottom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-bottom")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-bottom")
			}
			arg0Val.ScrollToBottom()
			return arg0
		},
	},
	"ptr-table//scroll-to-leading": {
		Doc:   "(*widget.Table).ScrollToLeading",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-leading")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-leading")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-leading")
			}
			arg0Val.ScrollToLeading()
			return arg0
		},
	},
	"ptr-table//scroll-to-top": {
		Doc:   "(*widget.Table).ScrollToTop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-top")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-top")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-top")
			}
			arg0Val.ScrollToTop()
			return arg0
		},
	},
	"ptr-table//scroll-to-trailing": {
		Doc:   "(*widget.Table).ScrollToTrailing",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-trailing")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-trailing")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//scroll-to-trailing")
			}
			arg0Val.ScrollToTrailing()
			return arg0
		},
	},
	"ptr-table//select": {
		Doc:   "(*widget.Table).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//select")
			}
			var arg1Val widget.TableCellID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//select")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-table//set-column-width": {
		Doc:   "(*widget.Table).SetColumnWidth",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//set-column-width")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//set-column-width")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//set-column-width")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-table//set-column-width")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "ptr-table//set-column-width")
			}
			arg0Val.SetColumnWidth(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-table//set-row-height": {
		Doc:   "(*widget.Table).SetRowHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//set-row-height")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//set-row-height")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//set-row-height")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-table//set-row-height")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "ptr-table//set-row-height")
			}
			arg0Val.SetRowHeight(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-table//show": {
		Doc:   "(*widget.Table).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-table//show-header-column!": {
		Doc:   "Set *widget.Table ShowHeaderColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-column!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-column!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowHeaderColumn = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-table//show-header-column!")
			}
			return arg0
		},
	},
	"ptr-table//show-header-column?": {
		Doc:   "Get *widget.Table ShowHeaderColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-column?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-column?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowHeaderColumn))
			return resObj
		},
	},
	"ptr-table//show-header-row!": {
		Doc:   "Set *widget.Table ShowHeaderRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-row!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-row!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowHeaderRow = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-table//show-header-row!")
			}
			return arg0
		},
	},
	"ptr-table//show-header-row?": {
		Doc:   "Get *widget.Table ShowHeaderRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-row?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-row?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//show-header-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowHeaderRow))
			return resObj
		},
	},
	"ptr-table//size": {
		Doc:   "(*widget.Table).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-table//sticky-column-count!": {
		Doc:   "Set *widget.Table StickyColumnCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-column-count!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-column-count!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-column-count!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StickyColumnCount = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-table//sticky-column-count!")
			}
			return arg0
		},
	},
	"ptr-table//sticky-column-count?": {
		Doc:   "Get *widget.Table StickyColumnCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-column-count?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-column-count?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-column-count?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StickyColumnCount))
			return resObj
		},
	},
	"ptr-table//sticky-row-count!": {
		Doc:   "Set *widget.Table StickyRowCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-row-count!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-row-count!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-row-count!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StickyRowCount = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-table//sticky-row-count!")
			}
			return arg0
		},
	},
	"ptr-table//sticky-row-count?": {
		Doc:   "Get *widget.Table StickyRowCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-row-count?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-row-count?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//sticky-row-count?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StickyRowCount))
			return resObj
		},
	},
	"ptr-table//tapped": {
		Doc:   "(*widget.Table).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"ptr-table//touch-cancel": {
		Doc:   "(*widget.Table).TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//touch-cancel")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//touch-cancel")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//touch-cancel")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//touch-cancel")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"ptr-table//touch-down": {
		Doc:   "(*widget.Table).TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//touch-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//touch-down")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//touch-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//touch-down")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"ptr-table//touch-up": {
		Doc:   "(*widget.Table).TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//touch-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//touch-up")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//touch-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//touch-up")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"ptr-table//typed-key": {
		Doc:   "(*widget.Table).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-table//typed-rune": {
		Doc:   "(*widget.Table).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-table//unselect": {
		Doc:   "(*widget.Table).Unselect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//unselect")
			}
			var arg1Val widget.TableCellID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//unselect")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-table//unselect")
			}
			arg0Val.Unselect(arg1Val)
			return arg0
		},
	},
	"ptr-table//unselect-all": {
		Doc:   "(*widget.Table).UnselectAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//unselect-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//unselect-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//unselect-all")
			}
			arg0Val.UnselectAll()
			return arg0
		},
	},
	"ptr-table//update-cell!": {
		Doc:   "Set *widget.Table UpdateCell value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-cell!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-cell!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-cell!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//update-cell!")
				}
				self.UpdateCell = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-table//update-cell!")
				}
				self.UpdateCell = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//update-cell!")
			}
			return arg0
		},
	},
	"ptr-table//update-cell?": {
		Doc:   "Get *widget.Table UpdateCell value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-cell?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-cell?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-cell?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateCell, "func(table-cell-id_canvas-object)")
			return resObj
		},
	},
	"ptr-table//update-header!": {
		Doc:   "Set *widget.Table UpdateHeader value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-header!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-header!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-header!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//update-header!")
				}
				self.UpdateHeader = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-table//update-header!")
				}
				self.UpdateHeader = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-table//update-header!")
			}
			return arg0
		},
	},
	"ptr-table//update-header?": {
		Doc:   "Get *widget.Table UpdateHeader value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-header?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-header?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//update-header?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateHeader, "func(table-cell-id_canvas-object)")
			return resObj
		},
	},
	"ptr-table//visible": {
		Doc:   "(*widget.Table).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-table//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-text-grid-cell//rune!": {
		Doc:   "Set *widget.TextGridCell Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//rune!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//rune!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//rune!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid-cell//rune!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid-cell//rune!")
			}
			return arg0
		},
	},
	"ptr-text-grid-cell//rune?": {
		Doc:   "Get *widget.TextGridCell Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//rune?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//rune?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//rune?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"ptr-text-grid-cell//style!": {
		Doc:   "Set *widget.TextGridCell Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid-cell//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid-cell//style!")
				}
				self.Style = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid-cell//style!")
			}
			return arg0
		},
	},
	"ptr-text-grid-cell//style?": {
		Doc:   "Get *widget.TextGridCell Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-cell//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "text-grid-style")
			return resObj
		},
	},
	"ptr-text-grid-row//cells!": {
		Doc:   "Set *widget.TextGridRow Cells value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//cells!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//cells!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//cells!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cells = make([]widget.TextGridCell, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Cells[i], ok = v.Value.(widget.TextGridCell)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid-row//cells!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid-row//cells!")
					}
				}
			case env.Native:
				var ok bool
				self.Cells, ok = v.Value.([]widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid-row//cells!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid-row//cells!")
				}
				self.Cells = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid-row//cells!")
			}
			return arg0
		},
	},
	"ptr-text-grid-row//cells?": {
		Doc:   "Get *widget.TextGridRow Cells value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//cells?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//cells?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//cells?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cells))
				for i, it := range self.Cells {
					items[i] = *env.NewNative(ps.Idx, it, "text-grid-cell")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-text-grid-row//style!": {
		Doc:   "Set *widget.TextGridRow Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid-row//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid-row//style!")
				}
				self.Style = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid-row//style!")
			}
			return arg0
		},
	},
	"ptr-text-grid-row//style?": {
		Doc:   "Get *widget.TextGridRow Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid-row//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "text-grid-style")
			return resObj
		},
	},
	"ptr-text-grid//create-renderer": {
		Doc:   "(*widget.TextGrid).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-text-grid//extend-base-widget": {
		Doc:   "(*widget.TextGrid).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-text-grid//hidden!": {
		Doc:   "Set *widget.TextGrid Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//hidden!")
			}
			return arg0
		},
	},
	"ptr-text-grid//hidden?": {
		Doc:   "Get *widget.TextGrid Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-text-grid//hide": {
		Doc:   "(*widget.TextGrid).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-text-grid//min-size": {
		Doc:   "(*widget.TextGrid).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-text-grid//move": {
		Doc:   "(*widget.TextGrid).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-text-grid//position": {
		Doc:   "(*widget.TextGrid).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-text-grid//refresh": {
		Doc:   "(*widget.TextGrid).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-text-grid//resize": {
		Doc:   "(*widget.TextGrid).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-grid//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-text-grid//row": {
		Doc:   "(*widget.TextGrid).Row",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//row")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//row")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//row")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//row")
			}
			res0 := arg0Val.Row(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "text-grid-row")
			return res0Obj
		},
	},
	"ptr-text-grid//row-text": {
		Doc:   "(*widget.TextGrid).RowText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//row-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//row-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//row-text")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//row-text")
			}
			res0 := arg0Val.RowText(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-text-grid//rows!": {
		Doc:   "Set *widget.TextGrid Rows value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//rows!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//rows!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//rows!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Rows = make([]widget.TextGridRow, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Rows[i], ok = v.Value.(widget.TextGridRow)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid//rows!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid//rows!")
					}
				}
			case env.Native:
				var ok bool
				self.Rows, ok = v.Value.([]widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid//rows!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid//rows!")
				}
				self.Rows = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-text-grid//rows!")
			}
			return arg0
		},
	},
	"ptr-text-grid//rows?": {
		Doc:   "Get *widget.TextGrid Rows value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//rows?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//rows?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//rows?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Rows))
				for i, it := range self.Rows {
					items[i] = *env.NewNative(ps.Idx, it, "text-grid-row")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-text-grid//set-cell": {
		Doc:   "(*widget.TextGrid).SetCell",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-cell")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-cell")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-cell")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//set-cell")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "ptr-text-grid//set-cell")
			}
			var arg3Val widget.TextGridCell
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "ptr-text-grid//set-cell")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "ptr-text-grid//set-cell")
			}
			arg0Val.SetCell(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-text-grid//set-row": {
		Doc:   "(*widget.TextGrid).SetRow",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-row")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-row")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-row")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//set-row")
			}
			var arg2Val widget.TextGridRow
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-text-grid//set-row")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-text-grid//set-row")
			}
			arg0Val.SetRow(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-grid//set-row-style": {
		Doc:   "(*widget.TextGrid).SetRowStyle",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-row-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-row-style")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-row-style")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//set-row-style")
			}
			var arg2Val widget.TextGridStyle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-text-grid//set-row-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-text-grid//set-row-style")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-text-grid//set-row-style")
			}
			arg0Val.SetRowStyle(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-grid//set-rune": {
		Doc:   "(*widget.TextGrid).SetRune",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-rune")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//set-rune")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "ptr-text-grid//set-rune")
			}
			var arg3Val rune
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "ptr-text-grid//set-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "ptr-text-grid//set-rune")
			}
			arg0Val.SetRune(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-text-grid//set-style": {
		Doc:   "(*widget.TextGrid).SetStyle",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-style")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-style")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//set-style")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "ptr-text-grid//set-style")
			}
			var arg3Val widget.TextGridStyle
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "ptr-text-grid//set-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "ptr-text-grid//set-style")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "ptr-text-grid//set-style")
			}
			arg0Val.SetStyle(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"ptr-text-grid//set-text": {
		Doc:   "(*widget.TextGrid).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-text-grid//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"ptr-text-grid//show": {
		Doc:   "(*widget.TextGrid).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-text-grid//show-line-numbers!": {
		Doc:   "Set *widget.TextGrid ShowLineNumbers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-line-numbers!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-line-numbers!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-line-numbers!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowLineNumbers = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//show-line-numbers!")
			}
			return arg0
		},
	},
	"ptr-text-grid//show-line-numbers?": {
		Doc:   "Get *widget.TextGrid ShowLineNumbers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-line-numbers?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-line-numbers?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-line-numbers?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowLineNumbers))
			return resObj
		},
	},
	"ptr-text-grid//show-whitespace!": {
		Doc:   "Set *widget.TextGrid ShowWhitespace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-whitespace!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-whitespace!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-whitespace!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowWhitespace = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//show-whitespace!")
			}
			return arg0
		},
	},
	"ptr-text-grid//show-whitespace?": {
		Doc:   "Get *widget.TextGrid ShowWhitespace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-whitespace?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-whitespace?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//show-whitespace?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowWhitespace))
			return resObj
		},
	},
	"ptr-text-grid//size": {
		Doc:   "(*widget.TextGrid).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-text-grid//tab-width!": {
		Doc:   "Set *widget.TextGrid TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//tab-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//tab-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//tab-width!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-grid//tab-width!")
			}
			return arg0
		},
	},
	"ptr-text-grid//tab-width?": {
		Doc:   "Get *widget.TextGrid TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//tab-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//tab-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//tab-width?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"ptr-text-grid//text": {
		Doc:   "(*widget.TextGrid).Text",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//text")
			}
			res0 := arg0Val.Text()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-text-grid//visible": {
		Doc:   "(*widget.TextGrid).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-grid//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-text-segment//inline": {
		Doc:   "(*widget.TextSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-text-segment//select": {
		Doc:   "(*widget.TextSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-segment//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-text-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "ptr-text-segment//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"ptr-text-segment//selected-text": {
		Doc:   "(*widget.TextSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-text-segment//style!": {
		Doc:   "Set *widget.TextSegment Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-segment//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-segment//style!")
			}
			return arg0
		},
	},
	"ptr-text-segment//style?": {
		Doc:   "Get *widget.TextSegment Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "rich-text-style")
			return resObj
		},
	},
	"ptr-text-segment//text!": {
		Doc:   "Set *widget.TextSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-text-segment//text!")
			}
			return arg0
		},
	},
	"ptr-text-segment//text?": {
		Doc:   "Get *widget.TextSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-text-segment//textual": {
		Doc:   "(*widget.TextSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-text-segment//unselect": {
		Doc:   "(*widget.TextSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"ptr-text-segment//update": {
		Doc:   "(*widget.TextSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-segment//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text-segment//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"ptr-text-segment//visual": {
		Doc:   "(*widget.TextSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-segment//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"ptr-text-style//bold!": {
		Doc:   "Set *fyne.TextStyle Bold value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//bold!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//bold!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//bold!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Bold = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-style//bold!")
			}
			return arg0
		},
	},
	"ptr-text-style//bold?": {
		Doc:   "Get *fyne.TextStyle Bold value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//bold?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//bold?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//bold?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Bold))
			return resObj
		},
	},
	"ptr-text-style//italic!": {
		Doc:   "Set *fyne.TextStyle Italic value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//italic!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//italic!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//italic!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Italic = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-style//italic!")
			}
			return arg0
		},
	},
	"ptr-text-style//italic?": {
		Doc:   "Get *fyne.TextStyle Italic value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//italic?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//italic?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//italic?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Italic))
			return resObj
		},
	},
	"ptr-text-style//monospace!": {
		Doc:   "Set *fyne.TextStyle Monospace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//monospace!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//monospace!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//monospace!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Monospace = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-style//monospace!")
			}
			return arg0
		},
	},
	"ptr-text-style//monospace?": {
		Doc:   "Get *fyne.TextStyle Monospace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//monospace?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//monospace?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//monospace?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Monospace))
			return resObj
		},
	},
	"ptr-text-style//symbol!": {
		Doc:   "Set *fyne.TextStyle Symbol value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//symbol!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//symbol!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//symbol!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Symbol = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-style//symbol!")
			}
			return arg0
		},
	},
	"ptr-text-style//symbol?": {
		Doc:   "Get *fyne.TextStyle Symbol value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//symbol?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//symbol?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//symbol?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Symbol))
			return resObj
		},
	},
	"ptr-text-style//tab-width!": {
		Doc:   "Set *fyne.TextStyle TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//tab-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//tab-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//tab-width!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-text-style//tab-width!")
			}
			return arg0
		},
	},
	"ptr-text-style//tab-width?": {
		Doc:   "Get *fyne.TextStyle TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//tab-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//tab-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text-style//tab-width?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"ptr-text//alignment!": {
		Doc:   "Set *canvas.Text Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//alignment!")
			}
			return arg0
		},
	},
	"ptr-text//alignment?": {
		Doc:   "Get *canvas.Text Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"ptr-text//color!": {
		Doc:   "Set *canvas.Text Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Color, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//color!")
			}
			return arg0
		},
	},
	"ptr-text//color?": {
		Doc:   "Get *canvas.Text Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "color")
			return resObj
		},
	},
	"ptr-text//hide": {
		Doc:   "(*canvas.Text).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-text//min-size": {
		Doc:   "(*canvas.Text).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-text//move": {
		Doc:   "(*canvas.Text).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-text//refresh": {
		Doc:   "(*canvas.Text).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-text//resize": {
		Doc:   "(*canvas.Text).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-text//set-min-size": {
		Doc:   "(*canvas.Text).SetMinSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//set-min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//set-min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//set-min-size")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//set-min-size")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//set-min-size")
			}
			arg0Val.SetMinSize(arg1Val)
			return arg0
		},
	},
	"ptr-text//text!": {
		Doc:   "Set *canvas.Text Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-text//text!")
			}
			return arg0
		},
	},
	"ptr-text//text-size!": {
		Doc:   "Set *canvas.Text TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-size!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-size!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-size!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.TextSize = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "ptr-text//text-size!")
			}
			return arg0
		},
	},
	"ptr-text//text-size?": {
		Doc:   "Get *canvas.Text TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-size?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-size?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-size?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.TextSize))
			return resObj
		},
	},
	"ptr-text//text-style!": {
		Doc:   "Set *canvas.Text TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-text//text-style!")
			}
			return arg0
		},
	},
	"ptr-text//text-style?": {
		Doc:   "Get *canvas.Text TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"ptr-text//text?": {
		Doc:   "Get *canvas.Text Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-text//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"ptr-themed-resource//color-name!": {
		Doc:   "Set *theme.ThemedResource ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//color-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//color-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//color-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorName, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-themed-resource//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-themed-resource//color-name!")
			}
			return arg0
		},
	},
	"ptr-themed-resource//color-name?": {
		Doc:   "Get *theme.ThemedResource ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//color-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//color-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//color-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorName, "theme-color-name")
			return resObj
		},
	},
	"ptr-themed-resource//content": {
		Doc:   "(*theme.ThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"ptr-themed-resource//error": {
		Doc:   "(*theme.ThemedResource).Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//error")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//error")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//error")
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-error-themed-resource")
			return res0Obj
		},
	},
	"ptr-themed-resource//name": {
		Doc:   "(*theme.ThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-themed-resource//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"ptr-toolbar-action//icon!": {
		Doc:   "Set *widget.ToolbarAction Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//icon!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar-action//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar-action//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar-action//icon!")
			}
			return arg0
		},
	},
	"ptr-toolbar-action//icon?": {
		Doc:   "Get *widget.ToolbarAction Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//icon?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//icon?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"ptr-toolbar-action//on-activated!": {
		Doc:   "Set *widget.ToolbarAction OnActivated value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//on-activated!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//on-activated!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//on-activated!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-toolbar-action//on-activated!")
				}
				self.OnActivated = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-toolbar-action//on-activated!")
				}
				self.OnActivated = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-toolbar-action//on-activated!")
			}
			return arg0
		},
	},
	"ptr-toolbar-action//on-activated?": {
		Doc:   "Get *widget.ToolbarAction OnActivated value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//on-activated?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//on-activated?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//on-activated?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnActivated, "func()")
			return resObj
		},
	},
	"ptr-toolbar-action//set-icon": {
		Doc:   "(*widget.ToolbarAction).SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//set-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//set-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar-action//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar-action//set-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar-action//set-icon")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"ptr-toolbar-action//toolbar-object": {
		Doc:   "(*widget.ToolbarAction).ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//toolbar-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//toolbar-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-action//toolbar-object")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"ptr-toolbar-separator//toolbar-object": {
		Doc:   "(*widget.ToolbarSeparator).ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarSeparator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarSeparator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-separator//toolbar-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-separator//toolbar-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-separator//toolbar-object")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"ptr-toolbar-spacer//toolbar-object": {
		Doc:   "(*widget.ToolbarSpacer).ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarSpacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarSpacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-spacer//toolbar-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-spacer//toolbar-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar-spacer//toolbar-object")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"ptr-toolbar//append": {
		Doc:   "(*widget.Toolbar).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//append")
			}
			var arg1Val widget.ToolbarItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"ptr-toolbar//create-renderer": {
		Doc:   "(*widget.Toolbar).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-toolbar//extend-base-widget": {
		Doc:   "(*widget.Toolbar).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-toolbar//hidden!": {
		Doc:   "Set *widget.Toolbar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-toolbar//hidden!")
			}
			return arg0
		},
	},
	"ptr-toolbar//hidden?": {
		Doc:   "Get *widget.Toolbar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-toolbar//hide": {
		Doc:   "(*widget.Toolbar).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-toolbar//items!": {
		Doc:   "Set *widget.Toolbar Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.ToolbarItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.ToolbarItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-toolbar//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-toolbar//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-toolbar//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-toolbar//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-toolbar//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-toolbar//items!")
			}
			return arg0
		},
	},
	"ptr-toolbar//items?": {
		Doc:   "Get *widget.Toolbar Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "toolbar-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"ptr-toolbar//min-size": {
		Doc:   "(*widget.Toolbar).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-toolbar//move": {
		Doc:   "(*widget.Toolbar).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-toolbar//position": {
		Doc:   "(*widget.Toolbar).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-toolbar//prepend": {
		Doc:   "(*widget.Toolbar).Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//prepend")
			}
			var arg1Val widget.ToolbarItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//prepend")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//prepend")
			}
			arg0Val.Prepend(arg1Val)
			return arg0
		},
	},
	"ptr-toolbar//refresh": {
		Doc:   "(*widget.Toolbar).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-toolbar//resize": {
		Doc:   "(*widget.Toolbar).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-toolbar//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-toolbar//show": {
		Doc:   "(*widget.Toolbar).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-toolbar//size": {
		Doc:   "(*widget.Toolbar).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-toolbar//visible": {
		Doc:   "(*widget.Toolbar).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-toolbar//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-touch-event//absolute-position!": {
		Doc:   "Set *mobile.TouchEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-touch-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-touch-event//absolute-position!")
			}
			return arg0
		},
	},
	"ptr-touch-event//absolute-position?": {
		Doc:   "Get *mobile.TouchEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"ptr-touch-event//position!": {
		Doc:   "Set *mobile.TouchEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-touch-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-touch-event//position!")
			}
			return arg0
		},
	},
	"ptr-touch-event//position?": {
		Doc:   "Get *mobile.TouchEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-touch-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"ptr-tree//child-ui-ds!": {
		Doc:   "Set *widget.Tree ChildUIDs value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//child-ui-ds!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//child-ui-ds!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//child-ui-ds!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//child-ui-ds!")
				}
				self.ChildUIDs = func(arg0 widget.TreeNodeID) []widget.TreeNodeID {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res []widget.TreeNodeID
					switch v := ps.Res.(type) {
					case env.Block:
						res = make([]widget.TreeNodeID, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								res[i], ok = v.Value.(widget.TreeNodeID)
								if !ok {
									// TODO: Invalid type
								}
							default:
								// TODO: Invalid type
							}
						}
					case env.Native:
						var ok bool
						res, ok = v.Value.([]widget.TreeNodeID)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-tree//child-ui-ds!")
				}
				self.ChildUIDs = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//child-ui-ds!")
			}
			return arg0
		},
	},
	"ptr-tree//child-ui-ds?": {
		Doc:   "Get *widget.Tree ChildUIDs value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//child-ui-ds?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//child-ui-ds?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//child-ui-ds?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildUIDs, "func(tree-node-id)_(arr-tree-node-id)")
			return resObj
		},
	},
	"ptr-tree//close-all-branches": {
		Doc:   "(*widget.Tree).CloseAllBranches",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//close-all-branches")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//close-all-branches")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//close-all-branches")
			}
			arg0Val.CloseAllBranches()
			return arg0
		},
	},
	"ptr-tree//close-branch": {
		Doc:   "(*widget.Tree).CloseBranch",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//close-branch")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//close-branch")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//close-branch")
			}
			var arg1Val widget.TreeNodeID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TreeNodeID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//close-branch")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//close-branch")
			}
			arg0Val.CloseBranch(arg1Val)
			return arg0
		},
	},
	"ptr-tree//create-node!": {
		Doc:   "Set *widget.Tree CreateNode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//create-node!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//create-node!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//create-node!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//create-node!")
				}
				self.CreateNode = func(arg0 bool) fyne.CanvasObject {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-tree//create-node!")
				}
				self.CreateNode = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//create-node!")
			}
			return arg0
		},
	},
	"ptr-tree//create-node?": {
		Doc:   "Get *widget.Tree CreateNode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//create-node?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//create-node?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//create-node?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateNode, "func(bool)_(canvas-object)")
			return resObj
		},
	},
	"ptr-tree//create-renderer": {
		Doc:   "(*widget.Tree).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"ptr-tree//extend-base-widget": {
		Doc:   "(*widget.Tree).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"ptr-tree//focus-gained": {
		Doc:   "(*widget.Tree).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"ptr-tree//focus-lost": {
		Doc:   "(*widget.Tree).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"ptr-tree//hidden!": {
		Doc:   "Set *widget.Tree Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "ptr-tree//hidden!")
			}
			return arg0
		},
	},
	"ptr-tree//hidden?": {
		Doc:   "Get *widget.Tree Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"ptr-tree//hide": {
		Doc:   "(*widget.Tree).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"ptr-tree//is-branch!": {
		Doc:   "Set *widget.Tree IsBranch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//is-branch!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//is-branch!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//is-branch!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//is-branch!")
				}
				self.IsBranch = func(arg0 widget.TreeNodeID) bool {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-tree//is-branch!")
				}
				self.IsBranch = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//is-branch!")
			}
			return arg0
		},
	},
	"ptr-tree//is-branch-open": {
		Doc:   "(*widget.Tree).IsBranchOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//is-branch-open")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//is-branch-open")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//is-branch-open")
			}
			var arg1Val widget.TreeNodeID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TreeNodeID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//is-branch-open")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//is-branch-open")
			}
			res0 := arg0Val.IsBranchOpen(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"ptr-tree//is-branch?": {
		Doc:   "Get *widget.Tree IsBranch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//is-branch?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//is-branch?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//is-branch?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.IsBranch, "func(tree-node-id)_(bool)")
			return resObj
		},
	},
	"ptr-tree//min-size": {
		Doc:   "(*widget.Tree).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-tree//move": {
		Doc:   "(*widget.Tree).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"ptr-tree//on-branch-closed!": {
		Doc:   "Set *widget.Tree OnBranchClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-closed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-closed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-closed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//on-branch-closed!")
				}
				self.OnBranchClosed = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-tree//on-branch-closed!")
				}
				self.OnBranchClosed = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//on-branch-closed!")
			}
			return arg0
		},
	},
	"ptr-tree//on-branch-closed?": {
		Doc:   "Get *widget.Tree OnBranchClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-closed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-closed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-closed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnBranchClosed, "func(tree-node-id)")
			return resObj
		},
	},
	"ptr-tree//on-branch-opened!": {
		Doc:   "Set *widget.Tree OnBranchOpened value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-opened!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-opened!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-opened!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//on-branch-opened!")
				}
				self.OnBranchOpened = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-tree//on-branch-opened!")
				}
				self.OnBranchOpened = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//on-branch-opened!")
			}
			return arg0
		},
	},
	"ptr-tree//on-branch-opened?": {
		Doc:   "Get *widget.Tree OnBranchOpened value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-opened?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-opened?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-branch-opened?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnBranchOpened, "func(tree-node-id)")
			return resObj
		},
	},
	"ptr-tree//on-selected!": {
		Doc:   "Set *widget.Tree OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//on-selected!")
				}
				self.OnSelected = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-tree//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//on-selected!")
			}
			return arg0
		},
	},
	"ptr-tree//on-selected?": {
		Doc:   "Get *widget.Tree OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(tree-node-id)")
			return resObj
		},
	},
	"ptr-tree//on-unselected!": {
		Doc:   "Set *widget.Tree OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-unselected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-unselected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "ptr-tree//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "ptr-tree//on-unselected!")
			}
			return arg0
		},
	},
	"ptr-tree//on-unselected?": {
		Doc:   "Get *widget.Tree OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-unselected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-unselected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(tree-node-id)")
			return resObj
		},
	},
	"ptr-tree//open-all-branches": {
		Doc:   "(*widget.Tree).OpenAllBranches",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//open-all-branches")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//open-all-branches")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//open-all-branches")
			}
			arg0Val.OpenAllBranches()
			return arg0
		},
	},
	"ptr-tree//open-branch": {
		Doc:   "(*widget.Tree).OpenBranch",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//open-branch")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//open-branch")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//open-branch")
			}
			var arg1Val widget.TreeNodeID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TreeNodeID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//open-branch")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//open-branch")
			}
			arg0Val.OpenBranch(arg1Val)
			return arg0
		},
	},
	"ptr-tree//position": {
		Doc:   "(*widget.Tree).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"ptr-tree//refresh": {
		Doc:   "(*widget.Tree).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"ptr-tree//refresh-item": {
		Doc:   "(*widget.Tree).RefreshItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//refresh-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//refresh-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//refresh-item")
			}
			var arg1Val widget.TreeNodeID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TreeNodeID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//refresh-item")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//refresh-item")
			}
			arg0Val.RefreshItem(arg1Val)
			return arg0
		},
	},
	"ptr-tree//resize": {
		Doc:   "(*widget.Tree).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"ptr-tree//root!": {
		Doc:   "Set *widget.Tree Root value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//root!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//root!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//root!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Root, ok = v.Value.(widget.TreeNodeID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//root!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//root!")
			}
			return arg0
		},
	},
	"ptr-tree//root?": {
		Doc:   "Get *widget.Tree Root value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//root?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//root?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//root?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Root, "tree-node-id")
			return resObj
		},
	},
	"ptr-tree//scroll-to": {
		Doc:   "(*widget.Tree).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//scroll-to")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//scroll-to")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//scroll-to")
			}
			var arg1Val widget.TreeNodeID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TreeNodeID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//scroll-to")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//scroll-to")
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"ptr-tree//scroll-to-bottom": {
		Doc:   "(*widget.Tree).ScrollToBottom",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//scroll-to-bottom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//scroll-to-bottom")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//scroll-to-bottom")
			}
			arg0Val.ScrollToBottom()
			return arg0
		},
	},
	"ptr-tree//scroll-to-top": {
		Doc:   "(*widget.Tree).ScrollToTop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//scroll-to-top")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//scroll-to-top")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//scroll-to-top")
			}
			arg0Val.ScrollToTop()
			return arg0
		},
	},
	"ptr-tree//select": {
		Doc:   "(*widget.Tree).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//select")
			}
			var arg1Val widget.TreeNodeID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TreeNodeID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//select")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"ptr-tree//show": {
		Doc:   "(*widget.Tree).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"ptr-tree//size": {
		Doc:   "(*widget.Tree).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"ptr-tree//toggle-branch": {
		Doc:   "(*widget.Tree).ToggleBranch",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//toggle-branch")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//toggle-branch")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//toggle-branch")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "ptr-tree//toggle-branch")
			}
			arg0Val.ToggleBranch(arg1Val)
			return arg0
		},
	},
	"ptr-tree//typed-key": {
		Doc:   "(*widget.Tree).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"ptr-tree//typed-rune": {
		Doc:   "(*widget.Tree).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"ptr-tree//unselect": {
		Doc:   "(*widget.Tree).Unselect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//unselect")
			}
			var arg1Val widget.TreeNodeID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.TreeNodeID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//unselect")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//unselect")
			}
			arg0Val.Unselect(arg1Val)
			return arg0
		},
	},
	"ptr-tree//unselect-all": {
		Doc:   "(*widget.Tree).UnselectAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//unselect-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//unselect-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//unselect-all")
			}
			arg0Val.UnselectAll()
			return arg0
		},
	},
	"ptr-tree//update-node!": {
		Doc:   "Set *widget.Tree UpdateNode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//update-node!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//update-node!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//update-node!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.UpdateNode, ok = v.Value.(func(widget.TreeNodeID, bool, fyne.CanvasObject))
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//update-node!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "ptr-tree//update-node!")
			}
			return arg0
		},
	},
	"ptr-tree//update-node?": {
		Doc:   "Get *widget.Tree UpdateNode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//update-node?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//update-node?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//update-node?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateNode, "func(tree-node-id_bool_canvas-object)")
			return resObj
		},
	},
	"ptr-tree//visible": {
		Doc:   "(*widget.Tree).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "ptr-tree//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"question-icon": {
		Doc:   "theme.QuestionIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.QuestionIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"radial-gradient": {
		Doc:   "canvas.NewRadialGradient",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "radial-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "radial-gradient")
			}
			res0 := canvas.NewRadialGradient(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-radial-gradient")
			return res0Obj
		},
	},
	"radial-gradient//center-offset-x!": {
		Doc:   "Set canvas.RadialGradient CenterOffsetX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//center-offset-x!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//center-offset-x!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetX = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "radial-gradient//center-offset-x!")
			}
			return arg0
		},
	},
	"radial-gradient//center-offset-x?": {
		Doc:   "Get canvas.RadialGradient CenterOffsetX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//center-offset-x?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//center-offset-x?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetX))
			return resObj
		},
	},
	"radial-gradient//center-offset-y!": {
		Doc:   "Set canvas.RadialGradient CenterOffsetY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//center-offset-y!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//center-offset-y!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetY = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "radial-gradient//center-offset-y!")
			}
			return arg0
		},
	},
	"radial-gradient//center-offset-y?": {
		Doc:   "Get canvas.RadialGradient CenterOffsetY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//center-offset-y?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//center-offset-y?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetY))
			return resObj
		},
	},
	"radial-gradient//end-color!": {
		Doc:   "Set canvas.RadialGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//end-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "radial-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "radial-gradient//end-color!")
			}
			return arg0
		},
	},
	"radial-gradient//end-color?": {
		Doc:   "Get canvas.RadialGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//end-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//end-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color")
			return resObj
		},
	},
	"radial-gradient//start-color!": {
		Doc:   "Set canvas.RadialGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//start-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "radial-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "radial-gradient//start-color!")
			}
			return arg0
		},
	},
	"radial-gradient//start-color?": {
		Doc:   "Get canvas.RadialGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//start-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radial-gradient//start-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color")
			return resObj
		},
	},
	"radio-button-checked-icon": {
		Doc:   "theme.RadioButtonCheckedIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.RadioButtonCheckedIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"radio-button-icon": {
		Doc:   "theme.RadioButtonIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.RadioButtonIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"radio-group": {
		Doc:   "widget.NewRadioGroup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "radio-group")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "radio-group")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "radio-group")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "radio-group")
			}
			var arg1Val func(string)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "radio-group")
				}
				arg1Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "radio-group")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "radio-group")
			}
			res0 := widget.NewRadioGroup(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-radio-group")
			return res0Obj
		},
	},
	"radio-group//hidden!": {
		Doc:   "Set widget.RadioGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "radio-group//hidden!")
			}
			return arg0
		},
	},
	"radio-group//hidden?": {
		Doc:   "Get widget.RadioGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"radio-group//horizontal!": {
		Doc:   "Set widget.RadioGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//horizontal!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "radio-group//horizontal!")
			}
			return arg0
		},
	},
	"radio-group//horizontal?": {
		Doc:   "Get widget.RadioGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//horizontal?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"radio-group//on-changed!": {
		Doc:   "Set widget.RadioGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "radio-group//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "radio-group//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "radio-group//on-changed!")
			}
			return arg0
		},
	},
	"radio-group//on-changed?": {
		Doc:   "Get widget.RadioGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"radio-group//options!": {
		Doc:   "Set widget.RadioGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//options!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "radio-group//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "radio-group//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "radio-group//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "radio-group//options!")
			}
			return arg0
		},
	},
	"radio-group//options?": {
		Doc:   "Get widget.RadioGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//options?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//options?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"radio-group//required!": {
		Doc:   "Set widget.RadioGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//required!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//required!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "radio-group//required!")
			}
			return arg0
		},
	},
	"radio-group//required?": {
		Doc:   "Get widget.RadioGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//required?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//required?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"radio-group//selected!": {
		Doc:   "Set widget.RadioGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//selected!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "radio-group//selected!")
			}
			return arg0
		},
	},
	"radio-group//selected?": {
		Doc:   "Get widget.RadioGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "radio-group//selected?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"raster": {
		Doc:   "canvas.NewRaster",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(int, int) image.Image
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "raster")
				}
				arg0Val = func(arg0 int, arg1 int) image.Image {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
					var res image.Image
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(image.Image)
						if !ok {
							// TODO: Invalid type
						}
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "raster")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "raster")
			}
			res0 := canvas.NewRaster(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-raster")
			return res0Obj
		},
	},
	"raster-from-image": {
		Doc:   "canvas.NewRasterFromImage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster-from-image")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster-from-image")
			}
			res0 := canvas.NewRasterFromImage(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-raster")
			return res0Obj
		},
	},
	"raster-with-pixels": {
		Doc:   "canvas.NewRasterWithPixels",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(int, int, int, int) color.Color
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 4 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "raster-with-pixels")
				}
				arg0Val = func(arg0 int, arg1 int, arg2 int, arg3 int) color.Color {
					var arg0Val, arg1Val, arg2Val, arg3Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					arg2Val = *env.NewInteger(int64(arg2))
					arg3Val = *env.NewInteger(int64(arg3))
					evaldo.CallFunctionArgs4(fn, ps, arg0Val, arg1Val, arg2Val, arg3Val, ps.Ctx)
					var res color.Color
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(color.Color)
						if !ok {
							// TODO: Invalid type
						}
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "raster-with-pixels")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "raster-with-pixels")
			}
			res0 := canvas.NewRasterWithPixels(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-raster")
			return res0Obj
		},
	},
	"raster//generator!": {
		Doc:   "Set canvas.Raster Generator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//generator!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//generator!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "raster//generator!")
				}
				self.Generator = func(arg0 int, arg1 int) image.Image {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
					var res image.Image
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(image.Image)
						if !ok {
							// TODO: Invalid type
						}
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "raster//generator!")
				}
				self.Generator = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "raster//generator!")
			}
			return arg0
		},
	},
	"raster//generator?": {
		Doc:   "Get canvas.Raster Generator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//generator?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//generator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Generator, "func(int_int)_(image)")
			return resObj
		},
	},
	"raster//scale-mode!": {
		Doc:   "Set canvas.Raster ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//scale-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ScaleMode, ok = v.Value.(canvas.ImageScale)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "raster//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "raster//scale-mode!")
			}
			return arg0
		},
	},
	"raster//scale-mode?": {
		Doc:   "Get canvas.Raster ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//scale-mode?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//scale-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ScaleMode, "image-scale")
			return resObj
		},
	},
	"raster//translucency!": {
		Doc:   "Set canvas.Raster Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//translucency!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//translucency!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "raster//translucency!")
			}
			return arg0
		},
	},
	"raster//translucency?": {
		Doc:   "Get canvas.Raster Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//translucency?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "raster//translucency?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"reader": {
		Doc:   "storage.Reader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "reader")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "reader")
			}
			res0, res1 := storage.Reader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"rectangle": {
		Doc:   "canvas.NewRectangle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle")
			}
			res0 := canvas.NewRectangle(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-rectangle")
			return res0Obj
		},
	},
	"rectangle//corner-radius!": {
		Doc:   "Set canvas.Rectangle CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//corner-radius!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//corner-radius!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CornerRadius = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "rectangle//corner-radius!")
			}
			return arg0
		},
	},
	"rectangle//corner-radius?": {
		Doc:   "Get canvas.Rectangle CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//corner-radius?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//corner-radius?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CornerRadius))
			return resObj
		},
	},
	"rectangle//fill-color!": {
		Doc:   "Set canvas.Rectangle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//fill-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rectangle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rectangle//fill-color!")
			}
			return arg0
		},
	},
	"rectangle//fill-color?": {
		Doc:   "Get canvas.Rectangle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//fill-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//fill-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color")
			return resObj
		},
	},
	"rectangle//stroke-color!": {
		Doc:   "Set canvas.Rectangle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rectangle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rectangle//stroke-color!")
			}
			return arg0
		},
	},
	"rectangle//stroke-color?": {
		Doc:   "Get canvas.Rectangle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//stroke-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color")
			return resObj
		},
	},
	"rectangle//stroke-width!": {
		Doc:   "Set canvas.Rectangle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//stroke-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "rectangle//stroke-width!")
			}
			return arg0
		},
	},
	"rectangle//stroke-width?": {
		Doc:   "Get canvas.Rectangle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//stroke-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rectangle//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"refresh": {
		Doc:   "canvas.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "refresh")
			}
			canvas.Refresh(arg0Val)
			return nil
		},
	},
	"regexp": {
		Doc:   "validation.NewRegexp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "regexp")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "regexp")
			}
			res0 := validation.NewRegexp(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-validator")
			return res0Obj
		},
	},
	"register": {
		Doc:   "repository.Register",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "register")
			}
			var arg1Val repository.Repository
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "register")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "register")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "register")
			}
			repository.Register(arg0Val, arg1Val)
			return nil
		},
	},
	"render": {
		Doc:   "software.Render",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "render")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "render")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "render")
			}
			var arg1Val fyne.Theme
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "render")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "render")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "render")
			}
			res0 := software.Render(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image")
			return res0Obj
		},
	},
	"render-canvas": {
		Doc:   "software.RenderCanvas",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "render-canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "render-canvas")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "render-canvas")
			}
			var arg1Val fyne.Theme
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "render-canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "render-canvas")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "render-canvas")
			}
			res0 := software.RenderCanvas(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image")
			return res0Obj
		},
	},
	"render-window": {
		Doc:   "playground.RenderWindow",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "render-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "render-window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "render-window")
			}
			playground.RenderWindow(arg0Val)
			return nil
		},
	},
	"repository//can-read": {
		Doc:   "repository.Repository.CanRead",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//can-read")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//can-read")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//can-read")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository//can-read")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository//can-read")
			}
			res0, res1 := arg0Val.CanRead(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository//destroy": {
		Doc:   "repository.Repository.Destroy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//destroy")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//destroy")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//destroy")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "repository//destroy")
			}
			arg0Val.Destroy(arg1Val)
			return arg0
		},
	},
	"repository//exists": {
		Doc:   "repository.Repository.Exists",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//exists")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//exists")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//exists")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository//exists")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository//exists")
			}
			res0, res1 := arg0Val.Exists(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository//reader": {
		Doc:   "repository.Repository.Reader",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//reader")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//reader")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository//reader")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository//reader")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository//reader")
			}
			res0, res1 := arg0Val.Reader(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"resource//content": {
		Doc:   "fyne.Resource.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "resource//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "resource//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "resource//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"resource//name": {
		Doc:   "fyne.Resource.Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "resource//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "resource//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "resource//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"rich-text": {
		Doc:   "widget.NewRichText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "rich-text")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "rich-text")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "rich-text")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "rich-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "rich-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "rich-text")
			}
			res0 := widget.NewRichText(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-rich-text")
			return res0Obj
		},
	},
	"rich-text-block//segments": {
		Doc:   "widget.RichTextBlock.Segments",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextBlock
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextBlock)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-block//segments")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-block//segments")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-block//segments")
			}
			res0 := arg0Val.Segments()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rich-text-segment")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"rich-text-from-markdown": {
		Doc:   "widget.NewRichTextFromMarkdown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "rich-text-from-markdown")
			}
			res0 := widget.NewRichTextFromMarkdown(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-rich-text")
			return res0Obj
		},
	},
	"rich-text-segment//inline": {
		Doc:   "widget.RichTextSegment.Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"rich-text-segment//select": {
		Doc:   "widget.RichTextSegment.Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-segment//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "rich-text-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "rich-text-segment//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"rich-text-segment//selected-text": {
		Doc:   "widget.RichTextSegment.SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"rich-text-segment//textual": {
		Doc:   "widget.RichTextSegment.Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"rich-text-segment//unselect": {
		Doc:   "widget.RichTextSegment.Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"rich-text-segment//update": {
		Doc:   "widget.RichTextSegment.Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-segment//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-segment//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"rich-text-segment//visual": {
		Doc:   "widget.RichTextSegment.Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-segment//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"rich-text-style//alignment!": {
		Doc:   "Set widget.RichTextStyle Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-style//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-style//alignment!")
			}
			return arg0
		},
	},
	"rich-text-style//alignment?": {
		Doc:   "Get widget.RichTextStyle Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"rich-text-style//color-name!": {
		Doc:   "Set widget.RichTextStyle ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//color-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorName, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-style//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-style//color-name!")
			}
			return arg0
		},
	},
	"rich-text-style//color-name?": {
		Doc:   "Get widget.RichTextStyle ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//color-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//color-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorName, "theme-color-name")
			return resObj
		},
	},
	"rich-text-style//inline!": {
		Doc:   "Set widget.RichTextStyle Inline value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//inline!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//inline!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Inline = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "rich-text-style//inline!")
			}
			return arg0
		},
	},
	"rich-text-style//inline?": {
		Doc:   "Get widget.RichTextStyle Inline value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//inline?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//inline?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Inline))
			return resObj
		},
	},
	"rich-text-style//size-name!": {
		Doc:   "Set widget.RichTextStyle SizeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//size-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//size-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.SizeName, ok = v.Value.(fyne.ThemeSizeName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-style//size-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-style//size-name!")
			}
			return arg0
		},
	},
	"rich-text-style//size-name?": {
		Doc:   "Get widget.RichTextStyle SizeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//size-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//size-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SizeName, "theme-size-name")
			return resObj
		},
	},
	"rich-text-style//text-style!": {
		Doc:   "Set widget.RichTextStyle TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-style//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text-style//text-style!")
			}
			return arg0
		},
	},
	"rich-text-style//text-style?": {
		Doc:   "Get widget.RichTextStyle TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text-style//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"rich-text-with-text": {
		Doc:   "widget.NewRichTextWithText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "rich-text-with-text")
			}
			res0 := widget.NewRichTextWithText(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-rich-text")
			return res0Obj
		},
	},
	"rich-text//hidden!": {
		Doc:   "Set widget.RichText Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "rich-text//hidden!")
			}
			return arg0
		},
	},
	"rich-text//hidden?": {
		Doc:   "Get widget.RichText Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"rich-text//scroll!": {
		Doc:   "Set widget.RichText Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text//scroll!")
			}
			return arg0
		},
	},
	"rich-text//scroll?": {
		Doc:   "Get widget.RichText Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//scroll?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "scroll-direction")
			return resObj
		},
	},
	"rich-text//segments!": {
		Doc:   "Set widget.RichText Segments value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//segments!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//segments!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Segments = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Segments[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rich-text//segments!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rich-text//segments!")
						}
						self.Segments[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rich-text//segments!")
					}
				}
			case env.Native:
				var ok bool
				self.Segments, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rich-text//segments!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rich-text//segments!")
				}
				self.Segments = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rich-text//segments!")
			}
			return arg0
		},
	},
	"rich-text//segments?": {
		Doc:   "Get widget.RichText Segments value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//segments?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//segments?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Segments))
				for i, it := range self.Segments {
					items[i] = *env.NewNative(ps.Idx, it, "rich-text-segment")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"rich-text//truncation!": {
		Doc:   "Set widget.RichText Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//truncation!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//truncation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Truncation, ok = v.Value.(fyne.TextTruncation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text//truncation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text//truncation!")
			}
			return arg0
		},
	},
	"rich-text//truncation?": {
		Doc:   "Get widget.RichText Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//truncation?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//truncation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Truncation, "text-truncation")
			return resObj
		},
	},
	"rich-text//wrapping!": {
		Doc:   "Set widget.RichText Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rich-text//wrapping!")
			}
			return arg0
		},
	},
	"rich-text//wrapping?": {
		Doc:   "Get widget.RichText Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//wrapping?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rich-text//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"rune": {
		Doc:   "binding.NewRune",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewRune()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			return res0Obj
		},
	},
	"rune-list": {
		Doc:   "binding.NewRuneList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewRuneList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune-list")
			return res0Obj
		},
	},
	"rune-list//append": {
		Doc:   "binding.RuneList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//append")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rune-list//append")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rune-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"rune-list//get": {
		Doc:   "binding.RuneList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "rune")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"rune-list//get-value": {
		Doc:   "binding.RuneList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "rune-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"rune-list//prepend": {
		Doc:   "binding.RuneList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//prepend")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rune-list//prepend")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rune-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"rune-list//set": {
		Doc:   "binding.RuneList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//set")
			}
			var arg1Val []rune
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]rune, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(rune)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rune-list//set")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rune-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rune-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rune-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "rune-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"rune-list//set-value": {
		Doc:   "binding.RuneList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "rune-list//set-value")
			}
			var arg2Val rune
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "rune-list//set-value")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "rune-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"rune-tree": {
		Doc:   "binding.NewRuneTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewRuneTree()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune-tree")
			return res0Obj
		},
	},
	"rune-tree//append": {
		Doc:   "binding.RuneTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "rune-tree//append")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "rune-tree//append")
			}
			var arg3Val rune
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "rune-tree//append")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "rune-tree//append")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"rune-tree//get": {
		Doc:   "binding.RuneTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//get")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewNative(ps.Idx, mVal, "rune")
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"rune-tree//get-value": {
		Doc:   "binding.RuneTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//get-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "rune-tree//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"rune-tree//prepend": {
		Doc:   "binding.RuneTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "rune-tree//prepend")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "rune-tree//prepend")
			}
			var arg3Val rune
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "rune-tree//prepend")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "rune-tree//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"rune-tree//set": {
		Doc:   "binding.RuneTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//set")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
			}
			var arg2Val map[string]rune
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
				}
				arg2Val = make(map[string]rune, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
					}
					var mapV rune
					switch v := v.Series.S[i+1].(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(rune)
						if !ok {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
						}
					default:
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]rune, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV rune
					switch v := dictV.(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(rune)
						if !ok {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
						}
					default:
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]rune)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "rune-tree//set")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"rune-tree//set-value": {
		Doc:   "binding.RuneTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune-tree//set-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "rune-tree//set-value")
			}
			var arg2Val rune
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "rune-tree//set-value")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "rune-tree//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"rune//get": {
		Doc:   "binding.Rune.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Rune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"rune//set": {
		Doc:   "binding.Rune.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Rune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "rune//set")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rune//set")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "rune//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"save-file-to-uri": {
		Doc:   "storage.SaveFileToURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "save-file-to-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "save-file-to-uri")
			}
			res0, res1 := storage.SaveFileToURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"scroll": {
		Doc:   "container.NewScroll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll")
			}
			res0 := container.NewScroll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-scroll")
			return res0Obj
		},
	},
	"scroll-bar-color": {
		Doc:   "theme.ScrollBarColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ScrollBarColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"scroll-bar-size": {
		Doc:   "theme.ScrollBarSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ScrollBarSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"scroll-bar-small-size": {
		Doc:   "theme.ScrollBarSmallSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ScrollBarSmallSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"scroll-event//absolute-position!": {
		Doc:   "Set fyne.ScrollEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "scroll-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "scroll-event//absolute-position!")
			}
			return arg0
		},
	},
	"scroll-event//absolute-position?": {
		Doc:   "Get fyne.ScrollEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"scroll-event//position!": {
		Doc:   "Set fyne.ScrollEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "scroll-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "scroll-event//position!")
			}
			return arg0
		},
	},
	"scroll-event//position?": {
		Doc:   "Get fyne.ScrollEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"scroll-event//scrolled!": {
		Doc:   "Set fyne.ScrollEvent Scrolled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//scrolled!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//scrolled!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scrolled, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "scroll-event//scrolled!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "scroll-event//scrolled!")
			}
			return arg0
		},
	},
	"scroll-event//scrolled?": {
		Doc:   "Get fyne.ScrollEvent Scrolled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//scrolled?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scroll-event//scrolled?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scrolled, "delta")
			return resObj
		},
	},
	"scrollable//scrolled": {
		Doc:   "fyne.Scrollable.Scrolled",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Scrollable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Scrollable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scrollable//scrolled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scrollable//scrolled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "scrollable//scrolled")
			}
			var arg1Val *fyne.ScrollEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "scrollable//scrolled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "scrollable//scrolled")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "scrollable//scrolled")
			}
			arg0Val.Scrolled(arg1Val)
			return arg0
		},
	},
	"search-icon": {
		Doc:   "theme.SearchIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SearchIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"search-replace-icon": {
		Doc:   "theme.SearchReplaceIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SearchReplaceIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"secondary-tappable//tapped-secondary": {
		Doc:   "fyne.SecondaryTappable.TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.SecondaryTappable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.SecondaryTappable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "secondary-tappable//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "secondary-tappable//tapped-secondary")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "secondary-tappable//tapped-secondary")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "secondary-tappable//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "secondary-tappable//tapped-secondary")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "secondary-tappable//tapped-secondary")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"select": {
		Doc:   "widget.NewSelect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "select")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "select")
			}
			var arg1Val func(string)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select")
				}
				arg1Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "select")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select")
			}
			res0 := widget.NewSelect(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-select")
			return res0Obj
		},
	},
	"select-entry": {
		Doc:   "widget.NewSelectEntry",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "select-entry")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "select-entry")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "select-entry")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "select-entry")
			}
			res0 := widget.NewSelectEntry(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-select-entry")
			return res0Obj
		},
	},
	"select-entry//action-item!": {
		Doc:   "Set widget.SelectEntry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//action-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//action-item!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//action-item!")
				}
				self.ActionItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//action-item!")
			}
			return arg0
		},
	},
	"select-entry//action-item?": {
		Doc:   "Get widget.SelectEntry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//action-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//action-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ActionItem, "canvas-object")
			return resObj
		},
	},
	"select-entry//cursor-column!": {
		Doc:   "Set widget.SelectEntry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//cursor-column!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//cursor-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "select-entry//cursor-column!")
			}
			return arg0
		},
	},
	"select-entry//cursor-column?": {
		Doc:   "Get widget.SelectEntry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//cursor-column?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//cursor-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"select-entry//cursor-row!": {
		Doc:   "Set widget.SelectEntry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//cursor-row!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//cursor-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "select-entry//cursor-row!")
			}
			return arg0
		},
	},
	"select-entry//cursor-row?": {
		Doc:   "Get widget.SelectEntry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//cursor-row?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//cursor-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"select-entry//hidden!": {
		Doc:   "Set widget.SelectEntry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "select-entry//hidden!")
			}
			return arg0
		},
	},
	"select-entry//hidden?": {
		Doc:   "Get widget.SelectEntry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"select-entry//multi-line!": {
		Doc:   "Set widget.SelectEntry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//multi-line!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//multi-line!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "select-entry//multi-line!")
			}
			return arg0
		},
	},
	"select-entry//multi-line?": {
		Doc:   "Get widget.SelectEntry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//multi-line?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//multi-line?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"select-entry//on-changed!": {
		Doc:   "Set widget.SelectEntry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select-entry//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "select-entry//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select-entry//on-changed!")
			}
			return arg0
		},
	},
	"select-entry//on-changed?": {
		Doc:   "Get widget.SelectEntry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"select-entry//on-cursor-changed!": {
		Doc:   "Set widget.SelectEntry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-cursor-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-cursor-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "select-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select-entry//on-cursor-changed!")
			}
			return arg0
		},
	},
	"select-entry//on-cursor-changed?": {
		Doc:   "Get widget.SelectEntry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-cursor-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-cursor-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "func()")
			return resObj
		},
	},
	"select-entry//on-submitted!": {
		Doc:   "Set widget.SelectEntry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-submitted!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-submitted!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select-entry//on-submitted!")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "select-entry//on-submitted!")
				}
				self.OnSubmitted = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select-entry//on-submitted!")
			}
			return arg0
		},
	},
	"select-entry//on-submitted?": {
		Doc:   "Get widget.SelectEntry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-submitted?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//on-submitted?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "func(string)")
			return resObj
		},
	},
	"select-entry//password!": {
		Doc:   "Set widget.SelectEntry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//password!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//password!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "select-entry//password!")
			}
			return arg0
		},
	},
	"select-entry//password?": {
		Doc:   "Get widget.SelectEntry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//password?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//password?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"select-entry//place-holder!": {
		Doc:   "Set widget.SelectEntry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//place-holder!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "select-entry//place-holder!")
			}
			return arg0
		},
	},
	"select-entry//place-holder?": {
		Doc:   "Get widget.SelectEntry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//place-holder?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"select-entry//scroll!": {
		Doc:   "Set widget.SelectEntry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//scroll!")
			}
			return arg0
		},
	},
	"select-entry//scroll?": {
		Doc:   "Get widget.SelectEntry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//scroll?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "scroll-direction")
			return resObj
		},
	},
	"select-entry//text!": {
		Doc:   "Set widget.SelectEntry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "select-entry//text!")
			}
			return arg0
		},
	},
	"select-entry//text-style!": {
		Doc:   "Set widget.SelectEntry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//text-style!")
			}
			return arg0
		},
	},
	"select-entry//text-style?": {
		Doc:   "Get widget.SelectEntry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"select-entry//text?": {
		Doc:   "Get widget.SelectEntry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"select-entry//validator!": {
		Doc:   "Set widget.SelectEntry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//validator!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Validator, ok = v.Value.(fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//validator!")
			}
			return arg0
		},
	},
	"select-entry//validator?": {
		Doc:   "Get widget.SelectEntry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//validator?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//validator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Validator, "string-validator")
			return resObj
		},
	},
	"select-entry//wrapping!": {
		Doc:   "Set widget.SelectEntry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select-entry//wrapping!")
			}
			return arg0
		},
	},
	"select-entry//wrapping?": {
		Doc:   "Get widget.SelectEntry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//wrapping?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select-entry//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "text-wrap")
			return resObj
		},
	},
	"select//alignment!": {
		Doc:   "Set widget.Select Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "select//alignment!")
			}
			return arg0
		},
	},
	"select//alignment?": {
		Doc:   "Get widget.Select Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"select//hidden!": {
		Doc:   "Set widget.Select Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "select//hidden!")
			}
			return arg0
		},
	},
	"select//hidden?": {
		Doc:   "Get widget.Select Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"select//on-changed!": {
		Doc:   "Set widget.Select OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "select//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "select//on-changed!")
			}
			return arg0
		},
	},
	"select//on-changed?": {
		Doc:   "Get widget.Select OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(string)")
			return resObj
		},
	},
	"select//options!": {
		Doc:   "Set widget.Select Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//options!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "select//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "select//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "select//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "select//options!")
			}
			return arg0
		},
	},
	"select//options?": {
		Doc:   "Get widget.Select Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//options?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//options?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Options))
				for i, it := range self.Options {
					items[i] = *env.NewString(it)
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"select//place-holder!": {
		Doc:   "Set widget.Select PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//place-holder!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "select//place-holder!")
			}
			return arg0
		},
	},
	"select//place-holder?": {
		Doc:   "Get widget.Select PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//place-holder?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"select//selected!": {
		Doc:   "Set widget.Select Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//selected!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "select//selected!")
			}
			return arg0
		},
	},
	"select//selected?": {
		Doc:   "Get widget.Select Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "select//selected?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"selection-color": {
		Doc:   "theme.SelectionColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SelectionColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"selection-radius-size": {
		Doc:   "theme.SelectionRadiusSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SelectionRadiusSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"separator": {
		Doc:   "widget.NewSeparator",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewSeparator()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-separator")
			return res0Obj
		},
	},
	"separator-color": {
		Doc:   "theme.SeparatorColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SeparatorColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"separator-thickness-size": {
		Doc:   "theme.SeparatorThicknessSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SeparatorThicknessSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"separator//hidden!": {
		Doc:   "Set widget.Separator Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "separator//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "separator//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "separator//hidden!")
			}
			return arg0
		},
	},
	"separator//hidden?": {
		Doc:   "Get widget.Separator Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "separator//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "separator//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"set-current-app": {
		Doc:   "fyne.SetCurrentApp",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "set-current-app")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "set-current-app")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "set-current-app")
			}
			fyne.SetCurrentApp(arg0Val)
			return nil
		},
	},
	"set-metadata": {
		Doc:   "app.SetMetadata",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "set-metadata")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "set-metadata")
			}
			app.SetMetadata(arg0Val)
			return nil
		},
	},
	"settings-icon": {
		Doc:   "theme.SettingsIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SettingsIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"settings-schema//cloud-config!": {
		Doc:   "Set app.SettingsSchema CloudConfig value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//cloud-config!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//cloud-config!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudConfig = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "settings-schema//cloud-config!")
			}
			return arg0
		},
	},
	"settings-schema//cloud-config?": {
		Doc:   "Get app.SettingsSchema CloudConfig value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//cloud-config?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//cloud-config?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudConfig)
			return resObj
		},
	},
	"settings-schema//cloud-name!": {
		Doc:   "Set app.SettingsSchema CloudName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//cloud-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//cloud-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "settings-schema//cloud-name!")
			}
			return arg0
		},
	},
	"settings-schema//cloud-name?": {
		Doc:   "Get app.SettingsSchema CloudName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//cloud-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//cloud-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudName)
			return resObj
		},
	},
	"settings-schema//disable-animations!": {
		Doc:   "Set app.SettingsSchema DisableAnimations value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//disable-animations!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//disable-animations!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.DisableAnimations = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "settings-schema//disable-animations!")
			}
			return arg0
		},
	},
	"settings-schema//disable-animations?": {
		Doc:   "Get app.SettingsSchema DisableAnimations value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//disable-animations?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//disable-animations?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.DisableAnimations))
			return resObj
		},
	},
	"settings-schema//primary-color!": {
		Doc:   "Set app.SettingsSchema PrimaryColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//primary-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//primary-color!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PrimaryColor = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "settings-schema//primary-color!")
			}
			return arg0
		},
	},
	"settings-schema//primary-color?": {
		Doc:   "Get app.SettingsSchema PrimaryColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//primary-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//primary-color?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PrimaryColor)
			return resObj
		},
	},
	"settings-schema//scale!": {
		Doc:   "Set app.SettingsSchema Scale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//scale!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//scale!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Scale = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "settings-schema//scale!")
			}
			return arg0
		},
	},
	"settings-schema//scale?": {
		Doc:   "Get app.SettingsSchema Scale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//scale?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//scale?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Scale))
			return resObj
		},
	},
	"settings-schema//theme-name!": {
		Doc:   "Set app.SettingsSchema ThemeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//theme-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//theme-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.ThemeName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "settings-schema//theme-name!")
			}
			return arg0
		},
	},
	"settings-schema//theme-name?": {
		Doc:   "Get app.SettingsSchema ThemeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//theme-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings-schema//theme-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ThemeName)
			return resObj
		},
	},
	"settings//build-type": {
		Doc:   "fyne.Settings.BuildType",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//build-type")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//build-type")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//build-type")
			}
			res0 := arg0Val.BuildType()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "build-type")
			return res0Obj
		},
	},
	"settings//primary-color": {
		Doc:   "fyne.Settings.PrimaryColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//primary-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//primary-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//primary-color")
			}
			res0 := arg0Val.PrimaryColor()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"settings//scale": {
		Doc:   "fyne.Settings.Scale",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//scale")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//scale")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//scale")
			}
			res0 := arg0Val.Scale()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"settings//set-theme": {
		Doc:   "fyne.Settings.SetTheme",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//set-theme")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//set-theme")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//set-theme")
			}
			var arg1Val fyne.Theme
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "settings//set-theme")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "settings//set-theme")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "settings//set-theme")
			}
			arg0Val.SetTheme(arg1Val)
			return arg0
		},
	},
	"settings//show-animations": {
		Doc:   "fyne.Settings.ShowAnimations",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//show-animations")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//show-animations")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//show-animations")
			}
			res0 := arg0Val.ShowAnimations()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"settings//theme": {
		Doc:   "fyne.Settings.Theme",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//theme")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//theme")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//theme")
			}
			res0 := arg0Val.Theme()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme")
			return res0Obj
		},
	},
	"settings//theme-variant": {
		Doc:   "fyne.Settings.ThemeVariant",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//theme-variant")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//theme-variant")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "settings//theme-variant")
			}
			res0 := arg0Val.ThemeVariant()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-variant")
			return res0Obj
		},
	},
	"shadow-color": {
		Doc:   "theme.ShadowColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ShadowColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"shortcut-copy//clipboard!": {
		Doc:   "Set fyne.ShortcutCopy Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-copy//clipboard!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-copy//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcut-copy//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcut-copy//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcut-copy//clipboard!")
			}
			return arg0
		},
	},
	"shortcut-copy//clipboard?": {
		Doc:   "Get fyne.ShortcutCopy Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-copy//clipboard?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-copy//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "clipboard")
			return resObj
		},
	},
	"shortcut-cut//clipboard!": {
		Doc:   "Set fyne.ShortcutCut Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-cut//clipboard!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-cut//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcut-cut//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcut-cut//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcut-cut//clipboard!")
			}
			return arg0
		},
	},
	"shortcut-cut//clipboard?": {
		Doc:   "Get fyne.ShortcutCut Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-cut//clipboard?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-cut//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "clipboard")
			return resObj
		},
	},
	"shortcut-paste//clipboard!": {
		Doc:   "Set fyne.ShortcutPaste Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-paste//clipboard!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-paste//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcut-paste//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcut-paste//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcut-paste//clipboard!")
			}
			return arg0
		},
	},
	"shortcut-paste//clipboard?": {
		Doc:   "Get fyne.ShortcutPaste Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-paste//clipboard?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut-paste//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "clipboard")
			return resObj
		},
	},
	"shortcut//shortcut-name": {
		Doc:   "fyne.Shortcut.ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Shortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcut//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"shortcutable//typed-shortcut": {
		Doc:   "fyne.Shortcutable.TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Shortcutable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Shortcutable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcutable//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcutable//typed-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "shortcutable//typed-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcutable//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcutable//typed-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "shortcutable//typed-shortcut")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"show-color-picker": {
		Doc:   "dialog.ShowColorPicker",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "show-color-picker")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "show-color-picker")
			}
			var arg2Val func(color.Color)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "show-color-picker")
				}
				arg2Val = func(arg0 color.Color) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "color")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "show-color-picker")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "show-color-picker")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-color-picker")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-color-picker")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-color-picker")
			}
			dialog.ShowColorPicker(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"show-confirm": {
		Doc:   "dialog.ShowConfirm",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "show-confirm")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "show-confirm")
			}
			var arg2Val func(bool)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "show-confirm")
				}
				arg2Val = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "show-confirm")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "show-confirm")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-confirm")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-confirm")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-confirm")
			}
			dialog.ShowConfirm(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"show-custom": {
		Doc:   "dialog.ShowCustom",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "show-custom")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "show-custom")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-custom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-custom")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-custom")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-custom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-custom")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-custom")
			}
			dialog.ShowCustom(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"show-custom-without-buttons": {
		Doc:   "dialog.ShowCustomWithoutButtons",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "show-custom-without-buttons")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-custom-without-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-custom-without-buttons")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-custom-without-buttons")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-custom-without-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-custom-without-buttons")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-custom-without-buttons")
			}
			dialog.ShowCustomWithoutButtons(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"show-entry-dialog": {
		Doc:   "dialog.ShowEntryDialog",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "show-entry-dialog")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "show-entry-dialog")
			}
			var arg2Val func(string)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "show-entry-dialog")
				}
				arg2Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "show-entry-dialog")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "show-entry-dialog")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-entry-dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-entry-dialog")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-entry-dialog")
			}
			dialog.ShowEntryDialog(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"show-error": {
		Doc:   "dialog.ShowError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val error
			if v, ok := arg0.(env.Error); ok {
				arg0Val = errors.New(v.Print(*ps.Idx))
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.ErrorType}, "show-error")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-error")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-error")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-error")
			}
			dialog.ShowError(arg0Val, arg1Val)
			return nil
		},
	},
	"show-folder-open": {
		Doc:   "dialog.ShowFolderOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.ListableURI, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "show-folder-open")
				}
				arg0Val = func(arg0 fyne.ListableURI, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "listable-uri")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "show-folder-open")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "show-folder-open")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-folder-open")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-folder-open")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-folder-open")
			}
			dialog.ShowFolderOpen(arg0Val, arg1Val)
			return nil
		},
	},
	"show-information": {
		Doc:   "dialog.ShowInformation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "show-information")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "show-information")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-information")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-information")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-information")
			}
			dialog.ShowInformation(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"show-modal-pop-up": {
		Doc:   "widget.ShowModalPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-modal-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-modal-pop-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-modal-pop-up")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-modal-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-modal-pop-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-modal-pop-up")
			}
			widget.ShowModalPopUp(arg0Val, arg1Val)
			return nil
		},
	},
	"show-pop-up": {
		Doc:   "widget.ShowPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up")
			}
			widget.ShowPopUp(arg0Val, arg1Val)
			return nil
		},
	},
	"show-pop-up-at-position": {
		Doc:   "widget.ShowPopUpAtPosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-at-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-at-position")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-at-position")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-at-position")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-pop-up-at-position")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-pop-up-at-position")
			}
			widget.ShowPopUpAtPosition(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"show-pop-up-at-relative-position": {
		Doc:   "widget.ShowPopUpAtRelativePosition",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-pop-up-at-relative-position")
			}
			widget.ShowPopUpAtRelativePosition(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"show-pop-up-menu-at-position": {
		Doc:   "widget.ShowPopUpMenuAtPosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-menu-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-menu-at-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-menu-at-position")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-menu-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-menu-at-position")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-menu-at-position")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-pop-up-menu-at-position")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-pop-up-menu-at-position")
			}
			widget.ShowPopUpMenuAtPosition(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"show-pop-up-menu-at-relative-position": {
		Doc:   "widget.ShowPopUpMenuAtRelativePosition",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "show-pop-up-menu-at-relative-position")
			}
			widget.ShowPopUpMenuAtRelativePosition(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"simple-renderer": {
		Doc:   "widget.NewSimpleRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "simple-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "simple-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "simple-renderer")
			}
			res0 := widget.NewSimpleRenderer(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"size": {
		Doc:   "fyne.NewSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "size")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "size")
			}
			res0 := fyne.NewSize(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"size-animation": {
		Doc:   "canvas.NewSizeAnimation",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size-animation")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size-animation")
			}
			var arg2Val time.Duration
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "size-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "size-animation")
			}
			var arg3Val func(fyne.Size)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "size-animation")
				}
				arg3Val = func(arg0 fyne.Size) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "size")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "size-animation")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "size-animation")
			}
			res0 := canvas.NewSizeAnimation(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-animation")
			return res0Obj
		},
	},
	"size//add": {
		Doc:   "fyne.Size.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//add")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//add")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//add")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//add")
			}
			res0 := arg0Val.Add(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"size//add-width-height": {
		Doc:   "fyne.Size.AddWidthHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//add-width-height")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//add-width-height")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "size//add-width-height")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "size//add-width-height")
			}
			res0 := arg0Val.AddWidthHeight(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"size//components": {
		Doc:   "fyne.Size.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//components")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//components")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"size//height!": {
		Doc:   "Set fyne.Size Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//height!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//height!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Height = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "size//height!")
			}
			return arg0
		},
	},
	"size//height?": {
		Doc:   "Get fyne.Size Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//height?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//height?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Height))
			return resObj
		},
	},
	"size//is-zero": {
		Doc:   "fyne.Size.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//is-zero")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//is-zero")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"size//max": {
		Doc:   "fyne.Size.Max",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//max")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//max")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//max")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//max")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//max")
			}
			res0 := arg0Val.Max(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"size//min": {
		Doc:   "fyne.Size.Min",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//min")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//min")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//min")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//min")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//min")
			}
			res0 := arg0Val.Min(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"size//subtract": {
		Doc:   "fyne.Size.Subtract",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//subtract")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//subtract")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//subtract")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//subtract")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "size//subtract")
			}
			res0 := arg0Val.Subtract(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"size//subtract-width-height": {
		Doc:   "fyne.Size.SubtractWidthHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//subtract-width-height")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//subtract-width-height")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "size//subtract-width-height")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "size//subtract-width-height")
			}
			res0 := arg0Val.SubtractWidthHeight(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"size//width!": {
		Doc:   "Set fyne.Size Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "size//width!")
			}
			return arg0
		},
	},
	"size//width?": {
		Doc:   "Get fyne.Size Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "size//width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"slider": {
		Doc:   "widget.NewSlider",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float64
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "slider")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "slider")
			}
			res0 := widget.NewSlider(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-slider")
			return res0Obj
		},
	},
	"slider-with-data": {
		Doc:   "widget.NewSliderWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float64
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "slider-with-data")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "slider-with-data")
			}
			var arg2Val binding.Float
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "slider-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "slider-with-data")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "slider-with-data")
			}
			res0 := widget.NewSliderWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-slider")
			return res0Obj
		},
	},
	"slider//hidden!": {
		Doc:   "Set widget.Slider Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "slider//hidden!")
			}
			return arg0
		},
	},
	"slider//hidden?": {
		Doc:   "Get widget.Slider Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"slider//max!": {
		Doc:   "Set widget.Slider Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//max!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//max!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "slider//max!")
			}
			return arg0
		},
	},
	"slider//max?": {
		Doc:   "Get widget.Slider Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//max?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//max?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"slider//min!": {
		Doc:   "Set widget.Slider Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//min!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//min!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "slider//min!")
			}
			return arg0
		},
	},
	"slider//min?": {
		Doc:   "Get widget.Slider Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//min?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//min?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"slider//on-change-ended!": {
		Doc:   "Set widget.Slider OnChangeEnded value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//on-change-ended!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//on-change-ended!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "slider//on-change-ended!")
				}
				self.OnChangeEnded = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "slider//on-change-ended!")
				}
				self.OnChangeEnded = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "slider//on-change-ended!")
			}
			return arg0
		},
	},
	"slider//on-change-ended?": {
		Doc:   "Get widget.Slider OnChangeEnded value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//on-change-ended?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//on-change-ended?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChangeEnded, "func(float64)")
			return resObj
		},
	},
	"slider//on-changed!": {
		Doc:   "Set widget.Slider OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "slider//on-changed!")
				}
				self.OnChanged = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "slider//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "slider//on-changed!")
			}
			return arg0
		},
	},
	"slider//on-changed?": {
		Doc:   "Get widget.Slider OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "func(float64)")
			return resObj
		},
	},
	"slider//orientation!": {
		Doc:   "Set widget.Slider Orientation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//orientation!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//orientation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Orientation, ok = v.Value.(widget.Orientation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "slider//orientation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "slider//orientation!")
			}
			return arg0
		},
	},
	"slider//orientation?": {
		Doc:   "Get widget.Slider Orientation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//orientation?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//orientation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Orientation, "orientation")
			return resObj
		},
	},
	"slider//step!": {
		Doc:   "Set widget.Slider Step value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//step!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//step!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Step = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "slider//step!")
			}
			return arg0
		},
	},
	"slider//step?": {
		Doc:   "Get widget.Slider Step value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//step?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//step?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Step))
			return resObj
		},
	},
	"slider//value!": {
		Doc:   "Set widget.Slider Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//value!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//value!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "slider//value!")
			}
			return arg0
		},
	},
	"slider//value?": {
		Doc:   "Get widget.Slider Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//value?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "slider//value?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"software-canvas": {
		Doc:   "playground.NewSoftwareCanvas",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := playground.NewSoftwareCanvas()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "windowless-canvas")
			return res0Obj
		},
	},
	"spacer": {
		Doc:   "layout.NewSpacer",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewSpacer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"spacer-object//expand-horizontal": {
		Doc:   "layout.SpacerObject.ExpandHorizontal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val layout.SpacerObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(layout.SpacerObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer-object//expand-horizontal")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer-object//expand-horizontal")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer-object//expand-horizontal")
			}
			res0 := arg0Val.ExpandHorizontal()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"spacer-object//expand-vertical": {
		Doc:   "layout.SpacerObject.ExpandVertical",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val layout.SpacerObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(layout.SpacerObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer-object//expand-vertical")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer-object//expand-vertical")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer-object//expand-vertical")
			}
			res0 := arg0Val.ExpandVertical()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"spacer//fix-horizontal!": {
		Doc:   "Set layout.Spacer FixHorizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer//fix-horizontal!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer//fix-horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixHorizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "spacer//fix-horizontal!")
			}
			return arg0
		},
	},
	"spacer//fix-horizontal?": {
		Doc:   "Get layout.Spacer FixHorizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer//fix-horizontal?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer//fix-horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixHorizontal))
			return resObj
		},
	},
	"spacer//fix-vertical!": {
		Doc:   "Set layout.Spacer FixVertical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer//fix-vertical!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer//fix-vertical!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixVertical = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "spacer//fix-vertical!")
			}
			return arg0
		},
	},
	"spacer//fix-vertical?": {
		Doc:   "Get layout.Spacer FixVertical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer//fix-vertical?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "spacer//fix-vertical?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixVertical))
			return resObj
		},
	},
	"split//hidden!": {
		Doc:   "Set container.Split Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "split//hidden!")
			}
			return arg0
		},
	},
	"split//hidden?": {
		Doc:   "Get container.Split Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"split//horizontal!": {
		Doc:   "Set container.Split Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//horizontal!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "split//horizontal!")
			}
			return arg0
		},
	},
	"split//horizontal?": {
		Doc:   "Get container.Split Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//horizontal?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"split//leading!": {
		Doc:   "Set container.Split Leading value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//leading!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//leading!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Leading, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "split//leading!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "split//leading!")
				}
				self.Leading = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "split//leading!")
			}
			return arg0
		},
	},
	"split//leading?": {
		Doc:   "Get container.Split Leading value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//leading?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//leading?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Leading, "canvas-object")
			return resObj
		},
	},
	"split//offset!": {
		Doc:   "Set container.Split Offset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//offset!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//offset!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Offset = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "split//offset!")
			}
			return arg0
		},
	},
	"split//offset?": {
		Doc:   "Get container.Split Offset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//offset?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//offset?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Offset))
			return resObj
		},
	},
	"split//trailing!": {
		Doc:   "Set container.Split Trailing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//trailing!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//trailing!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Trailing, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "split//trailing!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "split//trailing!")
				}
				self.Trailing = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "split//trailing!")
			}
			return arg0
		},
	},
	"split//trailing?": {
		Doc:   "Get container.Split Trailing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//trailing?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "split//trailing?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Trailing, "canvas-object")
			return resObj
		},
	},
	"sprintf": {
		Doc:   "binding.NewSprintf",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "sprintf")
			}
			var arg1Val []binding.DataItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]binding.DataItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(binding.DataItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "sprintf")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "sprintf")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "sprintf")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]binding.DataItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "sprintf")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "sprintf")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "sprintf")
			}
			res0 := binding.NewSprintf(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"square-offset-pos": {
		Doc:   "fyne.NewSquareOffsetPos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "square-offset-pos")
			}
			res0 := fyne.NewSquareOffsetPos(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "position")
			return res0Obj
		},
	},
	"square-size": {
		Doc:   "fyne.NewSquareSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "square-size")
			}
			res0 := fyne.NewSquareSize(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"stack": {
		Doc:   "container.NewStack",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "stack")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "stack")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "stack")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "stack")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "stack")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "stack")
			}
			res0 := container.NewStack(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"stack-layout": {
		Doc:   "layout.NewStackLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewStackLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"standard-cursor//image": {
		Doc:   "desktop.StandardCursor.Image",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.StandardCursor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.StandardCursor)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "standard-cursor//image")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "standard-cursor//image")
			}
			res0, res1, res2 := arg0Val.Image()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
				"3": res2Obj,
			})
		},
	},
	"static-resource": {
		Doc:   "fyne.NewStaticResource",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "static-resource")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource")
			}
			res0 := fyne.NewStaticResource(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-static-resource")
			return res0Obj
		},
	},
	"static-resource//static-content!": {
		Doc:   "Set fyne.StaticResource StaticContent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "static-resource//static-content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "static-resource//static-content!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.StaticContent = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.StaticContent[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource//static-content!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource//static-content!")
					}
				}
			case env.Native:
				var ok bool
				self.StaticContent, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource//static-content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource//static-content!")
				}
				self.StaticContent = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "static-resource//static-content!")
			}
			return arg0
		},
	},
	"static-resource//static-content?": {
		Doc:   "Get fyne.StaticResource StaticContent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "static-resource//static-content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "static-resource//static-content?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.StaticContent))
				for i, it := range self.StaticContent {
					items[i] = *env.NewNative(ps.Idx, it, "byte")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"static-resource//static-name!": {
		Doc:   "Set fyne.StaticResource StaticName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "static-resource//static-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "static-resource//static-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.StaticName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "static-resource//static-name!")
			}
			return arg0
		},
	},
	"static-resource//static-name?": {
		Doc:   "Get fyne.StaticResource StaticName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "static-resource//static-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "static-resource//static-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.StaticName)
			return resObj
		},
	},
	"storage-icon": {
		Doc:   "theme.StorageIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.StorageIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"storage//create": {
		Doc:   "fyne.Storage.Create",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//create")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//create")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//create")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "storage//create")
			}
			res0, res1 := arg0Val.Create(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage//list": {
		Doc:   "fyne.Storage.List",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//list")
			}
			res0 := arg0Val.List()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"storage//open": {
		Doc:   "fyne.Storage.Open",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//open")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//open")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//open")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "storage//open")
			}
			res0, res1 := arg0Val.Open(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage//remove": {
		Doc:   "fyne.Storage.Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//remove")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "storage//remove")
			}
			res0 := arg0Val.Remove(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"storage//root-uri": {
		Doc:   "fyne.Storage.RootURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//root-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//root-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//root-uri")
			}
			res0 := arg0Val.RootURI()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			return res0Obj
		},
	},
	"storage//save": {
		Doc:   "fyne.Storage.Save",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//save")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//save")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage//save")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "storage//save")
			}
			res0, res1 := arg0Val.Save(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"string": {
		Doc:   "binding.NewString",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewString()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"string-list": {
		Doc:   "binding.NewStringList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewStringList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-list")
			return res0Obj
		},
	},
	"string-list//append": {
		Doc:   "binding.StringList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"string-list//get": {
		Doc:   "binding.StringList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewString(it)
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"string-list//get-value": {
		Doc:   "binding.StringList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "string-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"string-list//prepend": {
		Doc:   "binding.StringList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"string-list//set": {
		Doc:   "binding.StringList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//set")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "string-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "string-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "string-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "string-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"string-list//set-value": {
		Doc:   "binding.StringList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "string-list//set-value")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "string-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"string-to-bool": {
		Doc:   "binding.StringToBool",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-bool")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-bool")
			}
			res0 := binding.StringToBool(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool")
			return res0Obj
		},
	},
	"string-to-bool-with-format": {
		Doc:   "binding.StringToBoolWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-bool-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-bool-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-bool-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-to-bool-with-format")
			}
			res0 := binding.StringToBoolWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool")
			return res0Obj
		},
	},
	"string-to-float": {
		Doc:   "binding.StringToFloat",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-float")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-float")
			}
			res0 := binding.StringToFloat(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "float")
			return res0Obj
		},
	},
	"string-to-float-with-format": {
		Doc:   "binding.StringToFloatWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-float-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-float-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-float-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-to-float-with-format")
			}
			res0 := binding.StringToFloatWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "float")
			return res0Obj
		},
	},
	"string-to-int": {
		Doc:   "binding.StringToInt",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-int")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-int")
			}
			res0 := binding.StringToInt(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "int")
			return res0Obj
		},
	},
	"string-to-int-with-format": {
		Doc:   "binding.StringToIntWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-int-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-int-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-int-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-to-int-with-format")
			}
			res0 := binding.StringToIntWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "int")
			return res0Obj
		},
	},
	"string-to-string-with-format": {
		Doc:   "binding.StringToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-string-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-string-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-string-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-to-string-with-format")
			}
			res0 := binding.StringToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"string-to-uri": {
		Doc:   "binding.StringToURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-to-uri")
			}
			res0 := binding.StringToURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			return res0Obj
		},
	},
	"string-tree": {
		Doc:   "binding.NewStringTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewStringTree()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-tree")
			return res0Obj
		},
	},
	"string-tree//append": {
		Doc:   "binding.StringTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-tree//append")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "string-tree//append")
			}
			var arg3Val string
			if v, ok := arg3.(env.String); ok {
				arg3Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.StringType}, "string-tree//append")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"string-tree//get": {
		Doc:   "binding.StringTree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//get")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewString(mVal)
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"string-tree//get-value": {
		Doc:   "binding.StringTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//get-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-tree//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"string-tree//prepend": {
		Doc:   "binding.StringTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-tree//prepend")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "string-tree//prepend")
			}
			var arg3Val string
			if v, ok := arg3.(env.String); ok {
				arg3Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.StringType}, "string-tree//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"string-tree//set": {
		Doc:   "binding.StringTree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//set")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
			}
			var arg2Val map[string]string
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
				}
				arg2Val = make(map[string]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
					}
					var mapV string
					if v, ok := v.Series.S[i+1].(env.String); ok {
						mapV = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV string
					if v, ok := dictV.(env.String); ok {
						mapV = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]string)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "string-tree//set")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"string-tree//set-value": {
		Doc:   "binding.StringTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string-tree//set-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string-tree//set-value")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "string-tree//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"string//get": {
		Doc:   "binding.String.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"string//set": {
		Doc:   "binding.String.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "string//set")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "string//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"success-color": {
		Doc:   "theme.SuccessColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SuccessColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"success-themed-resource": {
		Doc:   "theme.NewSuccessThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "success-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "success-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "success-themed-resource")
			}
			res0 := theme.NewSuccessThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-themed-resource")
			return res0Obj
		},
	},
	"symbol-font": {
		Doc:   "theme.SymbolFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SymbolFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"tab-item": {
		Doc:   "container.NewTabItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "tab-item")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item")
			}
			res0 := container.NewTabItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-tab-item")
			return res0Obj
		},
	},
	"tab-item-with-icon": {
		Doc:   "container.NewTabItemWithIcon",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "tab-item-with-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item-with-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item-with-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item-with-icon")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "tab-item-with-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "tab-item-with-icon")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "tab-item-with-icon")
			}
			res0 := container.NewTabItemWithIcon(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-tab-item")
			return res0Obj
		},
	},
	"tab-item//content!": {
		Doc:   "Set container.TabItem Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item//content!")
			}
			return arg0
		},
	},
	"tab-item//content?": {
		Doc:   "Get container.TabItem Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "canvas-object")
			return resObj
		},
	},
	"tab-item//icon!": {
		Doc:   "Set container.TabItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//icon!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tab-item//icon!")
			}
			return arg0
		},
	},
	"tab-item//icon?": {
		Doc:   "Get container.TabItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//icon?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"tab-item//text!": {
		Doc:   "Set container.TabItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "tab-item//text!")
			}
			return arg0
		},
	},
	"tab-item//text?": {
		Doc:   "Get container.TabItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tab-item//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"tabbable//accepts-tab": {
		Doc:   "fyne.Tabbable.AcceptsTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Tabbable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Tabbable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tabbable//accepts-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tabbable//accepts-tab")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tabbable//accepts-tab")
			}
			res0 := arg0Val.AcceptsTab()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"table": {
		Doc:   "widget.NewTable",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func() (int, int)
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(func() (int, int))
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "table")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table")
			}
			var arg2Val func(widget.TableCellID, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "table")
				}
				arg2Val = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "table")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "table")
			}
			res0 := widget.NewTable(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-table")
			return res0Obj
		},
	},
	"table-cell-id//col!": {
		Doc:   "Set widget.TableCellID Col value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-cell-id//col!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-cell-id//col!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Col = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "table-cell-id//col!")
			}
			return arg0
		},
	},
	"table-cell-id//col?": {
		Doc:   "Get widget.TableCellID Col value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-cell-id//col?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-cell-id//col?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Col))
			return resObj
		},
	},
	"table-cell-id//row!": {
		Doc:   "Set widget.TableCellID Row value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-cell-id//row!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-cell-id//row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Row = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "table-cell-id//row!")
			}
			return arg0
		},
	},
	"table-cell-id//row?": {
		Doc:   "Get widget.TableCellID Row value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-cell-id//row?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-cell-id//row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Row))
			return resObj
		},
	},
	"table-with-headers": {
		Doc:   "widget.NewTableWithHeaders",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func() (int, int)
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(func() (int, int))
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-with-headers")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table-with-headers")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table-with-headers")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "table-with-headers")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table-with-headers")
			}
			var arg2Val func(widget.TableCellID, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "table-with-headers")
				}
				arg2Val = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "table-with-headers")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "table-with-headers")
			}
			res0 := widget.NewTableWithHeaders(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-table")
			return res0Obj
		},
	},
	"table//create-cell!": {
		Doc:   "Set widget.Table CreateCell value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//create-cell!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//create-cell!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//create-cell!")
				}
				self.CreateCell = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "table//create-cell!")
				}
				self.CreateCell = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//create-cell!")
			}
			return arg0
		},
	},
	"table//create-cell?": {
		Doc:   "Get widget.Table CreateCell value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//create-cell?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//create-cell?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateCell, "func()_(canvas-object)")
			return resObj
		},
	},
	"table//create-header!": {
		Doc:   "Set widget.Table CreateHeader value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//create-header!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//create-header!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//create-header!")
				}
				self.CreateHeader = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "table//create-header!")
				}
				self.CreateHeader = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//create-header!")
			}
			return arg0
		},
	},
	"table//create-header?": {
		Doc:   "Get widget.Table CreateHeader value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//create-header?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//create-header?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateHeader, "func()_(canvas-object)")
			return resObj
		},
	},
	"table//hidden!": {
		Doc:   "Set widget.Table Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "table//hidden!")
			}
			return arg0
		},
	},
	"table//hidden?": {
		Doc:   "Get widget.Table Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"table//length!": {
		Doc:   "Set widget.Table Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//length!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//length!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Length, ok = v.Value.(func() (int, int))
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "table//length!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "table//length!")
			}
			return arg0
		},
	},
	"table//length?": {
		Doc:   "Get widget.Table Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//length?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//length?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "func()_(int_int)")
			return resObj
		},
	},
	"table//on-selected!": {
		Doc:   "Set widget.Table OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//on-selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//on-selected!")
				}
				self.OnSelected = func(arg0 widget.TableCellID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "table//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//on-selected!")
			}
			return arg0
		},
	},
	"table//on-selected?": {
		Doc:   "Get widget.Table OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//on-selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(table-cell-id)")
			return resObj
		},
	},
	"table//on-unselected!": {
		Doc:   "Set widget.Table OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//on-unselected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.TableCellID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "table//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//on-unselected!")
			}
			return arg0
		},
	},
	"table//on-unselected?": {
		Doc:   "Get widget.Table OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//on-unselected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(table-cell-id)")
			return resObj
		},
	},
	"table//show-header-column!": {
		Doc:   "Set widget.Table ShowHeaderColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//show-header-column!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//show-header-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowHeaderColumn = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "table//show-header-column!")
			}
			return arg0
		},
	},
	"table//show-header-column?": {
		Doc:   "Get widget.Table ShowHeaderColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//show-header-column?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//show-header-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowHeaderColumn))
			return resObj
		},
	},
	"table//show-header-row!": {
		Doc:   "Set widget.Table ShowHeaderRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//show-header-row!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//show-header-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowHeaderRow = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "table//show-header-row!")
			}
			return arg0
		},
	},
	"table//show-header-row?": {
		Doc:   "Get widget.Table ShowHeaderRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//show-header-row?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//show-header-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowHeaderRow))
			return resObj
		},
	},
	"table//sticky-column-count!": {
		Doc:   "Set widget.Table StickyColumnCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//sticky-column-count!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//sticky-column-count!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StickyColumnCount = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "table//sticky-column-count!")
			}
			return arg0
		},
	},
	"table//sticky-column-count?": {
		Doc:   "Get widget.Table StickyColumnCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//sticky-column-count?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//sticky-column-count?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StickyColumnCount))
			return resObj
		},
	},
	"table//sticky-row-count!": {
		Doc:   "Set widget.Table StickyRowCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//sticky-row-count!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//sticky-row-count!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.StickyRowCount = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "table//sticky-row-count!")
			}
			return arg0
		},
	},
	"table//sticky-row-count?": {
		Doc:   "Get widget.Table StickyRowCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//sticky-row-count?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//sticky-row-count?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.StickyRowCount))
			return resObj
		},
	},
	"table//update-cell!": {
		Doc:   "Set widget.Table UpdateCell value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//update-cell!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//update-cell!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//update-cell!")
				}
				self.UpdateCell = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "table//update-cell!")
				}
				self.UpdateCell = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//update-cell!")
			}
			return arg0
		},
	},
	"table//update-cell?": {
		Doc:   "Get widget.Table UpdateCell value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//update-cell?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//update-cell?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateCell, "func(table-cell-id_canvas-object)")
			return resObj
		},
	},
	"table//update-header!": {
		Doc:   "Set widget.Table UpdateHeader value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//update-header!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//update-header!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//update-header!")
				}
				self.UpdateHeader = func(arg0 widget.TableCellID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "table-cell-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "table//update-header!")
				}
				self.UpdateHeader = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "table//update-header!")
			}
			return arg0
		},
	},
	"table//update-header?": {
		Doc:   "Get widget.Table UpdateHeader value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Table
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Table)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//update-header?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "table//update-header?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateHeader, "func(table-cell-id_canvas-object)")
			return resObj
		},
	},
	"tappable//tapped": {
		Doc:   "fyne.Tappable.Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Tappable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Tappable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tappable//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tappable//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tappable//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tappable//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tappable//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tappable//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"text": {
		Doc:   "canvas.NewText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "text")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text")
			}
			res0 := canvas.NewText(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text")
			return res0Obj
		},
	},
	"text-bold-font": {
		Doc:   "theme.TextBoldFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextBoldFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"text-bold-italic-font": {
		Doc:   "theme.TextBoldItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextBoldItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"text-color": {
		Doc:   "theme.TextColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"text-font": {
		Doc:   "theme.TextFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"text-grid": {
		Doc:   "widget.NewTextGrid",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewTextGrid()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-grid")
			return res0Obj
		},
	},
	"text-grid-cell//rune!": {
		Doc:   "Set widget.TextGridCell Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-cell//rune!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-cell//rune!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-grid-cell//rune!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-grid-cell//rune!")
			}
			return arg0
		},
	},
	"text-grid-cell//rune?": {
		Doc:   "Get widget.TextGridCell Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-cell//rune?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-cell//rune?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"text-grid-cell//style!": {
		Doc:   "Set widget.TextGridCell Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-cell//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-cell//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-grid-cell//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-grid-cell//style!")
				}
				self.Style = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-grid-cell//style!")
			}
			return arg0
		},
	},
	"text-grid-cell//style?": {
		Doc:   "Get widget.TextGridCell Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-cell//style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-cell//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "text-grid-style")
			return resObj
		},
	},
	"text-grid-from-string": {
		Doc:   "widget.NewTextGridFromString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "text-grid-from-string")
			}
			res0 := widget.NewTextGridFromString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-text-grid")
			return res0Obj
		},
	},
	"text-grid-row//cells!": {
		Doc:   "Set widget.TextGridRow Cells value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-row//cells!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-row//cells!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cells = make([]widget.TextGridCell, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Cells[i], ok = v.Value.(widget.TextGridCell)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid-row//cells!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid-row//cells!")
					}
				}
			case env.Native:
				var ok bool
				self.Cells, ok = v.Value.([]widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid-row//cells!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid-row//cells!")
				}
				self.Cells = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid-row//cells!")
			}
			return arg0
		},
	},
	"text-grid-row//cells?": {
		Doc:   "Get widget.TextGridRow Cells value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-row//cells?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-row//cells?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Cells))
				for i, it := range self.Cells {
					items[i] = *env.NewNative(ps.Idx, it, "text-grid-cell")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"text-grid-row//style!": {
		Doc:   "Set widget.TextGridRow Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-row//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-row//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-grid-row//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-grid-row//style!")
				}
				self.Style = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-grid-row//style!")
			}
			return arg0
		},
	},
	"text-grid-row//style?": {
		Doc:   "Get widget.TextGridRow Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-row//style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-row//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "text-grid-style")
			return resObj
		},
	},
	"text-grid-style//background-color": {
		Doc:   "widget.TextGridStyle.BackgroundColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.TextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-style//background-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-style//background-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-style//background-color")
			}
			res0 := arg0Val.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"text-grid-style//text-color": {
		Doc:   "widget.TextGridStyle.TextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.TextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-style//text-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-style//text-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid-style//text-color")
			}
			res0 := arg0Val.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"text-grid//hidden!": {
		Doc:   "Set widget.TextGrid Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "text-grid//hidden!")
			}
			return arg0
		},
	},
	"text-grid//hidden?": {
		Doc:   "Get widget.TextGrid Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"text-grid//rows!": {
		Doc:   "Set widget.TextGrid Rows value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//rows!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//rows!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Rows = make([]widget.TextGridRow, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Rows[i], ok = v.Value.(widget.TextGridRow)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid//rows!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid//rows!")
					}
				}
			case env.Native:
				var ok bool
				self.Rows, ok = v.Value.([]widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid//rows!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid//rows!")
				}
				self.Rows = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "text-grid//rows!")
			}
			return arg0
		},
	},
	"text-grid//rows?": {
		Doc:   "Get widget.TextGrid Rows value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//rows?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//rows?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Rows))
				for i, it := range self.Rows {
					items[i] = *env.NewNative(ps.Idx, it, "text-grid-row")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"text-grid//show-line-numbers!": {
		Doc:   "Set widget.TextGrid ShowLineNumbers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//show-line-numbers!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//show-line-numbers!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowLineNumbers = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "text-grid//show-line-numbers!")
			}
			return arg0
		},
	},
	"text-grid//show-line-numbers?": {
		Doc:   "Get widget.TextGrid ShowLineNumbers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//show-line-numbers?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//show-line-numbers?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowLineNumbers))
			return resObj
		},
	},
	"text-grid//show-whitespace!": {
		Doc:   "Set widget.TextGrid ShowWhitespace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//show-whitespace!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//show-whitespace!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowWhitespace = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "text-grid//show-whitespace!")
			}
			return arg0
		},
	},
	"text-grid//show-whitespace?": {
		Doc:   "Get widget.TextGrid ShowWhitespace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//show-whitespace?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//show-whitespace?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowWhitespace))
			return resObj
		},
	},
	"text-grid//tab-width!": {
		Doc:   "Set widget.TextGrid TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//tab-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//tab-width!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "text-grid//tab-width!")
			}
			return arg0
		},
	},
	"text-grid//tab-width?": {
		Doc:   "Get widget.TextGrid TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//tab-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-grid//tab-width?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"text-heading-size": {
		Doc:   "theme.TextHeadingSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextHeadingSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text-italic-font": {
		Doc:   "theme.TextItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"text-monospace-font": {
		Doc:   "theme.TextMonospaceFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextMonospaceFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"text-segment//style!": {
		Doc:   "Set widget.TextSegment Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-segment//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-segment//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-segment//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text-segment//style!")
			}
			return arg0
		},
	},
	"text-segment//style?": {
		Doc:   "Get widget.TextSegment Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-segment//style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-segment//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "rich-text-style")
			return resObj
		},
	},
	"text-segment//text!": {
		Doc:   "Set widget.TextSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-segment//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-segment//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "text-segment//text!")
			}
			return arg0
		},
	},
	"text-segment//text?": {
		Doc:   "Get widget.TextSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-segment//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-segment//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"text-size": {
		Doc:   "theme.TextSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text-style//bold!": {
		Doc:   "Set fyne.TextStyle Bold value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//bold!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//bold!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Bold = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "text-style//bold!")
			}
			return arg0
		},
	},
	"text-style//bold?": {
		Doc:   "Get fyne.TextStyle Bold value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//bold?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//bold?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Bold))
			return resObj
		},
	},
	"text-style//italic!": {
		Doc:   "Set fyne.TextStyle Italic value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//italic!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//italic!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Italic = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "text-style//italic!")
			}
			return arg0
		},
	},
	"text-style//italic?": {
		Doc:   "Get fyne.TextStyle Italic value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//italic?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//italic?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Italic))
			return resObj
		},
	},
	"text-style//monospace!": {
		Doc:   "Set fyne.TextStyle Monospace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//monospace!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//monospace!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Monospace = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "text-style//monospace!")
			}
			return arg0
		},
	},
	"text-style//monospace?": {
		Doc:   "Get fyne.TextStyle Monospace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//monospace?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//monospace?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Monospace))
			return resObj
		},
	},
	"text-style//symbol!": {
		Doc:   "Set fyne.TextStyle Symbol value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//symbol!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//symbol!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Symbol = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "text-style//symbol!")
			}
			return arg0
		},
	},
	"text-style//symbol?": {
		Doc:   "Get fyne.TextStyle Symbol value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//symbol?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//symbol?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Symbol))
			return resObj
		},
	},
	"text-style//tab-width!": {
		Doc:   "Set fyne.TextStyle TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//tab-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//tab-width!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "text-style//tab-width!")
			}
			return arg0
		},
	},
	"text-style//tab-width?": {
		Doc:   "Get fyne.TextStyle TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//tab-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text-style//tab-width?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"text-sub-heading-size": {
		Doc:   "theme.TextSubHeadingSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextSubHeadingSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"text//alignment!": {
		Doc:   "Set canvas.Text Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text//alignment!")
			}
			return arg0
		},
	},
	"text//alignment?": {
		Doc:   "Get canvas.Text Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "text-align")
			return resObj
		},
	},
	"text//color!": {
		Doc:   "Set canvas.Text Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Color, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text//color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text//color!")
			}
			return arg0
		},
	},
	"text//color?": {
		Doc:   "Get canvas.Text Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "color")
			return resObj
		},
	},
	"text//text!": {
		Doc:   "Set canvas.Text Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "text//text!")
			}
			return arg0
		},
	},
	"text//text-size!": {
		Doc:   "Set canvas.Text TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text-size!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text-size!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.TextSize = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "text//text-size!")
			}
			return arg0
		},
	},
	"text//text-size?": {
		Doc:   "Get canvas.Text TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text-size?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text-size?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.TextSize))
			return resObj
		},
	},
	"text//text-style!": {
		Doc:   "Set canvas.Text TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "text//text-style!")
			}
			return arg0
		},
	},
	"text//text-style?": {
		Doc:   "Get canvas.Text TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "text-style")
			return resObj
		},
	},
	"text//text?": {
		Doc:   "Get canvas.Text Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "text//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"theme//color": {
		Doc:   "fyne.Theme.Color",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//color")
			}
			var arg1Val fyne.ThemeColorName
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme//color")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme//color")
			}
			var arg2Val fyne.ThemeVariant
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.ThemeVariant)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "theme//color")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "theme//color")
			}
			res0 := arg0Val.Color(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"theme//font": {
		Doc:   "fyne.Theme.Font",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//font")
			}
			var arg1Val fyne.TextStyle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme//font")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme//font")
			}
			res0 := arg0Val.Font(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"theme//icon": {
		Doc:   "fyne.Theme.Icon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//icon")
			}
			var arg1Val fyne.ThemeIconName
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.ThemeIconName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme//icon")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme//icon")
			}
			res0 := arg0Val.Icon(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"theme//size": {
		Doc:   "fyne.Theme.Size",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme//size")
			}
			var arg1Val fyne.ThemeSizeName
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.ThemeSizeName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme//size")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme//size")
			}
			res0 := arg0Val.Size(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"themed-resource": {
		Doc:   "theme.NewThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "themed-resource")
			}
			res0 := theme.NewThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-themed-resource")
			return res0Obj
		},
	},
	"themed-resource//color-name!": {
		Doc:   "Set theme.ThemedResource ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "themed-resource//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "themed-resource//color-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorName, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "themed-resource//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "themed-resource//color-name!")
			}
			return arg0
		},
	},
	"themed-resource//color-name?": {
		Doc:   "Get theme.ThemedResource ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "themed-resource//color-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "themed-resource//color-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorName, "theme-color-name")
			return resObj
		},
	},
	"time": {
		Doc:   "validation.NewTime",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "time")
			}
			res0 := validation.NewTime(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-validator")
			return res0Obj
		},
	},
	"toolbar": {
		Doc:   "widget.NewToolbar",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []widget.ToolbarItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]widget.ToolbarItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(widget.ToolbarItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "toolbar")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "toolbar")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "toolbar")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "toolbar")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "toolbar")
			}
			res0 := widget.NewToolbar(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-toolbar")
			return res0Obj
		},
	},
	"toolbar-action": {
		Doc:   "widget.NewToolbarAction",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "toolbar-action")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "toolbar-action")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "toolbar-action")
			}
			res0 := widget.NewToolbarAction(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-toolbar-action")
			return res0Obj
		},
	},
	"toolbar-action//icon!": {
		Doc:   "Set widget.ToolbarAction Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action//icon!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "toolbar-action//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "toolbar-action//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "toolbar-action//icon!")
			}
			return arg0
		},
	},
	"toolbar-action//icon?": {
		Doc:   "Get widget.ToolbarAction Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action//icon?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "resource")
			return resObj
		},
	},
	"toolbar-action//on-activated!": {
		Doc:   "Set widget.ToolbarAction OnActivated value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action//on-activated!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action//on-activated!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "toolbar-action//on-activated!")
				}
				self.OnActivated = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "toolbar-action//on-activated!")
				}
				self.OnActivated = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "toolbar-action//on-activated!")
			}
			return arg0
		},
	},
	"toolbar-action//on-activated?": {
		Doc:   "Get widget.ToolbarAction OnActivated value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action//on-activated?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-action//on-activated?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnActivated, "func()")
			return resObj
		},
	},
	"toolbar-item//toolbar-object": {
		Doc:   "widget.ToolbarItem.ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.ToolbarItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-item//toolbar-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-item//toolbar-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar-item//toolbar-object")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"toolbar-separator": {
		Doc:   "widget.NewToolbarSeparator",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewToolbarSeparator()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-toolbar-separator")
			return res0Obj
		},
	},
	"toolbar-spacer": {
		Doc:   "widget.NewToolbarSpacer",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewToolbarSpacer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-toolbar-spacer")
			return res0Obj
		},
	},
	"toolbar//hidden!": {
		Doc:   "Set widget.Toolbar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "toolbar//hidden!")
			}
			return arg0
		},
	},
	"toolbar//hidden?": {
		Doc:   "Get widget.Toolbar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"toolbar//items!": {
		Doc:   "Set widget.Toolbar Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.ToolbarItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.ToolbarItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "toolbar//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "toolbar//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "toolbar//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "toolbar//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "toolbar//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "toolbar//items!")
			}
			return arg0
		},
	},
	"toolbar//items?": {
		Doc:   "Get widget.Toolbar Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "toolbar//items?")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Items))
				for i, it := range self.Items {
					items[i] = *env.NewNative(ps.Idx, it, "toolbar-item")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"touch-event//absolute-position!": {
		Doc:   "Set mobile.TouchEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touch-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touch-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touch-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touch-event//absolute-position!")
			}
			return arg0
		},
	},
	"touch-event//absolute-position?": {
		Doc:   "Get mobile.TouchEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touch-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touch-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "position")
			return resObj
		},
	},
	"touch-event//position!": {
		Doc:   "Set mobile.TouchEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touch-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touch-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touch-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touch-event//position!")
			}
			return arg0
		},
	},
	"touch-event//position?": {
		Doc:   "Get mobile.TouchEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touch-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touch-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "position")
			return resObj
		},
	},
	"touchable//touch-cancel": {
		Doc:   "mobile.Touchable.TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Touchable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Touchable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touchable//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touchable//touch-cancel")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touchable//touch-cancel")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touchable//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touchable//touch-cancel")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touchable//touch-cancel")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"touchable//touch-down": {
		Doc:   "mobile.Touchable.TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Touchable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Touchable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touchable//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touchable//touch-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touchable//touch-down")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touchable//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touchable//touch-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touchable//touch-down")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"touchable//touch-up": {
		Doc:   "mobile.Touchable.TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Touchable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Touchable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touchable//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touchable//touch-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "touchable//touch-up")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touchable//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touchable//touch-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "touchable//touch-up")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"transparent-canvas": {
		Doc:   "software.NewTransparentCanvas",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := software.NewTransparentCanvas()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "windowless-canvas")
			return res0Obj
		},
	},
	"tree": {
		Doc:   "widget.NewTree",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(widget.TreeNodeID) []widget.TreeNodeID
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "tree")
				}
				arg0Val = func(arg0 widget.TreeNodeID) []widget.TreeNodeID {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res []widget.TreeNodeID
					switch v := ps.Res.(type) {
					case env.Block:
						res = make([]widget.TreeNodeID, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								res[i], ok = v.Value.(widget.TreeNodeID)
								if !ok {
									// TODO: Invalid type
								}
							default:
								// TODO: Invalid type
							}
						}
					case env.Native:
						var ok bool
						res, ok = v.Value.([]widget.TreeNodeID)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "tree")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "tree")
			}
			var arg1Val func(widget.TreeNodeID) bool
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree")
				}
				arg1Val = func(arg0 widget.TreeNodeID) bool {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "tree")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree")
			}
			var arg2Val func(bool) fyne.CanvasObject
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "tree")
				}
				arg2Val = func(arg0 bool) fyne.CanvasObject {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "tree")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "tree")
			}
			var arg3Val func(widget.TreeNodeID, bool, fyne.CanvasObject)
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(func(widget.TreeNodeID, bool, fyne.CanvasObject))
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "tree")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "tree")
			}
			res0 := widget.NewTree(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-tree")
			return res0Obj
		},
	},
	"tree-with-data": {
		Doc:   "widget.NewTreeWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree-with-data")
			}
			var arg1Val func(bool) fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree-with-data")
				}
				arg1Val = func(arg0 bool) fyne.CanvasObject {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "tree-with-data")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree-with-data")
			}
			var arg2Val func(binding.DataItem, bool, fyne.CanvasObject)
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(func(binding.DataItem, bool, fyne.CanvasObject))
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "tree-with-data")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "tree-with-data")
			}
			res0 := widget.NewTreeWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-tree")
			return res0Obj
		},
	},
	"tree-with-strings": {
		Doc:   "widget.NewTreeWithStrings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val map[string][]string
			switch v := arg0.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
				}
				arg0Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
					}
					arg0Val[mapK] = mapV
				}
			case env.Dict:
				arg0Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
					}
					arg0Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType, env.DictType}, "tree-with-strings")
			}
			res0 := widget.NewTreeWithStrings(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-tree")
			return res0Obj
		},
	},
	"tree//child-ui-ds!": {
		Doc:   "Set widget.Tree ChildUIDs value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//child-ui-ds!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//child-ui-ds!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//child-ui-ds!")
				}
				self.ChildUIDs = func(arg0 widget.TreeNodeID) []widget.TreeNodeID {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res []widget.TreeNodeID
					switch v := ps.Res.(type) {
					case env.Block:
						res = make([]widget.TreeNodeID, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								res[i], ok = v.Value.(widget.TreeNodeID)
								if !ok {
									// TODO: Invalid type
								}
							default:
								// TODO: Invalid type
							}
						}
					case env.Native:
						var ok bool
						res, ok = v.Value.([]widget.TreeNodeID)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "tree//child-ui-ds!")
				}
				self.ChildUIDs = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//child-ui-ds!")
			}
			return arg0
		},
	},
	"tree//child-ui-ds?": {
		Doc:   "Get widget.Tree ChildUIDs value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//child-ui-ds?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//child-ui-ds?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildUIDs, "func(tree-node-id)_(arr-tree-node-id)")
			return resObj
		},
	},
	"tree//create-node!": {
		Doc:   "Set widget.Tree CreateNode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//create-node!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//create-node!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//create-node!")
				}
				self.CreateNode = func(arg0 bool) fyne.CanvasObject {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "tree//create-node!")
				}
				self.CreateNode = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//create-node!")
			}
			return arg0
		},
	},
	"tree//create-node?": {
		Doc:   "Get widget.Tree CreateNode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//create-node?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//create-node?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateNode, "func(bool)_(canvas-object)")
			return resObj
		},
	},
	"tree//hidden!": {
		Doc:   "Set widget.Tree Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "tree//hidden!")
			}
			return arg0
		},
	},
	"tree//hidden?": {
		Doc:   "Get widget.Tree Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"tree//is-branch!": {
		Doc:   "Set widget.Tree IsBranch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//is-branch!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//is-branch!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//is-branch!")
				}
				self.IsBranch = func(arg0 widget.TreeNodeID) bool {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
					var res bool
					if v, ok := ps.Res.(env.Integer); ok {
						res = v.Value != 0
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "tree//is-branch!")
				}
				self.IsBranch = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//is-branch!")
			}
			return arg0
		},
	},
	"tree//is-branch?": {
		Doc:   "Get widget.Tree IsBranch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//is-branch?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//is-branch?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.IsBranch, "func(tree-node-id)_(bool)")
			return resObj
		},
	},
	"tree//on-branch-closed!": {
		Doc:   "Set widget.Tree OnBranchClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-branch-closed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-branch-closed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//on-branch-closed!")
				}
				self.OnBranchClosed = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "tree//on-branch-closed!")
				}
				self.OnBranchClosed = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//on-branch-closed!")
			}
			return arg0
		},
	},
	"tree//on-branch-closed?": {
		Doc:   "Get widget.Tree OnBranchClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-branch-closed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-branch-closed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnBranchClosed, "func(tree-node-id)")
			return resObj
		},
	},
	"tree//on-branch-opened!": {
		Doc:   "Set widget.Tree OnBranchOpened value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-branch-opened!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-branch-opened!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//on-branch-opened!")
				}
				self.OnBranchOpened = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "tree//on-branch-opened!")
				}
				self.OnBranchOpened = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//on-branch-opened!")
			}
			return arg0
		},
	},
	"tree//on-branch-opened?": {
		Doc:   "Get widget.Tree OnBranchOpened value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-branch-opened?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-branch-opened?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnBranchOpened, "func(tree-node-id)")
			return resObj
		},
	},
	"tree//on-selected!": {
		Doc:   "Set widget.Tree OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//on-selected!")
				}
				self.OnSelected = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "tree//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//on-selected!")
			}
			return arg0
		},
	},
	"tree//on-selected?": {
		Doc:   "Get widget.Tree OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "func(tree-node-id)")
			return resObj
		},
	},
	"tree//on-unselected!": {
		Doc:   "Set widget.Tree OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-unselected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.TreeNodeID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "tree-node-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "tree//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "tree//on-unselected!")
			}
			return arg0
		},
	},
	"tree//on-unselected?": {
		Doc:   "Get widget.Tree OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-unselected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "func(tree-node-id)")
			return resObj
		},
	},
	"tree//root!": {
		Doc:   "Set widget.Tree Root value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//root!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//root!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Root, ok = v.Value.(widget.TreeNodeID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tree//root!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tree//root!")
			}
			return arg0
		},
	},
	"tree//root?": {
		Doc:   "Get widget.Tree Root value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//root?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//root?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Root, "tree-node-id")
			return resObj
		},
	},
	"tree//update-node!": {
		Doc:   "Set widget.Tree UpdateNode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//update-node!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//update-node!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.UpdateNode, ok = v.Value.(func(widget.TreeNodeID, bool, fyne.CanvasObject))
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tree//update-node!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "tree//update-node!")
			}
			return arg0
		},
	},
	"tree//update-node?": {
		Doc:   "Get widget.Tree UpdateNode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Tree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Tree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//update-node?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "tree//update-node?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateNode, "func(tree-node-id_bool_canvas-object)")
			return resObj
		},
	},
	"untyped": {
		Doc:   "binding.NewUntyped",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewUntyped()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "untyped")
			return res0Obj
		},
	},
	"untyped-list": {
		Doc:   "binding.NewUntypedList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewUntypedList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "untyped-list")
			return res0Obj
		},
	},
	"untyped-map": {
		Doc:   "binding.NewUntypedMap",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewUntypedMap()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "untyped-map")
			return res0Obj
		},
	},
	"untyped-map//delete": {
		Doc:   "binding.UntypedMap.Delete",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedMap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "untyped-map//delete")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "untyped-map//delete")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "untyped-map//delete")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "untyped-map//delete")
			}
			arg0Val.Delete(arg1Val)
			return arg0
		},
	},
	"upload-icon": {
		Doc:   "theme.UploadIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.UploadIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"uri": {
		Doc:   "storage.NewURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "uri")
			}
			res0 := storage.NewURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			return res0Obj
		},
	},
	"uri-to-string": {
		Doc:   "binding.URIToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-to-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-to-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-to-string")
			}
			res0 := binding.URIToString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string")
			return res0Obj
		},
	},
	"uri-tree": {
		Doc:   "binding.NewURITree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewURITree()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-tree")
			return res0Obj
		},
	},
	"uri-tree//append": {
		Doc:   "binding.URITree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "uri-tree//append")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "uri-tree//append")
			}
			var arg3Val fyne.URI
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "uri-tree//append")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "uri-tree//append")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"uri-tree//get": {
		Doc:   "binding.URITree.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//get")
			}
			res0, res1, res2 := arg0Val.Get()
			var res0Obj env.Object
			{
				data := make(map[string]any, len(res0))
				for mKey, mVal := range res0 {
					var dVal env.Object
					{
						items := make([]env.Object, len(mVal))
						for i, it := range mVal {
							items[i] = *env.NewString(it)
						}
						dVal = *env.NewBlock(*env.NewTSeries(items))
					}
					data[mKey] = dVal
				}
				res0Obj = *env.NewDict(data)
			}
			var res1Obj env.Object
			{
				data := make(map[string]any, len(res1))
				for mKey, mVal := range res1 {
					var dVal env.Object
					dVal = *env.NewNative(ps.Idx, mVal, "uri")
					data[mKey] = dVal
				}
				res1Obj = *env.NewDict(data)
			}
			var res2Obj env.Object
			res2Obj = *env.NewError(res2.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"2":   res1Obj,
				"err": res2Obj,
			})
		},
	},
	"uri-tree//get-value": {
		Doc:   "binding.URITree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//get-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "uri-tree//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"uri-tree//prepend": {
		Doc:   "binding.URITree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "uri-tree//prepend")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "uri-tree//prepend")
			}
			var arg3Val fyne.URI
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "uri-tree//prepend")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "uri-tree//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"uri-tree//set": {
		Doc:   "binding.URITree.Set",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//set")
			}
			var arg1Val map[string][]string
			switch v := arg1.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
				}
				arg1Val = make(map[string][]string, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
					}
					var mapV []string
					switch v := v.Series.S[i+1].(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Dict:
				arg1Val = make(map[string][]string, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV []string
					switch v := dictV.(type) {
					case env.Block:
						mapV = make([]string, len(v.Series.S))
						for i, it := range v.Series.S {
							if v, ok := it.(env.String); ok {
								mapV[i] = string(v.Value)
							} else {
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
							}
						}
					case env.Native:
						var ok bool
						mapV, ok = v.Value.([]string)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
						}
						mapV = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
					}
					arg1Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(map[string][]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
			}
			var arg2Val map[string]fyne.URI
			switch v := arg2.(type) {
			case env.Block:
				if len(v.Series.S)%2 != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
				}
				arg2Val = make(map[string]fyne.URI, len(v.Series.S)/2)
				for i := 0; i < len(v.Series.S); i += 2 {
					var mapK string
					if v, ok := v.Series.S[i+0].(env.String); ok {
						mapK = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
					}
					var mapV fyne.URI
					switch v := v.Series.S[i+1].(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(fyne.URI)
						if !ok {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
						}
					default:
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Dict:
				arg2Val = make(map[string]fyne.URI, len(v.Data))
				for dictK, dictV := range v.Data {
					mapK := dictK
					var mapV fyne.URI
					switch v := dictV.(type) {
					case env.Native:
						var ok bool
						mapV, ok = v.Value.(fyne.URI)
						if !ok {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
						}
					default:
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
					}
					arg2Val[mapK] = mapV
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(map[string]fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType, env.DictType}, "uri-tree//set")
			}
			res0 := arg0Val.Set(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"uri-tree//set-value": {
		Doc:   "binding.URITree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URITree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URITree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri-tree//set-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "uri-tree//set-value")
			}
			var arg2Val fyne.URI
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "uri-tree//set-value")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "uri-tree//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"uri//get": {
		Doc:   "binding.URI.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"uri//set": {
		Doc:   "binding.URI.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "uri//set")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "uri//set")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "uri//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"v-box": {
		Doc:   "container.NewVBox",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "v-box")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "v-box")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "v-box")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "v-box")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "v-box")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "v-box")
			}
			res0 := container.NewVBox(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"v-box-layout": {
		Doc:   "layout.NewVBoxLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewVBoxLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "layout")
			return res0Obj
		},
	},
	"v-scroll": {
		Doc:   "container.NewVScroll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "v-scroll")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "v-scroll")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "v-scroll")
			}
			res0 := container.NewVScroll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-scroll")
			return res0Obj
		},
	},
	"v-split": {
		Doc:   "container.NewVSplit",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "v-split")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "v-split")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "v-split")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "v-split")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "v-split")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "v-split")
			}
			res0 := container.NewVSplit(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-split")
			return res0Obj
		},
	},
	"validatable//set-on-validation-changed": {
		Doc:   "fyne.Validatable.SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Validatable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Validatable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "validatable//set-on-validation-changed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "validatable//set-on-validation-changed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "validatable//set-on-validation-changed")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "validatable//set-on-validation-changed")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "validatable//set-on-validation-changed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "validatable//set-on-validation-changed")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"validatable//validate": {
		Doc:   "fyne.Validatable.Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Validatable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Validatable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "validatable//validate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "validatable//validate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "validatable//validate")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"vector-2//components": {
		Doc:   "fyne.Vector2.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Vector2
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "vector-2//components")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "vector-2//components")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "vector-2//components")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"vector-2//is-zero": {
		Doc:   "fyne.Vector2.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Vector2
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "vector-2//is-zero")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "vector-2//is-zero")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "vector-2//is-zero")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"vertical-gradient": {
		Doc:   "canvas.NewVerticalGradient",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "vertical-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "vertical-gradient")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "vertical-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "vertical-gradient")
			}
			res0 := canvas.NewVerticalGradient(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-linear-gradient")
			return res0Obj
		},
	},
	"view-full-screen-icon": {
		Doc:   "theme.ViewFullScreenIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ViewFullScreenIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"view-refresh-icon": {
		Doc:   "theme.ViewRefreshIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ViewRefreshIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"view-restore-icon": {
		Doc:   "theme.ViewRestoreIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ViewRestoreIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"visibility-icon": {
		Doc:   "theme.VisibilityIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VisibilityIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"visibility-off-icon": {
		Doc:   "theme.VisibilityOffIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VisibilityOffIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"volume-down-icon": {
		Doc:   "theme.VolumeDownIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VolumeDownIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"volume-mute-icon": {
		Doc:   "theme.VolumeMuteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VolumeMuteIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"volume-up-icon": {
		Doc:   "theme.VolumeUpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VolumeUpIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"warning-color": {
		Doc:   "theme.WarningColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.WarningColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color")
			return res0Obj
		},
	},
	"warning-icon": {
		Doc:   "theme.WarningIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.WarningIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"warning-themed-resource": {
		Doc:   "theme.NewWarningThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "warning-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "warning-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "warning-themed-resource")
			}
			res0 := theme.NewWarningThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-themed-resource")
			return res0Obj
		},
	},
	"widget-renderer//destroy": {
		Doc:   "fyne.WidgetRenderer.Destroy",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//destroy")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//destroy")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//destroy")
			}
			arg0Val.Destroy()
			return arg0
		},
	},
	"widget-renderer//layout": {
		Doc:   "fyne.WidgetRenderer.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//layout")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-renderer//layout")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-renderer//layout")
			}
			arg0Val.Layout(arg1Val)
			return arg0
		},
	},
	"widget-renderer//min-size": {
		Doc:   "fyne.WidgetRenderer.MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "size")
			return res0Obj
		},
	},
	"widget-renderer//objects": {
		Doc:   "fyne.WidgetRenderer.Objects",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//objects")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//objects")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//objects")
			}
			res0 := arg0Val.Objects()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "canvas-object")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"widget-renderer//refresh": {
		Doc:   "fyne.WidgetRenderer.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-renderer//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"widget//create-renderer": {
		Doc:   "fyne.Widget.CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Widget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-renderer")
			return res0Obj
		},
	},
	"window//canvas": {
		Doc:   "fyne.Window.Canvas",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//canvas")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//canvas")
			}
			res0 := arg0Val.Canvas()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas")
			return res0Obj
		},
	},
	"window//center-on-screen": {
		Doc:   "fyne.Window.CenterOnScreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//center-on-screen")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//center-on-screen")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//center-on-screen")
			}
			arg0Val.CenterOnScreen()
			return arg0
		},
	},
	"window//clipboard": {
		Doc:   "fyne.Window.Clipboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//clipboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//clipboard")
			}
			res0 := arg0Val.Clipboard()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "clipboard")
			return res0Obj
		},
	},
	"window//close": {
		Doc:   "fyne.Window.Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//close")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//close")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//close")
			}
			arg0Val.Close()
			return arg0
		},
	},
	"window//content": {
		Doc:   "fyne.Window.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-object")
			return res0Obj
		},
	},
	"window//fixed-size": {
		Doc:   "fyne.Window.FixedSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//fixed-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//fixed-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//fixed-size")
			}
			res0 := arg0Val.FixedSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"window//full-screen": {
		Doc:   "fyne.Window.FullScreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//full-screen")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//full-screen")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//full-screen")
			}
			res0 := arg0Val.FullScreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"window//hide": {
		Doc:   "fyne.Window.Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"window//icon": {
		Doc:   "fyne.Window.Icon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//icon")
			}
			res0 := arg0Val.Icon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"window//main-menu": {
		Doc:   "fyne.Window.MainMenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//main-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//main-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//main-menu")
			}
			res0 := arg0Val.MainMenu()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-main-menu")
			return res0Obj
		},
	},
	"window//padded": {
		Doc:   "fyne.Window.Padded",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//padded")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//padded")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//padded")
			}
			res0 := arg0Val.Padded()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"window//request-focus": {
		Doc:   "fyne.Window.RequestFocus",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//request-focus")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//request-focus")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//request-focus")
			}
			arg0Val.RequestFocus()
			return arg0
		},
	},
	"window//resize": {
		Doc:   "fyne.Window.Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"window//set-close-intercept": {
		Doc:   "fyne.Window.SetCloseIntercept",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-close-intercept")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-close-intercept")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-close-intercept")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "window//set-close-intercept")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "window//set-close-intercept")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "window//set-close-intercept")
			}
			arg0Val.SetCloseIntercept(arg1Val)
			return arg0
		},
	},
	"window//set-content": {
		Doc:   "fyne.Window.SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-content")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//set-content")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//set-content")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"window//set-fixed-size": {
		Doc:   "fyne.Window.SetFixedSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-fixed-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-fixed-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-fixed-size")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "window//set-fixed-size")
			}
			arg0Val.SetFixedSize(arg1Val)
			return arg0
		},
	},
	"window//set-full-screen": {
		Doc:   "fyne.Window.SetFullScreen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-full-screen")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-full-screen")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-full-screen")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "window//set-full-screen")
			}
			arg0Val.SetFullScreen(arg1Val)
			return arg0
		},
	},
	"window//set-icon": {
		Doc:   "fyne.Window.SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//set-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//set-icon")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"window//set-main-menu": {
		Doc:   "fyne.Window.SetMainMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-main-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-main-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-main-menu")
			}
			var arg1Val *fyne.MainMenu
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//set-main-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//set-main-menu")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "window//set-main-menu")
			}
			arg0Val.SetMainMenu(arg1Val)
			return arg0
		},
	},
	"window//set-master": {
		Doc:   "fyne.Window.SetMaster",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-master")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-master")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-master")
			}
			arg0Val.SetMaster()
			return arg0
		},
	},
	"window//set-on-closed": {
		Doc:   "fyne.Window.SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-on-closed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-on-closed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-on-closed")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "window//set-on-closed")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "window//set-on-closed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "window//set-on-closed")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"window//set-on-dropped": {
		Doc:   "fyne.Window.SetOnDropped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-on-dropped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-on-dropped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-on-dropped")
			}
			var arg1Val func(fyne.Position, []fyne.URI)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "window//set-on-dropped")
				}
				arg1Val = func(arg0 fyne.Position, arg1 []fyne.URI) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "position")
					{
						items := make([]env.Object, len(arg1))
						for i, it := range arg1 {
							items[i] = *env.NewNative(ps.Idx, it, "uri")
						}
						arg1Val = *env.NewBlock(*env.NewTSeries(items))
					}
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "window//set-on-dropped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "window//set-on-dropped")
			}
			arg0Val.SetOnDropped(arg1Val)
			return arg0
		},
	},
	"window//set-padded": {
		Doc:   "fyne.Window.SetPadded",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-padded")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-padded")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-padded")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "window//set-padded")
			}
			arg0Val.SetPadded(arg1Val)
			return arg0
		},
	},
	"window//set-title": {
		Doc:   "fyne.Window.SetTitle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-title")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-title")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//set-title")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "window//set-title")
			}
			arg0Val.SetTitle(arg1Val)
			return arg0
		},
	},
	"window//show": {
		Doc:   "fyne.Window.Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"window//show-and-run": {
		Doc:   "fyne.Window.ShowAndRun",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//show-and-run")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//show-and-run")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//show-and-run")
			}
			arg0Val.ShowAndRun()
			return arg0
		},
	},
	"window//title": {
		Doc:   "fyne.Window.Title",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//title")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//title")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "window//title")
			}
			res0 := arg0Val.Title()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"with-id": {
		Doc:   "app.NewWithID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "with-id")
			}
			res0 := app.NewWithID(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "app")
			return res0Obj
		},
	},
	"without-layout": {
		Doc:   "container.NewWithoutLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "without-layout")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "without-layout")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "without-layout")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "without-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "without-layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "without-layout")
			}
			res0 := container.NewWithoutLayout(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "ptr-container")
			return res0Obj
		},
	},
	"writable-repository//can-write": {
		Doc:   "repository.WritableRepository.CanWrite",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.WritableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.WritableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writable-repository//can-write")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writable-repository//can-write")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writable-repository//can-write")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "writable-repository//can-write")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "writable-repository//can-write")
			}
			res0, res1 := arg0Val.CanWrite(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"writable-repository//delete": {
		Doc:   "repository.WritableRepository.Delete",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.WritableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.WritableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writable-repository//delete")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writable-repository//delete")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writable-repository//delete")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "writable-repository//delete")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "writable-repository//delete")
			}
			res0 := arg0Val.Delete(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"writable-repository//writer": {
		Doc:   "repository.WritableRepository.Writer",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.WritableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.WritableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writable-repository//writer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writable-repository//writer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writable-repository//writer")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "writable-repository//writer")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "writable-repository//writer")
			}
			res0, res1 := arg0Val.Writer(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"writer": {
		Doc:   "storage.Writer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writer")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "writer")
			}
			res0, res1 := storage.Writer(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"zoom-fit-icon": {
		Doc:   "theme.ZoomFitIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ZoomFitIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"zoom-in-icon": {
		Doc:   "theme.ZoomInIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ZoomInIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
	"zoom-out-icon": {
		Doc:   "theme.ZoomOutIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ZoomOutIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "resource")
			return res0Obj
		},
	},
}
