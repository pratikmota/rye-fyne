//go:build b_fynegen

// Code generated by generator/generate. DO NOT EDIT.

package fynegen

import (
	"errors"
	"image"
	"image/color"
	"io"
	"net/url"
	"time"

	"github.com/refaktor/rye/env"
	"github.com/refaktor/rye/evaldo"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/data/binding"
	"fyne.io/fyne/v2/data/validation"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/driver"
	"fyne.io/fyne/v2/driver/desktop"
	"fyne.io/fyne/v2/driver/mobile"
	"fyne.io/fyne/v2/driver/software"
	"fyne.io/fyne/v2/layout"
	"fyne.io/fyne/v2/storage"
	"fyne.io/fyne/v2/storage/repository"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/tools/playground"
	"fyne.io/fyne/v2/widget"
)

func boolToInt64(x bool) int64 {
	var res int64
	if x {
		res = 1
	}
	return res
}

var Builtins_fynegen = map[string]*env.Builtin{
	"app": {
		Doc:   "app.New",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := app.New()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-app")
			return res0Obj
		},
	},
	"app-set-metadata": {
		Doc:   "app.SetMetadata",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.AppMetadata
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.AppMetadata)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-set-metadata")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-set-metadata")
			}
			app.SetMetadata(arg0Val)
			return nil
		},
	},
	"app-settings-schema-ptr//cloud-config!": {
		Doc:   "Set *app.SettingsSchema CloudConfig value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-config!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-config!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-config!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudConfig = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-settings-schema-ptr//cloud-config!")
			}
			return arg0
		},
	},
	"app-settings-schema-ptr//cloud-config?": {
		Doc:   "Get *app.SettingsSchema CloudConfig value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-config?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-config?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-config?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudConfig)
			return resObj
		},
	},
	"app-settings-schema-ptr//cloud-name!": {
		Doc:   "Set *app.SettingsSchema CloudName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-settings-schema-ptr//cloud-name!")
			}
			return arg0
		},
	},
	"app-settings-schema-ptr//cloud-name?": {
		Doc:   "Get *app.SettingsSchema CloudName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//cloud-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudName)
			return resObj
		},
	},
	"app-settings-schema-ptr//disable-animations!": {
		Doc:   "Set *app.SettingsSchema DisableAnimations value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//disable-animations!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//disable-animations!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//disable-animations!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.DisableAnimations = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "app-settings-schema-ptr//disable-animations!")
			}
			return arg0
		},
	},
	"app-settings-schema-ptr//disable-animations?": {
		Doc:   "Get *app.SettingsSchema DisableAnimations value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//disable-animations?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//disable-animations?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//disable-animations?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.DisableAnimations))
			return resObj
		},
	},
	"app-settings-schema-ptr//primary-color!": {
		Doc:   "Set *app.SettingsSchema PrimaryColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//primary-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//primary-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//primary-color!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PrimaryColor = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-settings-schema-ptr//primary-color!")
			}
			return arg0
		},
	},
	"app-settings-schema-ptr//primary-color?": {
		Doc:   "Get *app.SettingsSchema PrimaryColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//primary-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//primary-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//primary-color?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PrimaryColor)
			return resObj
		},
	},
	"app-settings-schema-ptr//scale!": {
		Doc:   "Set *app.SettingsSchema Scale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//scale!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//scale!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//scale!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Scale = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "app-settings-schema-ptr//scale!")
			}
			return arg0
		},
	},
	"app-settings-schema-ptr//scale?": {
		Doc:   "Get *app.SettingsSchema Scale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//scale?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//scale?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//scale?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Scale))
			return resObj
		},
	},
	"app-settings-schema-ptr//storage-path": {
		Doc:   "(*app.SettingsSchema).StoragePath",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//storage-path")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//storage-path")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//storage-path")
			}
			res0 := arg0Val.StoragePath()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"app-settings-schema-ptr//theme-name!": {
		Doc:   "Set *app.SettingsSchema ThemeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//theme-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//theme-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//theme-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.ThemeName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-settings-schema-ptr//theme-name!")
			}
			return arg0
		},
	},
	"app-settings-schema-ptr//theme-name?": {
		Doc:   "Get *app.SettingsSchema ThemeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//theme-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//theme-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema-ptr//theme-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ThemeName)
			return resObj
		},
	},
	"app-settings-schema//cloud-config!": {
		Doc:   "Set app.SettingsSchema CloudConfig value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//cloud-config!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//cloud-config!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudConfig = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-settings-schema//cloud-config!")
			}
			return arg0
		},
	},
	"app-settings-schema//cloud-config?": {
		Doc:   "Get app.SettingsSchema CloudConfig value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//cloud-config?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//cloud-config?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudConfig)
			return resObj
		},
	},
	"app-settings-schema//cloud-name!": {
		Doc:   "Set app.SettingsSchema CloudName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//cloud-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//cloud-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CloudName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-settings-schema//cloud-name!")
			}
			return arg0
		},
	},
	"app-settings-schema//cloud-name?": {
		Doc:   "Get app.SettingsSchema CloudName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//cloud-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//cloud-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CloudName)
			return resObj
		},
	},
	"app-settings-schema//disable-animations!": {
		Doc:   "Set app.SettingsSchema DisableAnimations value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//disable-animations!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//disable-animations!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.DisableAnimations = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "app-settings-schema//disable-animations!")
			}
			return arg0
		},
	},
	"app-settings-schema//disable-animations?": {
		Doc:   "Get app.SettingsSchema DisableAnimations value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//disable-animations?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//disable-animations?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.DisableAnimations))
			return resObj
		},
	},
	"app-settings-schema//primary-color!": {
		Doc:   "Set app.SettingsSchema PrimaryColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//primary-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//primary-color!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PrimaryColor = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-settings-schema//primary-color!")
			}
			return arg0
		},
	},
	"app-settings-schema//primary-color?": {
		Doc:   "Get app.SettingsSchema PrimaryColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//primary-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//primary-color?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PrimaryColor)
			return resObj
		},
	},
	"app-settings-schema//scale!": {
		Doc:   "Set app.SettingsSchema Scale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//scale!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//scale!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Scale = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "app-settings-schema//scale!")
			}
			return arg0
		},
	},
	"app-settings-schema//scale?": {
		Doc:   "Get app.SettingsSchema Scale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//scale?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//scale?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Scale))
			return resObj
		},
	},
	"app-settings-schema//theme-name!": {
		Doc:   "Set app.SettingsSchema ThemeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//theme-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//theme-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.ThemeName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "app-settings-schema//theme-name!")
			}
			return arg0
		},
	},
	"app-settings-schema//theme-name?": {
		Doc:   "Get app.SettingsSchema ThemeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self app.SettingsSchema
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(app.SettingsSchema)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//theme-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "app-settings-schema//theme-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.ThemeName)
			return resObj
		},
	},
	"app-with-id": {
		Doc:   "app.NewWithID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "app-with-id")
			}
			res0 := app.NewWithID(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-app")
			return res0Obj
		},
	},
	"binding-and": {
		Doc:   "binding.And",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []binding.Bool
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]binding.Bool, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(binding.Bool)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-and")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-and")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-and")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-and")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-and")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-and")
			}
			res0 := binding.And(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
			return res0Obj
		},
	},
	"binding-bind-bool": {
		Doc:   "binding.BindBool",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bool")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bool")
			}
			res0 := binding.BindBool(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bool")
			return res0Obj
		},
	},
	"binding-bind-bool-list": {
		Doc:   "binding.BindBoolList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bool-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bool-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bool-list")
			}
			res0 := binding.BindBoolList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bool-list")
			return res0Obj
		},
	},
	"binding-bind-bytes": {
		Doc:   "binding.BindBytes",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]byte
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bytes")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bytes")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bytes")
			}
			res0 := binding.BindBytes(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bytes")
			return res0Obj
		},
	},
	"binding-bind-bytes-list": {
		Doc:   "binding.BindBytesList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[][]byte
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[][]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bytes-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bytes-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-bytes-list")
			}
			res0 := binding.BindBytesList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-bytes-list")
			return res0Obj
		},
	},
	"binding-bind-float": {
		Doc:   "binding.BindFloat",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *float64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*float64)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-float")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-float")
			}
			res0 := binding.BindFloat(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-float")
			return res0Obj
		},
	},
	"binding-bind-float-list": {
		Doc:   "binding.BindFloatList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]float64
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-float-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-float-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-float-list")
			}
			res0 := binding.BindFloatList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-float-list")
			return res0Obj
		},
	},
	"binding-bind-int": {
		Doc:   "binding.BindInt",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-int")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-int")
			}
			res0 := binding.BindInt(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-int")
			return res0Obj
		},
	},
	"binding-bind-int-list": {
		Doc:   "binding.BindIntList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-int-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-int-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-int-list")
			}
			res0 := binding.BindIntList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-int-list")
			return res0Obj
		},
	},
	"binding-bind-preference-bool": {
		Doc:   "binding.BindPreferenceBool",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "binding-bind-preference-bool")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-bool")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-bool")
			}
			res0 := binding.BindPreferenceBool(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
			return res0Obj
		},
	},
	"binding-bind-preference-float": {
		Doc:   "binding.BindPreferenceFloat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "binding-bind-preference-float")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-float")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-float")
			}
			res0 := binding.BindPreferenceFloat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-float")
			return res0Obj
		},
	},
	"binding-bind-preference-int": {
		Doc:   "binding.BindPreferenceInt",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "binding-bind-preference-int")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-int")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-int")
			}
			res0 := binding.BindPreferenceInt(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-int")
			return res0Obj
		},
	},
	"binding-bind-preference-string": {
		Doc:   "binding.BindPreferenceString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "binding-bind-preference-string")
			}
			var arg1Val fyne.Preferences
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-string")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-bind-preference-string")
			}
			res0 := binding.BindPreferenceString(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-bind-rune": {
		Doc:   "binding.BindRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*rune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-rune")
			}
			res0 := binding.BindRune(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-rune")
			return res0Obj
		},
	},
	"binding-bind-rune-list": {
		Doc:   "binding.BindRuneList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]rune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-rune-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-rune-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-rune-list")
			}
			res0 := binding.BindRuneList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-rune-list")
			return res0Obj
		},
	},
	"binding-bind-string": {
		Doc:   "binding.BindString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-string")
			}
			res0 := binding.BindString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-string")
			return res0Obj
		},
	},
	"binding-bind-string-list": {
		Doc:   "binding.BindStringList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *[]string
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*[]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-string-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-string-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-string-list")
			}
			res0 := binding.BindStringList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-string-list")
			return res0Obj
		},
	},
	"binding-bind-uri": {
		Doc:   "binding.BindURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bind-uri")
			}
			res0 := binding.BindURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-external-uri")
			return res0Obj
		},
	},
	"binding-bool": {
		Doc:   "binding.NewBool",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBool()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
			return res0Obj
		},
	},
	"binding-bool-list": {
		Doc:   "binding.NewBoolList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBoolList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool-list")
			return res0Obj
		},
	},
	"binding-bool-list//append": {
		Doc:   "binding.BoolList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//append")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-bool-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-list//get": {
		Doc:   "binding.BoolList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bool-list//get-value": {
		Doc:   "binding.BoolList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-bool-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bool-list//prepend": {
		Doc:   "binding.BoolList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//prepend")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-bool-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-list//set": {
		Doc:   "binding.BoolList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//set")
			}
			var arg1Val []bool
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]bool, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg1Val[i] = v.Value != 0
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bool-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bool-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bool-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bool-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-list//set-value": {
		Doc:   "binding.BoolList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-bool-list//set-value")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "binding-bool-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-to-string": {
		Doc:   "binding.BoolToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-to-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-to-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-to-string")
			}
			res0 := binding.BoolToString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-bool-to-string-with-format": {
		Doc:   "binding.BoolToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-to-string-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-to-string-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-to-string-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-bool-to-string-with-format")
			}
			res0 := binding.BoolToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-bool-tree": {
		Doc:   "binding.NewBoolTree",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBoolTree()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool-tree")
			return res0Obj
		},
	},
	"binding-bool-tree//append": {
		Doc:   "binding.BoolTree.Append",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-bool-tree//append")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "binding-bool-tree//append")
			}
			var arg3Val bool
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.IntegerType}, "binding-bool-tree//append")
			}
			res0 := arg0Val.Append(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-tree//get-value": {
		Doc:   "binding.BoolTree.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//get-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-bool-tree//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bool-tree//prepend": {
		Doc:   "binding.BoolTree.Prepend",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-bool-tree//prepend")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "binding-bool-tree//prepend")
			}
			var arg3Val bool
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 3, []env.Type{env.IntegerType}, "binding-bool-tree//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool-tree//set-value": {
		Doc:   "binding.BoolTree.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool-tree//set-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-bool-tree//set-value")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "binding-bool-tree//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bool//get": {
		Doc:   "binding.Bool.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bool//set": {
		Doc:   "binding.Bool.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bool//set")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-bool//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes": {
		Doc:   "binding.NewBytes",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBytes()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bytes")
			return res0Obj
		},
	},
	"binding-bytes-list": {
		Doc:   "binding.NewBytesList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewBytesList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bytes-list")
			return res0Obj
		},
	},
	"binding-bytes-list//append": {
		Doc:   "binding.BytesList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//append")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//append")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//append")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-list//get": {
		Doc:   "binding.BytesList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bytes-list//get-value": {
		Doc:   "binding.BytesList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-bytes-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bytes-list//prepend": {
		Doc:   "binding.BytesList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//prepend")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//prepend")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//prepend")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//prepend")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-list//set": {
		Doc:   "binding.BytesList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//set")
			}
			var arg1Val [][]byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([][]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Block:
						arg1Val[i] = make([]byte, len(v.Series.S))
						for i, it := range v.Series.S {
							switch v := it.(type) {
							case env.Native:
								var ok bool
								arg1Val[i][i], ok = v.Value.(byte)
								if !ok {
									return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set")
								}
							default:
								return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set")
							}
						}
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.([]byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([][]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes-list//set-value": {
		Doc:   "binding.BytesList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.BytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.BytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-bytes-list//set-value")
			}
			var arg2Val []byte
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg2Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set-value")
						}
					default:
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set-value")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set-value")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "binding-bytes-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-bytes//get": {
		Doc:   "binding.Bytes.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bytes
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bytes)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-bytes//set": {
		Doc:   "binding.Bytes.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bytes
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bytes)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-bytes//set")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes//set")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-bytes//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-data-item//add-listener": {
		Doc:   "binding.DataItem.AddListener",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-item//add-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-item//add-listener")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-item//add-listener")
			}
			var arg1Val binding.DataListener
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.DataListener)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-data-item//add-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-data-item//add-listener")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-data-item//add-listener")
			}
			arg0Val.AddListener(arg1Val)
			return arg0
		},
	},
	"binding-data-item//remove-listener": {
		Doc:   "binding.DataItem.RemoveListener",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-item//remove-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-item//remove-listener")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-item//remove-listener")
			}
			var arg1Val binding.DataListener
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.DataListener)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-data-item//remove-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-data-item//remove-listener")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-data-item//remove-listener")
			}
			arg0Val.RemoveListener(arg1Val)
			return arg0
		},
	},
	"binding-data-list//get-item": {
		Doc:   "binding.DataList.GetItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-list//get-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-list//get-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-list//get-item")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-data-list//get-item")
			}
			res0, res1 := arg0Val.GetItem(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-data-item")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-data-list//length": {
		Doc:   "binding.DataList.Length",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-list//length")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-list//length")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-list//length")
			}
			res0 := arg0Val.Length()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"binding-data-listener": {
		Doc:   "binding.NewDataListener",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func()
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "binding-data-listener")
				}
				arg0Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-data-listener")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "binding-data-listener")
			}
			res0 := binding.NewDataListener(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-data-listener")
			return res0Obj
		},
	},
	"binding-data-listener//data-changed": {
		Doc:   "binding.DataListener.DataChanged",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataListener
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataListener)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-listener//data-changed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-listener//data-changed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-listener//data-changed")
			}
			arg0Val.DataChanged()
			return arg0
		},
	},
	"binding-data-map//get-item": {
		Doc:   "binding.DataMap.GetItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataMap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-map//get-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-map//get-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-map//get-item")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-data-map//get-item")
			}
			res0, res1 := arg0Val.GetItem(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-data-item")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-data-map//keys": {
		Doc:   "binding.DataMap.Keys",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataMap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-map//keys")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-map//keys")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-map//keys")
			}
			res0 := arg0Val.Keys()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-arr")
			return res0Obj
		},
	},
	"binding-data-tree//child-i-ds": {
		Doc:   "binding.DataTree.ChildIDs",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-tree//child-i-ds")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-tree//child-i-ds")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-tree//child-i-ds")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-data-tree//child-i-ds")
			}
			res0 := arg0Val.ChildIDs(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-arr")
			return res0Obj
		},
	},
	"binding-data-tree//get-item": {
		Doc:   "binding.DataTree.GetItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-tree//get-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-tree//get-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-data-tree//get-item")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-data-tree//get-item")
			}
			res0, res1 := arg0Val.GetItem(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-data-item")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-external-bool-list//reload": {
		Doc:   "binding.ExternalBoolList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBoolList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBoolList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bool-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bool-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bool-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-bool-tree//reload": {
		Doc:   "binding.ExternalBoolTree.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBoolTree
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBoolTree)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bool-tree//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bool-tree//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bool-tree//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-bool//reload": {
		Doc:   "binding.ExternalBool.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bool//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bool//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bool//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-bytes-list//reload": {
		Doc:   "binding.ExternalBytesList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBytesList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBytesList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bytes-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bytes-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bytes-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-bytes//reload": {
		Doc:   "binding.ExternalBytes.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalBytes
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalBytes)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bytes//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bytes//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-bytes//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-float-list//reload": {
		Doc:   "binding.ExternalFloatList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalFloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalFloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-float-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-float-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-float-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-float//reload": {
		Doc:   "binding.ExternalFloat.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalFloat
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalFloat)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-float//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-float//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-float//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-int-list//reload": {
		Doc:   "binding.ExternalIntList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalIntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalIntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-int-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-int-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-int-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-int//reload": {
		Doc:   "binding.ExternalInt.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalInt
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalInt)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-int//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-int//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-int//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-rune-list//reload": {
		Doc:   "binding.ExternalRuneList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalRuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalRuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-rune-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-rune-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-rune-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-rune//reload": {
		Doc:   "binding.ExternalRune.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalRune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalRune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-rune//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-rune//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-rune//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-string-list//reload": {
		Doc:   "binding.ExternalStringList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalStringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalStringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-string-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-string-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-string-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-string//reload": {
		Doc:   "binding.ExternalString.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalString
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalString)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-string//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-string//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-string//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-untyped-list//reload": {
		Doc:   "binding.ExternalUntypedList.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalUntypedList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalUntypedList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-untyped-list//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-untyped-list//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-untyped-list//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-untyped-map//reload": {
		Doc:   "binding.ExternalUntypedMap.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalUntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalUntypedMap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-untyped-map//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-untyped-map//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-untyped-map//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-untyped//reload": {
		Doc:   "binding.ExternalUntyped.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalUntyped
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalUntyped)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-untyped//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-untyped//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-untyped//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-external-uri//reload": {
		Doc:   "binding.ExternalURI.Reload",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.ExternalURI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.ExternalURI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-uri//reload")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-uri//reload")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-external-uri//reload")
			}
			res0 := arg0Val.Reload()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float": {
		Doc:   "binding.NewFloat",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewFloat()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-float")
			return res0Obj
		},
	},
	"binding-float-list": {
		Doc:   "binding.NewFloatList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewFloatList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-float-list")
			return res0Obj
		},
	},
	"binding-float-list//append": {
		Doc:   "binding.FloatList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//append")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "binding-float-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-list//get": {
		Doc:   "binding.FloatList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "float64-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-float-list//get-value": {
		Doc:   "binding.FloatList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-float-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-float-list//prepend": {
		Doc:   "binding.FloatList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//prepend")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "binding-float-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-list//set": {
		Doc:   "binding.FloatList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//set")
			}
			var arg1Val []float64
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]float64, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg1Val[i] = float64(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-float-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-float-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-float-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-float-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-list//set-value": {
		Doc:   "binding.FloatList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.FloatList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.FloatList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-float-list//set-value")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "binding-float-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-float-to-string": {
		Doc:   "binding.FloatToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-to-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-to-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-to-string")
			}
			res0 := binding.FloatToString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-float-to-string-with-format": {
		Doc:   "binding.FloatToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-to-string-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-to-string-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float-to-string-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-float-to-string-with-format")
			}
			res0 := binding.FloatToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-float//get": {
		Doc:   "binding.Float.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-float//set": {
		Doc:   "binding.Float.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-float//set")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "binding-float//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int": {
		Doc:   "binding.NewInt",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewInt()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-int")
			return res0Obj
		},
	},
	"binding-int-list": {
		Doc:   "binding.NewIntList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewIntList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-int-list")
			return res0Obj
		},
	},
	"binding-int-list//append": {
		Doc:   "binding.IntList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//append")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-int-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-list//get": {
		Doc:   "binding.IntList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "int-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-int-list//get-value": {
		Doc:   "binding.IntList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-int-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-int-list//prepend": {
		Doc:   "binding.IntList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//prepend")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-int-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-list//set": {
		Doc:   "binding.IntList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//set")
			}
			var arg1Val []int
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg1Val[i] = int(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-int-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]int)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-int-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-int-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-int-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-list//set-value": {
		Doc:   "binding.IntList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.IntList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.IntList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-int-list//set-value")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "binding-int-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-int-to-string": {
		Doc:   "binding.IntToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-to-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-to-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-to-string")
			}
			res0 := binding.IntToString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-int-to-string-with-format": {
		Doc:   "binding.IntToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-to-string-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-to-string-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int-to-string-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-int-to-string-with-format")
			}
			res0 := binding.IntToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-int//get": {
		Doc:   "binding.Int.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-int//set": {
		Doc:   "binding.Int.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Int
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Int)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-int//set")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-int//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-not": {
		Doc:   "binding.Not",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-not")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-not")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-not")
			}
			res0 := binding.Not(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
			return res0Obj
		},
	},
	"binding-or": {
		Doc:   "binding.Or",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []binding.Bool
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]binding.Bool, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(binding.Bool)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-or")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-or")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-or")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-or")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-or")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "binding-or")
			}
			res0 := binding.Or(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
			return res0Obj
		},
	},
	"binding-rune": {
		Doc:   "binding.NewRune",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewRune()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-rune")
			return res0Obj
		},
	},
	"binding-rune-list": {
		Doc:   "binding.NewRuneList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewRuneList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-rune-list")
			return res0Obj
		},
	},
	"binding-rune-list//append": {
		Doc:   "binding.RuneList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//append")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-rune-list//append")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-rune-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-list//get": {
		Doc:   "binding.RuneList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-rune-list//get-value": {
		Doc:   "binding.RuneList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-rune-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-rune-list//prepend": {
		Doc:   "binding.RuneList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//prepend")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-rune-list//prepend")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-rune-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-list//set": {
		Doc:   "binding.RuneList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//set")
			}
			var arg1Val []rune
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]rune, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(rune)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-rune-list//set")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-rune-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-rune-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-rune-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-rune-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune-list//set-value": {
		Doc:   "binding.RuneList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.RuneList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.RuneList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-rune-list//set-value")
			}
			var arg2Val rune
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "binding-rune-list//set-value")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "binding-rune-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-rune//get": {
		Doc:   "binding.Rune.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Rune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "rune")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-rune//set": {
		Doc:   "binding.Rune.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Rune
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Rune)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-rune//set")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-rune//set")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-rune//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-sprintf": {
		Doc:   "binding.NewSprintf",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "binding-sprintf")
			}
			var arg1Val []binding.DataItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]binding.DataItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(binding.DataItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-sprintf")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-sprintf")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-sprintf")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]binding.DataItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-sprintf")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-sprintf")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-sprintf")
			}
			res0 := binding.NewSprintf(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-string": {
		Doc:   "binding.NewString",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewString()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-string-list": {
		Doc:   "binding.NewStringList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewStringList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string-list")
			return res0Obj
		},
	},
	"binding-string-list//append": {
		Doc:   "binding.StringList.Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-string-list//append")
			}
			res0 := arg0Val.Append(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-list//get": {
		Doc:   "binding.StringList.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-string-list//get-value": {
		Doc:   "binding.StringList.GetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//get-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//get-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//get-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-string-list//get-value")
			}
			res0, res1 := arg0Val.GetValue(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-string-list//prepend": {
		Doc:   "binding.StringList.Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//prepend")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-string-list//prepend")
			}
			res0 := arg0Val.Prepend(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-list//set": {
		Doc:   "binding.StringList.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//set")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-string-list//set")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-string-list//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-string-list//set")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "binding-string-list//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-list//set-value": {
		Doc:   "binding.StringList.SetValue",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.StringList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.StringList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-list//set-value")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "binding-string-list//set-value")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "binding-string-list//set-value")
			}
			res0 := arg0Val.SetValue(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-string-to-bool": {
		Doc:   "binding.StringToBool",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-bool")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-bool")
			}
			res0 := binding.StringToBool(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
			return res0Obj
		},
	},
	"binding-string-to-bool-with-format": {
		Doc:   "binding.StringToBoolWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-bool-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-bool-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-bool-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-string-to-bool-with-format")
			}
			res0 := binding.StringToBoolWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-bool")
			return res0Obj
		},
	},
	"binding-string-to-float": {
		Doc:   "binding.StringToFloat",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-float")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-float")
			}
			res0 := binding.StringToFloat(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-float")
			return res0Obj
		},
	},
	"binding-string-to-float-with-format": {
		Doc:   "binding.StringToFloatWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-float-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-float-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-float-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-string-to-float-with-format")
			}
			res0 := binding.StringToFloatWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-float")
			return res0Obj
		},
	},
	"binding-string-to-int": {
		Doc:   "binding.StringToInt",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-int")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-int")
			}
			res0 := binding.StringToInt(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-int")
			return res0Obj
		},
	},
	"binding-string-to-int-with-format": {
		Doc:   "binding.StringToIntWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-int-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-int-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-int-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-string-to-int-with-format")
			}
			res0 := binding.StringToIntWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-int")
			return res0Obj
		},
	},
	"binding-string-to-string-with-format": {
		Doc:   "binding.StringToStringWithFormat",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-string-with-format")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-string-with-format")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-string-with-format")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-string-to-string-with-format")
			}
			res0 := binding.StringToStringWithFormat(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-string-to-uri": {
		Doc:   "binding.StringToURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string-to-uri")
			}
			res0 := binding.StringToURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-uri")
			return res0Obj
		},
	},
	"binding-string//get": {
		Doc:   "binding.String.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-string//set": {
		Doc:   "binding.String.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-string//set")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-string//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"binding-untyped": {
		Doc:   "binding.NewUntyped",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewUntyped()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-untyped")
			return res0Obj
		},
	},
	"binding-untyped-list": {
		Doc:   "binding.NewUntypedList",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewUntypedList()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-untyped-list")
			return res0Obj
		},
	},
	"binding-untyped-map": {
		Doc:   "binding.NewUntypedMap",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewUntypedMap()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-untyped-map")
			return res0Obj
		},
	},
	"binding-untyped-map//delete": {
		Doc:   "binding.UntypedMap.Delete",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.UntypedMap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.UntypedMap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-untyped-map//delete")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-untyped-map//delete")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-untyped-map//delete")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "binding-untyped-map//delete")
			}
			arg0Val.Delete(arg1Val)
			return arg0
		},
	},
	"binding-uri": {
		Doc:   "binding.NewURI",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := binding.NewURI()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-uri")
			return res0Obj
		},
	},
	"binding-uri-to-string": {
		Doc:   "binding.URIToString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-uri-to-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-uri-to-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-uri-to-string")
			}
			res0 := binding.URIToString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "binding-string")
			return res0Obj
		},
	},
	"binding-uri//get": {
		Doc:   "binding.URI.Get",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-uri//get")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-uri//get")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-uri//get")
			}
			res0, res1 := arg0Val.Get()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"binding-uri//set": {
		Doc:   "binding.URI.Set",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-uri//set")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-uri//set")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "binding-uri//set")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-uri//set")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "binding-uri//set")
			}
			res0 := arg0Val.Set(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"canvas-circle": {
		Doc:   "canvas.NewCircle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle")
			}
			res0 := canvas.NewCircle(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-circle-ptr")
			return res0Obj
		},
	},
	"canvas-circle-ptr//fill-color!": {
		Doc:   "Set *canvas.Circle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//fill-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//fill-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//fill-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//fill-color!")
			}
			return arg0
		},
	},
	"canvas-circle-ptr//fill-color?": {
		Doc:   "Get *canvas.Circle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//fill-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//fill-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//fill-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color-color")
			return resObj
		},
	},
	"canvas-circle-ptr//hidden!": {
		Doc:   "Set *canvas.Circle Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "canvas-circle-ptr//hidden!")
			}
			return arg0
		},
	},
	"canvas-circle-ptr//hidden?": {
		Doc:   "Get *canvas.Circle Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"canvas-circle-ptr//hide": {
		Doc:   "(*canvas.Circle).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"canvas-circle-ptr//min-size": {
		Doc:   "(*canvas.Circle).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"canvas-circle-ptr//move": {
		Doc:   "(*canvas.Circle).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"canvas-circle-ptr//position": {
		Doc:   "(*canvas.Circle).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"canvas-circle-ptr//position-1!": {
		Doc:   "Set *canvas.Circle Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-1!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-1!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-1!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//position-1!")
			}
			return arg0
		},
	},
	"canvas-circle-ptr//position-1?": {
		Doc:   "Get *canvas.Circle Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-1?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-1?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-1?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "fyne-position")
			return resObj
		},
	},
	"canvas-circle-ptr//position-2!": {
		Doc:   "Set *canvas.Circle Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-2!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-2!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-2!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//position-2!")
			}
			return arg0
		},
	},
	"canvas-circle-ptr//position-2?": {
		Doc:   "Get *canvas.Circle Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-2?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-2?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//position-2?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "fyne-position")
			return resObj
		},
	},
	"canvas-circle-ptr//refresh": {
		Doc:   "(*canvas.Circle).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"canvas-circle-ptr//resize": {
		Doc:   "(*canvas.Circle).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"canvas-circle-ptr//show": {
		Doc:   "(*canvas.Circle).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"canvas-circle-ptr//size": {
		Doc:   "(*canvas.Circle).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"canvas-circle-ptr//stroke-color!": {
		Doc:   "Set *canvas.Circle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-color!")
			}
			return arg0
		},
	},
	"canvas-circle-ptr//stroke-color?": {
		Doc:   "Get *canvas.Circle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"canvas-circle-ptr//stroke-width!": {
		Doc:   "Set *canvas.Circle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-circle-ptr//stroke-width!")
			}
			return arg0
		},
	},
	"canvas-circle-ptr//stroke-width?": {
		Doc:   "Get *canvas.Circle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"canvas-circle-ptr//visible": {
		Doc:   "(*canvas.Circle).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle-ptr//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"canvas-circle//fill-color!": {
		Doc:   "Set canvas.Circle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//fill-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle//fill-color!")
			}
			return arg0
		},
	},
	"canvas-circle//fill-color?": {
		Doc:   "Get canvas.Circle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//fill-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//fill-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color-color")
			return resObj
		},
	},
	"canvas-circle//hidden!": {
		Doc:   "Set canvas.Circle Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "canvas-circle//hidden!")
			}
			return arg0
		},
	},
	"canvas-circle//hidden?": {
		Doc:   "Get canvas.Circle Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"canvas-circle//position-1!": {
		Doc:   "Set canvas.Circle Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//position-1!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle//position-1!")
			}
			return arg0
		},
	},
	"canvas-circle//position-1?": {
		Doc:   "Get canvas.Circle Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//position-1?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//position-1?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "fyne-position")
			return resObj
		},
	},
	"canvas-circle//position-2!": {
		Doc:   "Set canvas.Circle Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//position-2!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle//position-2!")
			}
			return arg0
		},
	},
	"canvas-circle//position-2?": {
		Doc:   "Get canvas.Circle Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//position-2?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//position-2?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "fyne-position")
			return resObj
		},
	},
	"canvas-circle//stroke-color!": {
		Doc:   "Set canvas.Circle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-circle//stroke-color!")
			}
			return arg0
		},
	},
	"canvas-circle//stroke-color?": {
		Doc:   "Get canvas.Circle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//stroke-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"canvas-circle//stroke-width!": {
		Doc:   "Set canvas.Circle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//stroke-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-circle//stroke-width!")
			}
			return arg0
		},
	},
	"canvas-circle//stroke-width?": {
		Doc:   "Get canvas.Circle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Circle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Circle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//stroke-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-circle//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"canvas-color-rgba-animation": {
		Doc:   "canvas.NewColorRGBAAnimation",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-color-rgba-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-color-rgba-animation")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-color-rgba-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-color-rgba-animation")
			}
			var arg2Val time.Duration
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "canvas-color-rgba-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "canvas-color-rgba-animation")
			}
			var arg3Val func(color.Color)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "canvas-color-rgba-animation")
				}
				arg3Val = func(arg0 color.Color) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "color-color")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "canvas-color-rgba-animation")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "canvas-color-rgba-animation")
			}
			res0 := canvas.NewColorRGBAAnimation(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-animation-ptr")
			return res0Obj
		},
	},
	"canvas-horizontal-gradient": {
		Doc:   "canvas.NewHorizontalGradient",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-horizontal-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-horizontal-gradient")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-horizontal-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-horizontal-gradient")
			}
			res0 := canvas.NewHorizontalGradient(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-linear-gradient-ptr")
			return res0Obj
		},
	},
	"canvas-image-from-file": {
		Doc:   "canvas.NewImageFromFile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "canvas-image-from-file")
			}
			res0 := canvas.NewImageFromFile(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-image-ptr")
			return res0Obj
		},
	},
	"canvas-image-from-image": {
		Doc:   "canvas.NewImageFromImage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-from-image")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-from-image")
			}
			res0 := canvas.NewImageFromImage(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-image-ptr")
			return res0Obj
		},
	},
	"canvas-image-from-reader": {
		Doc:   "canvas.NewImageFromReader",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-from-reader")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-from-reader")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "canvas-image-from-reader")
			}
			res0 := canvas.NewImageFromReader(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-image-ptr")
			return res0Obj
		},
	},
	"canvas-image-from-resource": {
		Doc:   "canvas.NewImageFromResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-from-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-from-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-from-resource")
			}
			res0 := canvas.NewImageFromResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-image-ptr")
			return res0Obj
		},
	},
	"canvas-image-from-uri": {
		Doc:   "canvas.NewImageFromURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-from-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-from-uri")
			}
			res0 := canvas.NewImageFromURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-image-ptr")
			return res0Obj
		},
	},
	"canvas-image-ptr//alpha": {
		Doc:   "(*canvas.Image).Alpha",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//alpha")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//alpha")
			}
			res0 := arg0Val.Alpha()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"canvas-image-ptr//aspect": {
		Doc:   "(*canvas.Image).Aspect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//aspect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//aspect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//aspect")
			}
			res0 := arg0Val.Aspect()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"canvas-image-ptr//file!": {
		Doc:   "Set *canvas.Image File value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//file!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//file!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//file!")
			}
			if v, ok := arg1.(env.String); ok {
				self.File = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "canvas-image-ptr//file!")
			}
			return arg0
		},
	},
	"canvas-image-ptr//file?": {
		Doc:   "Get *canvas.Image File value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//file?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//file?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//file?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.File)
			return resObj
		},
	},
	"canvas-image-ptr//fill-mode!": {
		Doc:   "Set *canvas.Image FillMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//fill-mode!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//fill-mode!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//fill-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillMode, ok = v.Value.(canvas.ImageFill)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//fill-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//fill-mode!")
			}
			return arg0
		},
	},
	"canvas-image-ptr//fill-mode?": {
		Doc:   "Get *canvas.Image FillMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//fill-mode?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//fill-mode?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//fill-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillMode, "canvas-image-fill")
			return resObj
		},
	},
	"canvas-image-ptr//hide": {
		Doc:   "(*canvas.Image).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"canvas-image-ptr//image!": {
		Doc:   "Set *canvas.Image Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//image!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//image!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//image!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(image.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//image!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//image!")
			}
			return arg0
		},
	},
	"canvas-image-ptr//image?": {
		Doc:   "Get *canvas.Image Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//image?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//image?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//image?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "image-image")
			return resObj
		},
	},
	"canvas-image-ptr//min-size": {
		Doc:   "(*canvas.Image).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"canvas-image-ptr//move": {
		Doc:   "(*canvas.Image).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"canvas-image-ptr//refresh": {
		Doc:   "(*canvas.Image).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"canvas-image-ptr//resize": {
		Doc:   "(*canvas.Image).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"canvas-image-ptr//resource!": {
		Doc:   "Set *canvas.Image Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//resource!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//resource!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//resource!")
				}
				self.Resource = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//resource!")
			}
			return arg0
		},
	},
	"canvas-image-ptr//resource?": {
		Doc:   "Get *canvas.Image Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//resource?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//resource?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//resource?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Resource, "fyne-resource")
			return resObj
		},
	},
	"canvas-image-ptr//scale-mode!": {
		Doc:   "Set *canvas.Image ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//scale-mode!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//scale-mode!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//scale-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ScaleMode, ok = v.Value.(canvas.ImageScale)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image-ptr//scale-mode!")
			}
			return arg0
		},
	},
	"canvas-image-ptr//scale-mode?": {
		Doc:   "Get *canvas.Image ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//scale-mode?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//scale-mode?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//scale-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ScaleMode, "canvas-image-scale")
			return resObj
		},
	},
	"canvas-image-ptr//translucency!": {
		Doc:   "Set *canvas.Image Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//translucency!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//translucency!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//translucency!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-image-ptr//translucency!")
			}
			return arg0
		},
	},
	"canvas-image-ptr//translucency?": {
		Doc:   "Get *canvas.Image Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//translucency?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//translucency?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image-ptr//translucency?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"canvas-image//file!": {
		Doc:   "Set canvas.Image File value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//file!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//file!")
			}
			if v, ok := arg1.(env.String); ok {
				self.File = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "canvas-image//file!")
			}
			return arg0
		},
	},
	"canvas-image//file?": {
		Doc:   "Get canvas.Image File value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//file?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//file?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.File)
			return resObj
		},
	},
	"canvas-image//fill-mode!": {
		Doc:   "Set canvas.Image FillMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//fill-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//fill-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillMode, ok = v.Value.(canvas.ImageFill)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image//fill-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image//fill-mode!")
			}
			return arg0
		},
	},
	"canvas-image//fill-mode?": {
		Doc:   "Get canvas.Image FillMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//fill-mode?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//fill-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillMode, "canvas-image-fill")
			return resObj
		},
	},
	"canvas-image//image!": {
		Doc:   "Set canvas.Image Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//image!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//image!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(image.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image//image!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image//image!")
			}
			return arg0
		},
	},
	"canvas-image//image?": {
		Doc:   "Get canvas.Image Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//image?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//image?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "image-image")
			return resObj
		},
	},
	"canvas-image//resource!": {
		Doc:   "Set canvas.Image Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//resource!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//resource!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image//resource!")
				}
				self.Resource = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image//resource!")
			}
			return arg0
		},
	},
	"canvas-image//resource?": {
		Doc:   "Get canvas.Image Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//resource?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//resource?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Resource, "fyne-resource")
			return resObj
		},
	},
	"canvas-image//scale-mode!": {
		Doc:   "Set canvas.Image ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//scale-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ScaleMode, ok = v.Value.(canvas.ImageScale)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-image//scale-mode!")
			}
			return arg0
		},
	},
	"canvas-image//scale-mode?": {
		Doc:   "Get canvas.Image ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//scale-mode?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//scale-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ScaleMode, "canvas-image-scale")
			return resObj
		},
	},
	"canvas-image//translucency!": {
		Doc:   "Set canvas.Image Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//translucency!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//translucency!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-image//translucency!")
			}
			return arg0
		},
	},
	"canvas-image//translucency?": {
		Doc:   "Get canvas.Image Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//translucency?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-image//translucency?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"canvas-line": {
		Doc:   "canvas.NewLine",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line")
			}
			res0 := canvas.NewLine(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-line-ptr")
			return res0Obj
		},
	},
	"canvas-line-ptr//hidden!": {
		Doc:   "Set *canvas.Line Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "canvas-line-ptr//hidden!")
			}
			return arg0
		},
	},
	"canvas-line-ptr//hidden?": {
		Doc:   "Get *canvas.Line Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"canvas-line-ptr//hide": {
		Doc:   "(*canvas.Line).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"canvas-line-ptr//min-size": {
		Doc:   "(*canvas.Line).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"canvas-line-ptr//move": {
		Doc:   "(*canvas.Line).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"canvas-line-ptr//position": {
		Doc:   "(*canvas.Line).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"canvas-line-ptr//position-1!": {
		Doc:   "Set *canvas.Line Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-1!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-1!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-1!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//position-1!")
			}
			return arg0
		},
	},
	"canvas-line-ptr//position-1?": {
		Doc:   "Get *canvas.Line Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-1?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-1?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-1?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "fyne-position")
			return resObj
		},
	},
	"canvas-line-ptr//position-2!": {
		Doc:   "Set *canvas.Line Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-2!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-2!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-2!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//position-2!")
			}
			return arg0
		},
	},
	"canvas-line-ptr//position-2?": {
		Doc:   "Get *canvas.Line Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-2?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-2?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//position-2?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "fyne-position")
			return resObj
		},
	},
	"canvas-line-ptr//refresh": {
		Doc:   "(*canvas.Line).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"canvas-line-ptr//resize": {
		Doc:   "(*canvas.Line).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"canvas-line-ptr//show": {
		Doc:   "(*canvas.Line).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"canvas-line-ptr//size": {
		Doc:   "(*canvas.Line).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"canvas-line-ptr//stroke-color!": {
		Doc:   "Set *canvas.Line StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-color!")
			}
			return arg0
		},
	},
	"canvas-line-ptr//stroke-color?": {
		Doc:   "Get *canvas.Line StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"canvas-line-ptr//stroke-width!": {
		Doc:   "Set *canvas.Line StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-line-ptr//stroke-width!")
			}
			return arg0
		},
	},
	"canvas-line-ptr//stroke-width?": {
		Doc:   "Get *canvas.Line StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"canvas-line-ptr//visible": {
		Doc:   "(*canvas.Line).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line-ptr//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"canvas-line//hidden!": {
		Doc:   "Set canvas.Line Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "canvas-line//hidden!")
			}
			return arg0
		},
	},
	"canvas-line//hidden?": {
		Doc:   "Get canvas.Line Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"canvas-line//position-1!": {
		Doc:   "Set canvas.Line Position1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//position-1!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position1, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line//position-1!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line//position-1!")
			}
			return arg0
		},
	},
	"canvas-line//position-1?": {
		Doc:   "Get canvas.Line Position1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//position-1?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//position-1?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position1, "fyne-position")
			return resObj
		},
	},
	"canvas-line//position-2!": {
		Doc:   "Set canvas.Line Position2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//position-2!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position2, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line//position-2!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line//position-2!")
			}
			return arg0
		},
	},
	"canvas-line//position-2?": {
		Doc:   "Get canvas.Line Position2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//position-2?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//position-2?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position2, "fyne-position")
			return resObj
		},
	},
	"canvas-line//stroke-color!": {
		Doc:   "Set canvas.Line StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-line//stroke-color!")
			}
			return arg0
		},
	},
	"canvas-line//stroke-color?": {
		Doc:   "Get canvas.Line StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//stroke-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"canvas-line//stroke-width!": {
		Doc:   "Set canvas.Line StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//stroke-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-line//stroke-width!")
			}
			return arg0
		},
	},
	"canvas-line//stroke-width?": {
		Doc:   "Get canvas.Line StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Line
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Line)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//stroke-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-line//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"canvas-linear-gradient": {
		Doc:   "canvas.NewLinearGradient",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "canvas-linear-gradient")
			}
			res0 := canvas.NewLinearGradient(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-linear-gradient-ptr")
			return res0Obj
		},
	},
	"canvas-linear-gradient-ptr//angle!": {
		Doc:   "Set *canvas.LinearGradient Angle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//angle!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//angle!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//angle!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Angle = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-linear-gradient-ptr//angle!")
			}
			return arg0
		},
	},
	"canvas-linear-gradient-ptr//angle?": {
		Doc:   "Get *canvas.LinearGradient Angle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//angle?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//angle?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//angle?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Angle))
			return resObj
		},
	},
	"canvas-linear-gradient-ptr//end-color!": {
		Doc:   "Set *canvas.LinearGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//end-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//end-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//end-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//end-color!")
			}
			return arg0
		},
	},
	"canvas-linear-gradient-ptr//end-color?": {
		Doc:   "Get *canvas.LinearGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//end-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//end-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//end-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color-color")
			return resObj
		},
	},
	"canvas-linear-gradient-ptr//generate": {
		Doc:   "(*canvas.LinearGradient).Generate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//generate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//generate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//generate")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "canvas-linear-gradient-ptr//generate")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "canvas-linear-gradient-ptr//generate")
			}
			res0 := arg0Val.Generate(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"canvas-linear-gradient-ptr//hide": {
		Doc:   "(*canvas.LinearGradient).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"canvas-linear-gradient-ptr//move": {
		Doc:   "(*canvas.LinearGradient).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"canvas-linear-gradient-ptr//refresh": {
		Doc:   "(*canvas.LinearGradient).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"canvas-linear-gradient-ptr//start-color!": {
		Doc:   "Set *canvas.LinearGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//start-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//start-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//start-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//start-color!")
			}
			return arg0
		},
	},
	"canvas-linear-gradient-ptr//start-color?": {
		Doc:   "Get *canvas.LinearGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//start-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//start-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient-ptr//start-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color-color")
			return resObj
		},
	},
	"canvas-linear-gradient//angle!": {
		Doc:   "Set canvas.LinearGradient Angle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//angle!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//angle!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Angle = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-linear-gradient//angle!")
			}
			return arg0
		},
	},
	"canvas-linear-gradient//angle?": {
		Doc:   "Get canvas.LinearGradient Angle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//angle?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//angle?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Angle))
			return resObj
		},
	},
	"canvas-linear-gradient//end-color!": {
		Doc:   "Set canvas.LinearGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//end-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient//end-color!")
			}
			return arg0
		},
	},
	"canvas-linear-gradient//end-color?": {
		Doc:   "Get canvas.LinearGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//end-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//end-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color-color")
			return resObj
		},
	},
	"canvas-linear-gradient//start-color!": {
		Doc:   "Set canvas.LinearGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//start-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-linear-gradient//start-color!")
			}
			return arg0
		},
	},
	"canvas-linear-gradient//start-color?": {
		Doc:   "Get canvas.LinearGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.LinearGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.LinearGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//start-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-linear-gradient//start-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color-color")
			return resObj
		},
	},
	"canvas-position-animation": {
		Doc:   "canvas.NewPositionAnimation",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-position-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-position-animation")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-position-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-position-animation")
			}
			var arg2Val time.Duration
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "canvas-position-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "canvas-position-animation")
			}
			var arg3Val func(fyne.Position)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "canvas-position-animation")
				}
				arg3Val = func(arg0 fyne.Position) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-position")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "canvas-position-animation")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "canvas-position-animation")
			}
			res0 := canvas.NewPositionAnimation(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-animation-ptr")
			return res0Obj
		},
	},
	"canvas-radial-gradient": {
		Doc:   "canvas.NewRadialGradient",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient")
			}
			res0 := canvas.NewRadialGradient(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-radial-gradient-ptr")
			return res0Obj
		},
	},
	"canvas-radial-gradient-ptr//center-offset-x!": {
		Doc:   "Set *canvas.RadialGradient CenterOffsetX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-x!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-x!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-x!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetX = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-radial-gradient-ptr//center-offset-x!")
			}
			return arg0
		},
	},
	"canvas-radial-gradient-ptr//center-offset-x?": {
		Doc:   "Get *canvas.RadialGradient CenterOffsetX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-x?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-x?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-x?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetX))
			return resObj
		},
	},
	"canvas-radial-gradient-ptr//center-offset-y!": {
		Doc:   "Set *canvas.RadialGradient CenterOffsetY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-y!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-y!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-y!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetY = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-radial-gradient-ptr//center-offset-y!")
			}
			return arg0
		},
	},
	"canvas-radial-gradient-ptr//center-offset-y?": {
		Doc:   "Get *canvas.RadialGradient CenterOffsetY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-y?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-y?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//center-offset-y?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetY))
			return resObj
		},
	},
	"canvas-radial-gradient-ptr//end-color!": {
		Doc:   "Set *canvas.RadialGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//end-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//end-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//end-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//end-color!")
			}
			return arg0
		},
	},
	"canvas-radial-gradient-ptr//end-color?": {
		Doc:   "Get *canvas.RadialGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//end-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//end-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//end-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color-color")
			return resObj
		},
	},
	"canvas-radial-gradient-ptr//generate": {
		Doc:   "(*canvas.RadialGradient).Generate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//generate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//generate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//generate")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "canvas-radial-gradient-ptr//generate")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "canvas-radial-gradient-ptr//generate")
			}
			res0 := arg0Val.Generate(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"canvas-radial-gradient-ptr//hide": {
		Doc:   "(*canvas.RadialGradient).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"canvas-radial-gradient-ptr//move": {
		Doc:   "(*canvas.RadialGradient).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"canvas-radial-gradient-ptr//refresh": {
		Doc:   "(*canvas.RadialGradient).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"canvas-radial-gradient-ptr//start-color!": {
		Doc:   "Set *canvas.RadialGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//start-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//start-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//start-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//start-color!")
			}
			return arg0
		},
	},
	"canvas-radial-gradient-ptr//start-color?": {
		Doc:   "Get *canvas.RadialGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//start-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//start-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient-ptr//start-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color-color")
			return resObj
		},
	},
	"canvas-radial-gradient//center-offset-x!": {
		Doc:   "Set canvas.RadialGradient CenterOffsetX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//center-offset-x!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//center-offset-x!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetX = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-radial-gradient//center-offset-x!")
			}
			return arg0
		},
	},
	"canvas-radial-gradient//center-offset-x?": {
		Doc:   "Get canvas.RadialGradient CenterOffsetX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//center-offset-x?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//center-offset-x?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetX))
			return resObj
		},
	},
	"canvas-radial-gradient//center-offset-y!": {
		Doc:   "Set canvas.RadialGradient CenterOffsetY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//center-offset-y!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//center-offset-y!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CenterOffsetY = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-radial-gradient//center-offset-y!")
			}
			return arg0
		},
	},
	"canvas-radial-gradient//center-offset-y?": {
		Doc:   "Get canvas.RadialGradient CenterOffsetY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//center-offset-y?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//center-offset-y?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CenterOffsetY))
			return resObj
		},
	},
	"canvas-radial-gradient//end-color!": {
		Doc:   "Set canvas.RadialGradient EndColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//end-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.EndColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient//end-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient//end-color!")
			}
			return arg0
		},
	},
	"canvas-radial-gradient//end-color?": {
		Doc:   "Get canvas.RadialGradient EndColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//end-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//end-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.EndColor, "color-color")
			return resObj
		},
	},
	"canvas-radial-gradient//start-color!": {
		Doc:   "Set canvas.RadialGradient StartColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//start-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StartColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient//start-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-radial-gradient//start-color!")
			}
			return arg0
		},
	},
	"canvas-radial-gradient//start-color?": {
		Doc:   "Get canvas.RadialGradient StartColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.RadialGradient
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.RadialGradient)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//start-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-radial-gradient//start-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StartColor, "color-color")
			return resObj
		},
	},
	"canvas-raster": {
		Doc:   "canvas.NewRaster",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(int, int) image.Image
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "canvas-raster")
				}
				arg0Val = func(arg0 int, arg1 int) image.Image {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
					var res image.Image
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(image.Image)
						if !ok {
							// TODO: Invalid type
						}
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "canvas-raster")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "canvas-raster")
			}
			res0 := canvas.NewRaster(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-raster-ptr")
			return res0Obj
		},
	},
	"canvas-raster-from-image": {
		Doc:   "canvas.NewRasterFromImage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-from-image")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-from-image")
			}
			res0 := canvas.NewRasterFromImage(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-raster-ptr")
			return res0Obj
		},
	},
	"canvas-raster-ptr//alpha": {
		Doc:   "(*canvas.Raster).Alpha",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//alpha")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//alpha")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//alpha")
			}
			res0 := arg0Val.Alpha()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"canvas-raster-ptr//generator!": {
		Doc:   "Set *canvas.Raster Generator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//generator!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//generator!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//generator!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas-raster-ptr//generator!")
				}
				self.Generator = func(arg0 int, arg1 int) image.Image {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
					var res image.Image
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(image.Image)
						if !ok {
							// TODO: Invalid type
						}
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "canvas-raster-ptr//generator!")
				}
				self.Generator = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas-raster-ptr//generator!")
			}
			return arg0
		},
	},
	"canvas-raster-ptr//generator?": {
		Doc:   "Get *canvas.Raster Generator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//generator?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//generator?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//generator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Generator, "--go-any-func--")
			return resObj
		},
	},
	"canvas-raster-ptr//hide": {
		Doc:   "(*canvas.Raster).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"canvas-raster-ptr//move": {
		Doc:   "(*canvas.Raster).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-raster-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-raster-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"canvas-raster-ptr//refresh": {
		Doc:   "(*canvas.Raster).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"canvas-raster-ptr//resize": {
		Doc:   "(*canvas.Raster).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-raster-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-raster-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"canvas-raster-ptr//scale-mode!": {
		Doc:   "Set *canvas.Raster ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//scale-mode!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//scale-mode!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//scale-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ScaleMode, ok = v.Value.(canvas.ImageScale)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-raster-ptr//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-raster-ptr//scale-mode!")
			}
			return arg0
		},
	},
	"canvas-raster-ptr//scale-mode?": {
		Doc:   "Get *canvas.Raster ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//scale-mode?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//scale-mode?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//scale-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ScaleMode, "canvas-image-scale")
			return resObj
		},
	},
	"canvas-raster-ptr//translucency!": {
		Doc:   "Set *canvas.Raster Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//translucency!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//translucency!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//translucency!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-raster-ptr//translucency!")
			}
			return arg0
		},
	},
	"canvas-raster-ptr//translucency?": {
		Doc:   "Get *canvas.Raster Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//translucency?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//translucency?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster-ptr//translucency?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"canvas-raster-with-pixels": {
		Doc:   "canvas.NewRasterWithPixels",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(int, int, int, int) color.Color
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 4 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "canvas-raster-with-pixels")
				}
				arg0Val = func(arg0 int, arg1 int, arg2 int, arg3 int) color.Color {
					var arg0Val, arg1Val, arg2Val, arg3Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					arg2Val = *env.NewInteger(int64(arg2))
					arg3Val = *env.NewInteger(int64(arg3))
					evaldo.CallFunctionArgs4(fn, ps, arg0Val, arg1Val, arg2Val, arg3Val, ps.Ctx)
					var res color.Color
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(color.Color)
						if !ok {
							// TODO: Invalid type
						}
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "canvas-raster-with-pixels")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "canvas-raster-with-pixels")
			}
			res0 := canvas.NewRasterWithPixels(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-raster-ptr")
			return res0Obj
		},
	},
	"canvas-raster//generator!": {
		Doc:   "Set canvas.Raster Generator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//generator!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//generator!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas-raster//generator!")
				}
				self.Generator = func(arg0 int, arg1 int) image.Image {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewInteger(int64(arg0))
					arg1Val = *env.NewInteger(int64(arg1))
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
					var res image.Image
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(image.Image)
						if !ok {
							// TODO: Invalid type
						}
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "canvas-raster//generator!")
				}
				self.Generator = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "canvas-raster//generator!")
			}
			return arg0
		},
	},
	"canvas-raster//generator?": {
		Doc:   "Get canvas.Raster Generator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//generator?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//generator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Generator, "--go-any-func--")
			return resObj
		},
	},
	"canvas-raster//scale-mode!": {
		Doc:   "Set canvas.Raster ScaleMode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//scale-mode!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ScaleMode, ok = v.Value.(canvas.ImageScale)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-raster//scale-mode!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-raster//scale-mode!")
			}
			return arg0
		},
	},
	"canvas-raster//scale-mode?": {
		Doc:   "Get canvas.Raster ScaleMode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//scale-mode?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//scale-mode?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ScaleMode, "canvas-image-scale")
			return resObj
		},
	},
	"canvas-raster//translucency!": {
		Doc:   "Set canvas.Raster Translucency value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//translucency!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//translucency!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Translucency = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-raster//translucency!")
			}
			return arg0
		},
	},
	"canvas-raster//translucency?": {
		Doc:   "Get canvas.Raster Translucency value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Raster
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Raster)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//translucency?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-raster//translucency?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Translucency))
			return resObj
		},
	},
	"canvas-rectangle": {
		Doc:   "canvas.NewRectangle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle")
			}
			res0 := canvas.NewRectangle(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-rectangle-ptr")
			return res0Obj
		},
	},
	"canvas-rectangle-ptr//corner-radius!": {
		Doc:   "Set *canvas.Rectangle CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//corner-radius!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//corner-radius!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//corner-radius!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CornerRadius = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-rectangle-ptr//corner-radius!")
			}
			return arg0
		},
	},
	"canvas-rectangle-ptr//corner-radius?": {
		Doc:   "Get *canvas.Rectangle CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//corner-radius?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//corner-radius?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//corner-radius?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CornerRadius))
			return resObj
		},
	},
	"canvas-rectangle-ptr//fill-color!": {
		Doc:   "Set *canvas.Rectangle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//fill-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//fill-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//fill-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle-ptr//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle-ptr//fill-color!")
			}
			return arg0
		},
	},
	"canvas-rectangle-ptr//fill-color?": {
		Doc:   "Get *canvas.Rectangle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//fill-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//fill-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//fill-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color-color")
			return resObj
		},
	},
	"canvas-rectangle-ptr//hide": {
		Doc:   "(*canvas.Rectangle).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"canvas-rectangle-ptr//move": {
		Doc:   "(*canvas.Rectangle).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"canvas-rectangle-ptr//refresh": {
		Doc:   "(*canvas.Rectangle).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"canvas-rectangle-ptr//resize": {
		Doc:   "(*canvas.Rectangle).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"canvas-rectangle-ptr//stroke-color!": {
		Doc:   "Set *canvas.Rectangle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-color!")
			}
			return arg0
		},
	},
	"canvas-rectangle-ptr//stroke-color?": {
		Doc:   "Get *canvas.Rectangle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"canvas-rectangle-ptr//stroke-width!": {
		Doc:   "Set *canvas.Rectangle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-rectangle-ptr//stroke-width!")
			}
			return arg0
		},
	},
	"canvas-rectangle-ptr//stroke-width?": {
		Doc:   "Get *canvas.Rectangle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle-ptr//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"canvas-rectangle//corner-radius!": {
		Doc:   "Set canvas.Rectangle CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//corner-radius!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//corner-radius!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.CornerRadius = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-rectangle//corner-radius!")
			}
			return arg0
		},
	},
	"canvas-rectangle//corner-radius?": {
		Doc:   "Get canvas.Rectangle CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//corner-radius?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//corner-radius?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.CornerRadius))
			return resObj
		},
	},
	"canvas-rectangle//fill-color!": {
		Doc:   "Set canvas.Rectangle FillColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//fill-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FillColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle//fill-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle//fill-color!")
			}
			return arg0
		},
	},
	"canvas-rectangle//fill-color?": {
		Doc:   "Get canvas.Rectangle FillColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//fill-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//fill-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FillColor, "color-color")
			return resObj
		},
	},
	"canvas-rectangle//stroke-color!": {
		Doc:   "Set canvas.Rectangle StrokeColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//stroke-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.StrokeColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle//stroke-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-rectangle//stroke-color!")
			}
			return arg0
		},
	},
	"canvas-rectangle//stroke-color?": {
		Doc:   "Get canvas.Rectangle StrokeColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//stroke-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//stroke-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StrokeColor, "color-color")
			return resObj
		},
	},
	"canvas-rectangle//stroke-width!": {
		Doc:   "Set canvas.Rectangle StrokeWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//stroke-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//stroke-width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.StrokeWidth = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-rectangle//stroke-width!")
			}
			return arg0
		},
	},
	"canvas-rectangle//stroke-width?": {
		Doc:   "Get canvas.Rectangle StrokeWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Rectangle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//stroke-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-rectangle//stroke-width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.StrokeWidth))
			return resObj
		},
	},
	"canvas-refresh": {
		Doc:   "canvas.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-refresh")
			}
			canvas.Refresh(arg0Val)
			return nil
		},
	},
	"canvas-size-animation": {
		Doc:   "canvas.NewSizeAnimation",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-size-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-size-animation")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-size-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-size-animation")
			}
			var arg2Val time.Duration
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "canvas-size-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "canvas-size-animation")
			}
			var arg3Val func(fyne.Size)
			switch fn := arg3.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "canvas-size-animation")
				}
				arg3Val = func(arg0 fyne.Size) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-size")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.BlockType, env.NativeType}, "canvas-size-animation")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.FunctionType}, "canvas-size-animation")
			}
			res0 := canvas.NewSizeAnimation(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-animation-ptr")
			return res0Obj
		},
	},
	"canvas-text": {
		Doc:   "canvas.NewText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "canvas-text")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text")
			}
			res0 := canvas.NewText(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-text-ptr")
			return res0Obj
		},
	},
	"canvas-text-ptr//alignment!": {
		Doc:   "Set *canvas.Text Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//alignment!")
			}
			return arg0
		},
	},
	"canvas-text-ptr//alignment?": {
		Doc:   "Get *canvas.Text Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"canvas-text-ptr//color!": {
		Doc:   "Set *canvas.Text Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Color, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//color!")
			}
			return arg0
		},
	},
	"canvas-text-ptr//color?": {
		Doc:   "Get *canvas.Text Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "color-color")
			return resObj
		},
	},
	"canvas-text-ptr//hide": {
		Doc:   "(*canvas.Text).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"canvas-text-ptr//min-size": {
		Doc:   "(*canvas.Text).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"canvas-text-ptr//move": {
		Doc:   "(*canvas.Text).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"canvas-text-ptr//refresh": {
		Doc:   "(*canvas.Text).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"canvas-text-ptr//resize": {
		Doc:   "(*canvas.Text).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"canvas-text-ptr//set-min-size": {
		Doc:   "(*canvas.Text).SetMinSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//set-min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//set-min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//set-min-size")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//set-min-size")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//set-min-size")
			}
			arg0Val.SetMinSize(arg1Val)
			return arg0
		},
	},
	"canvas-text-ptr//text!": {
		Doc:   "Set *canvas.Text Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "canvas-text-ptr//text!")
			}
			return arg0
		},
	},
	"canvas-text-ptr//text-size!": {
		Doc:   "Set *canvas.Text TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-size!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-size!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-size!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.TextSize = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-text-ptr//text-size!")
			}
			return arg0
		},
	},
	"canvas-text-ptr//text-size?": {
		Doc:   "Get *canvas.Text TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-size?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-size?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-size?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.TextSize))
			return resObj
		},
	},
	"canvas-text-ptr//text-style!": {
		Doc:   "Set *canvas.Text TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text-ptr//text-style!")
			}
			return arg0
		},
	},
	"canvas-text-ptr//text-style?": {
		Doc:   "Get *canvas.Text TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"canvas-text-ptr//text?": {
		Doc:   "Get *canvas.Text Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"canvas-text//alignment!": {
		Doc:   "Set canvas.Text Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text//alignment!")
			}
			return arg0
		},
	},
	"canvas-text//alignment?": {
		Doc:   "Get canvas.Text Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"canvas-text//color!": {
		Doc:   "Set canvas.Text Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Color, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text//color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text//color!")
			}
			return arg0
		},
	},
	"canvas-text//color?": {
		Doc:   "Get canvas.Text Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "color-color")
			return resObj
		},
	},
	"canvas-text//text!": {
		Doc:   "Set canvas.Text Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "canvas-text//text!")
			}
			return arg0
		},
	},
	"canvas-text//text-size!": {
		Doc:   "Set canvas.Text TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text-size!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text-size!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.TextSize = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "canvas-text//text-size!")
			}
			return arg0
		},
	},
	"canvas-text//text-size?": {
		Doc:   "Get canvas.Text TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text-size?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text-size?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.TextSize))
			return resObj
		},
	},
	"canvas-text//text-style!": {
		Doc:   "Set canvas.Text TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-text//text-style!")
			}
			return arg0
		},
	},
	"canvas-text//text-style?": {
		Doc:   "Get canvas.Text TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"canvas-text//text?": {
		Doc:   "Get canvas.Text Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self canvas.Text
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(canvas.Text)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-text//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"canvas-vertical-gradient": {
		Doc:   "canvas.NewVerticalGradient",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val color.Color
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-vertical-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "canvas-vertical-gradient")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-vertical-gradient")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "canvas-vertical-gradient")
			}
			res0 := canvas.NewVerticalGradient(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "canvas-linear-gradient-ptr")
			return res0Obj
		},
	},
	"container": {
		Doc:   "container.New",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container")
			}
			res0 := container.New(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-adaptive-grid": {
		Doc:   "container.NewAdaptiveGrid",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "container-adaptive-grid")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-adaptive-grid")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-adaptive-grid")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-adaptive-grid")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-adaptive-grid")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-adaptive-grid")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-adaptive-grid")
			}
			res0 := container.NewAdaptiveGrid(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-app-tabs": {
		Doc:   "container.NewAppTabs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*container.TabItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs")
			}
			res0 := container.NewAppTabs(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-app-tabs-ptr")
			return res0Obj
		},
	},
	"container-app-tabs-ptr//append": {
		Doc:   "(*container.AppTabs).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//append")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//create-renderer": {
		Doc:   "(*container.AppTabs).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"container-app-tabs-ptr//current-tab": {
		Doc:   "(*container.AppTabs).CurrentTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//current-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//current-tab")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//current-tab")
			}
			res0 := arg0Val.CurrentTab()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-tab-item-ptr")
			return res0Obj
		},
	},
	"container-app-tabs-ptr//current-tab-index": {
		Doc:   "(*container.AppTabs).CurrentTabIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//current-tab-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//current-tab-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//current-tab-index")
			}
			res0 := arg0Val.CurrentTabIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"container-app-tabs-ptr//disable-index": {
		Doc:   "(*container.AppTabs).DisableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//disable-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//disable-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//disable-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-app-tabs-ptr//disable-index")
			}
			arg0Val.DisableIndex(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//disable-item": {
		Doc:   "(*container.AppTabs).DisableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//disable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//disable-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//disable-item")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//disable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//disable-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//disable-item")
			}
			arg0Val.DisableItem(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//enable-index": {
		Doc:   "(*container.AppTabs).EnableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//enable-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//enable-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//enable-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-app-tabs-ptr//enable-index")
			}
			arg0Val.EnableIndex(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//enable-item": {
		Doc:   "(*container.AppTabs).EnableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//enable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//enable-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//enable-item")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//enable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//enable-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//enable-item")
			}
			arg0Val.EnableItem(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//extend-base-widget": {
		Doc:   "(*container.AppTabs).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//hidden!": {
		Doc:   "Set *container.AppTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-app-tabs-ptr//hidden!")
			}
			return arg0
		},
	},
	"container-app-tabs-ptr//hidden?": {
		Doc:   "Get *container.AppTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container-app-tabs-ptr//hide": {
		Doc:   "(*container.AppTabs).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"container-app-tabs-ptr//items!": {
		Doc:   "Set *container.AppTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//items!")
			}
			return arg0
		},
	},
	"container-app-tabs-ptr//items?": {
		Doc:   "Get *container.AppTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "container-tab-item-ptr-arr")
			return resObj
		},
	},
	"container-app-tabs-ptr//min-size": {
		Doc:   "(*container.AppTabs).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"container-app-tabs-ptr//on-changed!": {
		Doc:   "Set *container.AppTabs OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs-ptr//on-changed!")
				}
				self.OnChanged = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs-ptr//on-changed!")
			}
			return arg0
		},
	},
	"container-app-tabs-ptr//on-changed?": {
		Doc:   "Get *container.AppTabs OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"container-app-tabs-ptr//on-selected!": {
		Doc:   "Set *container.AppTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs-ptr//on-selected!")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs-ptr//on-selected!")
			}
			return arg0
		},
	},
	"container-app-tabs-ptr//on-selected?": {
		Doc:   "Get *container.AppTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "--go-any-func--")
			return resObj
		},
	},
	"container-app-tabs-ptr//on-unselected!": {
		Doc:   "Set *container.AppTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-unselected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-unselected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs-ptr//on-unselected!")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs-ptr//on-unselected!")
			}
			return arg0
		},
	},
	"container-app-tabs-ptr//on-unselected?": {
		Doc:   "Get *container.AppTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-unselected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-unselected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "--go-any-func--")
			return resObj
		},
	},
	"container-app-tabs-ptr//remove": {
		Doc:   "(*container.AppTabs).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//remove")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//remove-index": {
		Doc:   "(*container.AppTabs).RemoveIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//remove-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//remove-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//remove-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-app-tabs-ptr//remove-index")
			}
			arg0Val.RemoveIndex(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//select": {
		Doc:   "(*container.AppTabs).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//select")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//select")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//select-index": {
		Doc:   "(*container.AppTabs).SelectIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-app-tabs-ptr//select-index")
			}
			arg0Val.SelectIndex(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//select-tab": {
		Doc:   "(*container.AppTabs).SelectTab",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-tab")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-tab")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-tab")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-tab")
			}
			arg0Val.SelectTab(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//select-tab-index": {
		Doc:   "(*container.AppTabs).SelectTabIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-tab-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-tab-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//select-tab-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-app-tabs-ptr//select-tab-index")
			}
			arg0Val.SelectTabIndex(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//selected": {
		Doc:   "(*container.AppTabs).Selected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//selected")
			}
			res0 := arg0Val.Selected()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-tab-item-ptr")
			return res0Obj
		},
	},
	"container-app-tabs-ptr//selected-index": {
		Doc:   "(*container.AppTabs).SelectedIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//selected-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//selected-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//selected-index")
			}
			res0 := arg0Val.SelectedIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"container-app-tabs-ptr//set-items": {
		Doc:   "(*container.AppTabs).SetItems",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//set-items")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//set-items")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//set-items")
			}
			var arg1Val []*container.TabItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//set-items")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//set-items")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//set-items")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//set-items")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//set-items")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs-ptr//set-items")
			}
			arg0Val.SetItems(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//set-tab-location": {
		Doc:   "(*container.AppTabs).SetTabLocation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//set-tab-location")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//set-tab-location")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//set-tab-location")
			}
			var arg1Val container.TabLocation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(container.TabLocation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//set-tab-location")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-app-tabs-ptr//set-tab-location")
			}
			arg0Val.SetTabLocation(arg1Val)
			return arg0
		},
	},
	"container-app-tabs-ptr//show": {
		Doc:   "(*container.AppTabs).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"container-app-tabs//hidden!": {
		Doc:   "Set container.AppTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-app-tabs//hidden!")
			}
			return arg0
		},
	},
	"container-app-tabs//hidden?": {
		Doc:   "Get container.AppTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container-app-tabs//items!": {
		Doc:   "Set container.AppTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs//items!")
			}
			return arg0
		},
	},
	"container-app-tabs//items?": {
		Doc:   "Get container.AppTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "container-tab-item-ptr-arr")
			return resObj
		},
	},
	"container-app-tabs//on-changed!": {
		Doc:   "Set container.AppTabs OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs//on-changed!")
				}
				self.OnChanged = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs//on-changed!")
			}
			return arg0
		},
	},
	"container-app-tabs//on-changed?": {
		Doc:   "Get container.AppTabs OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"container-app-tabs//on-selected!": {
		Doc:   "Set container.AppTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs//on-selected!")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs//on-selected!")
			}
			return arg0
		},
	},
	"container-app-tabs//on-selected?": {
		Doc:   "Get container.AppTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "--go-any-func--")
			return resObj
		},
	},
	"container-app-tabs//on-unselected!": {
		Doc:   "Set container.AppTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-unselected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs//on-unselected!")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-app-tabs//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-app-tabs//on-unselected!")
			}
			return arg0
		},
	},
	"container-app-tabs//on-unselected?": {
		Doc:   "Get container.AppTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.AppTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.AppTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-unselected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-app-tabs//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "--go-any-func--")
			return resObj
		},
	},
	"container-border": {
		Doc:   "container.NewBorder",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-border")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-border")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-border")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-border")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "container-border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "container-border")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "container-border")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "container-border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "container-border")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "container-border")
			}
			var arg4Val []fyne.CanvasObject
			switch v := arg4.(type) {
			case env.Block:
				arg4Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg4Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "container-border")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "container-border")
						}
						arg4Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "container-border")
					}
				}
			case env.Native:
				var ok bool
				arg4Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "container-border")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "container-border")
				}
				arg4Val = nil
			default:
				return evaldo.MakeArgError(ps, 4, []env.Type{env.BlockType, env.NativeType}, "container-border")
			}
			res0 := container.NewBorder(arg0Val, arg1Val, arg2Val, arg3Val, arg4Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-center": {
		Doc:   "container.NewCenter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-center")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-center")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-center")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-center")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-center")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-center")
			}
			res0 := container.NewCenter(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-doc-tabs": {
		Doc:   "container.NewDocTabs",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*container.TabItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs")
			}
			res0 := container.NewDocTabs(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-doc-tabs-ptr")
			return res0Obj
		},
	},
	"container-doc-tabs-ptr//append": {
		Doc:   "(*container.DocTabs).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//append")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//close-intercept!": {
		Doc:   "Set *container.DocTabs CloseIntercept value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//close-intercept!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//close-intercept!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//close-intercept!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//close-intercept!")
				}
				self.CloseIntercept = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//close-intercept!")
				}
				self.CloseIntercept = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//close-intercept!")
			}
			return arg0
		},
	},
	"container-doc-tabs-ptr//close-intercept?": {
		Doc:   "Get *container.DocTabs CloseIntercept value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//close-intercept?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//close-intercept?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//close-intercept?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CloseIntercept, "--go-any-func--")
			return resObj
		},
	},
	"container-doc-tabs-ptr//create-renderer": {
		Doc:   "(*container.DocTabs).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"container-doc-tabs-ptr//create-tab!": {
		Doc:   "Set *container.DocTabs CreateTab value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//create-tab!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//create-tab!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//create-tab!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//create-tab!")
				}
				self.CreateTab = func() *container.TabItem {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res *container.TabItem
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(*container.TabItem)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//create-tab!")
				}
				self.CreateTab = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//create-tab!")
			}
			return arg0
		},
	},
	"container-doc-tabs-ptr//create-tab?": {
		Doc:   "Get *container.DocTabs CreateTab value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//create-tab?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//create-tab?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//create-tab?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateTab, "--go-any-func--")
			return resObj
		},
	},
	"container-doc-tabs-ptr//disable-index": {
		Doc:   "(*container.DocTabs).DisableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//disable-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//disable-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//disable-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-doc-tabs-ptr//disable-index")
			}
			arg0Val.DisableIndex(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//disable-item": {
		Doc:   "(*container.DocTabs).DisableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//disable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//disable-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//disable-item")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//disable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//disable-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//disable-item")
			}
			arg0Val.DisableItem(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//enable-index": {
		Doc:   "(*container.DocTabs).EnableIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//enable-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//enable-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//enable-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-doc-tabs-ptr//enable-index")
			}
			arg0Val.EnableIndex(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//enable-item": {
		Doc:   "(*container.DocTabs).EnableItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//enable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//enable-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//enable-item")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//enable-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//enable-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//enable-item")
			}
			arg0Val.EnableItem(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//hidden!": {
		Doc:   "Set *container.DocTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-doc-tabs-ptr//hidden!")
			}
			return arg0
		},
	},
	"container-doc-tabs-ptr//hidden?": {
		Doc:   "Get *container.DocTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container-doc-tabs-ptr//hide": {
		Doc:   "(*container.DocTabs).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"container-doc-tabs-ptr//items!": {
		Doc:   "Set *container.DocTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//items!")
			}
			return arg0
		},
	},
	"container-doc-tabs-ptr//items?": {
		Doc:   "Get *container.DocTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "container-tab-item-ptr-arr")
			return resObj
		},
	},
	"container-doc-tabs-ptr//min-size": {
		Doc:   "(*container.DocTabs).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"container-doc-tabs-ptr//on-closed!": {
		Doc:   "Set *container.DocTabs OnClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-closed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-closed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-closed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//on-closed!")
				}
				self.OnClosed = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//on-closed!")
				}
				self.OnClosed = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//on-closed!")
			}
			return arg0
		},
	},
	"container-doc-tabs-ptr//on-closed?": {
		Doc:   "Get *container.DocTabs OnClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-closed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-closed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-closed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnClosed, "--go-any-func--")
			return resObj
		},
	},
	"container-doc-tabs-ptr//on-selected!": {
		Doc:   "Set *container.DocTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//on-selected!")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//on-selected!")
			}
			return arg0
		},
	},
	"container-doc-tabs-ptr//on-selected?": {
		Doc:   "Get *container.DocTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "--go-any-func--")
			return resObj
		},
	},
	"container-doc-tabs-ptr//on-unselected!": {
		Doc:   "Set *container.DocTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-unselected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-unselected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//on-unselected!")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs-ptr//on-unselected!")
			}
			return arg0
		},
	},
	"container-doc-tabs-ptr//on-unselected?": {
		Doc:   "Get *container.DocTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-unselected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-unselected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "--go-any-func--")
			return resObj
		},
	},
	"container-doc-tabs-ptr//remove": {
		Doc:   "(*container.DocTabs).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//remove")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//remove-index": {
		Doc:   "(*container.DocTabs).RemoveIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//remove-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//remove-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//remove-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-doc-tabs-ptr//remove-index")
			}
			arg0Val.RemoveIndex(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//select": {
		Doc:   "(*container.DocTabs).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//select")
			}
			var arg1Val *container.TabItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//select")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//select")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//select-index": {
		Doc:   "(*container.DocTabs).SelectIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//select-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//select-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//select-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-doc-tabs-ptr//select-index")
			}
			arg0Val.SelectIndex(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//selected": {
		Doc:   "(*container.DocTabs).Selected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//selected")
			}
			res0 := arg0Val.Selected()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-tab-item-ptr")
			return res0Obj
		},
	},
	"container-doc-tabs-ptr//selected-index": {
		Doc:   "(*container.DocTabs).SelectedIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//selected-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//selected-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//selected-index")
			}
			res0 := arg0Val.SelectedIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"container-doc-tabs-ptr//set-items": {
		Doc:   "(*container.DocTabs).SetItems",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//set-items")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//set-items")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//set-items")
			}
			var arg1Val []*container.TabItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//set-items")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//set-items")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//set-items")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//set-items")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//set-items")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs-ptr//set-items")
			}
			arg0Val.SetItems(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//set-tab-location": {
		Doc:   "(*container.DocTabs).SetTabLocation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//set-tab-location")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//set-tab-location")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//set-tab-location")
			}
			var arg1Val container.TabLocation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(container.TabLocation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//set-tab-location")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-doc-tabs-ptr//set-tab-location")
			}
			arg0Val.SetTabLocation(arg1Val)
			return arg0
		},
	},
	"container-doc-tabs-ptr//show": {
		Doc:   "(*container.DocTabs).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"container-doc-tabs//close-intercept!": {
		Doc:   "Set container.DocTabs CloseIntercept value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//close-intercept!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//close-intercept!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//close-intercept!")
				}
				self.CloseIntercept = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//close-intercept!")
				}
				self.CloseIntercept = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//close-intercept!")
			}
			return arg0
		},
	},
	"container-doc-tabs//close-intercept?": {
		Doc:   "Get container.DocTabs CloseIntercept value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//close-intercept?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//close-intercept?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CloseIntercept, "--go-any-func--")
			return resObj
		},
	},
	"container-doc-tabs//create-tab!": {
		Doc:   "Set container.DocTabs CreateTab value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//create-tab!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//create-tab!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//create-tab!")
				}
				self.CreateTab = func() *container.TabItem {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res *container.TabItem
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(*container.TabItem)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//create-tab!")
				}
				self.CreateTab = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//create-tab!")
			}
			return arg0
		},
	},
	"container-doc-tabs//create-tab?": {
		Doc:   "Get container.DocTabs CreateTab value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//create-tab?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//create-tab?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateTab, "--go-any-func--")
			return resObj
		},
	},
	"container-doc-tabs//hidden!": {
		Doc:   "Set container.DocTabs Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-doc-tabs//hidden!")
			}
			return arg0
		},
	},
	"container-doc-tabs//hidden?": {
		Doc:   "Get container.DocTabs Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container-doc-tabs//items!": {
		Doc:   "Set container.DocTabs Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*container.TabItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*container.TabItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//items!")
			}
			return arg0
		},
	},
	"container-doc-tabs//items?": {
		Doc:   "Get container.DocTabs Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "container-tab-item-ptr-arr")
			return resObj
		},
	},
	"container-doc-tabs//on-closed!": {
		Doc:   "Set container.DocTabs OnClosed value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-closed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-closed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//on-closed!")
				}
				self.OnClosed = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//on-closed!")
				}
				self.OnClosed = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//on-closed!")
			}
			return arg0
		},
	},
	"container-doc-tabs//on-closed?": {
		Doc:   "Get container.DocTabs OnClosed value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-closed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-closed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnClosed, "--go-any-func--")
			return resObj
		},
	},
	"container-doc-tabs//on-selected!": {
		Doc:   "Set container.DocTabs OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//on-selected!")
				}
				self.OnSelected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//on-selected!")
			}
			return arg0
		},
	},
	"container-doc-tabs//on-selected?": {
		Doc:   "Get container.DocTabs OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "--go-any-func--")
			return resObj
		},
	},
	"container-doc-tabs//on-unselected!": {
		Doc:   "Set container.DocTabs OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-unselected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//on-unselected!")
				}
				self.OnUnselected = func(arg0 *container.TabItem) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "container-tab-item-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-doc-tabs//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "container-doc-tabs//on-unselected!")
			}
			return arg0
		},
	},
	"container-doc-tabs//on-unselected?": {
		Doc:   "Get container.DocTabs OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.DocTabs
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.DocTabs)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-unselected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-doc-tabs//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "--go-any-func--")
			return resObj
		},
	},
	"container-grid-with-columns": {
		Doc:   "container.NewGridWithColumns",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "container-grid-with-columns")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-columns")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-columns")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-columns")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-columns")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-columns")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-columns")
			}
			res0 := container.NewGridWithColumns(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-grid-with-rows": {
		Doc:   "container.NewGridWithRows",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "container-grid-with-rows")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-rows")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-rows")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-rows")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-rows")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-rows")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-with-rows")
			}
			res0 := container.NewGridWithRows(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-grid-wrap": {
		Doc:   "container.NewGridWrap",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-grid-wrap")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-grid-wrap")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-wrap")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-wrap")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-wrap")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-wrap")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-wrap")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "container-grid-wrap")
			}
			res0 := container.NewGridWrap(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-h-box": {
		Doc:   "container.NewHBox",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-h-box")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-h-box")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-h-box")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-h-box")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-h-box")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-h-box")
			}
			res0 := container.NewHBox(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-h-scroll": {
		Doc:   "container.NewHScroll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-h-scroll")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-h-scroll")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-h-scroll")
			}
			res0 := container.NewHScroll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-scroll-ptr")
			return res0Obj
		},
	},
	"container-h-split": {
		Doc:   "container.NewHSplit",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-h-split")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-h-split")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-h-split")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-h-split")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-h-split")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-h-split")
			}
			res0 := container.NewHSplit(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-split-ptr")
			return res0Obj
		},
	},
	"container-max": {
		Doc:   "container.NewMax",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-max")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-max")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-max")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-max")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-max")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-max")
			}
			res0 := container.NewMax(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-padded": {
		Doc:   "container.NewPadded",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-padded")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-padded")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-padded")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-padded")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-padded")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-padded")
			}
			res0 := container.NewPadded(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-scroll": {
		Doc:   "container.NewScroll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-scroll")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-scroll")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-scroll")
			}
			res0 := container.NewScroll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-scroll-ptr")
			return res0Obj
		},
	},
	"container-split-ptr//create-renderer": {
		Doc:   "(*container.Split).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"container-split-ptr//extend-base-widget": {
		Doc:   "(*container.Split).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split-ptr//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split-ptr//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"container-split-ptr//hidden!": {
		Doc:   "Set *container.Split Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-split-ptr//hidden!")
			}
			return arg0
		},
	},
	"container-split-ptr//hidden?": {
		Doc:   "Get *container.Split Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container-split-ptr//horizontal!": {
		Doc:   "Set *container.Split Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//horizontal!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//horizontal!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-split-ptr//horizontal!")
			}
			return arg0
		},
	},
	"container-split-ptr//horizontal?": {
		Doc:   "Get *container.Split Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//horizontal?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//horizontal?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"container-split-ptr//leading!": {
		Doc:   "Set *container.Split Leading value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//leading!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//leading!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//leading!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Leading, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split-ptr//leading!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split-ptr//leading!")
				}
				self.Leading = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split-ptr//leading!")
			}
			return arg0
		},
	},
	"container-split-ptr//leading?": {
		Doc:   "Get *container.Split Leading value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//leading?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//leading?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//leading?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Leading, "fyne-canvas-object")
			return resObj
		},
	},
	"container-split-ptr//offset!": {
		Doc:   "Set *container.Split Offset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//offset!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//offset!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//offset!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Offset = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "container-split-ptr//offset!")
			}
			return arg0
		},
	},
	"container-split-ptr//offset?": {
		Doc:   "Get *container.Split Offset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//offset?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//offset?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//offset?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Offset))
			return resObj
		},
	},
	"container-split-ptr//set-offset": {
		Doc:   "(*container.Split).SetOffset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//set-offset")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//set-offset")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//set-offset")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "container-split-ptr//set-offset")
			}
			arg0Val.SetOffset(arg1Val)
			return arg0
		},
	},
	"container-split-ptr//trailing!": {
		Doc:   "Set *container.Split Trailing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//trailing!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//trailing!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//trailing!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Trailing, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split-ptr//trailing!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split-ptr//trailing!")
				}
				self.Trailing = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split-ptr//trailing!")
			}
			return arg0
		},
	},
	"container-split-ptr//trailing?": {
		Doc:   "Get *container.Split Trailing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//trailing?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//trailing?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split-ptr//trailing?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Trailing, "fyne-canvas-object")
			return resObj
		},
	},
	"container-split//hidden!": {
		Doc:   "Set container.Split Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-split//hidden!")
			}
			return arg0
		},
	},
	"container-split//hidden?": {
		Doc:   "Get container.Split Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"container-split//horizontal!": {
		Doc:   "Set container.Split Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//horizontal!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "container-split//horizontal!")
			}
			return arg0
		},
	},
	"container-split//horizontal?": {
		Doc:   "Get container.Split Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//horizontal?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"container-split//leading!": {
		Doc:   "Set container.Split Leading value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//leading!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//leading!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Leading, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split//leading!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split//leading!")
				}
				self.Leading = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split//leading!")
			}
			return arg0
		},
	},
	"container-split//leading?": {
		Doc:   "Get container.Split Leading value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//leading?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//leading?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Leading, "fyne-canvas-object")
			return resObj
		},
	},
	"container-split//offset!": {
		Doc:   "Set container.Split Offset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//offset!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//offset!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Offset = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "container-split//offset!")
			}
			return arg0
		},
	},
	"container-split//offset?": {
		Doc:   "Get container.Split Offset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//offset?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//offset?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Offset))
			return resObj
		},
	},
	"container-split//trailing!": {
		Doc:   "Set container.Split Trailing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//trailing!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//trailing!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Trailing, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split//trailing!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split//trailing!")
				}
				self.Trailing = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-split//trailing!")
			}
			return arg0
		},
	},
	"container-split//trailing?": {
		Doc:   "Get container.Split Trailing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.Split
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.Split)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//trailing?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-split//trailing?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Trailing, "fyne-canvas-object")
			return resObj
		},
	},
	"container-stack": {
		Doc:   "container.NewStack",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-stack")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-stack")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-stack")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-stack")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-stack")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-stack")
			}
			res0 := container.NewStack(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-tab-item": {
		Doc:   "container.NewTabItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "container-tab-item")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item")
			}
			res0 := container.NewTabItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-tab-item-ptr")
			return res0Obj
		},
	},
	"container-tab-item-ptr//content!": {
		Doc:   "Set *container.TabItem Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item-ptr//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item-ptr//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item-ptr//content!")
			}
			return arg0
		},
	},
	"container-tab-item-ptr//content?": {
		Doc:   "Get *container.TabItem Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
			return resObj
		},
	},
	"container-tab-item-ptr//disabled": {
		Doc:   "(*container.TabItem).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"container-tab-item-ptr//icon!": {
		Doc:   "Set *container.TabItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//icon!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item-ptr//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item-ptr//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item-ptr//icon!")
			}
			return arg0
		},
	},
	"container-tab-item-ptr//icon?": {
		Doc:   "Get *container.TabItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//icon?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//icon?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
			return resObj
		},
	},
	"container-tab-item-ptr//text!": {
		Doc:   "Set *container.TabItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "container-tab-item-ptr//text!")
			}
			return arg0
		},
	},
	"container-tab-item-ptr//text?": {
		Doc:   "Get *container.TabItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"container-tab-item-with-icon": {
		Doc:   "container.NewTabItemWithIcon",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "container-tab-item-with-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item-with-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item-with-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item-with-icon")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "container-tab-item-with-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "container-tab-item-with-icon")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "container-tab-item-with-icon")
			}
			res0 := container.NewTabItemWithIcon(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-tab-item-ptr")
			return res0Obj
		},
	},
	"container-tab-item//content!": {
		Doc:   "Set container.TabItem Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item//content!")
			}
			return arg0
		},
	},
	"container-tab-item//content?": {
		Doc:   "Get container.TabItem Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
			return resObj
		},
	},
	"container-tab-item//icon!": {
		Doc:   "Set container.TabItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//icon!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-tab-item//icon!")
			}
			return arg0
		},
	},
	"container-tab-item//icon?": {
		Doc:   "Get container.TabItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//icon?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
			return resObj
		},
	},
	"container-tab-item//text!": {
		Doc:   "Set container.TabItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "container-tab-item//text!")
			}
			return arg0
		},
	},
	"container-tab-item//text?": {
		Doc:   "Get container.TabItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self container.TabItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(container.TabItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-tab-item//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"container-v-box": {
		Doc:   "container.NewVBox",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-v-box")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-v-box")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-v-box")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-v-box")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-v-box")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-v-box")
			}
			res0 := container.NewVBox(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"container-v-scroll": {
		Doc:   "container.NewVScroll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-v-scroll")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-v-scroll")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-v-scroll")
			}
			res0 := container.NewVScroll(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-scroll-ptr")
			return res0Obj
		},
	},
	"container-v-split": {
		Doc:   "container.NewVSplit",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-v-split")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-v-split")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "container-v-split")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-v-split")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-v-split")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "container-v-split")
			}
			res0 := container.NewVSplit(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "container-split-ptr")
			return res0Obj
		},
	},
	"container-without-layout": {
		Doc:   "container.NewWithoutLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "container-without-layout")
			}
			res0 := container.NewWithoutLayout(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"desktop-app//set-system-tray-icon": {
		Doc:   "desktop.App.SetSystemTrayIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-app//set-system-tray-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-app//set-system-tray-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-app//set-system-tray-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-app//set-system-tray-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-app//set-system-tray-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-app//set-system-tray-icon")
			}
			arg0Val.SetSystemTrayIcon(arg1Val)
			return arg0
		},
	},
	"desktop-app//set-system-tray-menu": {
		Doc:   "desktop.App.SetSystemTrayMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-app//set-system-tray-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-app//set-system-tray-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-app//set-system-tray-menu")
			}
			var arg1Val *fyne.Menu
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-app//set-system-tray-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-app//set-system-tray-menu")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-app//set-system-tray-menu")
			}
			arg0Val.SetSystemTrayMenu(arg1Val)
			return arg0
		},
	},
	"desktop-canvas//on-key-down": {
		Doc:   "desktop.Canvas.OnKeyDown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//on-key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//on-key-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//on-key-down")
			}
			res0 := arg0Val.OnKeyDown()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "--go-any-func--")
			return res0Obj
		},
	},
	"desktop-canvas//on-key-up": {
		Doc:   "desktop.Canvas.OnKeyUp",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//on-key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//on-key-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//on-key-up")
			}
			res0 := arg0Val.OnKeyUp()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "--go-any-func--")
			return res0Obj
		},
	},
	"desktop-canvas//set-on-key-down": {
		Doc:   "desktop.Canvas.SetOnKeyDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//set-on-key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//set-on-key-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//set-on-key-down")
			}
			var arg1Val func(*fyne.KeyEvent)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "desktop-canvas//set-on-key-down")
				}
				arg1Val = func(arg0 *fyne.KeyEvent) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-key-event-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "desktop-canvas//set-on-key-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "desktop-canvas//set-on-key-down")
			}
			arg0Val.SetOnKeyDown(arg1Val)
			return arg0
		},
	},
	"desktop-canvas//set-on-key-up": {
		Doc:   "desktop.Canvas.SetOnKeyUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//set-on-key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//set-on-key-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-canvas//set-on-key-up")
			}
			var arg1Val func(*fyne.KeyEvent)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "desktop-canvas//set-on-key-up")
				}
				arg1Val = func(arg0 *fyne.KeyEvent) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-key-event-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "desktop-canvas//set-on-key-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "desktop-canvas//set-on-key-up")
			}
			arg0Val.SetOnKeyUp(arg1Val)
			return arg0
		},
	},
	"desktop-cursor//image": {
		Doc:   "desktop.Cursor.Image",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Cursor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Cursor)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-cursor//image")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-cursor//image")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-cursor//image")
			}
			res0, res1, res2 := arg0Val.Image()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
				"3": res2Obj,
			})
		},
	},
	"desktop-cursorable//cursor": {
		Doc:   "desktop.Cursorable.Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Cursorable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Cursorable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-cursorable//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-cursorable//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-cursorable//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
			return res0Obj
		},
	},
	"desktop-custom-shortcut-ptr//key": {
		Doc:   "(*desktop.CustomShortcut).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-name")
			return res0Obj
		},
	},
	"desktop-custom-shortcut-ptr//mod": {
		Doc:   "(*desktop.CustomShortcut).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-modifier")
			return res0Obj
		},
	},
	"desktop-custom-shortcut-ptr//modifier!": {
		Doc:   "Set *desktop.CustomShortcut Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//modifier!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//modifier!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//modifier!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Modifier, ok = v.Value.(fyne.KeyModifier)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//modifier!")
			}
			return arg0
		},
	},
	"desktop-custom-shortcut-ptr//modifier?": {
		Doc:   "Get *desktop.CustomShortcut Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//modifier?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//modifier?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//modifier?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Modifier, "fyne-key-modifier")
			return resObj
		},
	},
	"desktop-custom-shortcut-ptr//shortcut-name": {
		Doc:   "(*desktop.CustomShortcut).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut-ptr//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"desktop-custom-shortcut//modifier!": {
		Doc:   "Set desktop.CustomShortcut Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut//modifier!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Modifier, ok = v.Value.(fyne.KeyModifier)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-custom-shortcut//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-custom-shortcut//modifier!")
			}
			return arg0
		},
	},
	"desktop-custom-shortcut//modifier?": {
		Doc:   "Get desktop.CustomShortcut Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.CustomShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.CustomShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut//modifier?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-custom-shortcut//modifier?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Modifier, "fyne-key-modifier")
			return resObj
		},
	},
	"desktop-driver//create-splash-window": {
		Doc:   "desktop.Driver.CreateSplashWindow",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-driver//create-splash-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-driver//create-splash-window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-driver//create-splash-window")
			}
			res0 := arg0Val.CreateSplashWindow()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-window")
			return res0Obj
		},
	},
	"desktop-driver//current-key-modifiers": {
		Doc:   "desktop.Driver.CurrentKeyModifiers",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-driver//current-key-modifiers")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-driver//current-key-modifiers")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-driver//current-key-modifiers")
			}
			res0 := arg0Val.CurrentKeyModifiers()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-modifier")
			return res0Obj
		},
	},
	"desktop-hoverable//mouse-in": {
		Doc:   "desktop.Hoverable.MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Hoverable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Hoverable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-hoverable//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-hoverable//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-hoverable//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-hoverable//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-hoverable//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-hoverable//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"desktop-hoverable//mouse-moved": {
		Doc:   "desktop.Hoverable.MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Hoverable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Hoverable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-hoverable//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-hoverable//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-hoverable//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-hoverable//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-hoverable//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-hoverable//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"desktop-hoverable//mouse-out": {
		Doc:   "desktop.Hoverable.MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Hoverable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Hoverable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-hoverable//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-hoverable//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-hoverable//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"desktop-mouse-event-ptr//absolute-position!": {
		Doc:   "Set *desktop.MouseEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//absolute-position!")
			}
			return arg0
		},
	},
	"desktop-mouse-event-ptr//absolute-position?": {
		Doc:   "Get *desktop.MouseEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"desktop-mouse-event-ptr//button!": {
		Doc:   "Set *desktop.MouseEvent Button value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//button!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//button!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//button!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Button, ok = v.Value.(desktop.MouseButton)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//button!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//button!")
			}
			return arg0
		},
	},
	"desktop-mouse-event-ptr//button?": {
		Doc:   "Get *desktop.MouseEvent Button value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//button?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//button?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//button?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Button, "desktop-mouse-button")
			return resObj
		},
	},
	"desktop-mouse-event-ptr//modifier!": {
		Doc:   "Set *desktop.MouseEvent Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//modifier!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//modifier!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//modifier!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Modifier, ok = v.Value.(fyne.KeyModifier)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//modifier!")
			}
			return arg0
		},
	},
	"desktop-mouse-event-ptr//modifier?": {
		Doc:   "Get *desktop.MouseEvent Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//modifier?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//modifier?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//modifier?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Modifier, "fyne-key-modifier")
			return resObj
		},
	},
	"desktop-mouse-event-ptr//position!": {
		Doc:   "Set *desktop.MouseEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//position!")
			}
			return arg0
		},
	},
	"desktop-mouse-event-ptr//position?": {
		Doc:   "Get *desktop.MouseEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event-ptr//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"desktop-mouse-event//absolute-position!": {
		Doc:   "Set desktop.MouseEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event//absolute-position!")
			}
			return arg0
		},
	},
	"desktop-mouse-event//absolute-position?": {
		Doc:   "Get desktop.MouseEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"desktop-mouse-event//button!": {
		Doc:   "Set desktop.MouseEvent Button value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//button!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//button!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Button, ok = v.Value.(desktop.MouseButton)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event//button!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event//button!")
			}
			return arg0
		},
	},
	"desktop-mouse-event//button?": {
		Doc:   "Get desktop.MouseEvent Button value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//button?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//button?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Button, "desktop-mouse-button")
			return resObj
		},
	},
	"desktop-mouse-event//modifier!": {
		Doc:   "Set desktop.MouseEvent Modifier value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//modifier!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Modifier, ok = v.Value.(fyne.KeyModifier)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event//modifier!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event//modifier!")
			}
			return arg0
		},
	},
	"desktop-mouse-event//modifier?": {
		Doc:   "Get desktop.MouseEvent Modifier value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//modifier?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//modifier?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Modifier, "fyne-key-modifier")
			return resObj
		},
	},
	"desktop-mouse-event//position!": {
		Doc:   "Set desktop.MouseEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouse-event//position!")
			}
			return arg0
		},
	},
	"desktop-mouse-event//position?": {
		Doc:   "Get desktop.MouseEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self desktop.MouseEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouse-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"desktop-mouseable//mouse-down": {
		Doc:   "desktop.Mouseable.MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Mouseable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Mouseable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouseable//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouseable//mouse-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouseable//mouse-down")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouseable//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouseable//mouse-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouseable//mouse-down")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"desktop-mouseable//mouse-up": {
		Doc:   "desktop.Mouseable.MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.Mouseable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.Mouseable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouseable//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouseable//mouse-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-mouseable//mouse-up")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouseable//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouseable//mouse-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "desktop-mouseable//mouse-up")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"desktop-standard-cursor//image": {
		Doc:   "desktop.StandardCursor.Image",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val desktop.StandardCursor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(desktop.StandardCursor)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-standard-cursor//image")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "desktop-standard-cursor//image")
			}
			res0, res1, res2 := arg0Val.Image()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewInteger(int64(res2))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
				"3": res2Obj,
			})
		},
	},
	"dialog-color-picker": {
		Doc:   "dialog.NewColorPicker",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-color-picker")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-color-picker")
			}
			var arg2Val func(color.Color)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-color-picker")
				}
				arg2Val = func(arg0 color.Color) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "color-color")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "dialog-color-picker")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-color-picker")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-color-picker")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-color-picker")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-color-picker")
			}
			res0 := dialog.NewColorPicker(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-color-picker-dialog-ptr")
			return res0Obj
		},
	},
	"dialog-color-picker-dialog-ptr//advanced!": {
		Doc:   "Set *dialog.ColorPickerDialog Advanced value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//advanced!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//advanced!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//advanced!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Advanced = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "dialog-color-picker-dialog-ptr//advanced!")
			}
			return arg0
		},
	},
	"dialog-color-picker-dialog-ptr//advanced?": {
		Doc:   "Get *dialog.ColorPickerDialog Advanced value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//advanced?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//advanced?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//advanced?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Advanced))
			return resObj
		},
	},
	"dialog-color-picker-dialog-ptr//refresh": {
		Doc:   "(*dialog.ColorPickerDialog).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"dialog-color-picker-dialog-ptr//set-color": {
		Doc:   "(*dialog.ColorPickerDialog).SetColor",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//set-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//set-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//set-color")
			}
			var arg1Val color.Color
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//set-color")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//set-color")
			}
			arg0Val.SetColor(arg1Val)
			return arg0
		},
	},
	"dialog-color-picker-dialog-ptr//show": {
		Doc:   "(*dialog.ColorPickerDialog).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"dialog-color-picker-dialog//advanced!": {
		Doc:   "Set dialog.ColorPickerDialog Advanced value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog//advanced!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog//advanced!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Advanced = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "dialog-color-picker-dialog//advanced!")
			}
			return arg0
		},
	},
	"dialog-color-picker-dialog//advanced?": {
		Doc:   "Get dialog.ColorPickerDialog Advanced value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self dialog.ColorPickerDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(dialog.ColorPickerDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog//advanced?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-color-picker-dialog//advanced?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Advanced))
			return resObj
		},
	},
	"dialog-confirm": {
		Doc:   "dialog.NewConfirm",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-confirm")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-confirm")
			}
			var arg2Val func(bool)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-confirm")
				}
				arg2Val = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "dialog-confirm")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-confirm")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-confirm")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-confirm")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-confirm")
			}
			res0 := dialog.NewConfirm(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-confirm-dialog-ptr")
			return res0Obj
		},
	},
	"dialog-confirm-dialog-ptr//set-confirm-importance": {
		Doc:   "(*dialog.ConfirmDialog).SetConfirmImportance",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ConfirmDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ConfirmDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-confirm-dialog-ptr//set-confirm-importance")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-confirm-dialog-ptr//set-confirm-importance")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-confirm-dialog-ptr//set-confirm-importance")
			}
			var arg1Val widget.Importance
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-confirm-dialog-ptr//set-confirm-importance")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-confirm-dialog-ptr//set-confirm-importance")
			}
			arg0Val.SetConfirmImportance(arg1Val)
			return arg0
		},
	},
	"dialog-confirm-dialog-ptr//set-confirm-text": {
		Doc:   "(*dialog.ConfirmDialog).SetConfirmText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ConfirmDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ConfirmDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-confirm-dialog-ptr//set-confirm-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-confirm-dialog-ptr//set-confirm-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-confirm-dialog-ptr//set-confirm-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-confirm-dialog-ptr//set-confirm-text")
			}
			arg0Val.SetConfirmText(arg1Val)
			return arg0
		},
	},
	"dialog-custom": {
		Doc:   "dialog.NewCustom",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-custom")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-custom")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-custom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-custom")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-custom")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-custom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-custom")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-custom")
			}
			res0 := dialog.NewCustom(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-custom-dialog-ptr")
			return res0Obj
		},
	},
	"dialog-custom-dialog-ptr//set-buttons": {
		Doc:   "(*dialog.CustomDialog).SetButtons",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.CustomDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.CustomDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-custom-dialog-ptr//set-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-custom-dialog-ptr//set-buttons")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-custom-dialog-ptr//set-buttons")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "dialog-custom-dialog-ptr//set-buttons")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "dialog-custom-dialog-ptr//set-buttons")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "dialog-custom-dialog-ptr//set-buttons")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "dialog-custom-dialog-ptr//set-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "dialog-custom-dialog-ptr//set-buttons")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "dialog-custom-dialog-ptr//set-buttons")
			}
			arg0Val.SetButtons(arg1Val)
			return arg0
		},
	},
	"dialog-custom-without-buttons": {
		Doc:   "dialog.NewCustomWithoutButtons",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-custom-without-buttons")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-custom-without-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-custom-without-buttons")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-custom-without-buttons")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-custom-without-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-custom-without-buttons")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-custom-without-buttons")
			}
			res0 := dialog.NewCustomWithoutButtons(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-custom-dialog-ptr")
			return res0Obj
		},
	},
	"dialog-dialog//hide": {
		Doc:   "dialog.Dialog.Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"dialog-dialog//min-size": {
		Doc:   "dialog.Dialog.MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"dialog-dialog//refresh": {
		Doc:   "dialog.Dialog.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"dialog-dialog//resize": {
		Doc:   "dialog.Dialog.Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-dialog//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-dialog//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"dialog-dialog//set-dismiss-text": {
		Doc:   "dialog.Dialog.SetDismissText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//set-dismiss-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//set-dismiss-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//set-dismiss-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-dialog//set-dismiss-text")
			}
			arg0Val.SetDismissText(arg1Val)
			return arg0
		},
	},
	"dialog-dialog//set-on-closed": {
		Doc:   "dialog.Dialog.SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//set-on-closed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//set-on-closed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//set-on-closed")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "dialog-dialog//set-on-closed")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "dialog-dialog//set-on-closed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "dialog-dialog//set-on-closed")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"dialog-dialog//show": {
		Doc:   "dialog.Dialog.Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val dialog.Dialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(dialog.Dialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-dialog//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"dialog-entry-dialog": {
		Doc:   "dialog.NewEntryDialog",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-entry-dialog")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-entry-dialog")
			}
			var arg2Val func(string)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-entry-dialog")
				}
				arg2Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "dialog-entry-dialog")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-entry-dialog")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-entry-dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-entry-dialog")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-entry-dialog")
			}
			res0 := dialog.NewEntryDialog(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-entry-dialog-ptr")
			return res0Obj
		},
	},
	"dialog-entry-dialog-ptr//set-on-closed": {
		Doc:   "(*dialog.EntryDialog).SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-entry-dialog-ptr//set-on-closed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-entry-dialog-ptr//set-on-closed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-entry-dialog-ptr//set-on-closed")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "dialog-entry-dialog-ptr//set-on-closed")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "dialog-entry-dialog-ptr//set-on-closed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "dialog-entry-dialog-ptr//set-on-closed")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"dialog-entry-dialog-ptr//set-placeholder": {
		Doc:   "(*dialog.EntryDialog).SetPlaceholder",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-entry-dialog-ptr//set-placeholder")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-entry-dialog-ptr//set-placeholder")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-entry-dialog-ptr//set-placeholder")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-entry-dialog-ptr//set-placeholder")
			}
			arg0Val.SetPlaceholder(arg1Val)
			return arg0
		},
	},
	"dialog-entry-dialog-ptr//set-text": {
		Doc:   "(*dialog.EntryDialog).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.EntryDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.EntryDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-entry-dialog-ptr//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-entry-dialog-ptr//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-entry-dialog-ptr//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-entry-dialog-ptr//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"dialog-error": {
		Doc:   "dialog.NewError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val error
			if v, ok := arg0.(env.Error); ok {
				arg0Val = errors.New(v.Print(*ps.Idx))
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.ErrorType}, "dialog-error")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-error")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-error")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-error")
			}
			res0 := dialog.NewError(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-dialog")
			return res0Obj
		},
	},
	"dialog-folder-open": {
		Doc:   "dialog.NewFolderOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.ListableURI, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "dialog-folder-open")
				}
				arg0Val = func(arg0 fyne.ListableURI, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-listable-uri")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "dialog-folder-open")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "dialog-folder-open")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-folder-open")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-folder-open")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-folder-open")
			}
			res0 := dialog.NewFolderOpen(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-file-dialog-ptr")
			return res0Obj
		},
	},
	"dialog-form-dialog-ptr//submit": {
		Doc:   "(*dialog.FormDialog).Submit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.FormDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.FormDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-form-dialog-ptr//submit")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-form-dialog-ptr//submit")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-form-dialog-ptr//submit")
			}
			arg0Val.Submit()
			return arg0
		},
	},
	"dialog-information": {
		Doc:   "dialog.NewInformation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-information")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-information")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-information")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-information")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-information")
			}
			res0 := dialog.NewInformation(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-dialog")
			return res0Obj
		},
	},
	"dialog-progress": {
		Doc:   "dialog.NewProgress",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-progress")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-progress")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-progress")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-progress")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-progress")
			}
			res0 := dialog.NewProgress(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-progress-dialog-ptr")
			return res0Obj
		},
	},
	"dialog-progress-dialog-ptr//set-value": {
		Doc:   "(*dialog.ProgressDialog).SetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ProgressDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ProgressDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-progress-dialog-ptr//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-progress-dialog-ptr//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-progress-dialog-ptr//set-value")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "dialog-progress-dialog-ptr//set-value")
			}
			arg0Val.SetValue(arg1Val)
			return arg0
		},
	},
	"dialog-progress-infinite": {
		Doc:   "dialog.NewProgressInfinite",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-progress-infinite")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-progress-infinite")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-progress-infinite")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-progress-infinite")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-progress-infinite")
			}
			res0 := dialog.NewProgressInfinite(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "dialog-progress-infinite-dialog-ptr")
			return res0Obj
		},
	},
	"dialog-progress-infinite-dialog-ptr//hide": {
		Doc:   "(*dialog.ProgressInfiniteDialog).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *dialog.ProgressInfiniteDialog
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*dialog.ProgressInfiniteDialog)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-progress-infinite-dialog-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-progress-infinite-dialog-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "dialog-progress-infinite-dialog-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"dialog-show-color-picker": {
		Doc:   "dialog.ShowColorPicker",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-show-color-picker")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-show-color-picker")
			}
			var arg2Val func(color.Color)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-show-color-picker")
				}
				arg2Val = func(arg0 color.Color) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "color-color")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "dialog-show-color-picker")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-show-color-picker")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-color-picker")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-color-picker")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-color-picker")
			}
			dialog.ShowColorPicker(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"dialog-show-confirm": {
		Doc:   "dialog.ShowConfirm",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-show-confirm")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-show-confirm")
			}
			var arg2Val func(bool)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-show-confirm")
				}
				arg2Val = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "dialog-show-confirm")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-show-confirm")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-confirm")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-confirm")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-confirm")
			}
			dialog.ShowConfirm(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"dialog-show-custom": {
		Doc:   "dialog.ShowCustom",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-show-custom")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-show-custom")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-show-custom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-show-custom")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-show-custom")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-custom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-custom")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-custom")
			}
			dialog.ShowCustom(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"dialog-show-custom-without-buttons": {
		Doc:   "dialog.ShowCustomWithoutButtons",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-show-custom-without-buttons")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-show-custom-without-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-show-custom-without-buttons")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-show-custom-without-buttons")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-show-custom-without-buttons")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-show-custom-without-buttons")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-show-custom-without-buttons")
			}
			dialog.ShowCustomWithoutButtons(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"dialog-show-entry-dialog": {
		Doc:   "dialog.ShowEntryDialog",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-show-entry-dialog")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-show-entry-dialog")
			}
			var arg2Val func(string)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-show-entry-dialog")
				}
				arg2Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "dialog-show-entry-dialog")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "dialog-show-entry-dialog")
			}
			var arg3Val fyne.Window
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-entry-dialog")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-entry-dialog")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "dialog-show-entry-dialog")
			}
			dialog.ShowEntryDialog(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"dialog-show-error": {
		Doc:   "dialog.ShowError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val error
			if v, ok := arg0.(env.Error); ok {
				arg0Val = errors.New(v.Print(*ps.Idx))
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.ErrorType}, "dialog-show-error")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-show-error")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-show-error")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-show-error")
			}
			dialog.ShowError(arg0Val, arg1Val)
			return nil
		},
	},
	"dialog-show-folder-open": {
		Doc:   "dialog.ShowFolderOpen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func(fyne.ListableURI, error)
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "dialog-show-folder-open")
				}
				arg0Val = func(arg0 fyne.ListableURI, arg1 error) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-listable-uri")
					arg1Val = *env.NewError(arg1.Error())
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "dialog-show-folder-open")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "dialog-show-folder-open")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-show-folder-open")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-show-folder-open")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "dialog-show-folder-open")
			}
			dialog.ShowFolderOpen(arg0Val, arg1Val)
			return nil
		},
	},
	"dialog-show-information": {
		Doc:   "dialog.ShowInformation",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "dialog-show-information")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "dialog-show-information")
			}
			var arg2Val fyne.Window
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-show-information")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-show-information")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "dialog-show-information")
			}
			dialog.ShowInformation(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"driver-android-context-ptr//ctx!": {
		Doc:   "Set *driver.AndroidContext Ctx value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//ctx!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//ctx!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//ctx!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Ctx, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context-ptr//ctx!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context-ptr//ctx!")
			}
			return arg0
		},
	},
	"driver-android-context-ptr//ctx?": {
		Doc:   "Get *driver.AndroidContext Ctx value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//ctx?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//ctx?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//ctx?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Ctx, "uintptr")
			return resObj
		},
	},
	"driver-android-context-ptr//env!": {
		Doc:   "Set *driver.AndroidContext Env value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//env!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//env!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//env!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Env, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context-ptr//env!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context-ptr//env!")
			}
			return arg0
		},
	},
	"driver-android-context-ptr//env?": {
		Doc:   "Get *driver.AndroidContext Env value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//env?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//env?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//env?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Env, "uintptr")
			return resObj
		},
	},
	"driver-android-context-ptr//vm!": {
		Doc:   "Set *driver.AndroidContext VM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//vm!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//vm!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//vm!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.VM, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context-ptr//vm!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context-ptr//vm!")
			}
			return arg0
		},
	},
	"driver-android-context-ptr//vm?": {
		Doc:   "Get *driver.AndroidContext VM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//vm?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//vm?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context-ptr//vm?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.VM, "uintptr")
			return resObj
		},
	},
	"driver-android-context//ctx!": {
		Doc:   "Set driver.AndroidContext Ctx value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//ctx!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//ctx!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Ctx, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context//ctx!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context//ctx!")
			}
			return arg0
		},
	},
	"driver-android-context//ctx?": {
		Doc:   "Get driver.AndroidContext Ctx value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//ctx?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//ctx?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Ctx, "uintptr")
			return resObj
		},
	},
	"driver-android-context//env!": {
		Doc:   "Set driver.AndroidContext Env value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//env!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//env!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Env, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context//env!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context//env!")
			}
			return arg0
		},
	},
	"driver-android-context//env?": {
		Doc:   "Get driver.AndroidContext Env value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//env?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//env?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Env, "uintptr")
			return resObj
		},
	},
	"driver-android-context//vm!": {
		Doc:   "Set driver.AndroidContext VM value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//vm!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//vm!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.VM, ok = v.Value.(uintptr)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context//vm!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "driver-android-context//vm!")
			}
			return arg0
		},
	},
	"driver-android-context//vm?": {
		Doc:   "Get driver.AndroidContext VM value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self driver.AndroidContext
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(driver.AndroidContext)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//vm?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "driver-android-context//vm?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.VM, "uintptr")
			return resObj
		},
	},
	"fyne-animation": {
		Doc:   "fyne.NewAnimation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val time.Duration
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation")
			}
			var arg1Val func(float32)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-animation")
				}
				arg1Val = func(arg0 float32) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-animation")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-animation")
			}
			res0 := fyne.NewAnimation(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-animation-ptr")
			return res0Obj
		},
	},
	"fyne-animation-ptr//auto-reverse!": {
		Doc:   "Set *fyne.Animation AutoReverse value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//auto-reverse!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//auto-reverse!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//auto-reverse!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AutoReverse = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-animation-ptr//auto-reverse!")
			}
			return arg0
		},
	},
	"fyne-animation-ptr//auto-reverse?": {
		Doc:   "Get *fyne.Animation AutoReverse value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//auto-reverse?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//auto-reverse?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//auto-reverse?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AutoReverse))
			return resObj
		},
	},
	"fyne-animation-ptr//curve!": {
		Doc:   "Set *fyne.Animation Curve value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//curve!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//curve!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//curve!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Curve, ok = v.Value.(fyne.AnimationCurve)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-animation-ptr//curve!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-animation-ptr//curve!")
			}
			return arg0
		},
	},
	"fyne-animation-ptr//curve?": {
		Doc:   "Get *fyne.Animation Curve value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//curve?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//curve?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//curve?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Curve, "fyne-animation-curve")
			return resObj
		},
	},
	"fyne-animation-ptr//duration!": {
		Doc:   "Set *fyne.Animation Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//duration!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//duration!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//duration!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-animation-ptr//duration!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-animation-ptr//duration!")
			}
			return arg0
		},
	},
	"fyne-animation-ptr//duration?": {
		Doc:   "Get *fyne.Animation Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//duration?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//duration?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//duration?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"fyne-animation-ptr//repeat-count!": {
		Doc:   "Set *fyne.Animation RepeatCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//repeat-count!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//repeat-count!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//repeat-count!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.RepeatCount = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-animation-ptr//repeat-count!")
			}
			return arg0
		},
	},
	"fyne-animation-ptr//repeat-count?": {
		Doc:   "Get *fyne.Animation RepeatCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//repeat-count?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//repeat-count?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//repeat-count?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.RepeatCount))
			return resObj
		},
	},
	"fyne-animation-ptr//start": {
		Doc:   "(*fyne.Animation).Start",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//start")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//start")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//start")
			}
			arg0Val.Start()
			return arg0
		},
	},
	"fyne-animation-ptr//stop": {
		Doc:   "(*fyne.Animation).Stop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//stop")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//stop")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//stop")
			}
			arg0Val.Stop()
			return arg0
		},
	},
	"fyne-animation-ptr//tick!": {
		Doc:   "Set *fyne.Animation Tick value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//tick!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//tick!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//tick!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-animation-ptr//tick!")
				}
				self.Tick = func(arg0 float32) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-animation-ptr//tick!")
				}
				self.Tick = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-animation-ptr//tick!")
			}
			return arg0
		},
	},
	"fyne-animation-ptr//tick?": {
		Doc:   "Get *fyne.Animation Tick value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//tick?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//tick?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation-ptr//tick?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Tick, "--go-any-func--")
			return resObj
		},
	},
	"fyne-animation//auto-reverse!": {
		Doc:   "Set fyne.Animation AutoReverse value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//auto-reverse!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//auto-reverse!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.AutoReverse = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-animation//auto-reverse!")
			}
			return arg0
		},
	},
	"fyne-animation//auto-reverse?": {
		Doc:   "Get fyne.Animation AutoReverse value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//auto-reverse?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//auto-reverse?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.AutoReverse))
			return resObj
		},
	},
	"fyne-animation//curve!": {
		Doc:   "Set fyne.Animation Curve value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//curve!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//curve!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Curve, ok = v.Value.(fyne.AnimationCurve)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-animation//curve!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-animation//curve!")
			}
			return arg0
		},
	},
	"fyne-animation//curve?": {
		Doc:   "Get fyne.Animation Curve value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//curve?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//curve?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Curve, "fyne-animation-curve")
			return resObj
		},
	},
	"fyne-animation//duration!": {
		Doc:   "Set fyne.Animation Duration value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//duration!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//duration!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Duration, ok = v.Value.(time.Duration)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-animation//duration!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-animation//duration!")
			}
			return arg0
		},
	},
	"fyne-animation//duration?": {
		Doc:   "Get fyne.Animation Duration value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//duration?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//duration?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Duration, "time-duration")
			return resObj
		},
	},
	"fyne-animation//repeat-count!": {
		Doc:   "Set fyne.Animation RepeatCount value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//repeat-count!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//repeat-count!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.RepeatCount = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-animation//repeat-count!")
			}
			return arg0
		},
	},
	"fyne-animation//repeat-count?": {
		Doc:   "Get fyne.Animation RepeatCount value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//repeat-count?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//repeat-count?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.RepeatCount))
			return resObj
		},
	},
	"fyne-animation//tick!": {
		Doc:   "Set fyne.Animation Tick value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//tick!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//tick!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-animation//tick!")
				}
				self.Tick = func(arg0 float32) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-animation//tick!")
				}
				self.Tick = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-animation//tick!")
			}
			return arg0
		},
	},
	"fyne-animation//tick?": {
		Doc:   "Get fyne.Animation Tick value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Animation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//tick?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-animation//tick?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Tick, "--go-any-func--")
			return resObj
		},
	},
	"fyne-app//cloud-provider": {
		Doc:   "fyne.App.CloudProvider",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//cloud-provider")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//cloud-provider")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//cloud-provider")
			}
			res0 := arg0Val.CloudProvider()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-cloud-provider")
			return res0Obj
		},
	},
	"fyne-app//driver": {
		Doc:   "fyne.App.Driver",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//driver")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//driver")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//driver")
			}
			res0 := arg0Val.Driver()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-driver")
			return res0Obj
		},
	},
	"fyne-app//icon": {
		Doc:   "fyne.App.Icon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//icon")
			}
			res0 := arg0Val.Icon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-app//lifecycle": {
		Doc:   "fyne.App.Lifecycle",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//lifecycle")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//lifecycle")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//lifecycle")
			}
			res0 := arg0Val.Lifecycle()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-lifecycle")
			return res0Obj
		},
	},
	"fyne-app//metadata": {
		Doc:   "fyne.App.Metadata",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//metadata")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//metadata")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//metadata")
			}
			res0 := arg0Val.Metadata()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-app-metadata")
			return res0Obj
		},
	},
	"fyne-app//open-url": {
		Doc:   "fyne.App.OpenURL",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//open-url")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//open-url")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//open-url")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//open-url")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//open-url")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//open-url")
			}
			res0 := arg0Val.OpenURL(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"fyne-app//preferences": {
		Doc:   "fyne.App.Preferences",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//preferences")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//preferences")
			}
			res0 := arg0Val.Preferences()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-preferences")
			return res0Obj
		},
	},
	"fyne-app//quit": {
		Doc:   "fyne.App.Quit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//quit")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//quit")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//quit")
			}
			arg0Val.Quit()
			return arg0
		},
	},
	"fyne-app//run": {
		Doc:   "fyne.App.Run",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//run")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//run")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//run")
			}
			arg0Val.Run()
			return arg0
		},
	},
	"fyne-app//send-notification": {
		Doc:   "fyne.App.SendNotification",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//send-notification")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//send-notification")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//send-notification")
			}
			var arg1Val *fyne.Notification
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//send-notification")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//send-notification")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//send-notification")
			}
			arg0Val.SendNotification(arg1Val)
			return arg0
		},
	},
	"fyne-app//set-cloud-provider": {
		Doc:   "fyne.App.SetCloudProvider",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//set-cloud-provider")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//set-cloud-provider")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//set-cloud-provider")
			}
			var arg1Val fyne.CloudProvider
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//set-cloud-provider")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//set-cloud-provider")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//set-cloud-provider")
			}
			arg0Val.SetCloudProvider(arg1Val)
			return arg0
		},
	},
	"fyne-app//set-icon": {
		Doc:   "fyne.App.SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//set-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//set-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//set-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-app//set-icon")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"fyne-app//settings": {
		Doc:   "fyne.App.Settings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//settings")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//settings")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//settings")
			}
			res0 := arg0Val.Settings()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-settings")
			return res0Obj
		},
	},
	"fyne-app//storage": {
		Doc:   "fyne.App.Storage",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//storage")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//storage")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//storage")
			}
			res0 := arg0Val.Storage()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-storage")
			return res0Obj
		},
	},
	"fyne-app//unique-id": {
		Doc:   "fyne.App.UniqueID",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//unique-id")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//unique-id")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//unique-id")
			}
			res0 := arg0Val.UniqueID()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-app//window": {
		Doc:   "fyne.App.NewWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-app//window")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-app//window")
			}
			res0 := arg0Val.NewWindow(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-window")
			return res0Obj
		},
	},
	"fyne-canvas-object//hide": {
		Doc:   "fyne.CanvasObject.Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"fyne-canvas-object//min-size": {
		Doc:   "fyne.CanvasObject.MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-canvas-object//move": {
		Doc:   "fyne.CanvasObject.Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas-object//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas-object//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"fyne-canvas-object//position": {
		Doc:   "fyne.CanvasObject.Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-canvas-object//refresh": {
		Doc:   "fyne.CanvasObject.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"fyne-canvas-object//resize": {
		Doc:   "fyne.CanvasObject.Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas-object//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas-object//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"fyne-canvas-object//show": {
		Doc:   "fyne.CanvasObject.Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"fyne-canvas-object//size": {
		Doc:   "fyne.CanvasObject.Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-canvas-object//visible": {
		Doc:   "fyne.CanvasObject.Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas-object//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-canvas//add-shortcut": {
		Doc:   "fyne.Canvas.AddShortcut",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//add-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//add-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//add-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//add-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//add-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//add-shortcut")
			}
			var arg2Val func(fyne.Shortcut)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "fyne-canvas//add-shortcut")
				}
				arg2Val = func(arg0 fyne.Shortcut) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-shortcut")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-canvas//add-shortcut")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "fyne-canvas//add-shortcut")
			}
			arg0Val.AddShortcut(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-canvas//capture": {
		Doc:   "fyne.Canvas.Capture",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//capture")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//capture")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//capture")
			}
			res0 := arg0Val.Capture()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"fyne-canvas//content": {
		Doc:   "fyne.Canvas.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"fyne-canvas//focus": {
		Doc:   "fyne.Canvas.Focus",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focus")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focus")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focus")
			}
			var arg1Val fyne.Focusable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//focus")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//focus")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//focus")
			}
			arg0Val.Focus(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//focus-next": {
		Doc:   "fyne.Canvas.FocusNext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focus-next")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focus-next")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focus-next")
			}
			arg0Val.FocusNext()
			return arg0
		},
	},
	"fyne-canvas//focus-previous": {
		Doc:   "fyne.Canvas.FocusPrevious",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focus-previous")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focus-previous")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focus-previous")
			}
			arg0Val.FocusPrevious()
			return arg0
		},
	},
	"fyne-canvas//focused": {
		Doc:   "fyne.Canvas.Focused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focused")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focused")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//focused")
			}
			res0 := arg0Val.Focused()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-focusable")
			return res0Obj
		},
	},
	"fyne-canvas//interactive-area": {
		Doc:   "fyne.Canvas.InteractiveArea",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//interactive-area")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//interactive-area")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//interactive-area")
			}
			res0, res1 := arg0Val.InteractiveArea()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			var res1Obj env.Object
			res1Obj = *env.NewNative(ps.Idx, res1, "fyne-size")
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-canvas//on-typed-key": {
		Doc:   "fyne.Canvas.OnTypedKey",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//on-typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//on-typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//on-typed-key")
			}
			res0 := arg0Val.OnTypedKey()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "--go-any-func--")
			return res0Obj
		},
	},
	"fyne-canvas//on-typed-rune": {
		Doc:   "fyne.Canvas.OnTypedRune",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//on-typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//on-typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//on-typed-rune")
			}
			res0 := arg0Val.OnTypedRune()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "--go-any-func--")
			return res0Obj
		},
	},
	"fyne-canvas//overlays": {
		Doc:   "fyne.Canvas.Overlays",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//overlays")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//overlays")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//overlays")
			}
			res0 := arg0Val.Overlays()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-overlay-stack")
			return res0Obj
		},
	},
	"fyne-canvas//pixel-coordinate-for-position": {
		Doc:   "fyne.Canvas.PixelCoordinateForPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//pixel-coordinate-for-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//pixel-coordinate-for-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//pixel-coordinate-for-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//pixel-coordinate-for-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//pixel-coordinate-for-position")
			}
			res0, res1 := arg0Val.PixelCoordinateForPosition(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-canvas//refresh": {
		Doc:   "fyne.Canvas.Refresh",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//refresh")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//refresh")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//refresh")
			}
			arg0Val.Refresh(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//remove-shortcut": {
		Doc:   "fyne.Canvas.RemoveShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//remove-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//remove-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//remove-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//remove-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//remove-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//remove-shortcut")
			}
			arg0Val.RemoveShortcut(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//scale": {
		Doc:   "fyne.Canvas.Scale",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//scale")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//scale")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//scale")
			}
			res0 := arg0Val.Scale()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-canvas//set-content": {
		Doc:   "fyne.Canvas.SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//set-content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//set-content")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//set-content")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-canvas//set-content")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//set-on-typed-key": {
		Doc:   "fyne.Canvas.SetOnTypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//set-on-typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//set-on-typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//set-on-typed-key")
			}
			var arg1Val func(*fyne.KeyEvent)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-canvas//set-on-typed-key")
				}
				arg1Val = func(arg0 *fyne.KeyEvent) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-key-event-ptr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-canvas//set-on-typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-canvas//set-on-typed-key")
			}
			arg0Val.SetOnTypedKey(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//set-on-typed-rune": {
		Doc:   "fyne.Canvas.SetOnTypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//set-on-typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//set-on-typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//set-on-typed-rune")
			}
			var arg1Val func(rune)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-canvas//set-on-typed-rune")
				}
				arg1Val = func(arg0 rune) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "rune")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-canvas//set-on-typed-rune")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-canvas//set-on-typed-rune")
			}
			arg0Val.SetOnTypedRune(arg1Val)
			return arg0
		},
	},
	"fyne-canvas//size": {
		Doc:   "fyne.Canvas.Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-canvas//unfocus": {
		Doc:   "fyne.Canvas.Unfocus",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//unfocus")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//unfocus")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-canvas//unfocus")
			}
			arg0Val.Unfocus()
			return arg0
		},
	},
	"fyne-clipboard//content": {
		Doc:   "fyne.Clipboard.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Clipboard
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-clipboard//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-clipboard//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-clipboard//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-clipboard//set-content": {
		Doc:   "fyne.Clipboard.SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Clipboard
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-clipboard//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-clipboard//set-content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-clipboard//set-content")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-clipboard//set-content")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"fyne-cloud-provider-preferences//cloud-preferences": {
		Doc:   "fyne.CloudProviderPreferences.CloudPreferences",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProviderPreferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProviderPreferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider-preferences//cloud-preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider-preferences//cloud-preferences")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider-preferences//cloud-preferences")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider-preferences//cloud-preferences")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider-preferences//cloud-preferences")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider-preferences//cloud-preferences")
			}
			res0 := arg0Val.CloudPreferences(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-preferences")
			return res0Obj
		},
	},
	"fyne-cloud-provider-storage//cloud-storage": {
		Doc:   "fyne.CloudProviderStorage.CloudStorage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProviderStorage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProviderStorage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider-storage//cloud-storage")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider-storage//cloud-storage")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider-storage//cloud-storage")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider-storage//cloud-storage")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider-storage//cloud-storage")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider-storage//cloud-storage")
			}
			res0 := arg0Val.CloudStorage(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-storage")
			return res0Obj
		},
	},
	"fyne-cloud-provider//cleanup": {
		Doc:   "fyne.CloudProvider.Cleanup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//cleanup")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//cleanup")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//cleanup")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider//cleanup")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider//cleanup")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider//cleanup")
			}
			arg0Val.Cleanup(arg1Val)
			return arg0
		},
	},
	"fyne-cloud-provider//provider-description": {
		Doc:   "fyne.CloudProvider.ProviderDescription",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//provider-description")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//provider-description")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//provider-description")
			}
			res0 := arg0Val.ProviderDescription()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-cloud-provider//provider-icon": {
		Doc:   "fyne.CloudProvider.ProviderIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//provider-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//provider-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//provider-icon")
			}
			res0 := arg0Val.ProviderIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-cloud-provider//provider-name": {
		Doc:   "fyne.CloudProvider.ProviderName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//provider-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//provider-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//provider-name")
			}
			res0 := arg0Val.ProviderName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-cloud-provider//setup": {
		Doc:   "fyne.CloudProvider.Setup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CloudProvider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CloudProvider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//setup")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//setup")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-cloud-provider//setup")
			}
			var arg1Val fyne.App
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider//setup")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider//setup")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-cloud-provider//setup")
			}
			res0 := arg0Val.Setup(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"fyne-container": {
		Doc:   "fyne.NewContainer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container")
			}
			res0 := fyne.NewContainer(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"fyne-container-ptr//add": {
		Doc:   "(*fyne.Container).Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//add")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//add")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//add")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//add")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"fyne-container-ptr//add-object": {
		Doc:   "(*fyne.Container).AddObject",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//add-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//add-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//add-object")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//add-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//add-object")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//add-object")
			}
			arg0Val.AddObject(arg1Val)
			return arg0
		},
	},
	"fyne-container-ptr//hidden!": {
		Doc:   "Set *fyne.Container Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-container-ptr//hidden!")
			}
			return arg0
		},
	},
	"fyne-container-ptr//hidden?": {
		Doc:   "Get *fyne.Container Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"fyne-container-ptr//hide": {
		Doc:   "(*fyne.Container).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"fyne-container-ptr//layout!": {
		Doc:   "Set *fyne.Container Layout value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//layout!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//layout!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//layout!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Layout, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//layout!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//layout!")
				}
				self.Layout = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//layout!")
			}
			return arg0
		},
	},
	"fyne-container-ptr//layout?": {
		Doc:   "Get *fyne.Container Layout value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//layout?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//layout?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//layout?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Layout, "fyne-layout")
			return resObj
		},
	},
	"fyne-container-ptr//min-size": {
		Doc:   "(*fyne.Container).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-container-ptr//move": {
		Doc:   "(*fyne.Container).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"fyne-container-ptr//objects!": {
		Doc:   "Set *fyne.Container Objects value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//objects!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//objects!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//objects!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Objects = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Objects[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-ptr//objects!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-ptr//objects!")
						}
						self.Objects[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-ptr//objects!")
					}
				}
			case env.Native:
				var ok bool
				self.Objects, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-ptr//objects!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-ptr//objects!")
				}
				self.Objects = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-ptr//objects!")
			}
			return arg0
		},
	},
	"fyne-container-ptr//objects?": {
		Doc:   "Get *fyne.Container Objects value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//objects?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//objects?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//objects?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Objects, "fyne-canvas-object-arr")
			return resObj
		},
	},
	"fyne-container-ptr//position": {
		Doc:   "(*fyne.Container).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-container-ptr//refresh": {
		Doc:   "(*fyne.Container).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"fyne-container-ptr//remove": {
		Doc:   "(*fyne.Container).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//remove")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"fyne-container-ptr//remove-all": {
		Doc:   "(*fyne.Container).RemoveAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//remove-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//remove-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//remove-all")
			}
			arg0Val.RemoveAll()
			return arg0
		},
	},
	"fyne-container-ptr//resize": {
		Doc:   "(*fyne.Container).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"fyne-container-ptr//show": {
		Doc:   "(*fyne.Container).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"fyne-container-ptr//size": {
		Doc:   "(*fyne.Container).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-container-ptr//visible": {
		Doc:   "(*fyne.Container).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-ptr//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-container-with-layout": {
		Doc:   "fyne.NewContainerWithLayout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-with-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-with-layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container-with-layout")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-with-layout")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-with-layout")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-with-layout")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-with-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-with-layout")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container-with-layout")
			}
			res0 := fyne.NewContainerWithLayout(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"fyne-container-without-layout": {
		Doc:   "fyne.NewContainerWithoutLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container-without-layout")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container-without-layout")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container-without-layout")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container-without-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container-without-layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-container-without-layout")
			}
			res0 := fyne.NewContainerWithoutLayout(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-container-ptr")
			return res0Obj
		},
	},
	"fyne-container//hidden!": {
		Doc:   "Set fyne.Container Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-container//hidden!")
			}
			return arg0
		},
	},
	"fyne-container//hidden?": {
		Doc:   "Get fyne.Container Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"fyne-container//layout!": {
		Doc:   "Set fyne.Container Layout value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//layout!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//layout!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Layout, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container//layout!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container//layout!")
				}
				self.Layout = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-container//layout!")
			}
			return arg0
		},
	},
	"fyne-container//layout?": {
		Doc:   "Get fyne.Container Layout value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//layout?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//layout?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Layout, "fyne-layout")
			return resObj
		},
	},
	"fyne-container//objects!": {
		Doc:   "Set fyne.Container Objects value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//objects!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//objects!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Objects = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Objects[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container//objects!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container//objects!")
						}
						self.Objects[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container//objects!")
					}
				}
			case env.Native:
				var ok bool
				self.Objects, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container//objects!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container//objects!")
				}
				self.Objects = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-container//objects!")
			}
			return arg0
		},
	},
	"fyne-container//objects?": {
		Doc:   "Get fyne.Container Objects value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Container
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Container)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//objects?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-container//objects?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Objects, "fyne-canvas-object-arr")
			return resObj
		},
	},
	"fyne-current-app": {
		Doc:   "fyne.CurrentApp",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := fyne.CurrentApp()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-app")
			return res0Obj
		},
	},
	"fyne-current-device": {
		Doc:   "fyne.CurrentDevice",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := fyne.CurrentDevice()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-device")
			return res0Obj
		},
	},
	"fyne-delta": {
		Doc:   "fyne.NewDelta",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "fyne-delta")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-delta")
			}
			res0 := fyne.NewDelta(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-delta")
			return res0Obj
		},
	},
	"fyne-delta-ptr//dx!": {
		Doc:   "Set *fyne.Delta DX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dx!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dx!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dx!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DX = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-delta-ptr//dx!")
			}
			return arg0
		},
	},
	"fyne-delta-ptr//dx?": {
		Doc:   "Get *fyne.Delta DX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dx?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dx?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dx?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DX))
			return resObj
		},
	},
	"fyne-delta-ptr//dy!": {
		Doc:   "Set *fyne.Delta DY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dy!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dy!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dy!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DY = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-delta-ptr//dy!")
			}
			return arg0
		},
	},
	"fyne-delta-ptr//dy?": {
		Doc:   "Get *fyne.Delta DY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dy?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dy?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta-ptr//dy?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DY))
			return resObj
		},
	},
	"fyne-delta//components": {
		Doc:   "fyne.Delta.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//components")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//components")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-delta//dx!": {
		Doc:   "Set fyne.Delta DX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//dx!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//dx!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DX = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-delta//dx!")
			}
			return arg0
		},
	},
	"fyne-delta//dx?": {
		Doc:   "Get fyne.Delta DX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//dx?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//dx?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DX))
			return resObj
		},
	},
	"fyne-delta//dy!": {
		Doc:   "Set fyne.Delta DY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//dy!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//dy!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.DY = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-delta//dy!")
			}
			return arg0
		},
	},
	"fyne-delta//dy?": {
		Doc:   "Get fyne.Delta DY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//dy?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//dy?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.DY))
			return resObj
		},
	},
	"fyne-delta//is-zero": {
		Doc:   "fyne.Delta.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Delta
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//is-zero")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-delta//is-zero")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-device//has-keyboard": {
		Doc:   "fyne.Device.HasKeyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//has-keyboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//has-keyboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//has-keyboard")
			}
			res0 := arg0Val.HasKeyboard()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-device//is-browser": {
		Doc:   "fyne.Device.IsBrowser",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//is-browser")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//is-browser")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//is-browser")
			}
			res0 := arg0Val.IsBrowser()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-device//is-mobile": {
		Doc:   "fyne.Device.IsMobile",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//is-mobile")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//is-mobile")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//is-mobile")
			}
			res0 := arg0Val.IsMobile()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-device//orientation": {
		Doc:   "fyne.Device.Orientation",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//orientation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//orientation")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//orientation")
			}
			res0 := arg0Val.Orientation()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-device-orientation")
			return res0Obj
		},
	},
	"fyne-device//system-scale-for-window": {
		Doc:   "fyne.Device.SystemScaleForWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//system-scale-for-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//system-scale-for-window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-device//system-scale-for-window")
			}
			var arg1Val fyne.Window
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-device//system-scale-for-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-device//system-scale-for-window")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-device//system-scale-for-window")
			}
			res0 := arg0Val.SystemScaleForWindow(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-disableable//disable": {
		Doc:   "fyne.Disableable.Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Disableable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Disableable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-disableable//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-disableable//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-disableable//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"fyne-disableable//disabled": {
		Doc:   "fyne.Disableable.Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Disableable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Disableable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-disableable//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-disableable//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-disableable//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-disableable//enable": {
		Doc:   "fyne.Disableable.Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Disableable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Disableable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-disableable//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-disableable//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-disableable//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"fyne-double-tappable//double-tapped": {
		Doc:   "fyne.DoubleTappable.DoubleTapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.DoubleTappable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.DoubleTappable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-double-tappable//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-double-tappable//double-tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-double-tappable//double-tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-double-tappable//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-double-tappable//double-tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-double-tappable//double-tapped")
			}
			arg0Val.DoubleTapped(arg1Val)
			return arg0
		},
	},
	"fyne-drag-event-ptr//absolute-position!": {
		Doc:   "Set *fyne.DragEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event-ptr//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event-ptr//absolute-position!")
			}
			return arg0
		},
	},
	"fyne-drag-event-ptr//absolute-position?": {
		Doc:   "Get *fyne.DragEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"fyne-drag-event-ptr//dragged!": {
		Doc:   "Set *fyne.DragEvent Dragged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//dragged!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//dragged!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//dragged!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Dragged, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event-ptr//dragged!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event-ptr//dragged!")
			}
			return arg0
		},
	},
	"fyne-drag-event-ptr//dragged?": {
		Doc:   "Get *fyne.DragEvent Dragged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//dragged?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//dragged?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//dragged?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Dragged, "fyne-delta")
			return resObj
		},
	},
	"fyne-drag-event-ptr//position!": {
		Doc:   "Set *fyne.DragEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event-ptr//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event-ptr//position!")
			}
			return arg0
		},
	},
	"fyne-drag-event-ptr//position?": {
		Doc:   "Get *fyne.DragEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event-ptr//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"fyne-drag-event//absolute-position!": {
		Doc:   "Set fyne.DragEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event//absolute-position!")
			}
			return arg0
		},
	},
	"fyne-drag-event//absolute-position?": {
		Doc:   "Get fyne.DragEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"fyne-drag-event//dragged!": {
		Doc:   "Set fyne.DragEvent Dragged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//dragged!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//dragged!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Dragged, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event//dragged!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event//dragged!")
			}
			return arg0
		},
	},
	"fyne-drag-event//dragged?": {
		Doc:   "Get fyne.DragEvent Dragged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//dragged?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//dragged?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Dragged, "fyne-delta")
			return resObj
		},
	},
	"fyne-drag-event//position!": {
		Doc:   "Set fyne.DragEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-drag-event//position!")
			}
			return arg0
		},
	},
	"fyne-drag-event//position?": {
		Doc:   "Get fyne.DragEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.DragEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-drag-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"fyne-draggable//drag-end": {
		Doc:   "fyne.Draggable.DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Draggable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-draggable//drag-end")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-draggable//drag-end")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-draggable//drag-end")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"fyne-draggable//dragged": {
		Doc:   "fyne.Draggable.Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Draggable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-draggable//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-draggable//dragged")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-draggable//dragged")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-draggable//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-draggable//dragged")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-draggable//dragged")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"fyne-driver//absolute-position-for-object": {
		Doc:   "fyne.Driver.AbsolutePositionForObject",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//absolute-position-for-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//absolute-position-for-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//absolute-position-for-object")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//absolute-position-for-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//absolute-position-for-object")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//absolute-position-for-object")
			}
			res0 := arg0Val.AbsolutePositionForObject(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-driver//all-windows": {
		Doc:   "fyne.Driver.AllWindows",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//all-windows")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//all-windows")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//all-windows")
			}
			res0 := arg0Val.AllWindows()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-window-arr")
			return res0Obj
		},
	},
	"fyne-driver//canvas-for-object": {
		Doc:   "fyne.Driver.CanvasForObject",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//canvas-for-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//canvas-for-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//canvas-for-object")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//canvas-for-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//canvas-for-object")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//canvas-for-object")
			}
			res0 := arg0Val.CanvasForObject(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas")
			return res0Obj
		},
	},
	"fyne-driver//create-window": {
		Doc:   "fyne.Driver.CreateWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//create-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//create-window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//create-window")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-driver//create-window")
			}
			res0 := arg0Val.CreateWindow(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-window")
			return res0Obj
		},
	},
	"fyne-driver//device": {
		Doc:   "fyne.Driver.Device",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//device")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//device")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//device")
			}
			res0 := arg0Val.Device()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-device")
			return res0Obj
		},
	},
	"fyne-driver//quit": {
		Doc:   "fyne.Driver.Quit",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//quit")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//quit")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//quit")
			}
			arg0Val.Quit()
			return arg0
		},
	},
	"fyne-driver//rendered-text-size": {
		Doc:   "fyne.Driver.RenderedTextSize",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//rendered-text-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//rendered-text-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//rendered-text-size")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-driver//rendered-text-size")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "fyne-driver//rendered-text-size")
			}
			var arg3Val fyne.TextStyle
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "fyne-driver//rendered-text-size")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "fyne-driver//rendered-text-size")
			}
			res0, res1 := arg0Val.RenderedTextSize(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"size":     res0Obj,
				"baseline": res1Obj,
			})
		},
	},
	"fyne-driver//run": {
		Doc:   "fyne.Driver.Run",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//run")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//run")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//run")
			}
			arg0Val.Run()
			return arg0
		},
	},
	"fyne-driver//start-animation": {
		Doc:   "fyne.Driver.StartAnimation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//start-animation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//start-animation")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//start-animation")
			}
			var arg1Val *fyne.Animation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//start-animation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//start-animation")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//start-animation")
			}
			arg0Val.StartAnimation(arg1Val)
			return arg0
		},
	},
	"fyne-driver//stop-animation": {
		Doc:   "fyne.Driver.StopAnimation",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//stop-animation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//stop-animation")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-driver//stop-animation")
			}
			var arg1Val *fyne.Animation
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.Animation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//stop-animation")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//stop-animation")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-driver//stop-animation")
			}
			arg0Val.StopAnimation(arg1Val)
			return arg0
		},
	},
	"fyne-focusable//focus-gained": {
		Doc:   "fyne.Focusable.FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"fyne-focusable//focus-lost": {
		Doc:   "fyne.Focusable.FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"fyne-focusable//typed-key": {
		Doc:   "fyne.Focusable.TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-focusable//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-focusable//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-focusable//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"fyne-focusable//typed-rune": {
		Doc:   "fyne.Focusable.TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Focusable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Focusable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-focusable//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-focusable//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-focusable//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"fyne-hardware-key-ptr//scan-code!": {
		Doc:   "Set *fyne.HardwareKey ScanCode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key-ptr//scan-code!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key-ptr//scan-code!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key-ptr//scan-code!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScanCode = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-hardware-key-ptr//scan-code!")
			}
			return arg0
		},
	},
	"fyne-hardware-key-ptr//scan-code?": {
		Doc:   "Get *fyne.HardwareKey ScanCode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key-ptr//scan-code?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key-ptr//scan-code?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key-ptr//scan-code?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.ScanCode))
			return resObj
		},
	},
	"fyne-hardware-key//scan-code!": {
		Doc:   "Set fyne.HardwareKey ScanCode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key//scan-code!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key//scan-code!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ScanCode = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-hardware-key//scan-code!")
			}
			return arg0
		},
	},
	"fyne-hardware-key//scan-code?": {
		Doc:   "Get fyne.HardwareKey ScanCode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.HardwareKey
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key//scan-code?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-hardware-key//scan-code?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.ScanCode))
			return resObj
		},
	},
	"fyne-is-horizontal": {
		Doc:   "fyne.IsHorizontal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.DeviceOrientation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.DeviceOrientation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-is-horizontal")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-is-horizontal")
			}
			res0 := fyne.IsHorizontal(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-is-vertical": {
		Doc:   "fyne.IsVertical",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.DeviceOrientation
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.DeviceOrientation)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-is-vertical")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-is-vertical")
			}
			res0 := fyne.IsVertical(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-key-event-ptr//name!": {
		Doc:   "Set *fyne.KeyEvent Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Name, ok = v.Value.(fyne.KeyName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-key-event-ptr//name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-key-event-ptr//name!")
			}
			return arg0
		},
	},
	"fyne-key-event-ptr//name?": {
		Doc:   "Get *fyne.KeyEvent Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Name, "fyne-key-name")
			return resObj
		},
	},
	"fyne-key-event-ptr//physical!": {
		Doc:   "Set *fyne.KeyEvent Physical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//physical!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//physical!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//physical!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Physical, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-key-event-ptr//physical!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-key-event-ptr//physical!")
			}
			return arg0
		},
	},
	"fyne-key-event-ptr//physical?": {
		Doc:   "Get *fyne.KeyEvent Physical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//physical?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//physical?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event-ptr//physical?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Physical, "fyne-hardware-key")
			return resObj
		},
	},
	"fyne-key-event//name!": {
		Doc:   "Set fyne.KeyEvent Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event//name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event//name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Name, ok = v.Value.(fyne.KeyName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-key-event//name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-key-event//name!")
			}
			return arg0
		},
	},
	"fyne-key-event//name?": {
		Doc:   "Get fyne.KeyEvent Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event//name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event//name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Name, "fyne-key-name")
			return resObj
		},
	},
	"fyne-key-event//physical!": {
		Doc:   "Set fyne.KeyEvent Physical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event//physical!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event//physical!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Physical, ok = v.Value.(fyne.HardwareKey)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-key-event//physical!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-key-event//physical!")
			}
			return arg0
		},
	},
	"fyne-key-event//physical?": {
		Doc:   "Get fyne.KeyEvent Physical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.KeyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event//physical?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-key-event//physical?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Physical, "fyne-hardware-key")
			return resObj
		},
	},
	"fyne-keyboard-shortcut//key": {
		Doc:   "fyne.KeyboardShortcut.Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.KeyboardShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.KeyboardShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-keyboard-shortcut//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-keyboard-shortcut//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-keyboard-shortcut//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-name")
			return res0Obj
		},
	},
	"fyne-keyboard-shortcut//mod": {
		Doc:   "fyne.KeyboardShortcut.Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.KeyboardShortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.KeyboardShortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-keyboard-shortcut//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-keyboard-shortcut//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-keyboard-shortcut//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-modifier")
			return res0Obj
		},
	},
	"fyne-layout//layout": {
		Doc:   "fyne.Layout.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-layout//layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-layout//layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-layout//layout")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//layout")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//layout")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//layout")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//layout")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//layout")
			}
			var arg2Val fyne.Size
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "fyne-layout//layout")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "fyne-layout//layout")
			}
			arg0Val.Layout(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-layout//min-size": {
		Doc:   "fyne.Layout.MinSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Layout
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Layout)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-layout//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-layout//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-layout//min-size")
			}
			var arg1Val []fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//min-size")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//min-size")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//min-size")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//min-size")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-layout//min-size")
			}
			res0 := arg0Val.MinSize(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-legacy-theme//background-color": {
		Doc:   "fyne.LegacyTheme.BackgroundColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//background-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//background-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//background-color")
			}
			res0 := arg0Val.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//button-color": {
		Doc:   "fyne.LegacyTheme.ButtonColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//button-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//button-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//button-color")
			}
			res0 := arg0Val.ButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//disabled-button-color": {
		Doc:   "fyne.LegacyTheme.DisabledButtonColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//disabled-button-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//disabled-button-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//disabled-button-color")
			}
			res0 := arg0Val.DisabledButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//disabled-text-color": {
		Doc:   "fyne.LegacyTheme.DisabledTextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//disabled-text-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//disabled-text-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//disabled-text-color")
			}
			res0 := arg0Val.DisabledTextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//focus-color": {
		Doc:   "fyne.LegacyTheme.FocusColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//focus-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//focus-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//focus-color")
			}
			res0 := arg0Val.FocusColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//hover-color": {
		Doc:   "fyne.LegacyTheme.HoverColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//hover-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//hover-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//hover-color")
			}
			res0 := arg0Val.HoverColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//icon-inline-size": {
		Doc:   "fyne.LegacyTheme.IconInlineSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//icon-inline-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//icon-inline-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//icon-inline-size")
			}
			res0 := arg0Val.IconInlineSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-legacy-theme//padding": {
		Doc:   "fyne.LegacyTheme.Padding",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//padding")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//padding")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//padding")
			}
			res0 := arg0Val.Padding()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-legacy-theme//place-holder-color": {
		Doc:   "fyne.LegacyTheme.PlaceHolderColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//place-holder-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//place-holder-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//place-holder-color")
			}
			res0 := arg0Val.PlaceHolderColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//primary-color": {
		Doc:   "fyne.LegacyTheme.PrimaryColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//primary-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//primary-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//primary-color")
			}
			res0 := arg0Val.PrimaryColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//scroll-bar-color": {
		Doc:   "fyne.LegacyTheme.ScrollBarColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//scroll-bar-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//scroll-bar-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//scroll-bar-color")
			}
			res0 := arg0Val.ScrollBarColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//scroll-bar-size": {
		Doc:   "fyne.LegacyTheme.ScrollBarSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//scroll-bar-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//scroll-bar-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//scroll-bar-size")
			}
			res0 := arg0Val.ScrollBarSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-legacy-theme//scroll-bar-small-size": {
		Doc:   "fyne.LegacyTheme.ScrollBarSmallSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//scroll-bar-small-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//scroll-bar-small-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//scroll-bar-small-size")
			}
			res0 := arg0Val.ScrollBarSmallSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-legacy-theme//shadow-color": {
		Doc:   "fyne.LegacyTheme.ShadowColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//shadow-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//shadow-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//shadow-color")
			}
			res0 := arg0Val.ShadowColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-bold-font": {
		Doc:   "fyne.LegacyTheme.TextBoldFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-bold-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-bold-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-bold-font")
			}
			res0 := arg0Val.TextBoldFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-bold-italic-font": {
		Doc:   "fyne.LegacyTheme.TextBoldItalicFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-bold-italic-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-bold-italic-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-bold-italic-font")
			}
			res0 := arg0Val.TextBoldItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-color": {
		Doc:   "fyne.LegacyTheme.TextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-color")
			}
			res0 := arg0Val.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-font": {
		Doc:   "fyne.LegacyTheme.TextFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-font")
			}
			res0 := arg0Val.TextFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-italic-font": {
		Doc:   "fyne.LegacyTheme.TextItalicFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-italic-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-italic-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-italic-font")
			}
			res0 := arg0Val.TextItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-monospace-font": {
		Doc:   "fyne.LegacyTheme.TextMonospaceFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-monospace-font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-monospace-font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-monospace-font")
			}
			res0 := arg0Val.TextMonospaceFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-legacy-theme//text-size": {
		Doc:   "fyne.LegacyTheme.TextSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-legacy-theme//text-size")
			}
			res0 := arg0Val.TextSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-load-resource-from-path": {
		Doc:   "fyne.LoadResourceFromPath",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "fyne-load-resource-from-path")
			}
			res0, res1 := fyne.LoadResourceFromPath(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"fyne-load-resource-from-url-string": {
		Doc:   "fyne.LoadResourceFromURLString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "fyne-load-resource-from-url-string")
			}
			res0, res1 := fyne.LoadResourceFromURLString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"fyne-log-error": {
		Doc:   "fyne.LogError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "fyne-log-error")
			}
			var arg1Val error
			if v, ok := arg1.(env.Error); ok {
				arg1Val = errors.New(v.Print(*ps.Idx))
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.ErrorType}, "fyne-log-error")
			}
			fyne.LogError(arg0Val, arg1Val)
			return nil
		},
	},
	"fyne-main-menu": {
		Doc:   "fyne.NewMainMenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*fyne.Menu
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*fyne.Menu, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*fyne.Menu)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu")
			}
			res0 := fyne.NewMainMenu(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-main-menu-ptr")
			return res0Obj
		},
	},
	"fyne-main-menu-ptr//items!": {
		Doc:   "Set *fyne.MainMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.Menu, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.Menu)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu-ptr//items!")
			}
			return arg0
		},
	},
	"fyne-main-menu-ptr//items?": {
		Doc:   "Get *fyne.MainMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "fyne-menu-ptr-arr")
			return resObj
		},
	},
	"fyne-main-menu-ptr//refresh": {
		Doc:   "(*fyne.MainMenu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"fyne-main-menu//items!": {
		Doc:   "Set fyne.MainMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.Menu, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.Menu)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-main-menu//items!")
			}
			return arg0
		},
	},
	"fyne-main-menu//items?": {
		Doc:   "Get fyne.MainMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MainMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-main-menu//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "fyne-menu-ptr-arr")
			return resObj
		},
	},
	"fyne-max": {
		Doc:   "fyne.Max",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "fyne-max")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-max")
			}
			res0 := fyne.Max(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-measure-text": {
		Doc:   "fyne.MeasureText",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "fyne-measure-text")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-measure-text")
			}
			var arg2Val fyne.TextStyle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "fyne-measure-text")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "fyne-measure-text")
			}
			res0 := fyne.MeasureText(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-menu": {
		Doc:   "fyne.NewMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "fyne-menu")
			}
			var arg1Val []*fyne.MenuItem
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]*fyne.MenuItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(*fyne.MenuItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu")
						}
						arg1Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu")
			}
			res0 := fyne.NewMenu(arg0Val, arg1Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-menu-ptr")
			return res0Obj
		},
	},
	"fyne-menu-item": {
		Doc:   "fyne.NewMenuItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "fyne-menu-item")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-menu-item")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-menu-item")
			}
			res0 := fyne.NewMenuItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-menu-item-ptr")
			return res0Obj
		},
	},
	"fyne-menu-item-ptr//action!": {
		Doc:   "Set *fyne.MenuItem Action value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//action!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//action!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//action!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-menu-item-ptr//action!")
				}
				self.Action = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu-item-ptr//action!")
				}
				self.Action = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-menu-item-ptr//action!")
			}
			return arg0
		},
	},
	"fyne-menu-item-ptr//action?": {
		Doc:   "Get *fyne.MenuItem Action value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//action?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//action?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//action?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Action, "--go-any-func--")
			return resObj
		},
	},
	"fyne-menu-item-ptr//checked!": {
		Doc:   "Set *fyne.MenuItem Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//checked!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//checked!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//checked!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-menu-item-ptr//checked!")
			}
			return arg0
		},
	},
	"fyne-menu-item-ptr//checked?": {
		Doc:   "Get *fyne.MenuItem Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//checked?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//checked?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//checked?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"fyne-menu-item-ptr//child-menu!": {
		Doc:   "Set *fyne.MenuItem ChildMenu value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//child-menu!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//child-menu!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//child-menu!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ChildMenu, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item-ptr//child-menu!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item-ptr//child-menu!")
				}
				self.ChildMenu = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item-ptr//child-menu!")
			}
			return arg0
		},
	},
	"fyne-menu-item-ptr//child-menu?": {
		Doc:   "Get *fyne.MenuItem ChildMenu value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//child-menu?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//child-menu?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//child-menu?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildMenu, "fyne-menu-ptr")
			return resObj
		},
	},
	"fyne-menu-item-ptr//disabled!": {
		Doc:   "Set *fyne.MenuItem Disabled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//disabled!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//disabled!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//disabled!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Disabled = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-menu-item-ptr//disabled!")
			}
			return arg0
		},
	},
	"fyne-menu-item-ptr//disabled?": {
		Doc:   "Get *fyne.MenuItem Disabled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//disabled?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//disabled?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//disabled?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Disabled))
			return resObj
		},
	},
	"fyne-menu-item-ptr//icon!": {
		Doc:   "Set *fyne.MenuItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//icon!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item-ptr//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item-ptr//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item-ptr//icon!")
			}
			return arg0
		},
	},
	"fyne-menu-item-ptr//icon?": {
		Doc:   "Get *fyne.MenuItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//icon?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//icon?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
			return resObj
		},
	},
	"fyne-menu-item-ptr//is-quit!": {
		Doc:   "Set *fyne.MenuItem IsQuit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-quit!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-quit!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-quit!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsQuit = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-menu-item-ptr//is-quit!")
			}
			return arg0
		},
	},
	"fyne-menu-item-ptr//is-quit?": {
		Doc:   "Get *fyne.MenuItem IsQuit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-quit?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-quit?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-quit?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsQuit))
			return resObj
		},
	},
	"fyne-menu-item-ptr//is-separator!": {
		Doc:   "Set *fyne.MenuItem IsSeparator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-separator!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-separator!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-separator!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsSeparator = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-menu-item-ptr//is-separator!")
			}
			return arg0
		},
	},
	"fyne-menu-item-ptr//is-separator?": {
		Doc:   "Get *fyne.MenuItem IsSeparator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-separator?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-separator?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//is-separator?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsSeparator))
			return resObj
		},
	},
	"fyne-menu-item-ptr//label!": {
		Doc:   "Set *fyne.MenuItem Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//label!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//label!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//label!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-menu-item-ptr//label!")
			}
			return arg0
		},
	},
	"fyne-menu-item-ptr//label?": {
		Doc:   "Get *fyne.MenuItem Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//label?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//label?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//label?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"fyne-menu-item-ptr//shortcut!": {
		Doc:   "Set *fyne.MenuItem Shortcut value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//shortcut!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//shortcut!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//shortcut!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Shortcut, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item-ptr//shortcut!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item-ptr//shortcut!")
				}
				self.Shortcut = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item-ptr//shortcut!")
			}
			return arg0
		},
	},
	"fyne-menu-item-ptr//shortcut?": {
		Doc:   "Get *fyne.MenuItem Shortcut value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//shortcut?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//shortcut?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item-ptr//shortcut?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Shortcut, "fyne-shortcut")
			return resObj
		},
	},
	"fyne-menu-item-separator": {
		Doc:   "fyne.NewMenuItemSeparator",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := fyne.NewMenuItemSeparator()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-menu-item-ptr")
			return res0Obj
		},
	},
	"fyne-menu-item//action!": {
		Doc:   "Set fyne.MenuItem Action value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//action!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//action!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-menu-item//action!")
				}
				self.Action = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu-item//action!")
				}
				self.Action = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-menu-item//action!")
			}
			return arg0
		},
	},
	"fyne-menu-item//action?": {
		Doc:   "Get fyne.MenuItem Action value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//action?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//action?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Action, "--go-any-func--")
			return resObj
		},
	},
	"fyne-menu-item//checked!": {
		Doc:   "Set fyne.MenuItem Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//checked!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//checked!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-menu-item//checked!")
			}
			return arg0
		},
	},
	"fyne-menu-item//checked?": {
		Doc:   "Get fyne.MenuItem Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//checked?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//checked?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"fyne-menu-item//child-menu!": {
		Doc:   "Set fyne.MenuItem ChildMenu value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//child-menu!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//child-menu!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ChildMenu, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item//child-menu!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item//child-menu!")
				}
				self.ChildMenu = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item//child-menu!")
			}
			return arg0
		},
	},
	"fyne-menu-item//child-menu?": {
		Doc:   "Get fyne.MenuItem ChildMenu value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//child-menu?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//child-menu?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ChildMenu, "fyne-menu-ptr")
			return resObj
		},
	},
	"fyne-menu-item//disabled!": {
		Doc:   "Set fyne.MenuItem Disabled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//disabled!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//disabled!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Disabled = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-menu-item//disabled!")
			}
			return arg0
		},
	},
	"fyne-menu-item//disabled?": {
		Doc:   "Get fyne.MenuItem Disabled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//disabled?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//disabled?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Disabled))
			return resObj
		},
	},
	"fyne-menu-item//icon!": {
		Doc:   "Set fyne.MenuItem Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//icon!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item//icon!")
			}
			return arg0
		},
	},
	"fyne-menu-item//icon?": {
		Doc:   "Get fyne.MenuItem Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//icon?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
			return resObj
		},
	},
	"fyne-menu-item//is-quit!": {
		Doc:   "Set fyne.MenuItem IsQuit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//is-quit!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//is-quit!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsQuit = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-menu-item//is-quit!")
			}
			return arg0
		},
	},
	"fyne-menu-item//is-quit?": {
		Doc:   "Get fyne.MenuItem IsQuit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//is-quit?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//is-quit?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsQuit))
			return resObj
		},
	},
	"fyne-menu-item//is-separator!": {
		Doc:   "Set fyne.MenuItem IsSeparator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//is-separator!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//is-separator!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.IsSeparator = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-menu-item//is-separator!")
			}
			return arg0
		},
	},
	"fyne-menu-item//is-separator?": {
		Doc:   "Get fyne.MenuItem IsSeparator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//is-separator?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//is-separator?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.IsSeparator))
			return resObj
		},
	},
	"fyne-menu-item//label!": {
		Doc:   "Set fyne.MenuItem Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//label!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//label!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-menu-item//label!")
			}
			return arg0
		},
	},
	"fyne-menu-item//label?": {
		Doc:   "Get fyne.MenuItem Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//label?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//label?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"fyne-menu-item//shortcut!": {
		Doc:   "Set fyne.MenuItem Shortcut value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//shortcut!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//shortcut!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Shortcut, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item//shortcut!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item//shortcut!")
				}
				self.Shortcut = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-menu-item//shortcut!")
			}
			return arg0
		},
	},
	"fyne-menu-item//shortcut?": {
		Doc:   "Get fyne.MenuItem Shortcut value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.MenuItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//shortcut?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-item//shortcut?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Shortcut, "fyne-shortcut")
			return resObj
		},
	},
	"fyne-menu-ptr//items!": {
		Doc:   "Set *fyne.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.MenuItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.MenuItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu-ptr//items!")
			}
			return arg0
		},
	},
	"fyne-menu-ptr//items?": {
		Doc:   "Get *fyne.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "fyne-menu-item-ptr-arr")
			return resObj
		},
	},
	"fyne-menu-ptr//label!": {
		Doc:   "Set *fyne.Menu Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//label!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//label!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//label!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-menu-ptr//label!")
			}
			return arg0
		},
	},
	"fyne-menu-ptr//label?": {
		Doc:   "Get *fyne.Menu Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//label?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//label?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//label?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"fyne-menu-ptr//refresh": {
		Doc:   "(*fyne.Menu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"fyne-menu//items!": {
		Doc:   "Set fyne.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*fyne.MenuItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*fyne.MenuItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*fyne.MenuItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-menu//items!")
			}
			return arg0
		},
	},
	"fyne-menu//items?": {
		Doc:   "Get fyne.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "fyne-menu-item-ptr-arr")
			return resObj
		},
	},
	"fyne-menu//label!": {
		Doc:   "Set fyne.Menu Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu//label!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu//label!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Label = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-menu//label!")
			}
			return arg0
		},
	},
	"fyne-menu//label?": {
		Doc:   "Get fyne.Menu Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu//label?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-menu//label?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"fyne-min": {
		Doc:   "fyne.Min",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "fyne-min")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-min")
			}
			res0 := fyne.Min(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-notification": {
		Doc:   "fyne.NewNotification",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "fyne-notification")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-notification")
			}
			res0 := fyne.NewNotification(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-notification-ptr")
			return res0Obj
		},
	},
	"fyne-notification-ptr//content!": {
		Doc:   "Set *fyne.Notification Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//content!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Content = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-notification-ptr//content!")
			}
			return arg0
		},
	},
	"fyne-notification-ptr//content?": {
		Doc:   "Get *fyne.Notification Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//content?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Content)
			return resObj
		},
	},
	"fyne-notification-ptr//title!": {
		Doc:   "Set *fyne.Notification Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//title!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//title!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-notification-ptr//title!")
			}
			return arg0
		},
	},
	"fyne-notification-ptr//title?": {
		Doc:   "Get *fyne.Notification Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//title?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//title?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification-ptr//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"fyne-notification//content!": {
		Doc:   "Set fyne.Notification Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification//content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification//content!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Content = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-notification//content!")
			}
			return arg0
		},
	},
	"fyne-notification//content?": {
		Doc:   "Get fyne.Notification Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification//content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification//content?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Content)
			return resObj
		},
	},
	"fyne-notification//title!": {
		Doc:   "Set fyne.Notification Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification//title!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-notification//title!")
			}
			return arg0
		},
	},
	"fyne-notification//title?": {
		Doc:   "Get fyne.Notification Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Notification
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Notification)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification//title?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-notification//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"fyne-overlay-stack//add": {
		Doc:   "fyne.OverlayStack.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//add")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//add")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-overlay-stack//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-overlay-stack//add")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-overlay-stack//add")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"fyne-overlay-stack//list": {
		Doc:   "fyne.OverlayStack.List",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//list")
			}
			res0 := arg0Val.List()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object-arr")
			return res0Obj
		},
	},
	"fyne-overlay-stack//remove": {
		Doc:   "fyne.OverlayStack.Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//remove")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-overlay-stack//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-overlay-stack//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-overlay-stack//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"fyne-overlay-stack//top": {
		Doc:   "fyne.OverlayStack.Top",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.OverlayStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.OverlayStack)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//top")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//top")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-overlay-stack//top")
			}
			res0 := arg0Val.Top()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"fyne-point-event-ptr//absolute-position!": {
		Doc:   "Set *fyne.PointEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-point-event-ptr//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-point-event-ptr//absolute-position!")
			}
			return arg0
		},
	},
	"fyne-point-event-ptr//absolute-position?": {
		Doc:   "Get *fyne.PointEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"fyne-point-event-ptr//position!": {
		Doc:   "Set *fyne.PointEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-point-event-ptr//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-point-event-ptr//position!")
			}
			return arg0
		},
	},
	"fyne-point-event-ptr//position?": {
		Doc:   "Get *fyne.PointEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event-ptr//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"fyne-point-event//absolute-position!": {
		Doc:   "Set fyne.PointEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-point-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-point-event//absolute-position!")
			}
			return arg0
		},
	},
	"fyne-point-event//absolute-position?": {
		Doc:   "Get fyne.PointEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"fyne-point-event//position!": {
		Doc:   "Set fyne.PointEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-point-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-point-event//position!")
			}
			return arg0
		},
	},
	"fyne-point-event//position?": {
		Doc:   "Get fyne.PointEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.PointEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-point-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"fyne-pos": {
		Doc:   "fyne.NewPos",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "fyne-pos")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-pos")
			}
			res0 := fyne.NewPos(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-position-ptr//x!": {
		Doc:   "Set *fyne.Position X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//x!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//x!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//x!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-position-ptr//x!")
			}
			return arg0
		},
	},
	"fyne-position-ptr//x?": {
		Doc:   "Get *fyne.Position X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//x?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//x?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//x?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"fyne-position-ptr//y!": {
		Doc:   "Set *fyne.Position Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//y!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//y!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//y!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-position-ptr//y!")
			}
			return arg0
		},
	},
	"fyne-position-ptr//y?": {
		Doc:   "Get *fyne.Position Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//y?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//y?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position-ptr//y?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"fyne-position//add": {
		Doc:   "fyne.Position.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//add")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//add")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-position//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-position//add")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-position//add")
			}
			res0 := arg0Val.Add(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-position//add-xy": {
		Doc:   "fyne.Position.AddXY",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//add-xy")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//add-xy")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-position//add-xy")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "fyne-position//add-xy")
			}
			res0 := arg0Val.AddXY(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-position//components": {
		Doc:   "fyne.Position.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//components")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//components")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-position//is-zero": {
		Doc:   "fyne.Position.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//is-zero")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//is-zero")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-position//subtract": {
		Doc:   "fyne.Position.Subtract",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//subtract")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//subtract")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-position//subtract")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-position//subtract")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-position//subtract")
			}
			res0 := arg0Val.Subtract(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-position//subtract-xy": {
		Doc:   "fyne.Position.SubtractXY",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//subtract-xy")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//subtract-xy")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-position//subtract-xy")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "fyne-position//subtract-xy")
			}
			res0 := arg0Val.SubtractXY(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-position//x!": {
		Doc:   "Set fyne.Position X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//x!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//x!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.X = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-position//x!")
			}
			return arg0
		},
	},
	"fyne-position//x?": {
		Doc:   "Get fyne.Position X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//x?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//x?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"fyne-position//y!": {
		Doc:   "Set fyne.Position Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//y!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//y!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Y = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-position//y!")
			}
			return arg0
		},
	},
	"fyne-position//y?": {
		Doc:   "Get fyne.Position Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//y?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-position//y?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"fyne-preferences//add-change-listener": {
		Doc:   "fyne.Preferences.AddChangeListener",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//add-change-listener")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//add-change-listener")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//add-change-listener")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-preferences//add-change-listener")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//add-change-listener")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-preferences//add-change-listener")
			}
			arg0Val.AddChangeListener(arg1Val)
			return arg0
		},
	},
	"fyne-preferences//bool": {
		Doc:   "fyne.Preferences.Bool",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//bool")
			}
			res0 := arg0Val.Bool(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//bool-list": {
		Doc:   "fyne.Preferences.BoolList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//bool-list")
			}
			res0 := arg0Val.BoolList(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool-arr")
			return res0Obj
		},
	},
	"fyne-preferences//bool-list-with-fallback": {
		Doc:   "fyne.Preferences.BoolListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool-list-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool-list-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//bool-list-with-fallback")
			}
			var arg2Val []bool
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]bool, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = v.Value != 0
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//bool-list-with-fallback")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//bool-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//bool-list-with-fallback")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//bool-list-with-fallback")
			}
			res0 := arg0Val.BoolListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "bool-arr")
			return res0Obj
		},
	},
	"fyne-preferences//bool-with-fallback": {
		Doc:   "fyne.Preferences.BoolWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//bool-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//bool-with-fallback")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "fyne-preferences//bool-with-fallback")
			}
			res0 := arg0Val.BoolWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//change-listeners": {
		Doc:   "fyne.Preferences.ChangeListeners",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//change-listeners")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//change-listeners")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//change-listeners")
			}
			res0 := arg0Val.ChangeListeners()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "--go-any-func---arr")
			return res0Obj
		},
	},
	"fyne-preferences//float": {
		Doc:   "fyne.Preferences.Float",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//float")
			}
			res0 := arg0Val.Float(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//float-list": {
		Doc:   "fyne.Preferences.FloatList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//float-list")
			}
			res0 := arg0Val.FloatList(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "float64-arr")
			return res0Obj
		},
	},
	"fyne-preferences//float-list-with-fallback": {
		Doc:   "fyne.Preferences.FloatListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float-list-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float-list-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//float-list-with-fallback")
			}
			var arg2Val []float64
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]float64, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg2Val[i] = float64(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//float-list-with-fallback")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//float-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//float-list-with-fallback")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//float-list-with-fallback")
			}
			res0 := arg0Val.FloatListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "float64-arr")
			return res0Obj
		},
	},
	"fyne-preferences//float-with-fallback": {
		Doc:   "fyne.Preferences.FloatWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//float-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//float-with-fallback")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "fyne-preferences//float-with-fallback")
			}
			res0 := arg0Val.FloatWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//int": {
		Doc:   "fyne.Preferences.Int",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//int")
			}
			res0 := arg0Val.Int(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//int-list": {
		Doc:   "fyne.Preferences.IntList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//int-list")
			}
			res0 := arg0Val.IntList(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "int-arr")
			return res0Obj
		},
	},
	"fyne-preferences//int-list-with-fallback": {
		Doc:   "fyne.Preferences.IntListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int-list-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int-list-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//int-list-with-fallback")
			}
			var arg2Val []int
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = int(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//int-list-with-fallback")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]int)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//int-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//int-list-with-fallback")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//int-list-with-fallback")
			}
			res0 := arg0Val.IntListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "int-arr")
			return res0Obj
		},
	},
	"fyne-preferences//int-with-fallback": {
		Doc:   "fyne.Preferences.IntWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//int-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//int-with-fallback")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "fyne-preferences//int-with-fallback")
			}
			res0 := arg0Val.IntWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"fyne-preferences//remove-value": {
		Doc:   "fyne.Preferences.RemoveValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//remove-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//remove-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//remove-value")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//remove-value")
			}
			arg0Val.RemoveValue(arg1Val)
			return arg0
		},
	},
	"fyne-preferences//set-bool": {
		Doc:   "fyne.Preferences.SetBool",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-bool")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-bool")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-bool")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//set-bool")
			}
			var arg2Val bool
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "fyne-preferences//set-bool")
			}
			arg0Val.SetBool(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-bool-list": {
		Doc:   "fyne.Preferences.SetBoolList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-bool-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-bool-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-bool-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//set-bool-list")
			}
			var arg2Val []bool
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]bool, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = v.Value != 0
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-bool-list")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]bool)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-bool-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-bool-list")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-bool-list")
			}
			arg0Val.SetBoolList(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-float": {
		Doc:   "fyne.Preferences.SetFloat",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-float")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-float")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-float")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//set-float")
			}
			var arg2Val float64
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "fyne-preferences//set-float")
			}
			arg0Val.SetFloat(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-float-list": {
		Doc:   "fyne.Preferences.SetFloatList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-float-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-float-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-float-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//set-float-list")
			}
			var arg2Val []float64
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]float64, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Decimal); ok {
						arg2Val[i] = float64(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-float-list")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]float64)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-float-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-float-list")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-float-list")
			}
			arg0Val.SetFloatList(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-int": {
		Doc:   "fyne.Preferences.SetInt",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-int")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-int")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-int")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//set-int")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "fyne-preferences//set-int")
			}
			arg0Val.SetInt(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-int-list": {
		Doc:   "fyne.Preferences.SetIntList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-int-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-int-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-int-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//set-int-list")
			}
			var arg2Val []int
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]int, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.Integer); ok {
						arg2Val[i] = int(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-int-list")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]int)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-int-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-int-list")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-int-list")
			}
			arg0Val.SetIntList(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-string": {
		Doc:   "fyne.Preferences.SetString",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//set-string")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "fyne-preferences//set-string")
			}
			arg0Val.SetString(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//set-string-list": {
		Doc:   "fyne.Preferences.SetStringList",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-string-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-string-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//set-string-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//set-string-list")
			}
			var arg2Val []string
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg2Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-string-list")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-string-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-string-list")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//set-string-list")
			}
			arg0Val.SetStringList(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-preferences//string": {
		Doc:   "fyne.Preferences.String",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//string")
			}
			res0 := arg0Val.String(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-preferences//string-list": {
		Doc:   "fyne.Preferences.StringList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string-list")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//string-list")
			}
			res0 := arg0Val.StringList(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-arr")
			return res0Obj
		},
	},
	"fyne-preferences//string-list-with-fallback": {
		Doc:   "fyne.Preferences.StringListWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string-list-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string-list-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//string-list-with-fallback")
			}
			var arg2Val []string
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg2Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//string-list-with-fallback")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//string-list-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//string-list-with-fallback")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-preferences//string-list-with-fallback")
			}
			res0 := arg0Val.StringListWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-arr")
			return res0Obj
		},
	},
	"fyne-preferences//string-with-fallback": {
		Doc:   "fyne.Preferences.StringWithFallback",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Preferences
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Preferences)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string-with-fallback")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string-with-fallback")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-preferences//string-with-fallback")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-preferences//string-with-fallback")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "fyne-preferences//string-with-fallback")
			}
			res0 := arg0Val.StringWithFallback(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-resource//content": {
		Doc:   "fyne.Resource.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-resource//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-resource//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-resource//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr")
			return res0Obj
		},
	},
	"fyne-resource//name": {
		Doc:   "fyne.Resource.Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-resource//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-resource//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-resource//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-scroll-event-ptr//absolute-position!": {
		Doc:   "Set *fyne.ScrollEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//absolute-position!")
			}
			return arg0
		},
	},
	"fyne-scroll-event-ptr//absolute-position?": {
		Doc:   "Get *fyne.ScrollEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"fyne-scroll-event-ptr//position!": {
		Doc:   "Set *fyne.ScrollEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//position!")
			}
			return arg0
		},
	},
	"fyne-scroll-event-ptr//position?": {
		Doc:   "Get *fyne.ScrollEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"fyne-scroll-event-ptr//scrolled!": {
		Doc:   "Set *fyne.ScrollEvent Scrolled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//scrolled!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//scrolled!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//scrolled!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scrolled, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//scrolled!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//scrolled!")
			}
			return arg0
		},
	},
	"fyne-scroll-event-ptr//scrolled?": {
		Doc:   "Get *fyne.ScrollEvent Scrolled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//scrolled?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//scrolled?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event-ptr//scrolled?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scrolled, "fyne-delta")
			return resObj
		},
	},
	"fyne-scroll-event//absolute-position!": {
		Doc:   "Set fyne.ScrollEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event//absolute-position!")
			}
			return arg0
		},
	},
	"fyne-scroll-event//absolute-position?": {
		Doc:   "Get fyne.ScrollEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"fyne-scroll-event//position!": {
		Doc:   "Set fyne.ScrollEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event//position!")
			}
			return arg0
		},
	},
	"fyne-scroll-event//position?": {
		Doc:   "Get fyne.ScrollEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"fyne-scroll-event//scrolled!": {
		Doc:   "Set fyne.ScrollEvent Scrolled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//scrolled!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//scrolled!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scrolled, ok = v.Value.(fyne.Delta)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event//scrolled!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scroll-event//scrolled!")
			}
			return arg0
		},
	},
	"fyne-scroll-event//scrolled?": {
		Doc:   "Get fyne.ScrollEvent Scrolled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ScrollEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//scrolled?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scroll-event//scrolled?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scrolled, "fyne-delta")
			return resObj
		},
	},
	"fyne-scrollable//scrolled": {
		Doc:   "fyne.Scrollable.Scrolled",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Scrollable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Scrollable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scrollable//scrolled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scrollable//scrolled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-scrollable//scrolled")
			}
			var arg1Val *fyne.ScrollEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.ScrollEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scrollable//scrolled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scrollable//scrolled")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-scrollable//scrolled")
			}
			arg0Val.Scrolled(arg1Val)
			return arg0
		},
	},
	"fyne-secondary-tappable//tapped-secondary": {
		Doc:   "fyne.SecondaryTappable.TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.SecondaryTappable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.SecondaryTappable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-secondary-tappable//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-secondary-tappable//tapped-secondary")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-secondary-tappable//tapped-secondary")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-secondary-tappable//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-secondary-tappable//tapped-secondary")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-secondary-tappable//tapped-secondary")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"fyne-set-current-app": {
		Doc:   "fyne.SetCurrentApp",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.App
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.App)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-set-current-app")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-set-current-app")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-set-current-app")
			}
			fyne.SetCurrentApp(arg0Val)
			return nil
		},
	},
	"fyne-settings//build-type": {
		Doc:   "fyne.Settings.BuildType",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//build-type")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//build-type")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//build-type")
			}
			res0 := arg0Val.BuildType()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-build-type")
			return res0Obj
		},
	},
	"fyne-settings//primary-color": {
		Doc:   "fyne.Settings.PrimaryColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//primary-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//primary-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//primary-color")
			}
			res0 := arg0Val.PrimaryColor()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-settings//scale": {
		Doc:   "fyne.Settings.Scale",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//scale")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//scale")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//scale")
			}
			res0 := arg0Val.Scale()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-settings//set-theme": {
		Doc:   "fyne.Settings.SetTheme",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//set-theme")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//set-theme")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//set-theme")
			}
			var arg1Val fyne.Theme
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-settings//set-theme")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-settings//set-theme")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-settings//set-theme")
			}
			arg0Val.SetTheme(arg1Val)
			return arg0
		},
	},
	"fyne-settings//show-animations": {
		Doc:   "fyne.Settings.ShowAnimations",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//show-animations")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//show-animations")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//show-animations")
			}
			res0 := arg0Val.ShowAnimations()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-settings//theme": {
		Doc:   "fyne.Settings.Theme",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//theme")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//theme")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//theme")
			}
			res0 := arg0Val.Theme()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
			return res0Obj
		},
	},
	"fyne-settings//theme-variant": {
		Doc:   "fyne.Settings.ThemeVariant",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Settings
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Settings)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//theme-variant")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//theme-variant")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-settings//theme-variant")
			}
			res0 := arg0Val.ThemeVariant()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme-variant")
			return res0Obj
		},
	},
	"fyne-shortcut-copy-ptr//clipboard!": {
		Doc:   "Set *fyne.ShortcutCopy Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//clipboard!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//clipboard!")
			}
			return arg0
		},
	},
	"fyne-shortcut-copy-ptr//clipboard?": {
		Doc:   "Get *fyne.ShortcutCopy Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//clipboard?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//clipboard?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
			return resObj
		},
	},
	"fyne-shortcut-copy-ptr//key": {
		Doc:   "(*fyne.ShortcutCopy).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-name")
			return res0Obj
		},
	},
	"fyne-shortcut-copy-ptr//mod": {
		Doc:   "(*fyne.ShortcutCopy).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-modifier")
			return res0Obj
		},
	},
	"fyne-shortcut-copy-ptr//shortcut-name": {
		Doc:   "(*fyne.ShortcutCopy).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy-ptr//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-shortcut-copy//clipboard!": {
		Doc:   "Set fyne.ShortcutCopy Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy//clipboard!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-copy//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-copy//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-copy//clipboard!")
			}
			return arg0
		},
	},
	"fyne-shortcut-copy//clipboard?": {
		Doc:   "Get fyne.ShortcutCopy Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCopy
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCopy)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy//clipboard?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-copy//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
			return resObj
		},
	},
	"fyne-shortcut-cut-ptr//clipboard!": {
		Doc:   "Set *fyne.ShortcutCut Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//clipboard!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//clipboard!")
			}
			return arg0
		},
	},
	"fyne-shortcut-cut-ptr//clipboard?": {
		Doc:   "Get *fyne.ShortcutCut Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//clipboard?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//clipboard?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
			return resObj
		},
	},
	"fyne-shortcut-cut-ptr//key": {
		Doc:   "(*fyne.ShortcutCut).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-name")
			return res0Obj
		},
	},
	"fyne-shortcut-cut-ptr//mod": {
		Doc:   "(*fyne.ShortcutCut).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-modifier")
			return res0Obj
		},
	},
	"fyne-shortcut-cut-ptr//shortcut-name": {
		Doc:   "(*fyne.ShortcutCut).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut-ptr//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-shortcut-cut//clipboard!": {
		Doc:   "Set fyne.ShortcutCut Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut//clipboard!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-cut//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-cut//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-cut//clipboard!")
			}
			return arg0
		},
	},
	"fyne-shortcut-cut//clipboard?": {
		Doc:   "Get fyne.ShortcutCut Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutCut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutCut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut//clipboard?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-cut//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
			return resObj
		},
	},
	"fyne-shortcut-handler-ptr//add-shortcut": {
		Doc:   "(*fyne.ShortcutHandler).AddShortcut",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutHandler
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutHandler)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//add-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//add-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//add-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//add-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//add-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//add-shortcut")
			}
			var arg2Val func(fyne.Shortcut)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "fyne-shortcut-handler-ptr//add-shortcut")
				}
				arg2Val = func(arg0 fyne.Shortcut) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-shortcut")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "fyne-shortcut-handler-ptr//add-shortcut")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "fyne-shortcut-handler-ptr//add-shortcut")
			}
			arg0Val.AddShortcut(arg1Val, arg2Val)
			return arg0
		},
	},
	"fyne-shortcut-handler-ptr//remove-shortcut": {
		Doc:   "(*fyne.ShortcutHandler).RemoveShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutHandler
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutHandler)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//remove-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//remove-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//remove-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//remove-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//remove-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//remove-shortcut")
			}
			arg0Val.RemoveShortcut(arg1Val)
			return arg0
		},
	},
	"fyne-shortcut-handler-ptr//typed-shortcut": {
		Doc:   "(*fyne.ShortcutHandler).TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutHandler
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutHandler)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//typed-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//typed-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//typed-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-handler-ptr//typed-shortcut")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"fyne-shortcut-paste-ptr//clipboard!": {
		Doc:   "Set *fyne.ShortcutPaste Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//clipboard!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//clipboard!")
			}
			return arg0
		},
	},
	"fyne-shortcut-paste-ptr//clipboard?": {
		Doc:   "Get *fyne.ShortcutPaste Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//clipboard?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//clipboard?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
			return resObj
		},
	},
	"fyne-shortcut-paste-ptr//key": {
		Doc:   "(*fyne.ShortcutPaste).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-name")
			return res0Obj
		},
	},
	"fyne-shortcut-paste-ptr//mod": {
		Doc:   "(*fyne.ShortcutPaste).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-modifier")
			return res0Obj
		},
	},
	"fyne-shortcut-paste-ptr//shortcut-name": {
		Doc:   "(*fyne.ShortcutPaste).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste-ptr//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-shortcut-paste//clipboard!": {
		Doc:   "Set fyne.ShortcutPaste Clipboard value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste//clipboard!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste//clipboard!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Clipboard, ok = v.Value.(fyne.Clipboard)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-paste//clipboard!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-paste//clipboard!")
				}
				self.Clipboard = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcut-paste//clipboard!")
			}
			return arg0
		},
	},
	"fyne-shortcut-paste//clipboard?": {
		Doc:   "Get fyne.ShortcutPaste Clipboard value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.ShortcutPaste
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.ShortcutPaste)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste//clipboard?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-paste//clipboard?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Clipboard, "fyne-clipboard")
			return resObj
		},
	},
	"fyne-shortcut-select-all-ptr//key": {
		Doc:   "(*fyne.ShortcutSelectAll).Key",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutSelectAll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutSelectAll)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-select-all-ptr//key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-select-all-ptr//key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-select-all-ptr//key")
			}
			res0 := arg0Val.Key()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-name")
			return res0Obj
		},
	},
	"fyne-shortcut-select-all-ptr//mod": {
		Doc:   "(*fyne.ShortcutSelectAll).Mod",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutSelectAll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutSelectAll)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-select-all-ptr//mod")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-select-all-ptr//mod")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-select-all-ptr//mod")
			}
			res0 := arg0Val.Mod()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-key-modifier")
			return res0Obj
		},
	},
	"fyne-shortcut-select-all-ptr//shortcut-name": {
		Doc:   "(*fyne.ShortcutSelectAll).ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.ShortcutSelectAll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.ShortcutSelectAll)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-select-all-ptr//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-select-all-ptr//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut-select-all-ptr//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-shortcut//shortcut-name": {
		Doc:   "fyne.Shortcut.ShortcutName",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Shortcut
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut//shortcut-name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut//shortcut-name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcut//shortcut-name")
			}
			res0 := arg0Val.ShortcutName()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-shortcutable//typed-shortcut": {
		Doc:   "fyne.Shortcutable.TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Shortcutable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Shortcutable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcutable//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcutable//typed-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-shortcutable//typed-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcutable//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcutable//typed-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-shortcutable//typed-shortcut")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"fyne-size": {
		Doc:   "fyne.NewSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "fyne-size")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-size")
			}
			res0 := fyne.NewSize(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size-ptr//height!": {
		Doc:   "Set *fyne.Size Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//height!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//height!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//height!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Height = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-size-ptr//height!")
			}
			return arg0
		},
	},
	"fyne-size-ptr//height?": {
		Doc:   "Get *fyne.Size Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//height?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//height?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//height?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Height))
			return resObj
		},
	},
	"fyne-size-ptr//width!": {
		Doc:   "Set *fyne.Size Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-size-ptr//width!")
			}
			return arg0
		},
	},
	"fyne-size-ptr//width?": {
		Doc:   "Get *fyne.Size Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size-ptr//width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"fyne-size//add": {
		Doc:   "fyne.Size.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//add")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//add")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//add")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//add")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//add")
			}
			res0 := arg0Val.Add(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//add-width-height": {
		Doc:   "fyne.Size.AddWidthHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//add-width-height")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//add-width-height")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-size//add-width-height")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "fyne-size//add-width-height")
			}
			res0 := arg0Val.AddWidthHeight(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//components": {
		Doc:   "fyne.Size.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//components")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//components")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-size//height!": {
		Doc:   "Set fyne.Size Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//height!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//height!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Height = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-size//height!")
			}
			return arg0
		},
	},
	"fyne-size//height?": {
		Doc:   "Get fyne.Size Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//height?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//height?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Height))
			return resObj
		},
	},
	"fyne-size//is-zero": {
		Doc:   "fyne.Size.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//is-zero")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//is-zero")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-size//max": {
		Doc:   "fyne.Size.Max",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//max")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//max")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//max")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//max")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//max")
			}
			res0 := arg0Val.Max(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//min": {
		Doc:   "fyne.Size.Min",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//min")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//min")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//min")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//min")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//min")
			}
			res0 := arg0Val.Min(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//subtract": {
		Doc:   "fyne.Size.Subtract",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//subtract")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//subtract")
			}
			var arg1Val fyne.Vector2
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//subtract")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//subtract")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-size//subtract")
			}
			res0 := arg0Val.Subtract(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//subtract-width-height": {
		Doc:   "fyne.Size.SubtractWidthHeight",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//subtract-width-height")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//subtract-width-height")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-size//subtract-width-height")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.DecimalType}, "fyne-size//subtract-width-height")
			}
			res0 := arg0Val.SubtractWidthHeight(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-size//width!": {
		Doc:   "Set fyne.Size Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//width!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Width = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "fyne-size//width!")
			}
			return arg0
		},
	},
	"fyne-size//width?": {
		Doc:   "Get fyne.Size Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-size//width?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"fyne-square-offset-pos": {
		Doc:   "fyne.NewSquareOffsetPos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "fyne-square-offset-pos")
			}
			res0 := fyne.NewSquareOffsetPos(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"fyne-square-size": {
		Doc:   "fyne.NewSquareSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "fyne-square-size")
			}
			res0 := fyne.NewSquareSize(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-static-resource": {
		Doc:   "fyne.NewStaticResource",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "fyne-static-resource")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource")
			}
			res0 := fyne.NewStaticResource(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-static-resource-ptr")
			return res0Obj
		},
	},
	"fyne-static-resource-ptr//content": {
		Doc:   "(*fyne.StaticResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr")
			return res0Obj
		},
	},
	"fyne-static-resource-ptr//go-string": {
		Doc:   "(*fyne.StaticResource).GoString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//go-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//go-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//go-string")
			}
			res0 := arg0Val.GoString()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-static-resource-ptr//name": {
		Doc:   "(*fyne.StaticResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"fyne-static-resource-ptr//static-content!": {
		Doc:   "Set *fyne.StaticResource StaticContent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-content!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.StaticContent = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.StaticContent[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource-ptr//static-content!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource-ptr//static-content!")
					}
				}
			case env.Native:
				var ok bool
				self.StaticContent, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource-ptr//static-content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource-ptr//static-content!")
				}
				self.StaticContent = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource-ptr//static-content!")
			}
			return arg0
		},
	},
	"fyne-static-resource-ptr//static-content?": {
		Doc:   "Get *fyne.StaticResource StaticContent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StaticContent, "byte-arr")
			return resObj
		},
	},
	"fyne-static-resource-ptr//static-name!": {
		Doc:   "Set *fyne.StaticResource StaticName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.StaticName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-static-resource-ptr//static-name!")
			}
			return arg0
		},
	},
	"fyne-static-resource-ptr//static-name?": {
		Doc:   "Get *fyne.StaticResource StaticName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource-ptr//static-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.StaticName)
			return resObj
		},
	},
	"fyne-static-resource//static-content!": {
		Doc:   "Set fyne.StaticResource StaticContent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource//static-content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource//static-content!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.StaticContent = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.StaticContent[i], ok = v.Value.(byte)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource//static-content!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource//static-content!")
					}
				}
			case env.Native:
				var ok bool
				self.StaticContent, ok = v.Value.([]byte)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource//static-content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource//static-content!")
				}
				self.StaticContent = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-static-resource//static-content!")
			}
			return arg0
		},
	},
	"fyne-static-resource//static-content?": {
		Doc:   "Get fyne.StaticResource StaticContent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource//static-content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource//static-content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StaticContent, "byte-arr")
			return resObj
		},
	},
	"fyne-static-resource//static-name!": {
		Doc:   "Set fyne.StaticResource StaticName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource//static-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource//static-name!")
			}
			if v, ok := arg1.(env.String); ok {
				self.StaticName = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-static-resource//static-name!")
			}
			return arg0
		},
	},
	"fyne-static-resource//static-name?": {
		Doc:   "Get fyne.StaticResource StaticName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.StaticResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.StaticResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource//static-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-static-resource//static-name?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.StaticName)
			return resObj
		},
	},
	"fyne-storage//create": {
		Doc:   "fyne.Storage.Create",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//create")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//create")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//create")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-storage//create")
			}
			res0, res1 := arg0Val.Create(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"fyne-storage//list": {
		Doc:   "fyne.Storage.List",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//list")
			}
			res0 := arg0Val.List()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-arr")
			return res0Obj
		},
	},
	"fyne-storage//open": {
		Doc:   "fyne.Storage.Open",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//open")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//open")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//open")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-storage//open")
			}
			res0, res1 := arg0Val.Open(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"fyne-storage//remove": {
		Doc:   "fyne.Storage.Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//remove")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-storage//remove")
			}
			res0 := arg0Val.Remove(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"fyne-storage//root-uri": {
		Doc:   "fyne.Storage.RootURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//root-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//root-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//root-uri")
			}
			res0 := arg0Val.RootURI()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			return res0Obj
		},
	},
	"fyne-storage//save": {
		Doc:   "fyne.Storage.Save",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Storage
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Storage)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//save")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//save")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-storage//save")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-storage//save")
			}
			res0, res1 := arg0Val.Save(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"fyne-tabbable//accepts-tab": {
		Doc:   "fyne.Tabbable.AcceptsTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Tabbable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Tabbable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-tabbable//accepts-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-tabbable//accepts-tab")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-tabbable//accepts-tab")
			}
			res0 := arg0Val.AcceptsTab()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-tappable//tapped": {
		Doc:   "fyne.Tappable.Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Tappable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Tappable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-tappable//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-tappable//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-tappable//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-tappable//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-tappable//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-tappable//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"fyne-text-style-ptr//bold!": {
		Doc:   "Set *fyne.TextStyle Bold value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//bold!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//bold!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//bold!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Bold = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style-ptr//bold!")
			}
			return arg0
		},
	},
	"fyne-text-style-ptr//bold?": {
		Doc:   "Get *fyne.TextStyle Bold value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//bold?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//bold?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//bold?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Bold))
			return resObj
		},
	},
	"fyne-text-style-ptr//italic!": {
		Doc:   "Set *fyne.TextStyle Italic value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//italic!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//italic!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//italic!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Italic = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style-ptr//italic!")
			}
			return arg0
		},
	},
	"fyne-text-style-ptr//italic?": {
		Doc:   "Get *fyne.TextStyle Italic value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//italic?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//italic?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//italic?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Italic))
			return resObj
		},
	},
	"fyne-text-style-ptr//monospace!": {
		Doc:   "Set *fyne.TextStyle Monospace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//monospace!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//monospace!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//monospace!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Monospace = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style-ptr//monospace!")
			}
			return arg0
		},
	},
	"fyne-text-style-ptr//monospace?": {
		Doc:   "Get *fyne.TextStyle Monospace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//monospace?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//monospace?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//monospace?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Monospace))
			return resObj
		},
	},
	"fyne-text-style-ptr//symbol!": {
		Doc:   "Set *fyne.TextStyle Symbol value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//symbol!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//symbol!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//symbol!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Symbol = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style-ptr//symbol!")
			}
			return arg0
		},
	},
	"fyne-text-style-ptr//symbol?": {
		Doc:   "Get *fyne.TextStyle Symbol value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//symbol?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//symbol?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//symbol?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Symbol))
			return resObj
		},
	},
	"fyne-text-style-ptr//tab-width!": {
		Doc:   "Set *fyne.TextStyle TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//tab-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//tab-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//tab-width!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style-ptr//tab-width!")
			}
			return arg0
		},
	},
	"fyne-text-style-ptr//tab-width?": {
		Doc:   "Get *fyne.TextStyle TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//tab-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//tab-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style-ptr//tab-width?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"fyne-text-style//bold!": {
		Doc:   "Set fyne.TextStyle Bold value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//bold!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//bold!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Bold = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style//bold!")
			}
			return arg0
		},
	},
	"fyne-text-style//bold?": {
		Doc:   "Get fyne.TextStyle Bold value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//bold?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//bold?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Bold))
			return resObj
		},
	},
	"fyne-text-style//italic!": {
		Doc:   "Set fyne.TextStyle Italic value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//italic!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//italic!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Italic = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style//italic!")
			}
			return arg0
		},
	},
	"fyne-text-style//italic?": {
		Doc:   "Get fyne.TextStyle Italic value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//italic?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//italic?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Italic))
			return resObj
		},
	},
	"fyne-text-style//monospace!": {
		Doc:   "Set fyne.TextStyle Monospace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//monospace!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//monospace!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Monospace = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style//monospace!")
			}
			return arg0
		},
	},
	"fyne-text-style//monospace?": {
		Doc:   "Get fyne.TextStyle Monospace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//monospace?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//monospace?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Monospace))
			return resObj
		},
	},
	"fyne-text-style//symbol!": {
		Doc:   "Set fyne.TextStyle Symbol value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//symbol!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//symbol!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Symbol = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style//symbol!")
			}
			return arg0
		},
	},
	"fyne-text-style//symbol?": {
		Doc:   "Get fyne.TextStyle Symbol value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//symbol?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//symbol?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Symbol))
			return resObj
		},
	},
	"fyne-text-style//tab-width!": {
		Doc:   "Set fyne.TextStyle TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//tab-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//tab-width!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-text-style//tab-width!")
			}
			return arg0
		},
	},
	"fyne-text-style//tab-width?": {
		Doc:   "Get fyne.TextStyle TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self fyne.TextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//tab-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-text-style//tab-width?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"fyne-theme//color": {
		Doc:   "fyne.Theme.Color",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//color")
			}
			var arg1Val fyne.ThemeColorName
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-theme//color")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-theme//color")
			}
			var arg2Val fyne.ThemeVariant
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.ThemeVariant)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "fyne-theme//color")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "fyne-theme//color")
			}
			res0 := arg0Val.Color(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"fyne-theme//font": {
		Doc:   "fyne.Theme.Font",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//font")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//font")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//font")
			}
			var arg1Val fyne.TextStyle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-theme//font")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-theme//font")
			}
			res0 := arg0Val.Font(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-theme//icon": {
		Doc:   "fyne.Theme.Icon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//icon")
			}
			var arg1Val fyne.ThemeIconName
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.ThemeIconName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-theme//icon")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-theme//icon")
			}
			res0 := arg0Val.Icon(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-theme//size": {
		Doc:   "fyne.Theme.Size",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-theme//size")
			}
			var arg1Val fyne.ThemeSizeName
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.ThemeSizeName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-theme//size")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-theme//size")
			}
			res0 := arg0Val.Size(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"fyne-validatable//set-on-validation-changed": {
		Doc:   "fyne.Validatable.SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Validatable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Validatable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-validatable//set-on-validation-changed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-validatable//set-on-validation-changed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-validatable//set-on-validation-changed")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-validatable//set-on-validation-changed")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-validatable//set-on-validation-changed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-validatable//set-on-validation-changed")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"fyne-validatable//validate": {
		Doc:   "fyne.Validatable.Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Validatable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Validatable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-validatable//validate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-validatable//validate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-validatable//validate")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"fyne-vector-2//components": {
		Doc:   "fyne.Vector2.Components",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Vector2
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-vector-2//components")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-vector-2//components")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-vector-2//components")
			}
			res0, res1 := arg0Val.Components()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			return env.NewDict(map[string]any{
				"1": res0Obj,
				"2": res1Obj,
			})
		},
	},
	"fyne-vector-2//is-zero": {
		Doc:   "fyne.Vector2.IsZero",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Vector2
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Vector2)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-vector-2//is-zero")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-vector-2//is-zero")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-vector-2//is-zero")
			}
			res0 := arg0Val.IsZero()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-widget-renderer//destroy": {
		Doc:   "fyne.WidgetRenderer.Destroy",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//destroy")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//destroy")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//destroy")
			}
			arg0Val.Destroy()
			return arg0
		},
	},
	"fyne-widget-renderer//layout": {
		Doc:   "fyne.WidgetRenderer.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//layout")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-widget-renderer//layout")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-widget-renderer//layout")
			}
			arg0Val.Layout(arg1Val)
			return arg0
		},
	},
	"fyne-widget-renderer//min-size": {
		Doc:   "fyne.WidgetRenderer.MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"fyne-widget-renderer//objects": {
		Doc:   "fyne.WidgetRenderer.Objects",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//objects")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//objects")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//objects")
			}
			res0 := arg0Val.Objects()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object-arr")
			return res0Obj
		},
	},
	"fyne-widget-renderer//refresh": {
		Doc:   "fyne.WidgetRenderer.Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.WidgetRenderer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.WidgetRenderer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget-renderer//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"fyne-widget//create-renderer": {
		Doc:   "fyne.Widget.CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Widget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-widget//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"fyne-window//canvas": {
		Doc:   "fyne.Window.Canvas",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//canvas")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//canvas")
			}
			res0 := arg0Val.Canvas()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas")
			return res0Obj
		},
	},
	"fyne-window//center-on-screen": {
		Doc:   "fyne.Window.CenterOnScreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//center-on-screen")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//center-on-screen")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//center-on-screen")
			}
			arg0Val.CenterOnScreen()
			return arg0
		},
	},
	"fyne-window//clipboard": {
		Doc:   "fyne.Window.Clipboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//clipboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//clipboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//clipboard")
			}
			res0 := arg0Val.Clipboard()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-clipboard")
			return res0Obj
		},
	},
	"fyne-window//close": {
		Doc:   "fyne.Window.Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//close")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//close")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//close")
			}
			arg0Val.Close()
			return arg0
		},
	},
	"fyne-window//content": {
		Doc:   "fyne.Window.Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"fyne-window//fixed-size": {
		Doc:   "fyne.Window.FixedSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//fixed-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//fixed-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//fixed-size")
			}
			res0 := arg0Val.FixedSize()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-window//full-screen": {
		Doc:   "fyne.Window.FullScreen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//full-screen")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//full-screen")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//full-screen")
			}
			res0 := arg0Val.FullScreen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-window//hide": {
		Doc:   "fyne.Window.Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"fyne-window//icon": {
		Doc:   "fyne.Window.Icon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//icon")
			}
			res0 := arg0Val.Icon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"fyne-window//main-menu": {
		Doc:   "fyne.Window.MainMenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//main-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//main-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//main-menu")
			}
			res0 := arg0Val.MainMenu()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-main-menu-ptr")
			return res0Obj
		},
	},
	"fyne-window//padded": {
		Doc:   "fyne.Window.Padded",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//padded")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//padded")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//padded")
			}
			res0 := arg0Val.Padded()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"fyne-window//request-focus": {
		Doc:   "fyne.Window.RequestFocus",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//request-focus")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//request-focus")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//request-focus")
			}
			arg0Val.RequestFocus()
			return arg0
		},
	},
	"fyne-window//resize": {
		Doc:   "fyne.Window.Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-close-intercept": {
		Doc:   "fyne.Window.SetCloseIntercept",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-close-intercept")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-close-intercept")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-close-intercept")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-window//set-close-intercept")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-window//set-close-intercept")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-window//set-close-intercept")
			}
			arg0Val.SetCloseIntercept(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-content": {
		Doc:   "fyne.Window.SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-content")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//set-content")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//set-content")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-fixed-size": {
		Doc:   "fyne.Window.SetFixedSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-fixed-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-fixed-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-fixed-size")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-window//set-fixed-size")
			}
			arg0Val.SetFixedSize(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-full-screen": {
		Doc:   "fyne.Window.SetFullScreen",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-full-screen")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-full-screen")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-full-screen")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-window//set-full-screen")
			}
			arg0Val.SetFullScreen(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-icon": {
		Doc:   "fyne.Window.SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//set-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//set-icon")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-main-menu": {
		Doc:   "fyne.Window.SetMainMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-main-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-main-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-main-menu")
			}
			var arg1Val *fyne.MainMenu
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.MainMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//set-main-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//set-main-menu")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "fyne-window//set-main-menu")
			}
			arg0Val.SetMainMenu(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-master": {
		Doc:   "fyne.Window.SetMaster",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-master")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-master")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-master")
			}
			arg0Val.SetMaster()
			return arg0
		},
	},
	"fyne-window//set-on-closed": {
		Doc:   "fyne.Window.SetOnClosed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-on-closed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-on-closed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-on-closed")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-window//set-on-closed")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-window//set-on-closed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-window//set-on-closed")
			}
			arg0Val.SetOnClosed(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-on-dropped": {
		Doc:   "fyne.Window.SetOnDropped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-on-dropped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-on-dropped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-on-dropped")
			}
			var arg1Val func(fyne.Position, []fyne.URI)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-window//set-on-dropped")
				}
				arg1Val = func(arg0 fyne.Position, arg1 []fyne.URI) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "fyne-position")
					arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-uri-arr")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "fyne-window//set-on-dropped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "fyne-window//set-on-dropped")
			}
			arg0Val.SetOnDropped(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-padded": {
		Doc:   "fyne.Window.SetPadded",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-padded")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-padded")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-padded")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "fyne-window//set-padded")
			}
			arg0Val.SetPadded(arg1Val)
			return arg0
		},
	},
	"fyne-window//set-title": {
		Doc:   "fyne.Window.SetTitle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-title")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-title")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//set-title")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "fyne-window//set-title")
			}
			arg0Val.SetTitle(arg1Val)
			return arg0
		},
	},
	"fyne-window//show": {
		Doc:   "fyne.Window.Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"fyne-window//show-and-run": {
		Doc:   "fyne.Window.ShowAndRun",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//show-and-run")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//show-and-run")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//show-and-run")
			}
			arg0Val.ShowAndRun()
			return arg0
		},
	},
	"fyne-window//title": {
		Doc:   "fyne.Window.Title",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//title")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//title")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "fyne-window//title")
			}
			res0 := arg0Val.Title()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"layout-adaptive-grid-layout": {
		Doc:   "layout.NewAdaptiveGridLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "layout-adaptive-grid-layout")
			}
			res0 := layout.NewAdaptiveGridLayout(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-border-layout": {
		Doc:   "layout.NewBorderLayout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-border-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-border-layout")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-border-layout")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "layout-border-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "layout-border-layout")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "layout-border-layout")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "layout-border-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "layout-border-layout")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "layout-border-layout")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "layout-border-layout")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "layout-border-layout")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "layout-border-layout")
			}
			res0 := layout.NewBorderLayout(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-center-layout": {
		Doc:   "layout.NewCenterLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewCenterLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-form-layout": {
		Doc:   "layout.NewFormLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewFormLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-grid-layout": {
		Doc:   "layout.NewGridLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "layout-grid-layout")
			}
			res0 := layout.NewGridLayout(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-grid-layout-with-columns": {
		Doc:   "layout.NewGridLayoutWithColumns",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "layout-grid-layout-with-columns")
			}
			res0 := layout.NewGridLayoutWithColumns(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-grid-layout-with-rows": {
		Doc:   "layout.NewGridLayoutWithRows",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.IntegerType}, "layout-grid-layout-with-rows")
			}
			res0 := layout.NewGridLayoutWithRows(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-grid-wrap-layout": {
		Doc:   "layout.NewGridWrapLayout",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Size
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-grid-wrap-layout")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-grid-wrap-layout")
			}
			res0 := layout.NewGridWrapLayout(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-h-box-layout": {
		Doc:   "layout.NewHBoxLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewHBoxLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-max-layout": {
		Doc:   "layout.NewMaxLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewMaxLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-padded-layout": {
		Doc:   "layout.NewPaddedLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewPaddedLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-spacer": {
		Doc:   "layout.NewSpacer",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewSpacer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"layout-spacer-object//expand-horizontal": {
		Doc:   "layout.SpacerObject.ExpandHorizontal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val layout.SpacerObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(layout.SpacerObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-object//expand-horizontal")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-object//expand-horizontal")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-object//expand-horizontal")
			}
			res0 := arg0Val.ExpandHorizontal()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"layout-spacer-object//expand-vertical": {
		Doc:   "layout.SpacerObject.ExpandVertical",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val layout.SpacerObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(layout.SpacerObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-object//expand-vertical")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-object//expand-vertical")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-object//expand-vertical")
			}
			res0 := arg0Val.ExpandVertical()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"layout-spacer-ptr//expand-horizontal": {
		Doc:   "(*layout.Spacer).ExpandHorizontal",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//expand-horizontal")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//expand-horizontal")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//expand-horizontal")
			}
			res0 := arg0Val.ExpandHorizontal()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"layout-spacer-ptr//expand-vertical": {
		Doc:   "(*layout.Spacer).ExpandVertical",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//expand-vertical")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//expand-vertical")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//expand-vertical")
			}
			res0 := arg0Val.ExpandVertical()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"layout-spacer-ptr//fix-horizontal!": {
		Doc:   "Set *layout.Spacer FixHorizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-horizontal!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-horizontal!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixHorizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "layout-spacer-ptr//fix-horizontal!")
			}
			return arg0
		},
	},
	"layout-spacer-ptr//fix-horizontal?": {
		Doc:   "Get *layout.Spacer FixHorizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-horizontal?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-horizontal?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixHorizontal))
			return resObj
		},
	},
	"layout-spacer-ptr//fix-vertical!": {
		Doc:   "Set *layout.Spacer FixVertical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-vertical!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-vertical!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-vertical!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixVertical = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "layout-spacer-ptr//fix-vertical!")
			}
			return arg0
		},
	},
	"layout-spacer-ptr//fix-vertical?": {
		Doc:   "Get *layout.Spacer FixVertical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-vertical?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-vertical?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//fix-vertical?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixVertical))
			return resObj
		},
	},
	"layout-spacer-ptr//hide": {
		Doc:   "(*layout.Spacer).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"layout-spacer-ptr//min-size": {
		Doc:   "(*layout.Spacer).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"layout-spacer-ptr//move": {
		Doc:   "(*layout.Spacer).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "layout-spacer-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "layout-spacer-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"layout-spacer-ptr//position": {
		Doc:   "(*layout.Spacer).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"layout-spacer-ptr//refresh": {
		Doc:   "(*layout.Spacer).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"layout-spacer-ptr//resize": {
		Doc:   "(*layout.Spacer).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "layout-spacer-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "layout-spacer-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"layout-spacer-ptr//show": {
		Doc:   "(*layout.Spacer).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"layout-spacer-ptr//size": {
		Doc:   "(*layout.Spacer).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"layout-spacer-ptr//visible": {
		Doc:   "(*layout.Spacer).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer-ptr//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"layout-spacer//fix-horizontal!": {
		Doc:   "Set layout.Spacer FixHorizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer//fix-horizontal!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer//fix-horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixHorizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "layout-spacer//fix-horizontal!")
			}
			return arg0
		},
	},
	"layout-spacer//fix-horizontal?": {
		Doc:   "Get layout.Spacer FixHorizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer//fix-horizontal?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer//fix-horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixHorizontal))
			return resObj
		},
	},
	"layout-spacer//fix-vertical!": {
		Doc:   "Set layout.Spacer FixVertical value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer//fix-vertical!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer//fix-vertical!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.FixVertical = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "layout-spacer//fix-vertical!")
			}
			return arg0
		},
	},
	"layout-spacer//fix-vertical?": {
		Doc:   "Get layout.Spacer FixVertical value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(layout.Spacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer//fix-vertical?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "layout-spacer//fix-vertical?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.FixVertical))
			return resObj
		},
	},
	"layout-stack-layout": {
		Doc:   "layout.NewStackLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewStackLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"layout-v-box-layout": {
		Doc:   "layout.NewVBoxLayout",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := layout.NewVBoxLayout()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-layout")
			return res0Obj
		},
	},
	"mobile-device//hide-virtual-keyboard": {
		Doc:   "mobile.Device.HideVirtualKeyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-device//hide-virtual-keyboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-device//hide-virtual-keyboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-device//hide-virtual-keyboard")
			}
			arg0Val.HideVirtualKeyboard()
			return arg0
		},
	},
	"mobile-device//show-virtual-keyboard": {
		Doc:   "mobile.Device.ShowVirtualKeyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-device//show-virtual-keyboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-device//show-virtual-keyboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-device//show-virtual-keyboard")
			}
			arg0Val.ShowVirtualKeyboard()
			return arg0
		},
	},
	"mobile-device//show-virtual-keyboard-type": {
		Doc:   "mobile.Device.ShowVirtualKeyboardType",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Device
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Device)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-device//show-virtual-keyboard-type")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-device//show-virtual-keyboard-type")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-device//show-virtual-keyboard-type")
			}
			var arg1Val mobile.KeyboardType
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(mobile.KeyboardType)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-device//show-virtual-keyboard-type")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-device//show-virtual-keyboard-type")
			}
			arg0Val.ShowVirtualKeyboardType(arg1Val)
			return arg0
		},
	},
	"mobile-driver//go-back": {
		Doc:   "mobile.Driver.GoBack",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Driver
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Driver)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-driver//go-back")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-driver//go-back")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-driver//go-back")
			}
			arg0Val.GoBack()
			return arg0
		},
	},
	"mobile-touch-event-ptr//absolute-position!": {
		Doc:   "Set *mobile.TouchEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//absolute-position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//absolute-position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touch-event-ptr//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touch-event-ptr//absolute-position!")
			}
			return arg0
		},
	},
	"mobile-touch-event-ptr//absolute-position?": {
		Doc:   "Get *mobile.TouchEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//absolute-position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//absolute-position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"mobile-touch-event-ptr//position!": {
		Doc:   "Set *mobile.TouchEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//position!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//position!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touch-event-ptr//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touch-event-ptr//position!")
			}
			return arg0
		},
	},
	"mobile-touch-event-ptr//position?": {
		Doc:   "Get *mobile.TouchEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//position?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//position?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event-ptr//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"mobile-touch-event//absolute-position!": {
		Doc:   "Set mobile.TouchEvent AbsolutePosition value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event//absolute-position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.AbsolutePosition, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touch-event//absolute-position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touch-event//absolute-position!")
			}
			return arg0
		},
	},
	"mobile-touch-event//absolute-position?": {
		Doc:   "Get mobile.TouchEvent AbsolutePosition value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event//absolute-position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event//absolute-position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.AbsolutePosition, "fyne-position")
			return resObj
		},
	},
	"mobile-touch-event//position!": {
		Doc:   "Set mobile.TouchEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event//position!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Position, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touch-event//position!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touch-event//position!")
			}
			return arg0
		},
	},
	"mobile-touch-event//position?": {
		Doc:   "Get mobile.TouchEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self mobile.TouchEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event//position?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touch-event//position?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "fyne-position")
			return resObj
		},
	},
	"mobile-touchable//touch-cancel": {
		Doc:   "mobile.Touchable.TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Touchable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Touchable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touchable//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touchable//touch-cancel")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touchable//touch-cancel")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touchable//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touchable//touch-cancel")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touchable//touch-cancel")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"mobile-touchable//touch-down": {
		Doc:   "mobile.Touchable.TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Touchable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Touchable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touchable//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touchable//touch-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touchable//touch-down")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touchable//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touchable//touch-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touchable//touch-down")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"mobile-touchable//touch-up": {
		Doc:   "mobile.Touchable.TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val mobile.Touchable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(mobile.Touchable)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touchable//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touchable//touch-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "mobile-touchable//touch-up")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touchable//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touchable//touch-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "mobile-touchable//touch-up")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"playground-render": {
		Doc:   "playground.Render",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "playground-render")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "playground-render")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "playground-render")
			}
			playground.Render(arg0Val)
			return nil
		},
	},
	"playground-render-canvas": {
		Doc:   "playground.RenderCanvas",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "playground-render-canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "playground-render-canvas")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "playground-render-canvas")
			}
			playground.RenderCanvas(arg0Val)
			return nil
		},
	},
	"playground-render-window": {
		Doc:   "playground.RenderWindow",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Window)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "playground-render-window")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "playground-render-window")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "playground-render-window")
			}
			playground.RenderWindow(arg0Val)
			return nil
		},
	},
	"playground-software-canvas": {
		Doc:   "playground.NewSoftwareCanvas",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := playground.NewSoftwareCanvas()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "test-windowless-canvas")
			return res0Obj
		},
	},
	"repository-copyable-repository//copy": {
		Doc:   "repository.CopyableRepository.Copy",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.CopyableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.CopyableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-copyable-repository//copy")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-copyable-repository//copy")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-copyable-repository//copy")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-copyable-repository//copy")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-copyable-repository//copy")
			}
			var arg2Val fyne.URI
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "repository-copyable-repository//copy")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "repository-copyable-repository//copy")
			}
			res0 := arg0Val.Copy(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-custom-uri-repository//parse-uri": {
		Doc:   "repository.CustomURIRepository.ParseURI",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.CustomURIRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.CustomURIRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-custom-uri-repository//parse-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-custom-uri-repository//parse-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-custom-uri-repository//parse-uri")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "repository-custom-uri-repository//parse-uri")
			}
			res0, res1 := arg0Val.ParseURI(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-file-uri": {
		Doc:   "repository.NewFileURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "repository-file-uri")
			}
			res0 := repository.NewFileURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			return res0Obj
		},
	},
	"repository-for-scheme": {
		Doc:   "repository.ForScheme",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "repository-for-scheme")
			}
			res0, res1 := repository.ForScheme(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "repository-repository")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-for-uri": {
		Doc:   "repository.ForURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-for-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-for-uri")
			}
			res0, res1 := repository.ForURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "repository-repository")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-generic-child": {
		Doc:   "repository.GenericChild",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-generic-child")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-generic-child")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "repository-generic-child")
			}
			res0, res1 := repository.GenericChild(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-generic-copy": {
		Doc:   "repository.GenericCopy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-generic-copy")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-generic-copy")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-generic-copy")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-generic-copy")
			}
			res0 := repository.GenericCopy(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-generic-move": {
		Doc:   "repository.GenericMove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-generic-move")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-generic-move")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-generic-move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-generic-move")
			}
			res0 := repository.GenericMove(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-generic-parent": {
		Doc:   "repository.GenericParent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-generic-parent")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-generic-parent")
			}
			res0, res1 := repository.GenericParent(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-hierarchical-repository//child": {
		Doc:   "repository.HierarchicalRepository.Child",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.HierarchicalRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.HierarchicalRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-hierarchical-repository//child")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-hierarchical-repository//child")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-hierarchical-repository//child")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-hierarchical-repository//child")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-hierarchical-repository//child")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.StringType}, "repository-hierarchical-repository//child")
			}
			res0, res1 := arg0Val.Child(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-hierarchical-repository//parent": {
		Doc:   "repository.HierarchicalRepository.Parent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.HierarchicalRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.HierarchicalRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-hierarchical-repository//parent")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-hierarchical-repository//parent")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-hierarchical-repository//parent")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-hierarchical-repository//parent")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-hierarchical-repository//parent")
			}
			res0, res1 := arg0Val.Parent(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-listable-repository//can-list": {
		Doc:   "repository.ListableRepository.CanList",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.ListableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.ListableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-listable-repository//can-list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-listable-repository//can-list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-listable-repository//can-list")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-listable-repository//can-list")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-listable-repository//can-list")
			}
			res0, res1 := arg0Val.CanList(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-listable-repository//create-listable": {
		Doc:   "repository.ListableRepository.CreateListable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.ListableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.ListableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-listable-repository//create-listable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-listable-repository//create-listable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-listable-repository//create-listable")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-listable-repository//create-listable")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-listable-repository//create-listable")
			}
			res0 := arg0Val.CreateListable(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-listable-repository//list": {
		Doc:   "repository.ListableRepository.List",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.ListableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.ListableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-listable-repository//list")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-listable-repository//list")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-listable-repository//list")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-listable-repository//list")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-listable-repository//list")
			}
			res0, res1 := arg0Val.List(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-movable-repository//move": {
		Doc:   "repository.MovableRepository.Move",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.MovableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.MovableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-movable-repository//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-movable-repository//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-movable-repository//move")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-movable-repository//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-movable-repository//move")
			}
			var arg2Val fyne.URI
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "repository-movable-repository//move")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "repository-movable-repository//move")
			}
			res0 := arg0Val.Move(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-parse-uri": {
		Doc:   "repository.ParseURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "repository-parse-uri")
			}
			res0, res1 := repository.ParseURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-register": {
		Doc:   "repository.Register",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "repository-register")
			}
			var arg1Val repository.Repository
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-register")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-register")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-register")
			}
			repository.Register(arg0Val, arg1Val)
			return nil
		},
	},
	"repository-repository//can-read": {
		Doc:   "repository.Repository.CanRead",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//can-read")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//can-read")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//can-read")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-repository//can-read")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-repository//can-read")
			}
			res0, res1 := arg0Val.CanRead(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-repository//destroy": {
		Doc:   "repository.Repository.Destroy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//destroy")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//destroy")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//destroy")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "repository-repository//destroy")
			}
			arg0Val.Destroy(arg1Val)
			return arg0
		},
	},
	"repository-repository//exists": {
		Doc:   "repository.Repository.Exists",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//exists")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//exists")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//exists")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-repository//exists")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-repository//exists")
			}
			res0, res1 := arg0Val.Exists(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-repository//reader": {
		Doc:   "repository.Repository.Reader",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.Repository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.Repository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//reader")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//reader")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-repository//reader")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-repository//reader")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-repository//reader")
			}
			res0, res1 := arg0Val.Reader(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-writable-repository//can-write": {
		Doc:   "repository.WritableRepository.CanWrite",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.WritableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.WritableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-writable-repository//can-write")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-writable-repository//can-write")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-writable-repository//can-write")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-writable-repository//can-write")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-writable-repository//can-write")
			}
			res0, res1 := arg0Val.CanWrite(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"repository-writable-repository//delete": {
		Doc:   "repository.WritableRepository.Delete",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.WritableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.WritableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-writable-repository//delete")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-writable-repository//delete")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-writable-repository//delete")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-writable-repository//delete")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-writable-repository//delete")
			}
			res0 := arg0Val.Delete(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"repository-writable-repository//writer": {
		Doc:   "repository.WritableRepository.Writer",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val repository.WritableRepository
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(repository.WritableRepository)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-writable-repository//writer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-writable-repository//writer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "repository-writable-repository//writer")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-writable-repository//writer")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "repository-writable-repository//writer")
			}
			res0, res1 := arg0Val.Writer(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"software-canvas": {
		Doc:   "software.NewCanvas",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := software.NewCanvas()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "test-windowless-canvas")
			return res0Obj
		},
	},
	"software-render": {
		Doc:   "software.Render",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "software-render")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "software-render")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "software-render")
			}
			var arg1Val fyne.Theme
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "software-render")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "software-render")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "software-render")
			}
			res0 := software.Render(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"software-render-canvas": {
		Doc:   "software.RenderCanvas",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Canvas
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "software-render-canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "software-render-canvas")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "software-render-canvas")
			}
			var arg1Val fyne.Theme
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Theme)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "software-render-canvas")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "software-render-canvas")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "software-render-canvas")
			}
			res0 := software.RenderCanvas(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "image-image")
			return res0Obj
		},
	},
	"software-transparent-canvas": {
		Doc:   "software.NewTransparentCanvas",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := software.NewTransparentCanvas()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "test-windowless-canvas")
			return res0Obj
		},
	},
	"storage-can-list": {
		Doc:   "storage.CanList",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-can-list")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-can-list")
			}
			res0, res1 := storage.CanList(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-can-read": {
		Doc:   "storage.CanRead",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-can-read")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-can-read")
			}
			res0, res1 := storage.CanRead(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-can-write": {
		Doc:   "storage.CanWrite",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-can-write")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-can-write")
			}
			res0, res1 := storage.CanWrite(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-child": {
		Doc:   "storage.Child",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-child")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-child")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "storage-child")
			}
			res0, res1 := storage.Child(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-copy": {
		Doc:   "storage.Copy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-copy")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-copy")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-copy")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-copy")
			}
			res0 := storage.Copy(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"storage-create-listable": {
		Doc:   "storage.CreateListable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-create-listable")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-create-listable")
			}
			res0 := storage.CreateListable(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"storage-delete": {
		Doc:   "storage.Delete",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-delete")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-delete")
			}
			res0 := storage.Delete(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"storage-exists": {
		Doc:   "storage.Exists",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-exists")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-exists")
			}
			res0, res1 := storage.Exists(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-extension-file-filter": {
		Doc:   "storage.NewExtensionFileFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter")
			}
			res0 := storage.NewExtensionFileFilter(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "storage-file-filter")
			return res0Obj
		},
	},
	"storage-extension-file-filter-ptr//extensions!": {
		Doc:   "Set *storage.ExtensionFileFilter Extensions value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//extensions!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//extensions!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//extensions!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Extensions = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Extensions[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter-ptr//extensions!")
					}
				}
			case env.Native:
				var ok bool
				self.Extensions, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter-ptr//extensions!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter-ptr//extensions!")
				}
				self.Extensions = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter-ptr//extensions!")
			}
			return arg0
		},
	},
	"storage-extension-file-filter-ptr//extensions?": {
		Doc:   "Get *storage.ExtensionFileFilter Extensions value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//extensions?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//extensions?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//extensions?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Extensions, "string-arr")
			return resObj
		},
	},
	"storage-extension-file-filter-ptr//matches": {
		Doc:   "(*storage.ExtensionFileFilter).Matches",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//matches")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//matches")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//matches")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//matches")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-extension-file-filter-ptr//matches")
			}
			res0 := arg0Val.Matches(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"storage-extension-file-filter//extensions!": {
		Doc:   "Set storage.ExtensionFileFilter Extensions value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter//extensions!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter//extensions!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Extensions = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Extensions[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter//extensions!")
					}
				}
			case env.Native:
				var ok bool
				self.Extensions, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter//extensions!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter//extensions!")
				}
				self.Extensions = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-extension-file-filter//extensions!")
			}
			return arg0
		},
	},
	"storage-extension-file-filter//extensions?": {
		Doc:   "Get storage.ExtensionFileFilter Extensions value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.ExtensionFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.ExtensionFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter//extensions?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-extension-file-filter//extensions?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Extensions, "string-arr")
			return resObj
		},
	},
	"storage-file-filter//matches": {
		Doc:   "storage.FileFilter.Matches",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val storage.FileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(storage.FileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-file-filter//matches")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-file-filter//matches")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-file-filter//matches")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-file-filter//matches")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-file-filter//matches")
			}
			res0 := arg0Val.Matches(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"storage-file-uri": {
		Doc:   "storage.NewFileURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "storage-file-uri")
			}
			res0 := storage.NewFileURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			return res0Obj
		},
	},
	"storage-list": {
		Doc:   "storage.List",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-list")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-list")
			}
			res0, res1 := storage.List(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-arr")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-lister-for-uri": {
		Doc:   "storage.ListerForURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-lister-for-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-lister-for-uri")
			}
			res0, res1 := storage.ListerForURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-listable-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-load-resource-from-uri": {
		Doc:   "storage.LoadResourceFromURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-load-resource-from-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-load-resource-from-uri")
			}
			res0, res1 := storage.LoadResourceFromURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-mime-type-file-filter": {
		Doc:   "storage.NewMimeTypeFileFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter")
			}
			res0 := storage.NewMimeTypeFileFilter(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "storage-file-filter")
			return res0Obj
		},
	},
	"storage-mime-type-file-filter-ptr//matches": {
		Doc:   "(*storage.MimeTypeFileFilter).Matches",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//matches")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//matches")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//matches")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//matches")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//matches")
			}
			res0 := arg0Val.Matches(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"storage-mime-type-file-filter-ptr//mime-types!": {
		Doc:   "Set *storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.MimeTypes = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.MimeTypes[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types!")
					}
				}
			case env.Native:
				var ok bool
				self.MimeTypes, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types!")
				}
				self.MimeTypes = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types!")
			}
			return arg0
		},
	},
	"storage-mime-type-file-filter-ptr//mime-types?": {
		Doc:   "Get *storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter-ptr//mime-types?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.MimeTypes, "string-arr")
			return resObj
		},
	},
	"storage-mime-type-file-filter//mime-types!": {
		Doc:   "Set storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter//mime-types!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter//mime-types!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.MimeTypes = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.MimeTypes[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter//mime-types!")
					}
				}
			case env.Native:
				var ok bool
				self.MimeTypes, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter//mime-types!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter//mime-types!")
				}
				self.MimeTypes = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "storage-mime-type-file-filter//mime-types!")
			}
			return arg0
		},
	},
	"storage-mime-type-file-filter//mime-types?": {
		Doc:   "Get storage.MimeTypeFileFilter MimeTypes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self storage.MimeTypeFileFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(storage.MimeTypeFileFilter)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter//mime-types?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-mime-type-file-filter//mime-types?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.MimeTypes, "string-arr")
			return resObj
		},
	},
	"storage-move": {
		Doc:   "storage.Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-move")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-move")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "storage-move")
			}
			res0 := storage.Move(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"storage-open-file-from-uri": {
		Doc:   "storage.OpenFileFromURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-open-file-from-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-open-file-from-uri")
			}
			res0, res1 := storage.OpenFileFromURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-parent": {
		Doc:   "storage.Parent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-parent")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-parent")
			}
			res0, res1 := storage.Parent(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-parse-uri": {
		Doc:   "storage.ParseURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "storage-parse-uri")
			}
			res0, res1 := storage.ParseURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-reader": {
		Doc:   "storage.Reader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-reader")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-reader")
			}
			res0, res1 := storage.Reader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-read-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-save-file-to-uri": {
		Doc:   "storage.SaveFileToURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-save-file-to-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-save-file-to-uri")
			}
			res0, res1 := storage.SaveFileToURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"storage-uri": {
		Doc:   "storage.NewURI",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "storage-uri")
			}
			res0 := storage.NewURI(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri")
			return res0Obj
		},
	},
	"storage-writer": {
		Doc:   "storage.Writer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-writer")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "storage-writer")
			}
			res0, res1 := storage.Writer(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-uri-write-closer")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"theme-account-icon": {
		Doc:   "theme.AccountIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.AccountIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-background-color": {
		Doc:   "theme.BackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-broken-image-icon": {
		Doc:   "theme.BrokenImageIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.BrokenImageIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-button-color": {
		Doc:   "theme.ButtonColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-cancel-icon": {
		Doc:   "theme.CancelIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CancelIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-caption-text-size": {
		Doc:   "theme.CaptionTextSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CaptionTextSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-check-button-checked-icon": {
		Doc:   "theme.CheckButtonCheckedIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CheckButtonCheckedIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-check-button-icon": {
		Doc:   "theme.CheckButtonIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.CheckButtonIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-color-achromatic-icon": {
		Doc:   "theme.ColorAchromaticIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ColorAchromaticIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-color-chromatic-icon": {
		Doc:   "theme.ColorChromaticIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ColorChromaticIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-color-palette-icon": {
		Doc:   "theme.ColorPaletteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ColorPaletteIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-colored-resource": {
		Doc:   "theme.NewColoredResource",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-colored-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-colored-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-colored-resource")
			}
			var arg1Val fyne.ThemeColorName
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme-colored-resource")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme-colored-resource")
			}
			res0 := theme.NewColoredResource(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-themed-resource-ptr")
			return res0Obj
		},
	},
	"theme-computer-icon": {
		Doc:   "theme.ComputerIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ComputerIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-confirm-icon": {
		Doc:   "theme.ConfirmIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ConfirmIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-content-add-icon": {
		Doc:   "theme.ContentAddIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentAddIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-content-clear-icon": {
		Doc:   "theme.ContentClearIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentClearIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-content-copy-icon": {
		Doc:   "theme.ContentCopyIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentCopyIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-content-cut-icon": {
		Doc:   "theme.ContentCutIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentCutIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-content-paste-icon": {
		Doc:   "theme.ContentPasteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentPasteIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-content-redo-icon": {
		Doc:   "theme.ContentRedoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentRedoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-content-remove-icon": {
		Doc:   "theme.ContentRemoveIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentRemoveIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-content-undo-icon": {
		Doc:   "theme.ContentUndoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ContentUndoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-dark-theme": {
		Doc:   "theme.DarkTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DarkTheme()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
			return res0Obj
		},
	},
	"theme-default-emoji-font": {
		Doc:   "theme.DefaultEmojiFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultEmojiFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-default-symbol-font": {
		Doc:   "theme.DefaultSymbolFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultSymbolFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-default-text-bold-font": {
		Doc:   "theme.DefaultTextBoldFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextBoldFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-default-text-bold-italic-font": {
		Doc:   "theme.DefaultTextBoldItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextBoldItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-default-text-font": {
		Doc:   "theme.DefaultTextFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-default-text-italic-font": {
		Doc:   "theme.DefaultTextItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-default-text-monospace-font": {
		Doc:   "theme.DefaultTextMonospaceFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTextMonospaceFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-default-theme": {
		Doc:   "theme.DefaultTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DefaultTheme()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
			return res0Obj
		},
	},
	"theme-delete-icon": {
		Doc:   "theme.DeleteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DeleteIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-disabled-button-color": {
		Doc:   "theme.DisabledButtonColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DisabledButtonColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-disabled-color": {
		Doc:   "theme.DisabledColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DisabledColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-disabled-resource": {
		Doc:   "theme.NewDisabledResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-disabled-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-disabled-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-disabled-resource")
			}
			res0 := theme.NewDisabledResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-disabled-resource-ptr")
			return res0Obj
		},
	},
	"theme-disabled-resource-ptr//content": {
		Doc:   "(*theme.DisabledResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.DisabledResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.DisabledResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-disabled-resource-ptr//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-disabled-resource-ptr//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-disabled-resource-ptr//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr")
			return res0Obj
		},
	},
	"theme-disabled-resource-ptr//name": {
		Doc:   "(*theme.DisabledResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.DisabledResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.DisabledResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-disabled-resource-ptr//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-disabled-resource-ptr//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-disabled-resource-ptr//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"theme-disabled-text-color": {
		Doc:   "theme.DisabledTextColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DisabledTextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-document-create-icon": {
		Doc:   "theme.DocumentCreateIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentCreateIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-document-icon": {
		Doc:   "theme.DocumentIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-document-print-icon": {
		Doc:   "theme.DocumentPrintIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentPrintIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-document-save-icon": {
		Doc:   "theme.DocumentSaveIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DocumentSaveIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-download-icon": {
		Doc:   "theme.DownloadIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.DownloadIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-error-color": {
		Doc:   "theme.ErrorColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ErrorColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-error-icon": {
		Doc:   "theme.ErrorIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ErrorIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-error-themed-resource": {
		Doc:   "theme.NewErrorThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource")
			}
			res0 := theme.NewErrorThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-error-themed-resource-ptr")
			return res0Obj
		},
	},
	"theme-error-themed-resource-ptr//content": {
		Doc:   "(*theme.ErrorThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ErrorThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ErrorThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource-ptr//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource-ptr//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource-ptr//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr")
			return res0Obj
		},
	},
	"theme-error-themed-resource-ptr//name": {
		Doc:   "(*theme.ErrorThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ErrorThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ErrorThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource-ptr//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource-ptr//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource-ptr//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"theme-error-themed-resource-ptr//original": {
		Doc:   "(*theme.ErrorThemedResource).Original",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ErrorThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ErrorThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource-ptr//original")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource-ptr//original")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-error-themed-resource-ptr//original")
			}
			res0 := arg0Val.Original()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-file-application-icon": {
		Doc:   "theme.FileApplicationIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileApplicationIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-file-audio-icon": {
		Doc:   "theme.FileAudioIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileAudioIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-file-icon": {
		Doc:   "theme.FileIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-file-image-icon": {
		Doc:   "theme.FileImageIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileImageIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-file-text-icon": {
		Doc:   "theme.FileTextIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileTextIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-file-video-icon": {
		Doc:   "theme.FileVideoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FileVideoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-focus-color": {
		Doc:   "theme.FocusColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FocusColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-folder-icon": {
		Doc:   "theme.FolderIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FolderIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-folder-new-icon": {
		Doc:   "theme.FolderNewIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FolderNewIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-folder-open-icon": {
		Doc:   "theme.FolderOpenIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FolderOpenIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-foreground-color": {
		Doc:   "theme.ForegroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ForegroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-from-json": {
		Doc:   "theme.FromJSON",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "theme-from-json")
			}
			res0, res1 := theme.FromJSON(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"theme-from-json-reader": {
		Doc:   "theme.FromJSONReader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val io.Reader
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(io.Reader)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-from-json-reader")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-from-json-reader")
			}
			res0, res1 := theme.FromJSONReader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
			var res1Obj env.Object
			res1Obj = *env.NewError(res1.Error())
			return env.NewDict(map[string]any{
				"1":   res0Obj,
				"err": res1Obj,
			})
		},
	},
	"theme-from-legacy": {
		Doc:   "theme.FromLegacy",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.LegacyTheme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.LegacyTheme)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-from-legacy")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-from-legacy")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-from-legacy")
			}
			res0 := theme.FromLegacy(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
			return res0Obj
		},
	},
	"theme-fyne-logo": {
		Doc:   "theme.FyneLogo",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.FyneLogo()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-grid-icon": {
		Doc:   "theme.GridIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.GridIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-header-background-color": {
		Doc:   "theme.HeaderBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HeaderBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-help-icon": {
		Doc:   "theme.HelpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HelpIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-history-icon": {
		Doc:   "theme.HistoryIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HistoryIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-home-icon": {
		Doc:   "theme.HomeIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HomeIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-hover-color": {
		Doc:   "theme.HoverColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HoverColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-hyperlink-color": {
		Doc:   "theme.HyperlinkColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.HyperlinkColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-icon-inline-size": {
		Doc:   "theme.IconInlineSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.IconInlineSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-info-icon": {
		Doc:   "theme.InfoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InfoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-inner-padding": {
		Doc:   "theme.InnerPadding",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InnerPadding()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-input-background-color": {
		Doc:   "theme.InputBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-input-border-color": {
		Doc:   "theme.InputBorderColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputBorderColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-input-border-size": {
		Doc:   "theme.InputBorderSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputBorderSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-input-radius-size": {
		Doc:   "theme.InputRadiusSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.InputRadiusSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-inverted-themed-resource": {
		Doc:   "theme.NewInvertedThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource")
			}
			res0 := theme.NewInvertedThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-inverted-themed-resource-ptr")
			return res0Obj
		},
	},
	"theme-inverted-themed-resource-ptr//content": {
		Doc:   "(*theme.InvertedThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.InvertedThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.InvertedThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource-ptr//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource-ptr//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource-ptr//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr")
			return res0Obj
		},
	},
	"theme-inverted-themed-resource-ptr//name": {
		Doc:   "(*theme.InvertedThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.InvertedThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.InvertedThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource-ptr//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource-ptr//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource-ptr//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"theme-inverted-themed-resource-ptr//original": {
		Doc:   "(*theme.InvertedThemedResource).Original",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.InvertedThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.InvertedThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource-ptr//original")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource-ptr//original")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-inverted-themed-resource-ptr//original")
			}
			res0 := arg0Val.Original()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-light-theme": {
		Doc:   "theme.LightTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LightTheme()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-theme")
			return res0Obj
		},
	},
	"theme-line-spacing": {
		Doc:   "theme.LineSpacing",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LineSpacing()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-list-icon": {
		Doc:   "theme.ListIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ListIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-login-icon": {
		Doc:   "theme.LoginIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LoginIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-logout-icon": {
		Doc:   "theme.LogoutIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.LogoutIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-mail-attachment-icon": {
		Doc:   "theme.MailAttachmentIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailAttachmentIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-mail-compose-icon": {
		Doc:   "theme.MailComposeIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailComposeIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-mail-forward-icon": {
		Doc:   "theme.MailForwardIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailForwardIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-mail-reply-all-icon": {
		Doc:   "theme.MailReplyAllIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailReplyAllIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-mail-reply-icon": {
		Doc:   "theme.MailReplyIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailReplyIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-mail-send-icon": {
		Doc:   "theme.MailSendIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MailSendIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-fast-forward-icon": {
		Doc:   "theme.MediaFastForwardIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaFastForwardIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-fast-rewind-icon": {
		Doc:   "theme.MediaFastRewindIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaFastRewindIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-music-icon": {
		Doc:   "theme.MediaMusicIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaMusicIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-pause-icon": {
		Doc:   "theme.MediaPauseIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaPauseIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-photo-icon": {
		Doc:   "theme.MediaPhotoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaPhotoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-play-icon": {
		Doc:   "theme.MediaPlayIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaPlayIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-record-icon": {
		Doc:   "theme.MediaRecordIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaRecordIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-replay-icon": {
		Doc:   "theme.MediaReplayIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaReplayIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-skip-next-icon": {
		Doc:   "theme.MediaSkipNextIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaSkipNextIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-skip-previous-icon": {
		Doc:   "theme.MediaSkipPreviousIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaSkipPreviousIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-stop-icon": {
		Doc:   "theme.MediaStopIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaStopIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-media-video-icon": {
		Doc:   "theme.MediaVideoIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MediaVideoIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-menu-background-color": {
		Doc:   "theme.MenuBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-menu-drop-down-icon": {
		Doc:   "theme.MenuDropDownIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuDropDownIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-menu-drop-up-icon": {
		Doc:   "theme.MenuDropUpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuDropUpIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-menu-expand-icon": {
		Doc:   "theme.MenuExpandIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuExpandIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-menu-icon": {
		Doc:   "theme.MenuIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MenuIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-more-horizontal-icon": {
		Doc:   "theme.MoreHorizontalIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoreHorizontalIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-more-vertical-icon": {
		Doc:   "theme.MoreVerticalIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoreVerticalIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-move-down-icon": {
		Doc:   "theme.MoveDownIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoveDownIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-move-up-icon": {
		Doc:   "theme.MoveUpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.MoveUpIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-navigate-back-icon": {
		Doc:   "theme.NavigateBackIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.NavigateBackIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-navigate-next-icon": {
		Doc:   "theme.NavigateNextIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.NavigateNextIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-overlay-background-color": {
		Doc:   "theme.OverlayBackgroundColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.OverlayBackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-padding": {
		Doc:   "theme.Padding",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.Padding()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-place-holder-color": {
		Doc:   "theme.PlaceHolderColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PlaceHolderColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-pressed-color": {
		Doc:   "theme.PressedColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PressedColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-primary-color": {
		Doc:   "theme.PrimaryColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PrimaryColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-primary-color-named": {
		Doc:   "theme.PrimaryColorNamed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "theme-primary-color-named")
			}
			res0 := theme.PrimaryColorNamed(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-primary-color-names": {
		Doc:   "theme.PrimaryColorNames",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.PrimaryColorNames()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "string-arr")
			return res0Obj
		},
	},
	"theme-primary-themed-resource": {
		Doc:   "theme.NewPrimaryThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource")
			}
			res0 := theme.NewPrimaryThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-primary-themed-resource-ptr")
			return res0Obj
		},
	},
	"theme-primary-themed-resource-ptr//content": {
		Doc:   "(*theme.PrimaryThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.PrimaryThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.PrimaryThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource-ptr//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource-ptr//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource-ptr//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr")
			return res0Obj
		},
	},
	"theme-primary-themed-resource-ptr//name": {
		Doc:   "(*theme.PrimaryThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.PrimaryThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.PrimaryThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource-ptr//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource-ptr//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource-ptr//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"theme-primary-themed-resource-ptr//original": {
		Doc:   "(*theme.PrimaryThemedResource).Original",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.PrimaryThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.PrimaryThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource-ptr//original")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource-ptr//original")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-primary-themed-resource-ptr//original")
			}
			res0 := arg0Val.Original()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-question-icon": {
		Doc:   "theme.QuestionIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.QuestionIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-radio-button-checked-icon": {
		Doc:   "theme.RadioButtonCheckedIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.RadioButtonCheckedIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-radio-button-icon": {
		Doc:   "theme.RadioButtonIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.RadioButtonIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-scroll-bar-color": {
		Doc:   "theme.ScrollBarColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ScrollBarColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-scroll-bar-size": {
		Doc:   "theme.ScrollBarSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ScrollBarSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-scroll-bar-small-size": {
		Doc:   "theme.ScrollBarSmallSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ScrollBarSmallSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-search-icon": {
		Doc:   "theme.SearchIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SearchIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-search-replace-icon": {
		Doc:   "theme.SearchReplaceIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SearchReplaceIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-selection-color": {
		Doc:   "theme.SelectionColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SelectionColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-selection-radius-size": {
		Doc:   "theme.SelectionRadiusSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SelectionRadiusSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-separator-color": {
		Doc:   "theme.SeparatorColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SeparatorColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-separator-thickness-size": {
		Doc:   "theme.SeparatorThicknessSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SeparatorThicknessSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-settings-icon": {
		Doc:   "theme.SettingsIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SettingsIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-shadow-color": {
		Doc:   "theme.ShadowColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ShadowColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-storage-icon": {
		Doc:   "theme.StorageIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.StorageIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-success-color": {
		Doc:   "theme.SuccessColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SuccessColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-success-themed-resource": {
		Doc:   "theme.NewSuccessThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-success-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-success-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-success-themed-resource")
			}
			res0 := theme.NewSuccessThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-themed-resource-ptr")
			return res0Obj
		},
	},
	"theme-symbol-font": {
		Doc:   "theme.SymbolFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.SymbolFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-text-bold-font": {
		Doc:   "theme.TextBoldFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextBoldFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-text-bold-italic-font": {
		Doc:   "theme.TextBoldItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextBoldItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-text-color": {
		Doc:   "theme.TextColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-text-font": {
		Doc:   "theme.TextFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-text-heading-size": {
		Doc:   "theme.TextHeadingSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextHeadingSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-text-italic-font": {
		Doc:   "theme.TextItalicFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextItalicFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-text-monospace-font": {
		Doc:   "theme.TextMonospaceFont",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextMonospaceFont()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-text-size": {
		Doc:   "theme.TextSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-text-sub-heading-size": {
		Doc:   "theme.TextSubHeadingSize",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.TextSubHeadingSize()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"theme-themed-resource": {
		Doc:   "theme.NewThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource")
			}
			res0 := theme.NewThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-themed-resource-ptr")
			return res0Obj
		},
	},
	"theme-themed-resource-ptr//color-name!": {
		Doc:   "Set *theme.ThemedResource ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//color-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//color-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//color-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorName, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme-themed-resource-ptr//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme-themed-resource-ptr//color-name!")
			}
			return arg0
		},
	},
	"theme-themed-resource-ptr//color-name?": {
		Doc:   "Get *theme.ThemedResource ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//color-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//color-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//color-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorName, "fyne-theme-color-name")
			return resObj
		},
	},
	"theme-themed-resource-ptr//content": {
		Doc:   "(*theme.ThemedResource).Content",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//content")
			}
			res0 := arg0Val.Content()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "byte-arr")
			return res0Obj
		},
	},
	"theme-themed-resource-ptr//error": {
		Doc:   "(*theme.ThemedResource).Error",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//error")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//error")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//error")
			}
			res0 := arg0Val.Error()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-error-themed-resource-ptr")
			return res0Obj
		},
	},
	"theme-themed-resource-ptr//name": {
		Doc:   "(*theme.ThemedResource).Name",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//name")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//name")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource-ptr//name")
			}
			res0 := arg0Val.Name()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"theme-themed-resource//color-name!": {
		Doc:   "Set theme.ThemedResource ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource//color-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorName, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme-themed-resource//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "theme-themed-resource//color-name!")
			}
			return arg0
		},
	},
	"theme-themed-resource//color-name?": {
		Doc:   "Get theme.ThemedResource ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self theme.ThemedResource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(theme.ThemedResource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource//color-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-themed-resource//color-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorName, "fyne-theme-color-name")
			return resObj
		},
	},
	"theme-upload-icon": {
		Doc:   "theme.UploadIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.UploadIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-view-full-screen-icon": {
		Doc:   "theme.ViewFullScreenIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ViewFullScreenIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-view-refresh-icon": {
		Doc:   "theme.ViewRefreshIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ViewRefreshIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-view-restore-icon": {
		Doc:   "theme.ViewRestoreIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ViewRestoreIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-visibility-icon": {
		Doc:   "theme.VisibilityIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VisibilityIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-visibility-off-icon": {
		Doc:   "theme.VisibilityOffIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VisibilityOffIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-volume-down-icon": {
		Doc:   "theme.VolumeDownIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VolumeDownIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-volume-mute-icon": {
		Doc:   "theme.VolumeMuteIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VolumeMuteIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-volume-up-icon": {
		Doc:   "theme.VolumeUpIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.VolumeUpIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-warning-color": {
		Doc:   "theme.WarningColor",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.WarningColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"theme-warning-icon": {
		Doc:   "theme.WarningIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.WarningIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-warning-themed-resource": {
		Doc:   "theme.NewWarningThemedResource",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-warning-themed-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-warning-themed-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "theme-warning-themed-resource")
			}
			res0 := theme.NewWarningThemedResource(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "theme-themed-resource-ptr")
			return res0Obj
		},
	},
	"theme-zoom-fit-icon": {
		Doc:   "theme.ZoomFitIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ZoomFitIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-zoom-in-icon": {
		Doc:   "theme.ZoomInIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ZoomInIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"theme-zoom-out-icon": {
		Doc:   "theme.ZoomOutIcon",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := theme.ZoomOutIcon()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-resource")
			return res0Obj
		},
	},
	"validation-all-strings": {
		Doc:   "validation.NewAllStrings",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []fyne.StringValidator
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]fyne.StringValidator, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(fyne.StringValidator)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "validation-all-strings")
						}
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "validation-all-strings")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "validation-all-strings")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "validation-all-strings")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "validation-all-strings")
			}
			res0 := validation.NewAllStrings(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-string-validator")
			return res0Obj
		},
	},
	"validation-regexp": {
		Doc:   "validation.NewRegexp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "validation-regexp")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "validation-regexp")
			}
			res0 := validation.NewRegexp(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-string-validator")
			return res0Obj
		},
	},
	"validation-time": {
		Doc:   "validation.NewTime",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "validation-time")
			}
			res0 := validation.NewTime(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-string-validator")
			return res0Obj
		},
	},
	"widget-accordion": {
		Doc:   "widget.NewAccordion",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*widget.AccordionItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*widget.AccordionItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*widget.AccordionItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-accordion")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-accordion")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-accordion")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-accordion")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-accordion")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-accordion")
			}
			res0 := widget.NewAccordion(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-accordion-ptr")
			return res0Obj
		},
	},
	"widget-accordion-item": {
		Doc:   "widget.NewAccordionItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-accordion-item")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-item")
			}
			res0 := widget.NewAccordionItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-accordion-item-ptr")
			return res0Obj
		},
	},
	"widget-accordion-item-ptr//detail!": {
		Doc:   "Set *widget.AccordionItem Detail value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//detail!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//detail!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//detail!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Detail, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-item-ptr//detail!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-item-ptr//detail!")
				}
				self.Detail = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-item-ptr//detail!")
			}
			return arg0
		},
	},
	"widget-accordion-item-ptr//detail?": {
		Doc:   "Get *widget.AccordionItem Detail value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//detail?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//detail?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//detail?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Detail, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-accordion-item-ptr//open!": {
		Doc:   "Set *widget.AccordionItem Open value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//open!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//open!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//open!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Open = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-accordion-item-ptr//open!")
			}
			return arg0
		},
	},
	"widget-accordion-item-ptr//open?": {
		Doc:   "Get *widget.AccordionItem Open value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//open?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//open?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//open?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Open))
			return resObj
		},
	},
	"widget-accordion-item-ptr//title!": {
		Doc:   "Set *widget.AccordionItem Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//title!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//title!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-accordion-item-ptr//title!")
			}
			return arg0
		},
	},
	"widget-accordion-item-ptr//title?": {
		Doc:   "Get *widget.AccordionItem Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//title?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//title?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item-ptr//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"widget-accordion-item//detail!": {
		Doc:   "Set widget.AccordionItem Detail value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//detail!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//detail!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Detail, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-item//detail!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-item//detail!")
				}
				self.Detail = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-item//detail!")
			}
			return arg0
		},
	},
	"widget-accordion-item//detail?": {
		Doc:   "Get widget.AccordionItem Detail value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//detail?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//detail?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Detail, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-accordion-item//open!": {
		Doc:   "Set widget.AccordionItem Open value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//open!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//open!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Open = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-accordion-item//open!")
			}
			return arg0
		},
	},
	"widget-accordion-item//open?": {
		Doc:   "Get widget.AccordionItem Open value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//open?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//open?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Open))
			return resObj
		},
	},
	"widget-accordion-item//title!": {
		Doc:   "Set widget.AccordionItem Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//title!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-accordion-item//title!")
			}
			return arg0
		},
	},
	"widget-accordion-item//title?": {
		Doc:   "Get widget.AccordionItem Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.AccordionItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//title?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-item//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"widget-accordion-ptr//append": {
		Doc:   "(*widget.Accordion).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//append")
			}
			var arg1Val *widget.AccordionItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-ptr//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-ptr//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"widget-accordion-ptr//close": {
		Doc:   "(*widget.Accordion).Close",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//close")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//close")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//close")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-accordion-ptr//close")
			}
			arg0Val.Close(arg1Val)
			return arg0
		},
	},
	"widget-accordion-ptr//close-all": {
		Doc:   "(*widget.Accordion).CloseAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//close-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//close-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//close-all")
			}
			arg0Val.CloseAll()
			return arg0
		},
	},
	"widget-accordion-ptr//create-renderer": {
		Doc:   "(*widget.Accordion).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-accordion-ptr//hidden!": {
		Doc:   "Set *widget.Accordion Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-accordion-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-accordion-ptr//hidden?": {
		Doc:   "Get *widget.Accordion Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-accordion-ptr//items!": {
		Doc:   "Set *widget.Accordion Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.AccordionItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.AccordionItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion-ptr//items!")
			}
			return arg0
		},
	},
	"widget-accordion-ptr//items?": {
		Doc:   "Get *widget.Accordion Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "widget-accordion-item-ptr-arr")
			return resObj
		},
	},
	"widget-accordion-ptr//min-size": {
		Doc:   "(*widget.Accordion).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-accordion-ptr//multi-open!": {
		Doc:   "Set *widget.Accordion MultiOpen value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//multi-open!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//multi-open!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//multi-open!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiOpen = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-accordion-ptr//multi-open!")
			}
			return arg0
		},
	},
	"widget-accordion-ptr//multi-open?": {
		Doc:   "Get *widget.Accordion MultiOpen value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//multi-open?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//multi-open?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//multi-open?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiOpen))
			return resObj
		},
	},
	"widget-accordion-ptr//open": {
		Doc:   "(*widget.Accordion).Open",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//open")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//open")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//open")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-accordion-ptr//open")
			}
			arg0Val.Open(arg1Val)
			return arg0
		},
	},
	"widget-accordion-ptr//open-all": {
		Doc:   "(*widget.Accordion).OpenAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//open-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//open-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//open-all")
			}
			arg0Val.OpenAll()
			return arg0
		},
	},
	"widget-accordion-ptr//remove": {
		Doc:   "(*widget.Accordion).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//remove")
			}
			var arg1Val *widget.AccordionItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-ptr//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-ptr//remove")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-accordion-ptr//remove")
			}
			arg0Val.Remove(arg1Val)
			return arg0
		},
	},
	"widget-accordion-ptr//remove-index": {
		Doc:   "(*widget.Accordion).RemoveIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//remove-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//remove-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion-ptr//remove-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-accordion-ptr//remove-index")
			}
			arg0Val.RemoveIndex(arg1Val)
			return arg0
		},
	},
	"widget-accordion//hidden!": {
		Doc:   "Set widget.Accordion Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-accordion//hidden!")
			}
			return arg0
		},
	},
	"widget-accordion//hidden?": {
		Doc:   "Get widget.Accordion Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-accordion//items!": {
		Doc:   "Set widget.Accordion Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.AccordionItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.AccordionItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.AccordionItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-accordion//items!")
			}
			return arg0
		},
	},
	"widget-accordion//items?": {
		Doc:   "Get widget.Accordion Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "widget-accordion-item-ptr-arr")
			return resObj
		},
	},
	"widget-accordion//multi-open!": {
		Doc:   "Set widget.Accordion MultiOpen value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//multi-open!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//multi-open!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiOpen = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-accordion//multi-open!")
			}
			return arg0
		},
	},
	"widget-accordion//multi-open?": {
		Doc:   "Get widget.Accordion MultiOpen value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Accordion
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Accordion)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//multi-open?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-accordion//multi-open?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiOpen))
			return resObj
		},
	},
	"widget-base-widget-ptr//extend-base-widget": {
		Doc:   "(*widget.BaseWidget).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-base-widget-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-base-widget-ptr//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-base-widget-ptr//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"widget-base-widget-ptr//hidden!": {
		Doc:   "Set *widget.BaseWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-base-widget-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-base-widget-ptr//hidden?": {
		Doc:   "Get *widget.BaseWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-base-widget-ptr//hide": {
		Doc:   "(*widget.BaseWidget).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"widget-base-widget-ptr//min-size": {
		Doc:   "(*widget.BaseWidget).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-base-widget-ptr//move": {
		Doc:   "(*widget.BaseWidget).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-base-widget-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-base-widget-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"widget-base-widget-ptr//position": {
		Doc:   "(*widget.BaseWidget).Position",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//position")
			}
			res0 := arg0Val.Position()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-position")
			return res0Obj
		},
	},
	"widget-base-widget-ptr//refresh": {
		Doc:   "(*widget.BaseWidget).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"widget-base-widget-ptr//resize": {
		Doc:   "(*widget.BaseWidget).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-base-widget-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-base-widget-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"widget-base-widget-ptr//show": {
		Doc:   "(*widget.BaseWidget).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"widget-base-widget-ptr//size": {
		Doc:   "(*widget.BaseWidget).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//size")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-base-widget-ptr//visible": {
		Doc:   "(*widget.BaseWidget).Visible",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget-ptr//visible")
			}
			res0 := arg0Val.Visible()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-base-widget//hidden!": {
		Doc:   "Set widget.BaseWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-base-widget//hidden!")
			}
			return arg0
		},
	},
	"widget-base-widget//hidden?": {
		Doc:   "Get widget.BaseWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.BaseWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.BaseWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-base-widget//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-button": {
		Doc:   "widget.NewButton",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-button")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-button")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-button")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-button")
			}
			res0 := widget.NewButton(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-button-ptr")
			return res0Obj
		},
	},
	"widget-button-ptr//alignment!": {
		Doc:   "Set *widget.Button Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(widget.ButtonAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//alignment!")
			}
			return arg0
		},
	},
	"widget-button-ptr//alignment?": {
		Doc:   "Get *widget.Button Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "widget-button-align")
			return resObj
		},
	},
	"widget-button-ptr//create-renderer": {
		Doc:   "(*widget.Button).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-button-ptr//cursor": {
		Doc:   "(*widget.Button).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
			return res0Obj
		},
	},
	"widget-button-ptr//focus-gained": {
		Doc:   "(*widget.Button).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"widget-button-ptr//focus-lost": {
		Doc:   "(*widget.Button).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"widget-button-ptr//hidden!": {
		Doc:   "Set *widget.Button Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-button-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-button-ptr//hidden?": {
		Doc:   "Get *widget.Button Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-button-ptr//icon!": {
		Doc:   "Set *widget.Button Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//icon!")
			}
			return arg0
		},
	},
	"widget-button-ptr//icon-placement!": {
		Doc:   "Set *widget.Button IconPlacement value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon-placement!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon-placement!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon-placement!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.IconPlacement, ok = v.Value.(widget.ButtonIconPlacement)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//icon-placement!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//icon-placement!")
			}
			return arg0
		},
	},
	"widget-button-ptr//icon-placement?": {
		Doc:   "Get *widget.Button IconPlacement value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon-placement?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon-placement?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon-placement?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.IconPlacement, "widget-button-icon-placement")
			return resObj
		},
	},
	"widget-button-ptr//icon?": {
		Doc:   "Get *widget.Button Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
			return resObj
		},
	},
	"widget-button-ptr//importance!": {
		Doc:   "Set *widget.Button Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//importance!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//importance!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//importance!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Importance, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//importance!")
			}
			return arg0
		},
	},
	"widget-button-ptr//importance?": {
		Doc:   "Get *widget.Button Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//importance?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//importance?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//importance?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Importance, "widget-importance")
			return resObj
		},
	},
	"widget-button-ptr//min-size": {
		Doc:   "(*widget.Button).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-button-ptr//mouse-in": {
		Doc:   "(*widget.Button).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"widget-button-ptr//mouse-moved": {
		Doc:   "(*widget.Button).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"widget-button-ptr//mouse-out": {
		Doc:   "(*widget.Button).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"widget-button-ptr//on-tapped!": {
		Doc:   "Set *widget.Button OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//on-tapped!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//on-tapped!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-button-ptr//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-button-ptr//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-button-ptr//on-tapped!")
			}
			return arg0
		},
	},
	"widget-button-ptr//on-tapped?": {
		Doc:   "Get *widget.Button OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//on-tapped?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//on-tapped?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "--go-any-func--")
			return resObj
		},
	},
	"widget-button-ptr//set-icon": {
		Doc:   "(*widget.Button).SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//set-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//set-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//set-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//set-icon")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"widget-button-ptr//set-text": {
		Doc:   "(*widget.Button).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-button-ptr//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"widget-button-ptr//tapped": {
		Doc:   "(*widget.Button).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"widget-button-ptr//text!": {
		Doc:   "Set *widget.Button Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-button-ptr//text!")
			}
			return arg0
		},
	},
	"widget-button-ptr//text?": {
		Doc:   "Get *widget.Button Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-button-ptr//typed-key": {
		Doc:   "(*widget.Button).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"widget-button-ptr//typed-rune": {
		Doc:   "(*widget.Button).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button-ptr//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-ptr//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"widget-button-with-icon": {
		Doc:   "widget.NewButtonWithIcon",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-button-with-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-with-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-with-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button-with-icon")
			}
			var arg2Val func()
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "widget-button-with-icon")
				}
				arg2Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "widget-button-with-icon")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "widget-button-with-icon")
			}
			res0 := widget.NewButtonWithIcon(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-button-ptr")
			return res0Obj
		},
	},
	"widget-button//alignment!": {
		Doc:   "Set widget.Button Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(widget.ButtonAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button//alignment!")
			}
			return arg0
		},
	},
	"widget-button//alignment?": {
		Doc:   "Get widget.Button Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "widget-button-align")
			return resObj
		},
	},
	"widget-button//hidden!": {
		Doc:   "Set widget.Button Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-button//hidden!")
			}
			return arg0
		},
	},
	"widget-button//hidden?": {
		Doc:   "Get widget.Button Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-button//icon!": {
		Doc:   "Set widget.Button Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//icon!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button//icon!")
			}
			return arg0
		},
	},
	"widget-button//icon-placement!": {
		Doc:   "Set widget.Button IconPlacement value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//icon-placement!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//icon-placement!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.IconPlacement, ok = v.Value.(widget.ButtonIconPlacement)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button//icon-placement!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button//icon-placement!")
			}
			return arg0
		},
	},
	"widget-button//icon-placement?": {
		Doc:   "Get widget.Button IconPlacement value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//icon-placement?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//icon-placement?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.IconPlacement, "widget-button-icon-placement")
			return resObj
		},
	},
	"widget-button//icon?": {
		Doc:   "Get widget.Button Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//icon?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
			return resObj
		},
	},
	"widget-button//importance!": {
		Doc:   "Set widget.Button Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//importance!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Importance, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-button//importance!")
			}
			return arg0
		},
	},
	"widget-button//importance?": {
		Doc:   "Get widget.Button Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//importance?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//importance?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Importance, "widget-importance")
			return resObj
		},
	},
	"widget-button//on-tapped!": {
		Doc:   "Set widget.Button OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//on-tapped!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-button//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-button//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-button//on-tapped!")
			}
			return arg0
		},
	},
	"widget-button//on-tapped?": {
		Doc:   "Get widget.Button OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//on-tapped?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "--go-any-func--")
			return resObj
		},
	},
	"widget-button//text!": {
		Doc:   "Set widget.Button Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-button//text!")
			}
			return arg0
		},
	},
	"widget-button//text?": {
		Doc:   "Get widget.Button Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Button
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Button)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-button//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-card": {
		Doc:   "widget.NewCard",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-card")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-card")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-card")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-card")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-card")
			}
			res0 := widget.NewCard(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-card-ptr")
			return res0Obj
		},
	},
	"widget-card-ptr//content!": {
		Doc:   "Set *widget.Card Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//content!")
			}
			return arg0
		},
	},
	"widget-card-ptr//content?": {
		Doc:   "Get *widget.Card Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-card-ptr//create-renderer": {
		Doc:   "(*widget.Card).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-card-ptr//hidden!": {
		Doc:   "Set *widget.Card Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-card-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-card-ptr//hidden?": {
		Doc:   "Get *widget.Card Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-card-ptr//image!": {
		Doc:   "Set *widget.Card Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//image!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//image!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//image!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//image!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//image!")
				}
				self.Image = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//image!")
			}
			return arg0
		},
	},
	"widget-card-ptr//image?": {
		Doc:   "Get *widget.Card Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//image?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//image?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//image?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "canvas-image-ptr")
			return resObj
		},
	},
	"widget-card-ptr//min-size": {
		Doc:   "(*widget.Card).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-card-ptr//set-content": {
		Doc:   "(*widget.Card).SetContent",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-content")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-content")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//set-content")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//set-content")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//set-content")
			}
			arg0Val.SetContent(arg1Val)
			return arg0
		},
	},
	"widget-card-ptr//set-image": {
		Doc:   "(*widget.Card).SetImage",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-image")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-image")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-image")
			}
			var arg1Val *canvas.Image
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//set-image")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//set-image")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card-ptr//set-image")
			}
			arg0Val.SetImage(arg1Val)
			return arg0
		},
	},
	"widget-card-ptr//set-sub-title": {
		Doc:   "(*widget.Card).SetSubTitle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-sub-title")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-sub-title")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-sub-title")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-card-ptr//set-sub-title")
			}
			arg0Val.SetSubTitle(arg1Val)
			return arg0
		},
	},
	"widget-card-ptr//set-title": {
		Doc:   "(*widget.Card).SetTitle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-title")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-title")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//set-title")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-card-ptr//set-title")
			}
			arg0Val.SetTitle(arg1Val)
			return arg0
		},
	},
	"widget-card-ptr//subtitle!": {
		Doc:   "Set *widget.Card Subtitle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//subtitle!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//subtitle!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//subtitle!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Subtitle = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-card-ptr//subtitle!")
			}
			return arg0
		},
	},
	"widget-card-ptr//subtitle?": {
		Doc:   "Get *widget.Card Subtitle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//subtitle?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//subtitle?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//subtitle?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Subtitle)
			return resObj
		},
	},
	"widget-card-ptr//title!": {
		Doc:   "Set *widget.Card Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//title!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//title!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-card-ptr//title!")
			}
			return arg0
		},
	},
	"widget-card-ptr//title?": {
		Doc:   "Get *widget.Card Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//title?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//title?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card-ptr//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"widget-card//content!": {
		Doc:   "Set widget.Card Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card//content!")
			}
			return arg0
		},
	},
	"widget-card//content?": {
		Doc:   "Get widget.Card Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-card//hidden!": {
		Doc:   "Set widget.Card Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-card//hidden!")
			}
			return arg0
		},
	},
	"widget-card//hidden?": {
		Doc:   "Get widget.Card Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-card//image!": {
		Doc:   "Set widget.Card Image value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//image!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//image!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Image, ok = v.Value.(*canvas.Image)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card//image!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card//image!")
				}
				self.Image = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-card//image!")
			}
			return arg0
		},
	},
	"widget-card//image?": {
		Doc:   "Get widget.Card Image value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//image?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//image?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Image, "canvas-image-ptr")
			return resObj
		},
	},
	"widget-card//subtitle!": {
		Doc:   "Set widget.Card Subtitle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//subtitle!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//subtitle!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Subtitle = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-card//subtitle!")
			}
			return arg0
		},
	},
	"widget-card//subtitle?": {
		Doc:   "Get widget.Card Subtitle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//subtitle?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//subtitle?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Subtitle)
			return resObj
		},
	},
	"widget-card//title!": {
		Doc:   "Set widget.Card Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//title!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-card//title!")
			}
			return arg0
		},
	},
	"widget-card//title?": {
		Doc:   "Get widget.Card Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Card
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Card)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//title?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-card//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"widget-check": {
		Doc:   "widget.NewCheck",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-check")
			}
			var arg1Val func(bool)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check")
				}
				arg1Val = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check")
			}
			res0 := widget.NewCheck(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-check-ptr")
			return res0Obj
		},
	},
	"widget-check-group": {
		Doc:   "widget.NewCheckGroup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-check-group")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-check-group")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-check-group")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-check-group")
			}
			var arg1Val func([]string)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check-group")
				}
				arg1Val = func(arg0 []string) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "string-arr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check-group")
			}
			res0 := widget.NewCheckGroup(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-check-group-ptr")
			return res0Obj
		},
	},
	"widget-check-group-ptr//append": {
		Doc:   "(*widget.CheckGroup).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-check-group-ptr//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"widget-check-group-ptr//create-renderer": {
		Doc:   "(*widget.CheckGroup).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-check-group-ptr//hidden!": {
		Doc:   "Set *widget.CheckGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check-group-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-check-group-ptr//hidden?": {
		Doc:   "Get *widget.CheckGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-check-group-ptr//horizontal!": {
		Doc:   "Set *widget.CheckGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//horizontal!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//horizontal!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check-group-ptr//horizontal!")
			}
			return arg0
		},
	},
	"widget-check-group-ptr//horizontal?": {
		Doc:   "Get *widget.CheckGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//horizontal?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//horizontal?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"widget-check-group-ptr//min-size": {
		Doc:   "(*widget.CheckGroup).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-check-group-ptr//on-changed!": {
		Doc:   "Set *widget.CheckGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check-group-ptr//on-changed!")
				}
				self.OnChanged = func(arg0 []string) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "string-arr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check-group-ptr//on-changed!")
			}
			return arg0
		},
	},
	"widget-check-group-ptr//on-changed?": {
		Doc:   "Get *widget.CheckGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-check-group-ptr//options!": {
		Doc:   "Set *widget.CheckGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//options!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//options!")
			}
			return arg0
		},
	},
	"widget-check-group-ptr//options?": {
		Doc:   "Get *widget.CheckGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//options?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//options?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//options?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Options, "string-arr")
			return resObj
		},
	},
	"widget-check-group-ptr//refresh": {
		Doc:   "(*widget.CheckGroup).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"widget-check-group-ptr//remove": {
		Doc:   "(*widget.CheckGroup).Remove",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//remove")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//remove")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//remove")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-check-group-ptr//remove")
			}
			res0 := arg0Val.Remove(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-check-group-ptr//required!": {
		Doc:   "Set *widget.CheckGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//required!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//required!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//required!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check-group-ptr//required!")
			}
			return arg0
		},
	},
	"widget-check-group-ptr//required?": {
		Doc:   "Get *widget.CheckGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//required?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//required?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//required?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"widget-check-group-ptr//selected!": {
		Doc:   "Set *widget.CheckGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//selected!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Selected = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Selected[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//selected!")
					}
				}
			case env.Native:
				var ok bool
				self.Selected, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//selected!")
				}
				self.Selected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//selected!")
			}
			return arg0
		},
	},
	"widget-check-group-ptr//selected?": {
		Doc:   "Get *widget.CheckGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Selected, "string-arr")
			return resObj
		},
	},
	"widget-check-group-ptr//set-selected": {
		Doc:   "(*widget.CheckGroup).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//set-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group-ptr//set-selected")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//set-selected")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//set-selected")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group-ptr//set-selected")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"widget-check-group//hidden!": {
		Doc:   "Set widget.CheckGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check-group//hidden!")
			}
			return arg0
		},
	},
	"widget-check-group//hidden?": {
		Doc:   "Get widget.CheckGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-check-group//horizontal!": {
		Doc:   "Set widget.CheckGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//horizontal!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check-group//horizontal!")
			}
			return arg0
		},
	},
	"widget-check-group//horizontal?": {
		Doc:   "Get widget.CheckGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//horizontal?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"widget-check-group//on-changed!": {
		Doc:   "Set widget.CheckGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check-group//on-changed!")
				}
				self.OnChanged = func(arg0 []string) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "string-arr")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check-group//on-changed!")
			}
			return arg0
		},
	},
	"widget-check-group//on-changed?": {
		Doc:   "Get widget.CheckGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-check-group//options!": {
		Doc:   "Set widget.CheckGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//options!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group//options!")
			}
			return arg0
		},
	},
	"widget-check-group//options?": {
		Doc:   "Get widget.CheckGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//options?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//options?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Options, "string-arr")
			return resObj
		},
	},
	"widget-check-group//required!": {
		Doc:   "Set widget.CheckGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//required!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//required!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check-group//required!")
			}
			return arg0
		},
	},
	"widget-check-group//required?": {
		Doc:   "Get widget.CheckGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//required?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//required?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"widget-check-group//selected!": {
		Doc:   "Set widget.CheckGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//selected!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Selected = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Selected[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group//selected!")
					}
				}
			case env.Native:
				var ok bool
				self.Selected, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group//selected!")
				}
				self.Selected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-group//selected!")
			}
			return arg0
		},
	},
	"widget-check-group//selected?": {
		Doc:   "Get widget.CheckGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CheckGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CheckGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-group//selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Selected, "string-arr")
			return resObj
		},
	},
	"widget-check-ptr//bind": {
		Doc:   "(*widget.Check).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//bind")
			}
			var arg1Val binding.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"widget-check-ptr//checked!": {
		Doc:   "Set *widget.Check Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//checked!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//checked!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//checked!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check-ptr//checked!")
			}
			return arg0
		},
	},
	"widget-check-ptr//checked?": {
		Doc:   "Get *widget.Check Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//checked?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//checked?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//checked?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"widget-check-ptr//create-renderer": {
		Doc:   "(*widget.Check).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-check-ptr//focus-gained": {
		Doc:   "(*widget.Check).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"widget-check-ptr//focus-lost": {
		Doc:   "(*widget.Check).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"widget-check-ptr//hidden!": {
		Doc:   "Set *widget.Check Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-check-ptr//hidden?": {
		Doc:   "Get *widget.Check Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-check-ptr//hide": {
		Doc:   "(*widget.Check).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"widget-check-ptr//min-size": {
		Doc:   "(*widget.Check).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-check-ptr//mouse-in": {
		Doc:   "(*widget.Check).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"widget-check-ptr//mouse-moved": {
		Doc:   "(*widget.Check).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"widget-check-ptr//mouse-out": {
		Doc:   "(*widget.Check).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"widget-check-ptr//on-changed!": {
		Doc:   "Set *widget.Check OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check-ptr//on-changed!")
				}
				self.OnChanged = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check-ptr//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check-ptr//on-changed!")
			}
			return arg0
		},
	},
	"widget-check-ptr//on-changed?": {
		Doc:   "Get *widget.Check OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-check-ptr//set-checked": {
		Doc:   "(*widget.Check).SetChecked",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//set-checked")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//set-checked")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//set-checked")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check-ptr//set-checked")
			}
			arg0Val.SetChecked(arg1Val)
			return arg0
		},
	},
	"widget-check-ptr//set-text": {
		Doc:   "(*widget.Check).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-check-ptr//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"widget-check-ptr//tapped": {
		Doc:   "(*widget.Check).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"widget-check-ptr//text!": {
		Doc:   "Set *widget.Check Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-check-ptr//text!")
			}
			return arg0
		},
	},
	"widget-check-ptr//text?": {
		Doc:   "Get *widget.Check Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-check-ptr//typed-key": {
		Doc:   "(*widget.Check).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"widget-check-ptr//typed-rune": {
		Doc:   "(*widget.Check).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-ptr//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"widget-check-ptr//unbind": {
		Doc:   "(*widget.Check).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check-ptr//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"widget-check-with-data": {
		Doc:   "widget.NewCheckWithData",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-check-with-data")
			}
			var arg1Val binding.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Bool)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-with-data")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-check-with-data")
			}
			res0 := widget.NewCheckWithData(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-check-ptr")
			return res0Obj
		},
	},
	"widget-check//checked!": {
		Doc:   "Set widget.Check Checked value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//checked!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//checked!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Checked = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check//checked!")
			}
			return arg0
		},
	},
	"widget-check//checked?": {
		Doc:   "Get widget.Check Checked value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//checked?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//checked?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Checked))
			return resObj
		},
	},
	"widget-check//hidden!": {
		Doc:   "Set widget.Check Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-check//hidden!")
			}
			return arg0
		},
	},
	"widget-check//hidden?": {
		Doc:   "Get widget.Check Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-check//on-changed!": {
		Doc:   "Set widget.Check OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check//on-changed!")
				}
				self.OnChanged = func(arg0 bool) {
					var arg0Val env.Object
					arg0Val = *env.NewInteger(boolToInt64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-check//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-check//on-changed!")
			}
			return arg0
		},
	},
	"widget-check//on-changed?": {
		Doc:   "Get widget.Check OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-check//text!": {
		Doc:   "Set widget.Check Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-check//text!")
			}
			return arg0
		},
	},
	"widget-check//text?": {
		Doc:   "Get widget.Check Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Check
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Check)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-check//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-custom-text-grid-style-ptr//background-color": {
		Doc:   "(*widget.CustomTextGridStyle).BackgroundColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//background-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//background-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//background-color")
			}
			res0 := arg0Val.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"widget-custom-text-grid-style-ptr//bg-color!": {
		Doc:   "Set *widget.CustomTextGridStyle BGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//bg-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//bg-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//bg-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.BGColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//bg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//bg-color!")
			}
			return arg0
		},
	},
	"widget-custom-text-grid-style-ptr//bg-color?": {
		Doc:   "Get *widget.CustomTextGridStyle BGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//bg-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//bg-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//bg-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.BGColor, "color-color")
			return resObj
		},
	},
	"widget-custom-text-grid-style-ptr//fg-color!": {
		Doc:   "Set *widget.CustomTextGridStyle FGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//fg-color!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//fg-color!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//fg-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FGColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//fg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//fg-color!")
			}
			return arg0
		},
	},
	"widget-custom-text-grid-style-ptr//fg-color?": {
		Doc:   "Get *widget.CustomTextGridStyle FGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//fg-color?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//fg-color?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//fg-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FGColor, "color-color")
			return resObj
		},
	},
	"widget-custom-text-grid-style-ptr//text-color": {
		Doc:   "(*widget.CustomTextGridStyle).TextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//text-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//text-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style-ptr//text-color")
			}
			res0 := arg0Val.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"widget-custom-text-grid-style//bg-color!": {
		Doc:   "Set widget.CustomTextGridStyle BGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style//bg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style//bg-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.BGColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-custom-text-grid-style//bg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-custom-text-grid-style//bg-color!")
			}
			return arg0
		},
	},
	"widget-custom-text-grid-style//bg-color?": {
		Doc:   "Get widget.CustomTextGridStyle BGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style//bg-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style//bg-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.BGColor, "color-color")
			return resObj
		},
	},
	"widget-custom-text-grid-style//fg-color!": {
		Doc:   "Set widget.CustomTextGridStyle FGColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style//fg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style//fg-color!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.FGColor, ok = v.Value.(color.Color)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-custom-text-grid-style//fg-color!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-custom-text-grid-style//fg-color!")
			}
			return arg0
		},
	},
	"widget-custom-text-grid-style//fg-color?": {
		Doc:   "Get widget.CustomTextGridStyle FGColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.CustomTextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.CustomTextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style//fg-color?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-custom-text-grid-style//fg-color?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.FGColor, "color-color")
			return resObj
		},
	},
	"widget-disableable-widget-ptr//disable": {
		Doc:   "(*widget.DisableableWidget).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"widget-disableable-widget-ptr//disabled": {
		Doc:   "(*widget.DisableableWidget).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-disableable-widget-ptr//enable": {
		Doc:   "(*widget.DisableableWidget).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"widget-disableable-widget-ptr//hidden!": {
		Doc:   "Set *widget.DisableableWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-disableable-widget-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-disableable-widget-ptr//hidden?": {
		Doc:   "Get *widget.DisableableWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-disableable-widget//hidden!": {
		Doc:   "Set widget.DisableableWidget Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-disableable-widget//hidden!")
			}
			return arg0
		},
	},
	"widget-disableable-widget//hidden?": {
		Doc:   "Get widget.DisableableWidget Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.DisableableWidget
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.DisableableWidget)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-disableable-widget//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-entry": {
		Doc:   "widget.NewEntry",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewEntry()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-entry-ptr")
			return res0Obj
		},
	},
	"widget-entry-ptr//accepts-tab": {
		Doc:   "(*widget.Entry).AcceptsTab",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//accepts-tab")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//accepts-tab")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//accepts-tab")
			}
			res0 := arg0Val.AcceptsTab()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-entry-ptr//action-item!": {
		Doc:   "Set *widget.Entry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//action-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//action-item!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//action-item!")
				}
				self.ActionItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//action-item!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//action-item?": {
		Doc:   "Get *widget.Entry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//action-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//action-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//action-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ActionItem, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-entry-ptr//append": {
		Doc:   "(*widget.Entry).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-entry-ptr//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//bind": {
		Doc:   "(*widget.Entry).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//bind")
			}
			var arg1Val binding.String
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//create-renderer": {
		Doc:   "(*widget.Entry).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-entry-ptr//cursor": {
		Doc:   "(*widget.Entry).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
			return res0Obj
		},
	},
	"widget-entry-ptr//cursor-column!": {
		Doc:   "Set *widget.Entry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-column!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-column!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry-ptr//cursor-column!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//cursor-column?": {
		Doc:   "Get *widget.Entry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-column?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-column?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"widget-entry-ptr//cursor-row!": {
		Doc:   "Set *widget.Entry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-row!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-row!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry-ptr//cursor-row!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//cursor-row?": {
		Doc:   "Get *widget.Entry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-row?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-row?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//cursor-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"widget-entry-ptr//disable": {
		Doc:   "(*widget.Entry).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"widget-entry-ptr//disabled": {
		Doc:   "(*widget.Entry).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-entry-ptr//double-tapped": {
		Doc:   "(*widget.Entry).DoubleTapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//double-tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//double-tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//double-tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//double-tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//double-tapped")
			}
			arg0Val.DoubleTapped(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//drag-end": {
		Doc:   "(*widget.Entry).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//drag-end")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//drag-end")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//drag-end")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"widget-entry-ptr//dragged": {
		Doc:   "(*widget.Entry).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//dragged")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//dragged")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//dragged")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//dragged")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//enable": {
		Doc:   "(*widget.Entry).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"widget-entry-ptr//extend-base-widget": {
		Doc:   "(*widget.Entry).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//focus-gained": {
		Doc:   "(*widget.Entry).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"widget-entry-ptr//focus-lost": {
		Doc:   "(*widget.Entry).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"widget-entry-ptr//hidden!": {
		Doc:   "Set *widget.Entry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//hidden?": {
		Doc:   "Get *widget.Entry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-entry-ptr//hide": {
		Doc:   "(*widget.Entry).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"widget-entry-ptr//key-down": {
		Doc:   "(*widget.Entry).KeyDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//key-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//key-down")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//key-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//key-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//key-down")
			}
			arg0Val.KeyDown(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//key-up": {
		Doc:   "(*widget.Entry).KeyUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//key-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//key-up")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//key-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//key-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//key-up")
			}
			arg0Val.KeyUp(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//keyboard": {
		Doc:   "(*widget.Entry).Keyboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//keyboard")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//keyboard")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//keyboard")
			}
			res0 := arg0Val.Keyboard()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "mobile-keyboard-type")
			return res0Obj
		},
	},
	"widget-entry-ptr//min-size": {
		Doc:   "(*widget.Entry).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-entry-ptr//mouse-down": {
		Doc:   "(*widget.Entry).MouseDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-down")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-down")
			}
			arg0Val.MouseDown(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//mouse-up": {
		Doc:   "(*widget.Entry).MouseUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-up")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//mouse-up")
			}
			arg0Val.MouseUp(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//multi-line!": {
		Doc:   "Set *widget.Entry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//multi-line!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//multi-line!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//multi-line!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry-ptr//multi-line!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//multi-line?": {
		Doc:   "Get *widget.Entry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//multi-line?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//multi-line?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//multi-line?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"widget-entry-ptr//on-changed!": {
		Doc:   "Set *widget.Entry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry-ptr//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-entry-ptr//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry-ptr//on-changed!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//on-changed?": {
		Doc:   "Get *widget.Entry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-entry-ptr//on-cursor-changed!": {
		Doc:   "Set *widget.Entry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-cursor-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-cursor-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-cursor-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry-ptr//on-cursor-changed!")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-entry-ptr//on-cursor-changed!")
				}
				self.OnCursorChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry-ptr//on-cursor-changed!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//on-cursor-changed?": {
		Doc:   "Get *widget.Entry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-cursor-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-cursor-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-cursor-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-entry-ptr//on-submitted!": {
		Doc:   "Set *widget.Entry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-submitted!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-submitted!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-submitted!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry-ptr//on-submitted!")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-entry-ptr//on-submitted!")
				}
				self.OnSubmitted = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry-ptr//on-submitted!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//on-submitted?": {
		Doc:   "Get *widget.Entry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-submitted?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-submitted?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//on-submitted?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "--go-any-func--")
			return resObj
		},
	},
	"widget-entry-ptr//password!": {
		Doc:   "Set *widget.Entry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//password!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//password!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//password!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry-ptr//password!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//password?": {
		Doc:   "Get *widget.Entry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//password?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//password?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//password?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"widget-entry-ptr//place-holder!": {
		Doc:   "Set *widget.Entry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//place-holder!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//place-holder!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-entry-ptr//place-holder!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//place-holder?": {
		Doc:   "Get *widget.Entry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//place-holder?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//place-holder?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"widget-entry-ptr//refresh": {
		Doc:   "(*widget.Entry).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"widget-entry-ptr//scroll!": {
		Doc:   "Set *widget.Entry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//scroll!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//scroll!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//scroll!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//scroll?": {
		Doc:   "Get *widget.Entry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//scroll?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//scroll?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "container-scroll-direction")
			return resObj
		},
	},
	"widget-entry-ptr//selected-text": {
		Doc:   "(*widget.Entry).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-entry-ptr//set-min-rows-visible": {
		Doc:   "(*widget.Entry).SetMinRowsVisible",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-min-rows-visible")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-min-rows-visible")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-min-rows-visible")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry-ptr//set-min-rows-visible")
			}
			arg0Val.SetMinRowsVisible(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//set-on-validation-changed": {
		Doc:   "(*widget.Entry).SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-on-validation-changed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-on-validation-changed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-on-validation-changed")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry-ptr//set-on-validation-changed")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-entry-ptr//set-on-validation-changed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry-ptr//set-on-validation-changed")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//set-place-holder": {
		Doc:   "(*widget.Entry).SetPlaceHolder",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-place-holder")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-place-holder")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-place-holder")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-entry-ptr//set-place-holder")
			}
			arg0Val.SetPlaceHolder(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//set-text": {
		Doc:   "(*widget.Entry).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-entry-ptr//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//set-validation-error": {
		Doc:   "(*widget.Entry).SetValidationError",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-validation-error")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-validation-error")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//set-validation-error")
			}
			var arg1Val error
			if v, ok := arg1.(env.Error); ok {
				arg1Val = errors.New(v.Print(*ps.Idx))
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.ErrorType}, "widget-entry-ptr//set-validation-error")
			}
			arg0Val.SetValidationError(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//tapped": {
		Doc:   "(*widget.Entry).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//tapped-secondary": {
		Doc:   "(*widget.Entry).TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//tapped-secondary")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//tapped-secondary")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//tapped-secondary")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//tapped-secondary")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//text!": {
		Doc:   "Set *widget.Entry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-entry-ptr//text!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//text-style!": {
		Doc:   "Set *widget.Entry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//text-style!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//text-style?": {
		Doc:   "Get *widget.Entry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-entry-ptr//text?": {
		Doc:   "Get *widget.Entry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-entry-ptr//touch-cancel": {
		Doc:   "(*widget.Entry).TouchCancel",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//touch-cancel")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//touch-cancel")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//touch-cancel")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//touch-cancel")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//touch-cancel")
			}
			arg0Val.TouchCancel(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//touch-down": {
		Doc:   "(*widget.Entry).TouchDown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//touch-down")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//touch-down")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//touch-down")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//touch-down")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//touch-down")
			}
			arg0Val.TouchDown(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//touch-up": {
		Doc:   "(*widget.Entry).TouchUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//touch-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//touch-up")
			}
			var arg1Val *mobile.TouchEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*mobile.TouchEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//touch-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//touch-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//touch-up")
			}
			arg0Val.TouchUp(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//typed-key": {
		Doc:   "(*widget.Entry).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//typed-rune": {
		Doc:   "(*widget.Entry).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//typed-shortcut": {
		Doc:   "(*widget.Entry).TypedShortcut",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//typed-shortcut")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//typed-shortcut")
			}
			var arg1Val fyne.Shortcut
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Shortcut)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//typed-shortcut")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//typed-shortcut")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//typed-shortcut")
			}
			arg0Val.TypedShortcut(arg1Val)
			return arg0
		},
	},
	"widget-entry-ptr//unbind": {
		Doc:   "(*widget.Entry).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"widget-entry-ptr//validate": {
		Doc:   "(*widget.Entry).Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//validate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//validate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//validate")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"widget-entry-ptr//validator!": {
		Doc:   "Set *widget.Entry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//validator!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//validator!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//validator!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Validator, ok = v.Value.(fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//validator!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//validator?": {
		Doc:   "Get *widget.Entry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//validator?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//validator?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//validator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Validator, "fyne-string-validator")
			return resObj
		},
	},
	"widget-entry-ptr//wrapping!": {
		Doc:   "Set *widget.Entry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//wrapping!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//wrapping!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry-ptr//wrapping!")
			}
			return arg0
		},
	},
	"widget-entry-ptr//wrapping?": {
		Doc:   "Get *widget.Entry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//wrapping?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//wrapping?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-ptr//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "fyne-text-wrap")
			return resObj
		},
	},
	"widget-entry-with-data": {
		Doc:   "widget.NewEntryWithData",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry-with-data")
			}
			res0 := widget.NewEntryWithData(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-entry-ptr")
			return res0Obj
		},
	},
	"widget-entry//action-item!": {
		Doc:   "Set widget.Entry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//action-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//action-item!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//action-item!")
				}
				self.ActionItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//action-item!")
			}
			return arg0
		},
	},
	"widget-entry//action-item?": {
		Doc:   "Get widget.Entry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//action-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//action-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ActionItem, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-entry//cursor-column!": {
		Doc:   "Set widget.Entry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//cursor-column!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//cursor-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry//cursor-column!")
			}
			return arg0
		},
	},
	"widget-entry//cursor-column?": {
		Doc:   "Get widget.Entry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//cursor-column?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//cursor-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"widget-entry//cursor-row!": {
		Doc:   "Set widget.Entry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//cursor-row!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//cursor-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry//cursor-row!")
			}
			return arg0
		},
	},
	"widget-entry//cursor-row?": {
		Doc:   "Get widget.Entry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//cursor-row?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//cursor-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"widget-entry//hidden!": {
		Doc:   "Set widget.Entry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry//hidden!")
			}
			return arg0
		},
	},
	"widget-entry//hidden?": {
		Doc:   "Get widget.Entry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-entry//multi-line!": {
		Doc:   "Set widget.Entry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//multi-line!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//multi-line!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry//multi-line!")
			}
			return arg0
		},
	},
	"widget-entry//multi-line?": {
		Doc:   "Get widget.Entry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//multi-line?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//multi-line?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"widget-entry//on-changed!": {
		Doc:   "Set widget.Entry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-entry//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry//on-changed!")
			}
			return arg0
		},
	},
	"widget-entry//on-changed?": {
		Doc:   "Get widget.Entry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-entry//on-cursor-changed!": {
		Doc:   "Set widget.Entry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-cursor-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-cursor-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry//on-cursor-changed!")
			}
			return arg0
		},
	},
	"widget-entry//on-cursor-changed?": {
		Doc:   "Get widget.Entry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-cursor-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-cursor-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-entry//on-submitted!": {
		Doc:   "Set widget.Entry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-submitted!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-submitted!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry//on-submitted!")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-entry//on-submitted!")
				}
				self.OnSubmitted = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-entry//on-submitted!")
			}
			return arg0
		},
	},
	"widget-entry//on-submitted?": {
		Doc:   "Get widget.Entry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-submitted?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//on-submitted?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "--go-any-func--")
			return resObj
		},
	},
	"widget-entry//password!": {
		Doc:   "Set widget.Entry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//password!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//password!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-entry//password!")
			}
			return arg0
		},
	},
	"widget-entry//password?": {
		Doc:   "Get widget.Entry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//password?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//password?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"widget-entry//place-holder!": {
		Doc:   "Set widget.Entry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//place-holder!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-entry//place-holder!")
			}
			return arg0
		},
	},
	"widget-entry//place-holder?": {
		Doc:   "Get widget.Entry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//place-holder?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"widget-entry//scroll!": {
		Doc:   "Set widget.Entry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//scroll!")
			}
			return arg0
		},
	},
	"widget-entry//scroll?": {
		Doc:   "Get widget.Entry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//scroll?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "container-scroll-direction")
			return resObj
		},
	},
	"widget-entry//text!": {
		Doc:   "Set widget.Entry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-entry//text!")
			}
			return arg0
		},
	},
	"widget-entry//text-style!": {
		Doc:   "Set widget.Entry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//text-style!")
			}
			return arg0
		},
	},
	"widget-entry//text-style?": {
		Doc:   "Get widget.Entry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-entry//text?": {
		Doc:   "Get widget.Entry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-entry//validator!": {
		Doc:   "Set widget.Entry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//validator!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Validator, ok = v.Value.(fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//validator!")
			}
			return arg0
		},
	},
	"widget-entry//validator?": {
		Doc:   "Get widget.Entry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//validator?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//validator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Validator, "fyne-string-validator")
			return resObj
		},
	},
	"widget-entry//wrapping!": {
		Doc:   "Set widget.Entry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-entry//wrapping!")
			}
			return arg0
		},
	},
	"widget-entry//wrapping?": {
		Doc:   "Get widget.Entry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Entry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Entry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//wrapping?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-entry//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "fyne-text-wrap")
			return resObj
		},
	},
	"widget-file-icon": {
		Doc:   "widget.NewFileIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.URI
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon")
			}
			res0 := widget.NewFileIcon(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-file-icon-ptr")
			return res0Obj
		},
	},
	"widget-file-icon-ptr//create-renderer": {
		Doc:   "(*widget.FileIcon).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-file-icon-ptr//hidden!": {
		Doc:   "Set *widget.FileIcon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-file-icon-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-file-icon-ptr//hidden?": {
		Doc:   "Get *widget.FileIcon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-file-icon-ptr//min-size": {
		Doc:   "(*widget.FileIcon).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-file-icon-ptr//selected!": {
		Doc:   "Set *widget.FileIcon Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//selected!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Selected = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-file-icon-ptr//selected!")
			}
			return arg0
		},
	},
	"widget-file-icon-ptr//selected?": {
		Doc:   "Get *widget.FileIcon Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//selected?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Selected))
			return resObj
		},
	},
	"widget-file-icon-ptr//set-selected": {
		Doc:   "(*widget.FileIcon).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//set-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//set-selected")
			}
			var arg1Val bool
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-file-icon-ptr//set-selected")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"widget-file-icon-ptr//set-uri": {
		Doc:   "(*widget.FileIcon).SetURI",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//set-uri")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//set-uri")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//set-uri")
			}
			var arg1Val fyne.URI
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-file-icon-ptr//set-uri")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-file-icon-ptr//set-uri")
			}
			arg0Val.SetURI(arg1Val)
			return arg0
		},
	},
	"widget-file-icon-ptr//uri!": {
		Doc:   "Set *widget.FileIcon URI value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//uri!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//uri!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//uri!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URI, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-file-icon-ptr//uri!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-file-icon-ptr//uri!")
			}
			return arg0
		},
	},
	"widget-file-icon-ptr//uri?": {
		Doc:   "Get *widget.FileIcon URI value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//uri?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//uri?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon-ptr//uri?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URI, "fyne-uri")
			return resObj
		},
	},
	"widget-file-icon//hidden!": {
		Doc:   "Set widget.FileIcon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-file-icon//hidden!")
			}
			return arg0
		},
	},
	"widget-file-icon//hidden?": {
		Doc:   "Get widget.FileIcon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-file-icon//selected!": {
		Doc:   "Set widget.FileIcon Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//selected!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Selected = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-file-icon//selected!")
			}
			return arg0
		},
	},
	"widget-file-icon//selected?": {
		Doc:   "Get widget.FileIcon Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//selected?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Selected))
			return resObj
		},
	},
	"widget-file-icon//uri!": {
		Doc:   "Set widget.FileIcon URI value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//uri!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//uri!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URI, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-file-icon//uri!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-file-icon//uri!")
			}
			return arg0
		},
	},
	"widget-file-icon//uri?": {
		Doc:   "Get widget.FileIcon URI value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FileIcon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FileIcon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//uri?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-file-icon//uri?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URI, "fyne-uri")
			return resObj
		},
	},
	"widget-form": {
		Doc:   "widget.NewForm",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []*widget.FormItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]*widget.FormItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(*widget.FormItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-form")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-form")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-form")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-form")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-form")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-form")
			}
			res0 := widget.NewForm(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-form-ptr")
			return res0Obj
		},
	},
	"widget-form-item": {
		Doc:   "widget.NewFormItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-form-item")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-item")
			}
			res0 := widget.NewFormItem(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-form-item-ptr")
			return res0Obj
		},
	},
	"widget-form-item-ptr//hint-text!": {
		Doc:   "Set *widget.FormItem HintText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//hint-text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//hint-text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//hint-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.HintText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-form-item-ptr//hint-text!")
			}
			return arg0
		},
	},
	"widget-form-item-ptr//hint-text?": {
		Doc:   "Get *widget.FormItem HintText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//hint-text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//hint-text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//hint-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.HintText)
			return resObj
		},
	},
	"widget-form-item-ptr//text!": {
		Doc:   "Set *widget.FormItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-form-item-ptr//text!")
			}
			return arg0
		},
	},
	"widget-form-item-ptr//text?": {
		Doc:   "Get *widget.FormItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-form-item-ptr//widget!": {
		Doc:   "Set *widget.FormItem Widget value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//widget!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//widget!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//widget!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Widget, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-item-ptr//widget!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-item-ptr//widget!")
				}
				self.Widget = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-item-ptr//widget!")
			}
			return arg0
		},
	},
	"widget-form-item-ptr//widget?": {
		Doc:   "Get *widget.FormItem Widget value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//widget?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//widget?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item-ptr//widget?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Widget, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-form-item//hint-text!": {
		Doc:   "Set widget.FormItem HintText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//hint-text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//hint-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.HintText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-form-item//hint-text!")
			}
			return arg0
		},
	},
	"widget-form-item//hint-text?": {
		Doc:   "Get widget.FormItem HintText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//hint-text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//hint-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.HintText)
			return resObj
		},
	},
	"widget-form-item//text!": {
		Doc:   "Set widget.FormItem Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-form-item//text!")
			}
			return arg0
		},
	},
	"widget-form-item//text?": {
		Doc:   "Get widget.FormItem Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-form-item//widget!": {
		Doc:   "Set widget.FormItem Widget value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//widget!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//widget!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Widget, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-item//widget!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-item//widget!")
				}
				self.Widget = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-item//widget!")
			}
			return arg0
		},
	},
	"widget-form-item//widget?": {
		Doc:   "Get widget.FormItem Widget value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.FormItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//widget?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-item//widget?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Widget, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-form-ptr//append": {
		Doc:   "(*widget.Form).Append",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-form-ptr//append")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-form-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-form-ptr//append")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-form-ptr//append")
			}
			arg0Val.Append(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-form-ptr//append-item": {
		Doc:   "(*widget.Form).AppendItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//append-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//append-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//append-item")
			}
			var arg1Val *widget.FormItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-ptr//append-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-ptr//append-item")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-form-ptr//append-item")
			}
			arg0Val.AppendItem(arg1Val)
			return arg0
		},
	},
	"widget-form-ptr//cancel-text!": {
		Doc:   "Set *widget.Form CancelText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//cancel-text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//cancel-text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//cancel-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CancelText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-form-ptr//cancel-text!")
			}
			return arg0
		},
	},
	"widget-form-ptr//cancel-text?": {
		Doc:   "Get *widget.Form CancelText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//cancel-text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//cancel-text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//cancel-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CancelText)
			return resObj
		},
	},
	"widget-form-ptr//create-renderer": {
		Doc:   "(*widget.Form).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-form-ptr//disable": {
		Doc:   "(*widget.Form).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"widget-form-ptr//disabled": {
		Doc:   "(*widget.Form).Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//disabled")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//disabled")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//disabled")
			}
			res0 := arg0Val.Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-form-ptr//enable": {
		Doc:   "(*widget.Form).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"widget-form-ptr//hidden!": {
		Doc:   "Set *widget.Form Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-form-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-form-ptr//hidden?": {
		Doc:   "Get *widget.Form Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-form-ptr//items!": {
		Doc:   "Set *widget.Form Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.FormItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.FormItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form-ptr//items!")
			}
			return arg0
		},
	},
	"widget-form-ptr//items?": {
		Doc:   "Get *widget.Form Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "widget-form-item-ptr-arr")
			return resObj
		},
	},
	"widget-form-ptr//min-size": {
		Doc:   "(*widget.Form).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-form-ptr//on-cancel!": {
		Doc:   "Set *widget.Form OnCancel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-cancel!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-cancel!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-cancel!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form-ptr//on-cancel!")
				}
				self.OnCancel = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form-ptr//on-cancel!")
				}
				self.OnCancel = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form-ptr//on-cancel!")
			}
			return arg0
		},
	},
	"widget-form-ptr//on-cancel?": {
		Doc:   "Get *widget.Form OnCancel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-cancel?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-cancel?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-cancel?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCancel, "--go-any-func--")
			return resObj
		},
	},
	"widget-form-ptr//on-submit!": {
		Doc:   "Set *widget.Form OnSubmit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-submit!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-submit!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-submit!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form-ptr//on-submit!")
				}
				self.OnSubmit = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form-ptr//on-submit!")
				}
				self.OnSubmit = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form-ptr//on-submit!")
			}
			return arg0
		},
	},
	"widget-form-ptr//on-submit?": {
		Doc:   "Get *widget.Form OnSubmit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-submit?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-submit?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//on-submit?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmit, "--go-any-func--")
			return resObj
		},
	},
	"widget-form-ptr//refresh": {
		Doc:   "(*widget.Form).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"widget-form-ptr//set-on-validation-changed": {
		Doc:   "(*widget.Form).SetOnValidationChanged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//set-on-validation-changed")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//set-on-validation-changed")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//set-on-validation-changed")
			}
			var arg1Val func(error)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form-ptr//set-on-validation-changed")
				}
				arg1Val = func(arg0 error) {
					var arg0Val env.Object
					arg0Val = *env.NewError(arg0.Error())
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form-ptr//set-on-validation-changed")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form-ptr//set-on-validation-changed")
			}
			arg0Val.SetOnValidationChanged(arg1Val)
			return arg0
		},
	},
	"widget-form-ptr//submit-text!": {
		Doc:   "Set *widget.Form SubmitText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//submit-text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//submit-text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//submit-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.SubmitText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-form-ptr//submit-text!")
			}
			return arg0
		},
	},
	"widget-form-ptr//submit-text?": {
		Doc:   "Get *widget.Form SubmitText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//submit-text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//submit-text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//submit-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.SubmitText)
			return resObj
		},
	},
	"widget-form-ptr//validate": {
		Doc:   "(*widget.Form).Validate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//validate")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//validate")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form-ptr//validate")
			}
			res0 := arg0Val.Validate()
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"widget-form//cancel-text!": {
		Doc:   "Set widget.Form CancelText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//cancel-text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//cancel-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.CancelText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-form//cancel-text!")
			}
			return arg0
		},
	},
	"widget-form//cancel-text?": {
		Doc:   "Get widget.Form CancelText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//cancel-text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//cancel-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.CancelText)
			return resObj
		},
	},
	"widget-form//hidden!": {
		Doc:   "Set widget.Form Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-form//hidden!")
			}
			return arg0
		},
	},
	"widget-form//hidden?": {
		Doc:   "Get widget.Form Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-form//items!": {
		Doc:   "Set widget.Form Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]*widget.FormItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(*widget.FormItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]*widget.FormItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form//items!")
			}
			return arg0
		},
	},
	"widget-form//items?": {
		Doc:   "Get widget.Form Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "widget-form-item-ptr-arr")
			return resObj
		},
	},
	"widget-form//on-cancel!": {
		Doc:   "Set widget.Form OnCancel value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//on-cancel!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//on-cancel!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form//on-cancel!")
				}
				self.OnCancel = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form//on-cancel!")
				}
				self.OnCancel = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form//on-cancel!")
			}
			return arg0
		},
	},
	"widget-form//on-cancel?": {
		Doc:   "Get widget.Form OnCancel value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//on-cancel?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//on-cancel?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCancel, "--go-any-func--")
			return resObj
		},
	},
	"widget-form//on-submit!": {
		Doc:   "Set widget.Form OnSubmit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//on-submit!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//on-submit!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form//on-submit!")
				}
				self.OnSubmit = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-form//on-submit!")
				}
				self.OnSubmit = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-form//on-submit!")
			}
			return arg0
		},
	},
	"widget-form//on-submit?": {
		Doc:   "Get widget.Form OnSubmit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//on-submit?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//on-submit?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmit, "--go-any-func--")
			return resObj
		},
	},
	"widget-form//submit-text!": {
		Doc:   "Set widget.Form SubmitText value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//submit-text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//submit-text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.SubmitText = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-form//submit-text!")
			}
			return arg0
		},
	},
	"widget-form//submit-text?": {
		Doc:   "Get widget.Form SubmitText value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Form
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Form)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//submit-text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-form//submit-text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.SubmitText)
			return resObj
		},
	},
	"widget-grid-wrap": {
		Doc:   "widget.NewGridWrap",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val func() int
			switch fn := arg0.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "widget-grid-wrap")
				}
				arg0Val = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.FunctionType}, "widget-grid-wrap")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap")
			}
			var arg2Val func(widget.GridWrapItemID, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "widget-grid-wrap")
				}
				arg2Val = func(arg0 widget.GridWrapItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-grid-wrap-item-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "widget-grid-wrap")
			}
			res0 := widget.NewGridWrap(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-grid-wrap-ptr")
			return res0Obj
		},
	},
	"widget-grid-wrap-ptr//create-item!": {
		Doc:   "Set *widget.GridWrap CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//create-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//create-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//create-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//create-item!")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap-ptr//create-item!")
				}
				self.CreateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//create-item!")
			}
			return arg0
		},
	},
	"widget-grid-wrap-ptr//create-item?": {
		Doc:   "Get *widget.GridWrap CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//create-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//create-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//create-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "--go-any-func--")
			return resObj
		},
	},
	"widget-grid-wrap-ptr//create-renderer": {
		Doc:   "(*widget.GridWrap).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-grid-wrap-ptr//focus-gained": {
		Doc:   "(*widget.GridWrap).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"widget-grid-wrap-ptr//focus-lost": {
		Doc:   "(*widget.GridWrap).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"widget-grid-wrap-ptr//get-scroll-offset": {
		Doc:   "(*widget.GridWrap).GetScrollOffset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//get-scroll-offset")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//get-scroll-offset")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//get-scroll-offset")
			}
			res0 := arg0Val.GetScrollOffset()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"widget-grid-wrap-ptr//hidden!": {
		Doc:   "Set *widget.GridWrap Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-grid-wrap-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-grid-wrap-ptr//hidden?": {
		Doc:   "Get *widget.GridWrap Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-grid-wrap-ptr//length!": {
		Doc:   "Set *widget.GridWrap Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//length!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//length!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//length!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//length!")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap-ptr//length!")
				}
				self.Length = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//length!")
			}
			return arg0
		},
	},
	"widget-grid-wrap-ptr//length?": {
		Doc:   "Get *widget.GridWrap Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//length?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//length?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//length?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "--go-any-func--")
			return resObj
		},
	},
	"widget-grid-wrap-ptr//min-size": {
		Doc:   "(*widget.GridWrap).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-grid-wrap-ptr//on-selected!": {
		Doc:   "Set *widget.GridWrap OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//on-selected!")
				}
				self.OnSelected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-grid-wrap-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap-ptr//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//on-selected!")
			}
			return arg0
		},
	},
	"widget-grid-wrap-ptr//on-selected?": {
		Doc:   "Get *widget.GridWrap OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "--go-any-func--")
			return resObj
		},
	},
	"widget-grid-wrap-ptr//on-unselected!": {
		Doc:   "Set *widget.GridWrap OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-unselected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-unselected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-grid-wrap-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap-ptr//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//on-unselected!")
			}
			return arg0
		},
	},
	"widget-grid-wrap-ptr//on-unselected?": {
		Doc:   "Get *widget.GridWrap OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-unselected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-unselected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "--go-any-func--")
			return resObj
		},
	},
	"widget-grid-wrap-ptr//refresh-item": {
		Doc:   "(*widget.GridWrap).RefreshItem",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//refresh-item")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//refresh-item")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//refresh-item")
			}
			var arg1Val widget.GridWrapItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.GridWrapItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//refresh-item")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//refresh-item")
			}
			arg0Val.RefreshItem(arg1Val)
			return arg0
		},
	},
	"widget-grid-wrap-ptr//resize": {
		Doc:   "(*widget.GridWrap).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"widget-grid-wrap-ptr//scroll-to": {
		Doc:   "(*widget.GridWrap).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to")
			}
			var arg1Val widget.GridWrapItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.GridWrapItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to")
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"widget-grid-wrap-ptr//scroll-to-bottom": {
		Doc:   "(*widget.GridWrap).ScrollToBottom",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to-bottom")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to-bottom")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to-bottom")
			}
			arg0Val.ScrollToBottom()
			return arg0
		},
	},
	"widget-grid-wrap-ptr//scroll-to-offset": {
		Doc:   "(*widget.GridWrap).ScrollToOffset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to-offset")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to-offset")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to-offset")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-grid-wrap-ptr//scroll-to-offset")
			}
			arg0Val.ScrollToOffset(arg1Val)
			return arg0
		},
	},
	"widget-grid-wrap-ptr//scroll-to-top": {
		Doc:   "(*widget.GridWrap).ScrollToTop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to-top")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to-top")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//scroll-to-top")
			}
			arg0Val.ScrollToTop()
			return arg0
		},
	},
	"widget-grid-wrap-ptr//select": {
		Doc:   "(*widget.GridWrap).Select",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//select")
			}
			var arg1Val widget.GridWrapItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.GridWrapItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//select")
			}
			arg0Val.Select(arg1Val)
			return arg0
		},
	},
	"widget-grid-wrap-ptr//typed-key": {
		Doc:   "(*widget.GridWrap).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"widget-grid-wrap-ptr//typed-rune": {
		Doc:   "(*widget.GridWrap).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"widget-grid-wrap-ptr//unselect": {
		Doc:   "(*widget.GridWrap).Unselect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//unselect")
			}
			var arg1Val widget.GridWrapItemID
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.GridWrapItemID)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//unselect")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//unselect")
			}
			arg0Val.Unselect(arg1Val)
			return arg0
		},
	},
	"widget-grid-wrap-ptr//unselect-all": {
		Doc:   "(*widget.GridWrap).UnselectAll",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//unselect-all")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//unselect-all")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//unselect-all")
			}
			arg0Val.UnselectAll()
			return arg0
		},
	},
	"widget-grid-wrap-ptr//update-item!": {
		Doc:   "Set *widget.GridWrap UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//update-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//update-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//update-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//update-item!")
				}
				self.UpdateItem = func(arg0 widget.GridWrapItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-grid-wrap-item-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap-ptr//update-item!")
				}
				self.UpdateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-ptr//update-item!")
			}
			return arg0
		},
	},
	"widget-grid-wrap-ptr//update-item?": {
		Doc:   "Get *widget.GridWrap UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//update-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//update-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-ptr//update-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "--go-any-func--")
			return resObj
		},
	},
	"widget-grid-wrap-with-data": {
		Doc:   "widget.NewGridWrapWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.DataList
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.DataList)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap-with-data")
			}
			var arg1Val func() fyne.CanvasObject
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-with-data")
				}
				arg1Val = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap-with-data")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap-with-data")
			}
			var arg2Val func(binding.DataItem, fyne.CanvasObject)
			switch fn := arg2.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "widget-grid-wrap-with-data")
				}
				arg2Val = func(arg0 binding.DataItem, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "binding-data-item")
					arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap-with-data")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.FunctionType}, "widget-grid-wrap-with-data")
			}
			res0 := widget.NewGridWrapWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-grid-wrap-ptr")
			return res0Obj
		},
	},
	"widget-grid-wrap//create-item!": {
		Doc:   "Set widget.GridWrap CreateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//create-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//create-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//create-item!")
				}
				self.CreateItem = func() fyne.CanvasObject {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res fyne.CanvasObject
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(fyne.CanvasObject)
						if !ok {
							// TODO: Invalid type
						}
					case env.Integer:
						if v.Value != 0 {
							// TODO: Invalid type
						}
						res = nil
					default:
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap//create-item!")
				}
				self.CreateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//create-item!")
			}
			return arg0
		},
	},
	"widget-grid-wrap//create-item?": {
		Doc:   "Get widget.GridWrap CreateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//create-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//create-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CreateItem, "--go-any-func--")
			return resObj
		},
	},
	"widget-grid-wrap//hidden!": {
		Doc:   "Set widget.GridWrap Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-grid-wrap//hidden!")
			}
			return arg0
		},
	},
	"widget-grid-wrap//hidden?": {
		Doc:   "Get widget.GridWrap Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-grid-wrap//length!": {
		Doc:   "Set widget.GridWrap Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//length!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//length!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//length!")
				}
				self.Length = func() int {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res int
					if v, ok := ps.Res.(env.Integer); ok {
						res = int(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap//length!")
				}
				self.Length = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//length!")
			}
			return arg0
		},
	},
	"widget-grid-wrap//length?": {
		Doc:   "Get widget.GridWrap Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//length?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//length?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Length, "--go-any-func--")
			return resObj
		},
	},
	"widget-grid-wrap//on-selected!": {
		Doc:   "Set widget.GridWrap OnSelected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//on-selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//on-selected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//on-selected!")
				}
				self.OnSelected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-grid-wrap-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap//on-selected!")
				}
				self.OnSelected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//on-selected!")
			}
			return arg0
		},
	},
	"widget-grid-wrap//on-selected?": {
		Doc:   "Get widget.GridWrap OnSelected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//on-selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//on-selected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSelected, "--go-any-func--")
			return resObj
		},
	},
	"widget-grid-wrap//on-unselected!": {
		Doc:   "Set widget.GridWrap OnUnselected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//on-unselected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//on-unselected!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//on-unselected!")
				}
				self.OnUnselected = func(arg0 widget.GridWrapItemID) {
					var arg0Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-grid-wrap-item-id")
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap//on-unselected!")
				}
				self.OnUnselected = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//on-unselected!")
			}
			return arg0
		},
	},
	"widget-grid-wrap//on-unselected?": {
		Doc:   "Get widget.GridWrap OnUnselected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//on-unselected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//on-unselected?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnUnselected, "--go-any-func--")
			return resObj
		},
	},
	"widget-grid-wrap//update-item!": {
		Doc:   "Set widget.GridWrap UpdateItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//update-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//update-item!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 2 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//update-item!")
				}
				self.UpdateItem = func(arg0 widget.GridWrapItemID, arg1 fyne.CanvasObject) {
					var arg0Val, arg1Val env.Object
					arg0Val = *env.NewNative(ps.Idx, arg0, "widget-grid-wrap-item-id")
					arg1Val = *env.NewNative(ps.Idx, arg1, "fyne-canvas-object")
					evaldo.CallFunctionArgs2(fn, ps, arg0Val, arg1Val, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-grid-wrap//update-item!")
				}
				self.UpdateItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-grid-wrap//update-item!")
			}
			return arg0
		},
	},
	"widget-grid-wrap//update-item?": {
		Doc:   "Get widget.GridWrap UpdateItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.GridWrap
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.GridWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//update-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-grid-wrap//update-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.UpdateItem, "--go-any-func--")
			return resObj
		},
	},
	"widget-hyperlink": {
		Doc:   "widget.NewHyperlink",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-hyperlink")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink")
			}
			res0 := widget.NewHyperlink(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-hyperlink-ptr")
			return res0Obj
		},
	},
	"widget-hyperlink-ptr//alignment!": {
		Doc:   "Set *widget.Hyperlink Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//alignment!")
			}
			return arg0
		},
	},
	"widget-hyperlink-ptr//alignment?": {
		Doc:   "Get *widget.Hyperlink Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-hyperlink-ptr//create-renderer": {
		Doc:   "(*widget.Hyperlink).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-hyperlink-ptr//cursor": {
		Doc:   "(*widget.Hyperlink).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//cursor")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//cursor")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//cursor")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "desktop-cursor")
			return res0Obj
		},
	},
	"widget-hyperlink-ptr//focus-gained": {
		Doc:   "(*widget.Hyperlink).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"widget-hyperlink-ptr//focus-lost": {
		Doc:   "(*widget.Hyperlink).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"widget-hyperlink-ptr//hidden!": {
		Doc:   "Set *widget.Hyperlink Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-hyperlink-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-hyperlink-ptr//hidden?": {
		Doc:   "Get *widget.Hyperlink Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-hyperlink-ptr//min-size": {
		Doc:   "(*widget.Hyperlink).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-hyperlink-ptr//mouse-in": {
		Doc:   "(*widget.Hyperlink).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"widget-hyperlink-ptr//mouse-moved": {
		Doc:   "(*widget.Hyperlink).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"widget-hyperlink-ptr//mouse-out": {
		Doc:   "(*widget.Hyperlink).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"widget-hyperlink-ptr//on-tapped!": {
		Doc:   "Set *widget.Hyperlink OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//on-tapped!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//on-tapped!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-hyperlink-ptr//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-hyperlink-ptr//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-hyperlink-ptr//on-tapped!")
			}
			return arg0
		},
	},
	"widget-hyperlink-ptr//on-tapped?": {
		Doc:   "Get *widget.Hyperlink OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//on-tapped?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//on-tapped?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "--go-any-func--")
			return resObj
		},
	},
	"widget-hyperlink-ptr//refresh": {
		Doc:   "(*widget.Hyperlink).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"widget-hyperlink-ptr//resize": {
		Doc:   "(*widget.Hyperlink).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"widget-hyperlink-ptr//set-text": {
		Doc:   "(*widget.Hyperlink).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-hyperlink-ptr//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"widget-hyperlink-ptr//set-url": {
		Doc:   "(*widget.Hyperlink).SetURL",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-url")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-url")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-url")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-url")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-url")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-url")
			}
			arg0Val.SetURL(arg1Val)
			return arg0
		},
	},
	"widget-hyperlink-ptr//set-url-from-string": {
		Doc:   "(*widget.Hyperlink).SetURLFromString",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-url-from-string")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-url-from-string")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//set-url-from-string")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-hyperlink-ptr//set-url-from-string")
			}
			res0 := arg0Val.SetURLFromString(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewError(res0.Error())
			return res0Obj
		},
	},
	"widget-hyperlink-ptr//tapped": {
		Doc:   "(*widget.Hyperlink).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"widget-hyperlink-ptr//text!": {
		Doc:   "Set *widget.Hyperlink Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-hyperlink-ptr//text!")
			}
			return arg0
		},
	},
	"widget-hyperlink-ptr//text-style!": {
		Doc:   "Set *widget.Hyperlink TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text-style!")
			}
			return arg0
		},
	},
	"widget-hyperlink-ptr//text-style?": {
		Doc:   "Get *widget.Hyperlink TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-hyperlink-ptr//text?": {
		Doc:   "Get *widget.Hyperlink Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-hyperlink-ptr//typed-key": {
		Doc:   "(*widget.Hyperlink).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"widget-hyperlink-ptr//typed-rune": {
		Doc:   "(*widget.Hyperlink).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"widget-hyperlink-ptr//url!": {
		Doc:   "Set *widget.Hyperlink URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//url!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//url!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//url!")
				}
				self.URL = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//url!")
			}
			return arg0
		},
	},
	"widget-hyperlink-ptr//url?": {
		Doc:   "Get *widget.Hyperlink URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//url?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//url?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//url?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "url-url-ptr")
			return resObj
		},
	},
	"widget-hyperlink-ptr//wrapping!": {
		Doc:   "Set *widget.Hyperlink Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//wrapping!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//wrapping!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-ptr//wrapping!")
			}
			return arg0
		},
	},
	"widget-hyperlink-ptr//wrapping?": {
		Doc:   "Get *widget.Hyperlink Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//wrapping?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//wrapping?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-ptr//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "fyne-text-wrap")
			return resObj
		},
	},
	"widget-hyperlink-segment-ptr//alignment!": {
		Doc:   "Set *widget.HyperlinkSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//alignment!")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment-ptr//alignment?": {
		Doc:   "Get *widget.HyperlinkSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-hyperlink-segment-ptr//inline": {
		Doc:   "(*widget.HyperlinkSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-hyperlink-segment-ptr//on-tapped!": {
		Doc:   "Set *widget.HyperlinkSegment OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//on-tapped!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//on-tapped!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-hyperlink-segment-ptr//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-hyperlink-segment-ptr//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-hyperlink-segment-ptr//on-tapped!")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment-ptr//on-tapped?": {
		Doc:   "Get *widget.HyperlinkSegment OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//on-tapped?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//on-tapped?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "--go-any-func--")
			return resObj
		},
	},
	"widget-hyperlink-segment-ptr//select": {
		Doc:   "(*widget.HyperlinkSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-hyperlink-segment-ptr//selected-text": {
		Doc:   "(*widget.HyperlinkSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-hyperlink-segment-ptr//text!": {
		Doc:   "Set *widget.HyperlinkSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-hyperlink-segment-ptr//text!")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment-ptr//text?": {
		Doc:   "Get *widget.HyperlinkSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-hyperlink-segment-ptr//textual": {
		Doc:   "(*widget.HyperlinkSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-hyperlink-segment-ptr//unselect": {
		Doc:   "(*widget.HyperlinkSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"widget-hyperlink-segment-ptr//update": {
		Doc:   "(*widget.HyperlinkSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"widget-hyperlink-segment-ptr//url!": {
		Doc:   "Set *widget.HyperlinkSegment URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//url!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//url!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//url!")
				}
				self.URL = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//url!")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment-ptr//url?": {
		Doc:   "Get *widget.HyperlinkSegment URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//url?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//url?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//url?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "url-url-ptr")
			return resObj
		},
	},
	"widget-hyperlink-segment-ptr//visual": {
		Doc:   "(*widget.HyperlinkSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment-ptr//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-hyperlink-segment//alignment!": {
		Doc:   "Set widget.HyperlinkSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment//alignment!")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment//alignment?": {
		Doc:   "Get widget.HyperlinkSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-hyperlink-segment//on-tapped!": {
		Doc:   "Set widget.HyperlinkSegment OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//on-tapped!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-hyperlink-segment//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-hyperlink-segment//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-hyperlink-segment//on-tapped!")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment//on-tapped?": {
		Doc:   "Get widget.HyperlinkSegment OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//on-tapped?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "--go-any-func--")
			return resObj
		},
	},
	"widget-hyperlink-segment//text!": {
		Doc:   "Set widget.HyperlinkSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-hyperlink-segment//text!")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment//text?": {
		Doc:   "Get widget.HyperlinkSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-hyperlink-segment//url!": {
		Doc:   "Set widget.HyperlinkSegment URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//url!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//url!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment//url!")
				}
				self.URL = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-segment//url!")
			}
			return arg0
		},
	},
	"widget-hyperlink-segment//url?": {
		Doc:   "Get widget.HyperlinkSegment URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.HyperlinkSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.HyperlinkSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//url?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink-segment//url?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "url-url-ptr")
			return resObj
		},
	},
	"widget-hyperlink-with-style": {
		Doc:   "widget.NewHyperlinkWithStyle",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-hyperlink-with-style")
			}
			var arg1Val *url.URL
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-with-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-with-style")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink-with-style")
			}
			var arg2Val fyne.TextAlign
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-hyperlink-with-style")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-hyperlink-with-style")
			}
			var arg3Val fyne.TextStyle
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-hyperlink-with-style")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-hyperlink-with-style")
			}
			res0 := widget.NewHyperlinkWithStyle(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-hyperlink-ptr")
			return res0Obj
		},
	},
	"widget-hyperlink//alignment!": {
		Doc:   "Set widget.Hyperlink Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink//alignment!")
			}
			return arg0
		},
	},
	"widget-hyperlink//alignment?": {
		Doc:   "Get widget.Hyperlink Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-hyperlink//hidden!": {
		Doc:   "Set widget.Hyperlink Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-hyperlink//hidden!")
			}
			return arg0
		},
	},
	"widget-hyperlink//hidden?": {
		Doc:   "Get widget.Hyperlink Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-hyperlink//on-tapped!": {
		Doc:   "Set widget.Hyperlink OnTapped value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//on-tapped!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//on-tapped!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-hyperlink//on-tapped!")
				}
				self.OnTapped = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-hyperlink//on-tapped!")
				}
				self.OnTapped = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-hyperlink//on-tapped!")
			}
			return arg0
		},
	},
	"widget-hyperlink//on-tapped?": {
		Doc:   "Get widget.Hyperlink OnTapped value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//on-tapped?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//on-tapped?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnTapped, "--go-any-func--")
			return resObj
		},
	},
	"widget-hyperlink//text!": {
		Doc:   "Set widget.Hyperlink Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-hyperlink//text!")
			}
			return arg0
		},
	},
	"widget-hyperlink//text-style!": {
		Doc:   "Set widget.Hyperlink TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink//text-style!")
			}
			return arg0
		},
	},
	"widget-hyperlink//text-style?": {
		Doc:   "Get widget.Hyperlink TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-hyperlink//text?": {
		Doc:   "Get widget.Hyperlink Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-hyperlink//url!": {
		Doc:   "Set widget.Hyperlink URL value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//url!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//url!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.URL, ok = v.Value.(*url.URL)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink//url!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink//url!")
				}
				self.URL = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink//url!")
			}
			return arg0
		},
	},
	"widget-hyperlink//url?": {
		Doc:   "Get widget.Hyperlink URL value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//url?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//url?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.URL, "url-url-ptr")
			return resObj
		},
	},
	"widget-hyperlink//wrapping!": {
		Doc:   "Set widget.Hyperlink Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-hyperlink//wrapping!")
			}
			return arg0
		},
	},
	"widget-hyperlink//wrapping?": {
		Doc:   "Get widget.Hyperlink Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Hyperlink
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Hyperlink)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//wrapping?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-hyperlink//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "fyne-text-wrap")
			return resObj
		},
	},
	"widget-icon": {
		Doc:   "widget.NewIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon")
			}
			res0 := widget.NewIcon(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-icon-ptr")
			return res0Obj
		},
	},
	"widget-icon-ptr//create-renderer": {
		Doc:   "(*widget.Icon).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-icon-ptr//hidden!": {
		Doc:   "Set *widget.Icon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-icon-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-icon-ptr//hidden?": {
		Doc:   "Get *widget.Icon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-icon-ptr//min-size": {
		Doc:   "(*widget.Icon).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-icon-ptr//resource!": {
		Doc:   "Set *widget.Icon Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//resource!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//resource!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-icon-ptr//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-icon-ptr//resource!")
				}
				self.Resource = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-icon-ptr//resource!")
			}
			return arg0
		},
	},
	"widget-icon-ptr//resource?": {
		Doc:   "Get *widget.Icon Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//resource?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//resource?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//resource?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Resource, "fyne-resource")
			return resObj
		},
	},
	"widget-icon-ptr//set-resource": {
		Doc:   "(*widget.Icon).SetResource",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//set-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//set-resource")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon-ptr//set-resource")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-icon-ptr//set-resource")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-icon-ptr//set-resource")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-icon-ptr//set-resource")
			}
			arg0Val.SetResource(arg1Val)
			return arg0
		},
	},
	"widget-icon//hidden!": {
		Doc:   "Set widget.Icon Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-icon//hidden!")
			}
			return arg0
		},
	},
	"widget-icon//hidden?": {
		Doc:   "Get widget.Icon Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-icon//resource!": {
		Doc:   "Set widget.Icon Resource value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon//resource!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon//resource!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Resource, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-icon//resource!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-icon//resource!")
				}
				self.Resource = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-icon//resource!")
			}
			return arg0
		},
	},
	"widget-icon//resource?": {
		Doc:   "Get widget.Icon Resource value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Icon)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon//resource?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-icon//resource?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Resource, "fyne-resource")
			return resObj
		},
	},
	"widget-image-segment-ptr//alignment!": {
		Doc:   "Set *widget.ImageSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment-ptr//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment-ptr//alignment!")
			}
			return arg0
		},
	},
	"widget-image-segment-ptr//alignment?": {
		Doc:   "Get *widget.ImageSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-image-segment-ptr//inline": {
		Doc:   "(*widget.ImageSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-image-segment-ptr//select": {
		Doc:   "(*widget.ImageSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment-ptr//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-image-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-image-segment-ptr//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-image-segment-ptr//selected-text": {
		Doc:   "(*widget.ImageSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-image-segment-ptr//source!": {
		Doc:   "Set *widget.ImageSegment Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//source!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//source!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//source!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment-ptr//source!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment-ptr//source!")
			}
			return arg0
		},
	},
	"widget-image-segment-ptr//source?": {
		Doc:   "Get *widget.ImageSegment Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//source?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//source?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//source?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "fyne-uri")
			return resObj
		},
	},
	"widget-image-segment-ptr//textual": {
		Doc:   "(*widget.ImageSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-image-segment-ptr//title!": {
		Doc:   "Set *widget.ImageSegment Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//title!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//title!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-image-segment-ptr//title!")
			}
			return arg0
		},
	},
	"widget-image-segment-ptr//title?": {
		Doc:   "Get *widget.ImageSegment Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//title?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//title?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"widget-image-segment-ptr//unselect": {
		Doc:   "(*widget.ImageSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"widget-image-segment-ptr//update": {
		Doc:   "(*widget.ImageSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment-ptr//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment-ptr//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"widget-image-segment-ptr//visual": {
		Doc:   "(*widget.ImageSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment-ptr//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-image-segment//alignment!": {
		Doc:   "Set widget.ImageSegment Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment//alignment!")
			}
			return arg0
		},
	},
	"widget-image-segment//alignment?": {
		Doc:   "Get widget.ImageSegment Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-image-segment//source!": {
		Doc:   "Set widget.ImageSegment Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//source!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//source!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Source, ok = v.Value.(fyne.URI)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment//source!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-image-segment//source!")
			}
			return arg0
		},
	},
	"widget-image-segment//source?": {
		Doc:   "Get widget.ImageSegment Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//source?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//source?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Source, "fyne-uri")
			return resObj
		},
	},
	"widget-image-segment//title!": {
		Doc:   "Set widget.ImageSegment Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//title!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//title!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Title = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-image-segment//title!")
			}
			return arg0
		},
	},
	"widget-image-segment//title?": {
		Doc:   "Get widget.ImageSegment Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ImageSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ImageSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//title?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-image-segment//title?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"widget-label": {
		Doc:   "widget.NewLabel",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-label")
			}
			res0 := widget.NewLabel(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-label-ptr")
			return res0Obj
		},
	},
	"widget-label-ptr//alignment!": {
		Doc:   "Set *widget.Label Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//alignment!")
			}
			return arg0
		},
	},
	"widget-label-ptr//alignment?": {
		Doc:   "Get *widget.Label Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-label-ptr//bind": {
		Doc:   "(*widget.Label).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//bind")
			}
			var arg1Val binding.String
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"widget-label-ptr//create-renderer": {
		Doc:   "(*widget.Label).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-label-ptr//extend-base-widget": {
		Doc:   "(*widget.Label).ExtendBaseWidget",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//extend-base-widget")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//extend-base-widget")
			}
			var arg1Val fyne.Widget
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Widget)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//extend-base-widget")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//extend-base-widget")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//extend-base-widget")
			}
			arg0Val.ExtendBaseWidget(arg1Val)
			return arg0
		},
	},
	"widget-label-ptr//hidden!": {
		Doc:   "Set *widget.Label Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-label-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-label-ptr//hidden?": {
		Doc:   "Get *widget.Label Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-label-ptr//importance!": {
		Doc:   "Set *widget.Label Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//importance!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//importance!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//importance!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Importance, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//importance!")
			}
			return arg0
		},
	},
	"widget-label-ptr//importance?": {
		Doc:   "Get *widget.Label Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//importance?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//importance?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//importance?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Importance, "widget-importance")
			return resObj
		},
	},
	"widget-label-ptr//min-size": {
		Doc:   "(*widget.Label).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-label-ptr//refresh": {
		Doc:   "(*widget.Label).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"widget-label-ptr//resize": {
		Doc:   "(*widget.Label).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"widget-label-ptr//set-text": {
		Doc:   "(*widget.Label).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-label-ptr//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"widget-label-ptr//text!": {
		Doc:   "Set *widget.Label Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-label-ptr//text!")
			}
			return arg0
		},
	},
	"widget-label-ptr//text-style!": {
		Doc:   "Set *widget.Label TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//text-style!")
			}
			return arg0
		},
	},
	"widget-label-ptr//text-style?": {
		Doc:   "Get *widget.Label TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-label-ptr//text?": {
		Doc:   "Get *widget.Label Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-label-ptr//truncation!": {
		Doc:   "Set *widget.Label Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//truncation!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//truncation!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//truncation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Truncation, ok = v.Value.(fyne.TextTruncation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//truncation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//truncation!")
			}
			return arg0
		},
	},
	"widget-label-ptr//truncation?": {
		Doc:   "Get *widget.Label Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//truncation?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//truncation?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//truncation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Truncation, "fyne-text-truncation")
			return resObj
		},
	},
	"widget-label-ptr//unbind": {
		Doc:   "(*widget.Label).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"widget-label-ptr//wrapping!": {
		Doc:   "Set *widget.Label Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//wrapping!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//wrapping!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-ptr//wrapping!")
			}
			return arg0
		},
	},
	"widget-label-ptr//wrapping?": {
		Doc:   "Get *widget.Label Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//wrapping?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//wrapping?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-ptr//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "fyne-text-wrap")
			return resObj
		},
	},
	"widget-label-with-data": {
		Doc:   "widget.NewLabelWithData",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.String
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.String)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label-with-data")
			}
			res0 := widget.NewLabelWithData(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-label-ptr")
			return res0Obj
		},
	},
	"widget-label-with-style": {
		Doc:   "widget.NewLabelWithStyle",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-label-with-style")
			}
			var arg1Val fyne.TextAlign
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-with-style")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label-with-style")
			}
			var arg2Val fyne.TextStyle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-label-with-style")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-label-with-style")
			}
			res0 := widget.NewLabelWithStyle(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-label-ptr")
			return res0Obj
		},
	},
	"widget-label//alignment!": {
		Doc:   "Set widget.Label Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//alignment!")
			}
			return arg0
		},
	},
	"widget-label//alignment?": {
		Doc:   "Get widget.Label Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-label//hidden!": {
		Doc:   "Set widget.Label Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-label//hidden!")
			}
			return arg0
		},
	},
	"widget-label//hidden?": {
		Doc:   "Get widget.Label Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-label//importance!": {
		Doc:   "Set widget.Label Importance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//importance!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Importance, ok = v.Value.(widget.Importance)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//importance!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//importance!")
			}
			return arg0
		},
	},
	"widget-label//importance?": {
		Doc:   "Get widget.Label Importance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//importance?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//importance?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Importance, "widget-importance")
			return resObj
		},
	},
	"widget-label//text!": {
		Doc:   "Set widget.Label Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-label//text!")
			}
			return arg0
		},
	},
	"widget-label//text-style!": {
		Doc:   "Set widget.Label TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//text-style!")
			}
			return arg0
		},
	},
	"widget-label//text-style?": {
		Doc:   "Get widget.Label TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-label//text?": {
		Doc:   "Get widget.Label Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-label//truncation!": {
		Doc:   "Set widget.Label Truncation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//truncation!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//truncation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Truncation, ok = v.Value.(fyne.TextTruncation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//truncation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//truncation!")
			}
			return arg0
		},
	},
	"widget-label//truncation?": {
		Doc:   "Get widget.Label Truncation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//truncation?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//truncation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Truncation, "fyne-text-truncation")
			return resObj
		},
	},
	"widget-label//wrapping!": {
		Doc:   "Set widget.Label Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-label//wrapping!")
			}
			return arg0
		},
	},
	"widget-label//wrapping?": {
		Doc:   "Get widget.Label Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Label)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//wrapping?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-label//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "fyne-text-wrap")
			return resObj
		},
	},
	"widget-list-segment-ptr//inline": {
		Doc:   "(*widget.ListSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-list-segment-ptr//items!": {
		Doc:   "Set *widget.ListSegment Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment-ptr//items!")
			}
			return arg0
		},
	},
	"widget-list-segment-ptr//items?": {
		Doc:   "Get *widget.ListSegment Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "widget-rich-text-segment-arr")
			return resObj
		},
	},
	"widget-list-segment-ptr//ordered!": {
		Doc:   "Set *widget.ListSegment Ordered value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//ordered!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//ordered!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//ordered!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Ordered = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-list-segment-ptr//ordered!")
			}
			return arg0
		},
	},
	"widget-list-segment-ptr//ordered?": {
		Doc:   "Get *widget.ListSegment Ordered value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//ordered?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//ordered?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//ordered?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Ordered))
			return resObj
		},
	},
	"widget-list-segment-ptr//segments": {
		Doc:   "(*widget.ListSegment).Segments",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//segments")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//segments")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//segments")
			}
			res0 := arg0Val.Segments()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-rich-text-segment-arr")
			return res0Obj
		},
	},
	"widget-list-segment-ptr//select": {
		Doc:   "(*widget.ListSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-list-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-list-segment-ptr//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-list-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-list-segment-ptr//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-list-segment-ptr//selected-text": {
		Doc:   "(*widget.ListSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-list-segment-ptr//textual": {
		Doc:   "(*widget.ListSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-list-segment-ptr//unselect": {
		Doc:   "(*widget.ListSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"widget-list-segment-ptr//update": {
		Doc:   "(*widget.ListSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-list-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-list-segment-ptr//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-list-segment-ptr//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"widget-list-segment-ptr//visual": {
		Doc:   "(*widget.ListSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment-ptr//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-list-segment//items!": {
		Doc:   "Set widget.ListSegment Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-list-segment//items!")
			}
			return arg0
		},
	},
	"widget-list-segment//items?": {
		Doc:   "Get widget.ListSegment Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "widget-rich-text-segment-arr")
			return resObj
		},
	},
	"widget-list-segment//ordered!": {
		Doc:   "Set widget.ListSegment Ordered value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment//ordered!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment//ordered!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Ordered = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-list-segment//ordered!")
			}
			return arg0
		},
	},
	"widget-list-segment//ordered?": {
		Doc:   "Get widget.ListSegment Ordered value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ListSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ListSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment//ordered?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-list-segment//ordered?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Ordered))
			return resObj
		},
	},
	"widget-menu": {
		Doc:   "widget.NewMenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu")
			}
			res0 := widget.NewMenu(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-menu-ptr")
			return res0Obj
		},
	},
	"widget-menu-ptr//activate-last-submenu": {
		Doc:   "(*widget.Menu).ActivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//activate-last-submenu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//activate-last-submenu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//activate-last-submenu")
			}
			res0 := arg0Val.ActivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-menu-ptr//activate-next": {
		Doc:   "(*widget.Menu).ActivateNext",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//activate-next")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//activate-next")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//activate-next")
			}
			arg0Val.ActivateNext()
			return arg0
		},
	},
	"widget-menu-ptr//activate-previous": {
		Doc:   "(*widget.Menu).ActivatePrevious",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//activate-previous")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//activate-previous")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//activate-previous")
			}
			arg0Val.ActivatePrevious()
			return arg0
		},
	},
	"widget-menu-ptr//create-renderer": {
		Doc:   "(*widget.Menu).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-menu-ptr//deactivate-child": {
		Doc:   "(*widget.Menu).DeactivateChild",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//deactivate-child")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//deactivate-child")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//deactivate-child")
			}
			arg0Val.DeactivateChild()
			return arg0
		},
	},
	"widget-menu-ptr//deactivate-last-submenu": {
		Doc:   "(*widget.Menu).DeactivateLastSubmenu",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//deactivate-last-submenu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//deactivate-last-submenu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//deactivate-last-submenu")
			}
			res0 := arg0Val.DeactivateLastSubmenu()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-menu-ptr//dismiss": {
		Doc:   "(*widget.Menu).Dismiss",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//dismiss")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//dismiss")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//dismiss")
			}
			arg0Val.Dismiss()
			return arg0
		},
	},
	"widget-menu-ptr//hidden!": {
		Doc:   "Set *widget.Menu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-menu-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-menu-ptr//hidden?": {
		Doc:   "Get *widget.Menu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-menu-ptr//items!": {
		Doc:   "Set *widget.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu-ptr//items!")
			}
			return arg0
		},
	},
	"widget-menu-ptr//items?": {
		Doc:   "Get *widget.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "fyne-canvas-object-arr")
			return resObj
		},
	},
	"widget-menu-ptr//min-size": {
		Doc:   "(*widget.Menu).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-menu-ptr//on-dismiss!": {
		Doc:   "Set *widget.Menu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//on-dismiss!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//on-dismiss!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//on-dismiss!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-menu-ptr//on-dismiss!")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu-ptr//on-dismiss!")
				}
				self.OnDismiss = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-menu-ptr//on-dismiss!")
			}
			return arg0
		},
	},
	"widget-menu-ptr//on-dismiss?": {
		Doc:   "Get *widget.Menu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//on-dismiss?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//on-dismiss?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//on-dismiss?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "--go-any-func--")
			return resObj
		},
	},
	"widget-menu-ptr//refresh": {
		Doc:   "(*widget.Menu).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"widget-menu-ptr//tapped": {
		Doc:   "(*widget.Menu).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-menu-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-menu-ptr//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-menu-ptr//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"widget-menu-ptr//trigger-last": {
		Doc:   "(*widget.Menu).TriggerLast",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//trigger-last")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//trigger-last")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu-ptr//trigger-last")
			}
			arg0Val.TriggerLast()
			return arg0
		},
	},
	"widget-menu//hidden!": {
		Doc:   "Set widget.Menu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-menu//hidden!")
			}
			return arg0
		},
	},
	"widget-menu//hidden?": {
		Doc:   "Get widget.Menu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-menu//items!": {
		Doc:   "Set widget.Menu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu//items!")
			}
			return arg0
		},
	},
	"widget-menu//items?": {
		Doc:   "Get widget.Menu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "fyne-canvas-object-arr")
			return resObj
		},
	},
	"widget-menu//on-dismiss!": {
		Doc:   "Set widget.Menu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//on-dismiss!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//on-dismiss!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-menu//on-dismiss!")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-menu//on-dismiss!")
				}
				self.OnDismiss = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-menu//on-dismiss!")
			}
			return arg0
		},
	},
	"widget-menu//on-dismiss?": {
		Doc:   "Get widget.Menu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//on-dismiss?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-menu//on-dismiss?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "--go-any-func--")
			return resObj
		},
	},
	"widget-modal-pop-up": {
		Doc:   "widget.NewModalPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-modal-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-modal-pop-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-modal-pop-up")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-modal-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-modal-pop-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-modal-pop-up")
			}
			res0 := widget.NewModalPopUp(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-pop-up-ptr")
			return res0Obj
		},
	},
	"widget-multi-line-entry": {
		Doc:   "widget.NewMultiLineEntry",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewMultiLineEntry()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-entry-ptr")
			return res0Obj
		},
	},
	"widget-paragraph-segment-ptr//inline": {
		Doc:   "(*widget.ParagraphSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-paragraph-segment-ptr//segments": {
		Doc:   "(*widget.ParagraphSegment).Segments",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//segments")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//segments")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//segments")
			}
			res0 := arg0Val.Segments()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-rich-text-segment-arr")
			return res0Obj
		},
	},
	"widget-paragraph-segment-ptr//select": {
		Doc:   "(*widget.ParagraphSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-paragraph-segment-ptr//selected-text": {
		Doc:   "(*widget.ParagraphSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-paragraph-segment-ptr//texts!": {
		Doc:   "Set *widget.ParagraphSegment Texts value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//texts!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//texts!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//texts!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Texts = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Texts[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment-ptr//texts!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment-ptr//texts!")
						}
						self.Texts[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment-ptr//texts!")
					}
				}
			case env.Native:
				var ok bool
				self.Texts, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment-ptr//texts!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment-ptr//texts!")
				}
				self.Texts = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment-ptr//texts!")
			}
			return arg0
		},
	},
	"widget-paragraph-segment-ptr//texts?": {
		Doc:   "Get *widget.ParagraphSegment Texts value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//texts?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//texts?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//texts?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Texts, "widget-rich-text-segment-arr")
			return resObj
		},
	},
	"widget-paragraph-segment-ptr//textual": {
		Doc:   "(*widget.ParagraphSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-paragraph-segment-ptr//unselect": {
		Doc:   "(*widget.ParagraphSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"widget-paragraph-segment-ptr//update": {
		Doc:   "(*widget.ParagraphSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"widget-paragraph-segment-ptr//visual": {
		Doc:   "(*widget.ParagraphSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment-ptr//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-paragraph-segment//texts!": {
		Doc:   "Set widget.ParagraphSegment Texts value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment//texts!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment//texts!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Texts = make([]widget.RichTextSegment, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Texts[i], ok = v.Value.(widget.RichTextSegment)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment//texts!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment//texts!")
						}
						self.Texts[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment//texts!")
					}
				}
			case env.Native:
				var ok bool
				self.Texts, ok = v.Value.([]widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment//texts!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment//texts!")
				}
				self.Texts = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-paragraph-segment//texts!")
			}
			return arg0
		},
	},
	"widget-paragraph-segment//texts?": {
		Doc:   "Get widget.ParagraphSegment Texts value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ParagraphSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ParagraphSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment//texts?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-paragraph-segment//texts?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Texts, "widget-rich-text-segment-arr")
			return resObj
		},
	},
	"widget-password-entry": {
		Doc:   "widget.NewPasswordEntry",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewPasswordEntry()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-entry-ptr")
			return res0Obj
		},
	},
	"widget-pop-up": {
		Doc:   "widget.NewPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up")
			}
			res0 := widget.NewPopUp(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-pop-up-ptr")
			return res0Obj
		},
	},
	"widget-pop-up-menu": {
		Doc:   "widget.NewPopUpMenu",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu")
			}
			res0 := widget.NewPopUpMenu(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-pop-up-menu-ptr")
			return res0Obj
		},
	},
	"widget-pop-up-menu-ptr//focus-gained": {
		Doc:   "(*widget.PopUpMenu).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//focus-lost": {
		Doc:   "(*widget.PopUpMenu).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//hidden!": {
		Doc:   "Set *widget.PopUpMenu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-pop-up-menu-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//hidden?": {
		Doc:   "Get *widget.PopUpMenu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-pop-up-menu-ptr//hide": {
		Doc:   "(*widget.PopUpMenu).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//items!": {
		Doc:   "Set *widget.PopUpMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu-ptr//items!")
			}
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//items?": {
		Doc:   "Get *widget.PopUpMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "fyne-canvas-object-arr")
			return resObj
		},
	},
	"widget-pop-up-menu-ptr//move": {
		Doc:   "(*widget.PopUpMenu).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//on-dismiss!": {
		Doc:   "Set *widget.PopUpMenu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//on-dismiss!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//on-dismiss!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//on-dismiss!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-pop-up-menu-ptr//on-dismiss!")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu-ptr//on-dismiss!")
				}
				self.OnDismiss = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-pop-up-menu-ptr//on-dismiss!")
			}
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//on-dismiss?": {
		Doc:   "Get *widget.PopUpMenu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//on-dismiss?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//on-dismiss?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//on-dismiss?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "--go-any-func--")
			return resObj
		},
	},
	"widget-pop-up-menu-ptr//resize": {
		Doc:   "(*widget.PopUpMenu).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//show": {
		Doc:   "(*widget.PopUpMenu).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//show-at-position": {
		Doc:   "(*widget.PopUpMenu).ShowAtPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-position")
			}
			arg0Val.ShowAtPosition(arg1Val)
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//show-at-relative-position": {
		Doc:   "(*widget.PopUpMenu).ShowAtRelativePosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-relative-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-relative-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-relative-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-relative-position")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-relative-position")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//show-at-relative-position")
			}
			arg0Val.ShowAtRelativePosition(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//typed-key": {
		Doc:   "(*widget.PopUpMenu).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"widget-pop-up-menu-ptr//typed-rune": {
		Doc:   "(*widget.PopUpMenu).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-menu-ptr//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"widget-pop-up-menu//hidden!": {
		Doc:   "Set widget.PopUpMenu Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-pop-up-menu//hidden!")
			}
			return arg0
		},
	},
	"widget-pop-up-menu//hidden?": {
		Doc:   "Get widget.PopUpMenu Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-pop-up-menu//items!": {
		Doc:   "Set widget.PopUpMenu Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]fyne.CanvasObject, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(fyne.CanvasObject)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu//items!")
			}
			return arg0
		},
	},
	"widget-pop-up-menu//items?": {
		Doc:   "Get widget.PopUpMenu Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "fyne-canvas-object-arr")
			return resObj
		},
	},
	"widget-pop-up-menu//on-dismiss!": {
		Doc:   "Set widget.PopUpMenu OnDismiss value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//on-dismiss!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//on-dismiss!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-pop-up-menu//on-dismiss!")
				}
				self.OnDismiss = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-pop-up-menu//on-dismiss!")
				}
				self.OnDismiss = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-pop-up-menu//on-dismiss!")
			}
			return arg0
		},
	},
	"widget-pop-up-menu//on-dismiss?": {
		Doc:   "Get widget.PopUpMenu OnDismiss value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUpMenu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUpMenu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//on-dismiss?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-menu//on-dismiss?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnDismiss, "--go-any-func--")
			return resObj
		},
	},
	"widget-pop-up-ptr//canvas!": {
		Doc:   "Set *widget.PopUp Canvas value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//canvas!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//canvas!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//canvas!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Canvas, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//canvas!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//canvas!")
				}
				self.Canvas = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//canvas!")
			}
			return arg0
		},
	},
	"widget-pop-up-ptr//canvas?": {
		Doc:   "Get *widget.PopUp Canvas value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//canvas?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//canvas?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//canvas?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Canvas, "fyne-canvas")
			return resObj
		},
	},
	"widget-pop-up-ptr//content!": {
		Doc:   "Set *widget.PopUp Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//content!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//content!")
			}
			return arg0
		},
	},
	"widget-pop-up-ptr//content?": {
		Doc:   "Get *widget.PopUp Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//content?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//content?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-pop-up-ptr//create-renderer": {
		Doc:   "(*widget.PopUp).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-pop-up-ptr//hidden!": {
		Doc:   "Set *widget.PopUp Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-pop-up-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-pop-up-ptr//hidden?": {
		Doc:   "Get *widget.PopUp Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-pop-up-ptr//hide": {
		Doc:   "(*widget.PopUp).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"widget-pop-up-ptr//min-size": {
		Doc:   "(*widget.PopUp).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-pop-up-ptr//move": {
		Doc:   "(*widget.PopUp).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"widget-pop-up-ptr//resize": {
		Doc:   "(*widget.PopUp).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"widget-pop-up-ptr//show": {
		Doc:   "(*widget.PopUp).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"widget-pop-up-ptr//show-at-position": {
		Doc:   "(*widget.PopUp).ShowAtPosition",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-position")
			}
			arg0Val.ShowAtPosition(arg1Val)
			return arg0
		},
	},
	"widget-pop-up-ptr//show-at-relative-position": {
		Doc:   "(*widget.PopUp).ShowAtRelativePosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-relative-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-relative-position")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-relative-position")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-relative-position")
			}
			var arg2Val fyne.CanvasObject
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-relative-position")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-pop-up-ptr//show-at-relative-position")
			}
			arg0Val.ShowAtRelativePosition(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-pop-up-ptr//tapped": {
		Doc:   "(*widget.PopUp).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"widget-pop-up-ptr//tapped-secondary": {
		Doc:   "(*widget.PopUp).TappedSecondary",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped-secondary")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped-secondary")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped-secondary")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped-secondary")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up-ptr//tapped-secondary")
			}
			arg0Val.TappedSecondary(arg1Val)
			return arg0
		},
	},
	"widget-pop-up//canvas!": {
		Doc:   "Set widget.PopUp Canvas value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//canvas!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//canvas!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Canvas, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up//canvas!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up//canvas!")
				}
				self.Canvas = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up//canvas!")
			}
			return arg0
		},
	},
	"widget-pop-up//canvas?": {
		Doc:   "Get widget.PopUp Canvas value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//canvas?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//canvas?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Canvas, "fyne-canvas")
			return resObj
		},
	},
	"widget-pop-up//content!": {
		Doc:   "Set widget.PopUp Content value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//content!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//content!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Content, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up//content!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up//content!")
				}
				self.Content = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-pop-up//content!")
			}
			return arg0
		},
	},
	"widget-pop-up//content?": {
		Doc:   "Get widget.PopUp Content value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//content?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//content?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Content, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-pop-up//hidden!": {
		Doc:   "Set widget.PopUp Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-pop-up//hidden!")
			}
			return arg0
		},
	},
	"widget-pop-up//hidden?": {
		Doc:   "Get widget.PopUp Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.PopUp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.PopUp)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-pop-up//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-progress-bar": {
		Doc:   "widget.NewProgressBar",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewProgressBar()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-progress-bar-ptr")
			return res0Obj
		},
	},
	"widget-progress-bar-infinite": {
		Doc:   "widget.NewProgressBarInfinite",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewProgressBarInfinite()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-progress-bar-infinite-ptr")
			return res0Obj
		},
	},
	"widget-progress-bar-infinite-ptr//create-renderer": {
		Doc:   "(*widget.ProgressBarInfinite).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-progress-bar-infinite-ptr//hidden!": {
		Doc:   "Set *widget.ProgressBarInfinite Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-progress-bar-infinite-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-progress-bar-infinite-ptr//hidden?": {
		Doc:   "Get *widget.ProgressBarInfinite Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-progress-bar-infinite-ptr//hide": {
		Doc:   "(*widget.ProgressBarInfinite).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"widget-progress-bar-infinite-ptr//min-size": {
		Doc:   "(*widget.ProgressBarInfinite).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-progress-bar-infinite-ptr//running": {
		Doc:   "(*widget.ProgressBarInfinite).Running",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//running")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//running")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//running")
			}
			res0 := arg0Val.Running()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-progress-bar-infinite-ptr//show": {
		Doc:   "(*widget.ProgressBarInfinite).Show",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//show")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//show")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//show")
			}
			arg0Val.Show()
			return arg0
		},
	},
	"widget-progress-bar-infinite-ptr//start": {
		Doc:   "(*widget.ProgressBarInfinite).Start",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//start")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//start")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//start")
			}
			arg0Val.Start()
			return arg0
		},
	},
	"widget-progress-bar-infinite-ptr//stop": {
		Doc:   "(*widget.ProgressBarInfinite).Stop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//stop")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//stop")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite-ptr//stop")
			}
			arg0Val.Stop()
			return arg0
		},
	},
	"widget-progress-bar-infinite//hidden!": {
		Doc:   "Set widget.ProgressBarInfinite Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-progress-bar-infinite//hidden!")
			}
			return arg0
		},
	},
	"widget-progress-bar-infinite//hidden?": {
		Doc:   "Get widget.ProgressBarInfinite Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBarInfinite
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBarInfinite)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-infinite//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-progress-bar-ptr//bind": {
		Doc:   "(*widget.ProgressBar).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//bind")
			}
			var arg1Val binding.Float
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-progress-bar-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-progress-bar-ptr//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-progress-bar-ptr//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"widget-progress-bar-ptr//create-renderer": {
		Doc:   "(*widget.ProgressBar).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-progress-bar-ptr//hidden!": {
		Doc:   "Set *widget.ProgressBar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-progress-bar-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-progress-bar-ptr//hidden?": {
		Doc:   "Get *widget.ProgressBar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-progress-bar-ptr//max!": {
		Doc:   "Set *widget.ProgressBar Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//max!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//max!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//max!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-progress-bar-ptr//max!")
			}
			return arg0
		},
	},
	"widget-progress-bar-ptr//max?": {
		Doc:   "Get *widget.ProgressBar Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//max?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//max?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//max?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"widget-progress-bar-ptr//min!": {
		Doc:   "Set *widget.ProgressBar Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//min!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//min!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//min!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-progress-bar-ptr//min!")
			}
			return arg0
		},
	},
	"widget-progress-bar-ptr//min-size": {
		Doc:   "(*widget.ProgressBar).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-progress-bar-ptr//min?": {
		Doc:   "Get *widget.ProgressBar Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//min?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//min?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//min?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"widget-progress-bar-ptr//set-value": {
		Doc:   "(*widget.ProgressBar).SetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//set-value")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-progress-bar-ptr//set-value")
			}
			arg0Val.SetValue(arg1Val)
			return arg0
		},
	},
	"widget-progress-bar-ptr//text-formatter!": {
		Doc:   "Set *widget.ProgressBar TextFormatter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//text-formatter!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//text-formatter!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//text-formatter!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-progress-bar-ptr//text-formatter!")
				}
				self.TextFormatter = func() string {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res string
					if v, ok := ps.Res.(env.String); ok {
						res = string(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-progress-bar-ptr//text-formatter!")
				}
				self.TextFormatter = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-progress-bar-ptr//text-formatter!")
			}
			return arg0
		},
	},
	"widget-progress-bar-ptr//text-formatter?": {
		Doc:   "Get *widget.ProgressBar TextFormatter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//text-formatter?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//text-formatter?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//text-formatter?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextFormatter, "--go-any-func--")
			return resObj
		},
	},
	"widget-progress-bar-ptr//unbind": {
		Doc:   "(*widget.ProgressBar).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"widget-progress-bar-ptr//value!": {
		Doc:   "Set *widget.ProgressBar Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//value!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//value!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//value!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-progress-bar-ptr//value!")
			}
			return arg0
		},
	},
	"widget-progress-bar-ptr//value?": {
		Doc:   "Get *widget.ProgressBar Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//value?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//value?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-ptr//value?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"widget-progress-bar-with-data": {
		Doc:   "widget.NewProgressBarWithData",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val binding.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-with-data")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar-with-data")
			}
			res0 := widget.NewProgressBarWithData(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-progress-bar-ptr")
			return res0Obj
		},
	},
	"widget-progress-bar//hidden!": {
		Doc:   "Set widget.ProgressBar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-progress-bar//hidden!")
			}
			return arg0
		},
	},
	"widget-progress-bar//hidden?": {
		Doc:   "Get widget.ProgressBar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-progress-bar//max!": {
		Doc:   "Set widget.ProgressBar Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//max!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//max!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-progress-bar//max!")
			}
			return arg0
		},
	},
	"widget-progress-bar//max?": {
		Doc:   "Get widget.ProgressBar Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//max?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//max?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"widget-progress-bar//min!": {
		Doc:   "Set widget.ProgressBar Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//min!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//min!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-progress-bar//min!")
			}
			return arg0
		},
	},
	"widget-progress-bar//min?": {
		Doc:   "Get widget.ProgressBar Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//min?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//min?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"widget-progress-bar//text-formatter!": {
		Doc:   "Set widget.ProgressBar TextFormatter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//text-formatter!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//text-formatter!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-progress-bar//text-formatter!")
				}
				self.TextFormatter = func() string {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
					var res string
					if v, ok := ps.Res.(env.String); ok {
						res = string(v.Value)
					} else {
						// TODO: Invalid type
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-progress-bar//text-formatter!")
				}
				self.TextFormatter = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-progress-bar//text-formatter!")
			}
			return arg0
		},
	},
	"widget-progress-bar//text-formatter?": {
		Doc:   "Get widget.ProgressBar TextFormatter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//text-formatter?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//text-formatter?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextFormatter, "--go-any-func--")
			return resObj
		},
	},
	"widget-progress-bar//value!": {
		Doc:   "Set widget.ProgressBar Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//value!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//value!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-progress-bar//value!")
			}
			return arg0
		},
	},
	"widget-progress-bar//value?": {
		Doc:   "Get widget.ProgressBar Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ProgressBar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ProgressBar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//value?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-progress-bar//value?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"widget-radio-group": {
		Doc:   "widget.NewRadioGroup",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group")
			}
			var arg1Val func(string)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-radio-group")
				}
				arg1Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-radio-group")
			}
			res0 := widget.NewRadioGroup(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-radio-group-ptr")
			return res0Obj
		},
	},
	"widget-radio-group-ptr//append": {
		Doc:   "(*widget.RadioGroup).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//append")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-radio-group-ptr//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"widget-radio-group-ptr//create-renderer": {
		Doc:   "(*widget.RadioGroup).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-radio-group-ptr//hidden!": {
		Doc:   "Set *widget.RadioGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-radio-group-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-radio-group-ptr//hidden?": {
		Doc:   "Get *widget.RadioGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-radio-group-ptr//horizontal!": {
		Doc:   "Set *widget.RadioGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//horizontal!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//horizontal!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-radio-group-ptr//horizontal!")
			}
			return arg0
		},
	},
	"widget-radio-group-ptr//horizontal?": {
		Doc:   "Get *widget.RadioGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//horizontal?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//horizontal?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"widget-radio-group-ptr//min-size": {
		Doc:   "(*widget.RadioGroup).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-radio-group-ptr//on-changed!": {
		Doc:   "Set *widget.RadioGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-radio-group-ptr//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group-ptr//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-radio-group-ptr//on-changed!")
			}
			return arg0
		},
	},
	"widget-radio-group-ptr//on-changed?": {
		Doc:   "Get *widget.RadioGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-radio-group-ptr//options!": {
		Doc:   "Set *widget.RadioGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//options!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group-ptr//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group-ptr//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group-ptr//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group-ptr//options!")
			}
			return arg0
		},
	},
	"widget-radio-group-ptr//options?": {
		Doc:   "Get *widget.RadioGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//options?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//options?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//options?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Options, "string-arr")
			return resObj
		},
	},
	"widget-radio-group-ptr//refresh": {
		Doc:   "(*widget.RadioGroup).Refresh",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//refresh")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//refresh")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//refresh")
			}
			arg0Val.Refresh()
			return arg0
		},
	},
	"widget-radio-group-ptr//required!": {
		Doc:   "Set *widget.RadioGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//required!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//required!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//required!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-radio-group-ptr//required!")
			}
			return arg0
		},
	},
	"widget-radio-group-ptr//required?": {
		Doc:   "Get *widget.RadioGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//required?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//required?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//required?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"widget-radio-group-ptr//selected!": {
		Doc:   "Set *widget.RadioGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//selected!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-radio-group-ptr//selected!")
			}
			return arg0
		},
	},
	"widget-radio-group-ptr//selected?": {
		Doc:   "Get *widget.RadioGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//selected?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"widget-radio-group-ptr//set-selected": {
		Doc:   "(*widget.RadioGroup).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//set-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group-ptr//set-selected")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-radio-group-ptr//set-selected")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"widget-radio-group//hidden!": {
		Doc:   "Set widget.RadioGroup Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-radio-group//hidden!")
			}
			return arg0
		},
	},
	"widget-radio-group//hidden?": {
		Doc:   "Get widget.RadioGroup Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-radio-group//horizontal!": {
		Doc:   "Set widget.RadioGroup Horizontal value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//horizontal!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//horizontal!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Horizontal = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-radio-group//horizontal!")
			}
			return arg0
		},
	},
	"widget-radio-group//horizontal?": {
		Doc:   "Get widget.RadioGroup Horizontal value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//horizontal?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//horizontal?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Horizontal))
			return resObj
		},
	},
	"widget-radio-group//on-changed!": {
		Doc:   "Set widget.RadioGroup OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-radio-group//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-radio-group//on-changed!")
			}
			return arg0
		},
	},
	"widget-radio-group//on-changed?": {
		Doc:   "Get widget.RadioGroup OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-radio-group//options!": {
		Doc:   "Set widget.RadioGroup Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//options!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-radio-group//options!")
			}
			return arg0
		},
	},
	"widget-radio-group//options?": {
		Doc:   "Get widget.RadioGroup Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//options?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//options?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Options, "string-arr")
			return resObj
		},
	},
	"widget-radio-group//required!": {
		Doc:   "Set widget.RadioGroup Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//required!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//required!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Required = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-radio-group//required!")
			}
			return arg0
		},
	},
	"widget-radio-group//required?": {
		Doc:   "Get widget.RadioGroup Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//required?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//required?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Required))
			return resObj
		},
	},
	"widget-radio-group//selected!": {
		Doc:   "Set widget.RadioGroup Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//selected!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-radio-group//selected!")
			}
			return arg0
		},
	},
	"widget-radio-group//selected?": {
		Doc:   "Get widget.RadioGroup Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RadioGroup
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RadioGroup)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-radio-group//selected?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"widget-rich-text-from-markdown": {
		Doc:   "widget.NewRichTextFromMarkdown",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-rich-text-from-markdown")
			}
			res0 := widget.NewRichTextFromMarkdown(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-rich-text-ptr")
			return res0Obj
		},
	},
	"widget-rich-text-ptr//parse-markdown": {
		Doc:   "(*widget.RichText).ParseMarkdown",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.RichText
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.RichText)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-ptr//parse-markdown")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-ptr//parse-markdown")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-ptr//parse-markdown")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-rich-text-ptr//parse-markdown")
			}
			arg0Val.ParseMarkdown(arg1Val)
			return arg0
		},
	},
	"widget-rich-text-segment//inline": {
		Doc:   "widget.RichTextSegment.Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-rich-text-segment//select": {
		Doc:   "widget.RichTextSegment.Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-segment//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-rich-text-segment//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-rich-text-segment//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-rich-text-segment//selected-text": {
		Doc:   "widget.RichTextSegment.SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-rich-text-segment//textual": {
		Doc:   "widget.RichTextSegment.Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-rich-text-segment//unselect": {
		Doc:   "widget.RichTextSegment.Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"widget-rich-text-segment//update": {
		Doc:   "widget.RichTextSegment.Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-segment//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-segment//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-segment//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"widget-rich-text-segment//visual": {
		Doc:   "widget.RichTextSegment.Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.RichTextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.RichTextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-segment//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-rich-text-style-ptr//alignment!": {
		Doc:   "Set *widget.RichTextStyle Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//alignment!")
			}
			return arg0
		},
	},
	"widget-rich-text-style-ptr//alignment?": {
		Doc:   "Get *widget.RichTextStyle Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-rich-text-style-ptr//color-name!": {
		Doc:   "Set *widget.RichTextStyle ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//color-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//color-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//color-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorName, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//color-name!")
			}
			return arg0
		},
	},
	"widget-rich-text-style-ptr//color-name?": {
		Doc:   "Get *widget.RichTextStyle ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//color-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//color-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//color-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorName, "fyne-theme-color-name")
			return resObj
		},
	},
	"widget-rich-text-style-ptr//inline!": {
		Doc:   "Set *widget.RichTextStyle Inline value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//inline!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//inline!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//inline!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Inline = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-rich-text-style-ptr//inline!")
			}
			return arg0
		},
	},
	"widget-rich-text-style-ptr//inline?": {
		Doc:   "Get *widget.RichTextStyle Inline value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//inline?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//inline?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//inline?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Inline))
			return resObj
		},
	},
	"widget-rich-text-style-ptr//size-name!": {
		Doc:   "Set *widget.RichTextStyle SizeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//size-name!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//size-name!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//size-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.SizeName, ok = v.Value.(fyne.ThemeSizeName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//size-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//size-name!")
			}
			return arg0
		},
	},
	"widget-rich-text-style-ptr//size-name?": {
		Doc:   "Get *widget.RichTextStyle SizeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//size-name?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//size-name?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//size-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SizeName, "fyne-theme-size-name")
			return resObj
		},
	},
	"widget-rich-text-style-ptr//text-style!": {
		Doc:   "Set *widget.RichTextStyle TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//text-style!")
			}
			return arg0
		},
	},
	"widget-rich-text-style-ptr//text-style?": {
		Doc:   "Get *widget.RichTextStyle TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style-ptr//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-rich-text-style//alignment!": {
		Doc:   "Set widget.RichTextStyle Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style//alignment!")
			}
			return arg0
		},
	},
	"widget-rich-text-style//alignment?": {
		Doc:   "Get widget.RichTextStyle Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-rich-text-style//color-name!": {
		Doc:   "Set widget.RichTextStyle ColorName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//color-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ColorName, ok = v.Value.(fyne.ThemeColorName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style//color-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style//color-name!")
			}
			return arg0
		},
	},
	"widget-rich-text-style//color-name?": {
		Doc:   "Get widget.RichTextStyle ColorName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//color-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//color-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ColorName, "fyne-theme-color-name")
			return resObj
		},
	},
	"widget-rich-text-style//inline!": {
		Doc:   "Set widget.RichTextStyle Inline value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//inline!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//inline!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Inline = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-rich-text-style//inline!")
			}
			return arg0
		},
	},
	"widget-rich-text-style//inline?": {
		Doc:   "Get widget.RichTextStyle Inline value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//inline?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//inline?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Inline))
			return resObj
		},
	},
	"widget-rich-text-style//size-name!": {
		Doc:   "Set widget.RichTextStyle SizeName value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//size-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//size-name!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.SizeName, ok = v.Value.(fyne.ThemeSizeName)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style//size-name!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style//size-name!")
			}
			return arg0
		},
	},
	"widget-rich-text-style//size-name?": {
		Doc:   "Get widget.RichTextStyle SizeName value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//size-name?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//size-name?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SizeName, "fyne-theme-size-name")
			return resObj
		},
	},
	"widget-rich-text-style//text-style!": {
		Doc:   "Set widget.RichTextStyle TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-rich-text-style//text-style!")
			}
			return arg0
		},
	},
	"widget-rich-text-style//text-style?": {
		Doc:   "Get widget.RichTextStyle TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.RichTextStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-rich-text-style//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-select": {
		Doc:   "widget.NewSelect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-select")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-select")
			}
			var arg1Val func(string)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select")
				}
				arg1Val = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select")
			}
			res0 := widget.NewSelect(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-select-ptr")
			return res0Obj
		},
	},
	"widget-select-entry": {
		Doc:   "widget.NewSelectEntry",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []string
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg0Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry")
			}
			res0 := widget.NewSelectEntry(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-select-entry-ptr")
			return res0Obj
		},
	},
	"widget-select-entry-ptr//action-item!": {
		Doc:   "Set *widget.SelectEntry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//action-item!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//action-item!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//action-item!")
				}
				self.ActionItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//action-item!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//action-item?": {
		Doc:   "Get *widget.SelectEntry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//action-item?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//action-item?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//action-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ActionItem, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-select-entry-ptr//create-renderer": {
		Doc:   "(*widget.SelectEntry).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-select-entry-ptr//cursor-column!": {
		Doc:   "Set *widget.SelectEntry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-column!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-column!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry-ptr//cursor-column!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//cursor-column?": {
		Doc:   "Get *widget.SelectEntry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-column?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-column?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"widget-select-entry-ptr//cursor-row!": {
		Doc:   "Set *widget.SelectEntry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-row!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-row!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry-ptr//cursor-row!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//cursor-row?": {
		Doc:   "Get *widget.SelectEntry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-row?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-row?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//cursor-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"widget-select-entry-ptr//disable": {
		Doc:   "(*widget.SelectEntry).Disable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//disable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//disable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//disable")
			}
			arg0Val.Disable()
			return arg0
		},
	},
	"widget-select-entry-ptr//enable": {
		Doc:   "(*widget.SelectEntry).Enable",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//enable")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//enable")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//enable")
			}
			arg0Val.Enable()
			return arg0
		},
	},
	"widget-select-entry-ptr//hidden!": {
		Doc:   "Set *widget.SelectEntry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//hidden?": {
		Doc:   "Get *widget.SelectEntry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-select-entry-ptr//min-size": {
		Doc:   "(*widget.SelectEntry).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-select-entry-ptr//move": {
		Doc:   "(*widget.SelectEntry).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"widget-select-entry-ptr//multi-line!": {
		Doc:   "Set *widget.SelectEntry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//multi-line!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//multi-line!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//multi-line!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry-ptr//multi-line!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//multi-line?": {
		Doc:   "Get *widget.SelectEntry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//multi-line?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//multi-line?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//multi-line?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"widget-select-entry-ptr//on-changed!": {
		Doc:   "Set *widget.SelectEntry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry-ptr//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry-ptr//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry-ptr//on-changed!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//on-changed?": {
		Doc:   "Get *widget.SelectEntry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-select-entry-ptr//on-cursor-changed!": {
		Doc:   "Set *widget.SelectEntry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-cursor-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-cursor-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-cursor-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry-ptr//on-cursor-changed!")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry-ptr//on-cursor-changed!")
				}
				self.OnCursorChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry-ptr//on-cursor-changed!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//on-cursor-changed?": {
		Doc:   "Get *widget.SelectEntry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-cursor-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-cursor-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-cursor-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-select-entry-ptr//on-submitted!": {
		Doc:   "Set *widget.SelectEntry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-submitted!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-submitted!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-submitted!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry-ptr//on-submitted!")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry-ptr//on-submitted!")
				}
				self.OnSubmitted = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry-ptr//on-submitted!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//on-submitted?": {
		Doc:   "Get *widget.SelectEntry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-submitted?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-submitted?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//on-submitted?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "--go-any-func--")
			return resObj
		},
	},
	"widget-select-entry-ptr//password!": {
		Doc:   "Set *widget.SelectEntry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//password!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//password!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//password!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry-ptr//password!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//password?": {
		Doc:   "Get *widget.SelectEntry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//password?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//password?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//password?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"widget-select-entry-ptr//place-holder!": {
		Doc:   "Set *widget.SelectEntry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//place-holder!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//place-holder!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-select-entry-ptr//place-holder!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//place-holder?": {
		Doc:   "Get *widget.SelectEntry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//place-holder?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//place-holder?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"widget-select-entry-ptr//resize": {
		Doc:   "(*widget.SelectEntry).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"widget-select-entry-ptr//scroll!": {
		Doc:   "Set *widget.SelectEntry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//scroll!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//scroll!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//scroll!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//scroll?": {
		Doc:   "Get *widget.SelectEntry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//scroll?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//scroll?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "container-scroll-direction")
			return resObj
		},
	},
	"widget-select-entry-ptr//set-options": {
		Doc:   "(*widget.SelectEntry).SetOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//set-options")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//set-options")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//set-options")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry-ptr//set-options")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry-ptr//set-options")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry-ptr//set-options")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry-ptr//set-options")
			}
			arg0Val.SetOptions(arg1Val)
			return arg0
		},
	},
	"widget-select-entry-ptr//text!": {
		Doc:   "Set *widget.SelectEntry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-select-entry-ptr//text!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//text-style!": {
		Doc:   "Set *widget.SelectEntry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text-style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text-style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//text-style!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//text-style?": {
		Doc:   "Get *widget.SelectEntry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text-style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text-style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-select-entry-ptr//text?": {
		Doc:   "Get *widget.SelectEntry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-select-entry-ptr//validator!": {
		Doc:   "Set *widget.SelectEntry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//validator!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//validator!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//validator!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Validator, ok = v.Value.(fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//validator!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//validator?": {
		Doc:   "Get *widget.SelectEntry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//validator?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//validator?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//validator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Validator, "fyne-string-validator")
			return resObj
		},
	},
	"widget-select-entry-ptr//wrapping!": {
		Doc:   "Set *widget.SelectEntry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//wrapping!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//wrapping!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry-ptr//wrapping!")
			}
			return arg0
		},
	},
	"widget-select-entry-ptr//wrapping?": {
		Doc:   "Get *widget.SelectEntry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//wrapping?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//wrapping?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry-ptr//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "fyne-text-wrap")
			return resObj
		},
	},
	"widget-select-entry//action-item!": {
		Doc:   "Set widget.SelectEntry ActionItem value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//action-item!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//action-item!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.ActionItem, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//action-item!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//action-item!")
				}
				self.ActionItem = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//action-item!")
			}
			return arg0
		},
	},
	"widget-select-entry//action-item?": {
		Doc:   "Get widget.SelectEntry ActionItem value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//action-item?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//action-item?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ActionItem, "fyne-canvas-object")
			return resObj
		},
	},
	"widget-select-entry//cursor-column!": {
		Doc:   "Set widget.SelectEntry CursorColumn value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//cursor-column!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//cursor-column!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorColumn = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry//cursor-column!")
			}
			return arg0
		},
	},
	"widget-select-entry//cursor-column?": {
		Doc:   "Get widget.SelectEntry CursorColumn value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//cursor-column?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//cursor-column?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorColumn))
			return resObj
		},
	},
	"widget-select-entry//cursor-row!": {
		Doc:   "Set widget.SelectEntry CursorRow value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//cursor-row!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//cursor-row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.CursorRow = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry//cursor-row!")
			}
			return arg0
		},
	},
	"widget-select-entry//cursor-row?": {
		Doc:   "Get widget.SelectEntry CursorRow value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//cursor-row?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//cursor-row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.CursorRow))
			return resObj
		},
	},
	"widget-select-entry//hidden!": {
		Doc:   "Set widget.SelectEntry Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry//hidden!")
			}
			return arg0
		},
	},
	"widget-select-entry//hidden?": {
		Doc:   "Get widget.SelectEntry Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-select-entry//multi-line!": {
		Doc:   "Set widget.SelectEntry MultiLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//multi-line!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//multi-line!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.MultiLine = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry//multi-line!")
			}
			return arg0
		},
	},
	"widget-select-entry//multi-line?": {
		Doc:   "Get widget.SelectEntry MultiLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//multi-line?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//multi-line?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.MultiLine))
			return resObj
		},
	},
	"widget-select-entry//on-changed!": {
		Doc:   "Set widget.SelectEntry OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry//on-changed!")
			}
			return arg0
		},
	},
	"widget-select-entry//on-changed?": {
		Doc:   "Get widget.SelectEntry OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-select-entry//on-cursor-changed!": {
		Doc:   "Set widget.SelectEntry OnCursorChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-cursor-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-cursor-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry//on-cursor-changed!")
				}
				self.OnCursorChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry//on-cursor-changed!")
			}
			return arg0
		},
	},
	"widget-select-entry//on-cursor-changed?": {
		Doc:   "Get widget.SelectEntry OnCursorChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-cursor-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-cursor-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnCursorChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-select-entry//on-submitted!": {
		Doc:   "Set widget.SelectEntry OnSubmitted value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-submitted!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-submitted!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry//on-submitted!")
				}
				self.OnSubmitted = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-entry//on-submitted!")
				}
				self.OnSubmitted = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-entry//on-submitted!")
			}
			return arg0
		},
	},
	"widget-select-entry//on-submitted?": {
		Doc:   "Get widget.SelectEntry OnSubmitted value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-submitted?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//on-submitted?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnSubmitted, "--go-any-func--")
			return resObj
		},
	},
	"widget-select-entry//password!": {
		Doc:   "Set widget.SelectEntry Password value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//password!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//password!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Password = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-entry//password!")
			}
			return arg0
		},
	},
	"widget-select-entry//password?": {
		Doc:   "Get widget.SelectEntry Password value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//password?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//password?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Password))
			return resObj
		},
	},
	"widget-select-entry//place-holder!": {
		Doc:   "Set widget.SelectEntry PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//place-holder!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-select-entry//place-holder!")
			}
			return arg0
		},
	},
	"widget-select-entry//place-holder?": {
		Doc:   "Get widget.SelectEntry PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//place-holder?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"widget-select-entry//scroll!": {
		Doc:   "Set widget.SelectEntry Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//scroll!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Scroll, ok = v.Value.(container.ScrollDirection)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//scroll!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//scroll!")
			}
			return arg0
		},
	},
	"widget-select-entry//scroll?": {
		Doc:   "Get widget.SelectEntry Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//scroll?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//scroll?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scroll, "container-scroll-direction")
			return resObj
		},
	},
	"widget-select-entry//text!": {
		Doc:   "Set widget.SelectEntry Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-select-entry//text!")
			}
			return arg0
		},
	},
	"widget-select-entry//text-style!": {
		Doc:   "Set widget.SelectEntry TextStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//text-style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.TextStyle, ok = v.Value.(fyne.TextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//text-style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//text-style!")
			}
			return arg0
		},
	},
	"widget-select-entry//text-style?": {
		Doc:   "Get widget.SelectEntry TextStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//text-style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//text-style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextStyle, "fyne-text-style")
			return resObj
		},
	},
	"widget-select-entry//text?": {
		Doc:   "Get widget.SelectEntry Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-select-entry//validator!": {
		Doc:   "Set widget.SelectEntry Validator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//validator!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Validator, ok = v.Value.(fyne.StringValidator)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//validator!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//validator!")
			}
			return arg0
		},
	},
	"widget-select-entry//validator?": {
		Doc:   "Get widget.SelectEntry Validator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//validator?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//validator?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Validator, "fyne-string-validator")
			return resObj
		},
	},
	"widget-select-entry//wrapping!": {
		Doc:   "Set widget.SelectEntry Wrapping value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//wrapping!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Wrapping, ok = v.Value.(fyne.TextWrap)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//wrapping!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-entry//wrapping!")
			}
			return arg0
		},
	},
	"widget-select-entry//wrapping?": {
		Doc:   "Get widget.SelectEntry Wrapping value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.SelectEntry
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.SelectEntry)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//wrapping?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-entry//wrapping?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Wrapping, "fyne-text-wrap")
			return resObj
		},
	},
	"widget-select-ptr//alignment!": {
		Doc:   "Set *widget.Select Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//alignment!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//alignment!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//alignment!")
			}
			return arg0
		},
	},
	"widget-select-ptr//alignment?": {
		Doc:   "Get *widget.Select Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//alignment?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//alignment?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-select-ptr//clear-selected": {
		Doc:   "(*widget.Select).ClearSelected",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//clear-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//clear-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//clear-selected")
			}
			arg0Val.ClearSelected()
			return arg0
		},
	},
	"widget-select-ptr//create-renderer": {
		Doc:   "(*widget.Select).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-select-ptr//focus-gained": {
		Doc:   "(*widget.Select).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"widget-select-ptr//focus-lost": {
		Doc:   "(*widget.Select).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"widget-select-ptr//hidden!": {
		Doc:   "Set *widget.Select Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-select-ptr//hidden?": {
		Doc:   "Get *widget.Select Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-select-ptr//hide": {
		Doc:   "(*widget.Select).Hide",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//hide")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//hide")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//hide")
			}
			arg0Val.Hide()
			return arg0
		},
	},
	"widget-select-ptr//min-size": {
		Doc:   "(*widget.Select).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-select-ptr//mouse-in": {
		Doc:   "(*widget.Select).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"widget-select-ptr//mouse-moved": {
		Doc:   "(*widget.Select).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"widget-select-ptr//mouse-out": {
		Doc:   "(*widget.Select).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"widget-select-ptr//move": {
		Doc:   "(*widget.Select).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//move")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//move")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//move")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//move")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//move")
			}
			arg0Val.Move(arg1Val)
			return arg0
		},
	},
	"widget-select-ptr//on-changed!": {
		Doc:   "Set *widget.Select OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-ptr//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-ptr//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select-ptr//on-changed!")
			}
			return arg0
		},
	},
	"widget-select-ptr//on-changed?": {
		Doc:   "Get *widget.Select OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-select-ptr//options!": {
		Doc:   "Set *widget.Select Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//options!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-ptr//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-ptr//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-ptr//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-ptr//options!")
			}
			return arg0
		},
	},
	"widget-select-ptr//options?": {
		Doc:   "Get *widget.Select Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//options?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//options?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//options?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Options, "string-arr")
			return resObj
		},
	},
	"widget-select-ptr//place-holder!": {
		Doc:   "Set *widget.Select PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//place-holder!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//place-holder!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-select-ptr//place-holder!")
			}
			return arg0
		},
	},
	"widget-select-ptr//place-holder?": {
		Doc:   "Get *widget.Select PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//place-holder?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//place-holder?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"widget-select-ptr//resize": {
		Doc:   "(*widget.Select).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"widget-select-ptr//selected!": {
		Doc:   "Set *widget.Select Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//selected!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//selected!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//selected!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-select-ptr//selected!")
			}
			return arg0
		},
	},
	"widget-select-ptr//selected-index": {
		Doc:   "(*widget.Select).SelectedIndex",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//selected-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//selected-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//selected-index")
			}
			res0 := arg0Val.SelectedIndex()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"widget-select-ptr//selected?": {
		Doc:   "Get *widget.Select Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//selected?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//selected?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//selected?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"widget-select-ptr//set-options": {
		Doc:   "(*widget.Select).SetOptions",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//set-options")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//set-options")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//set-options")
			}
			var arg1Val []string
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						arg1Val[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-ptr//set-options")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-ptr//set-options")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-ptr//set-options")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select-ptr//set-options")
			}
			arg0Val.SetOptions(arg1Val)
			return arg0
		},
	},
	"widget-select-ptr//set-selected": {
		Doc:   "(*widget.Select).SetSelected",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//set-selected")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//set-selected")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//set-selected")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-select-ptr//set-selected")
			}
			arg0Val.SetSelected(arg1Val)
			return arg0
		},
	},
	"widget-select-ptr//set-selected-index": {
		Doc:   "(*widget.Select).SetSelectedIndex",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//set-selected-index")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//set-selected-index")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//set-selected-index")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select-ptr//set-selected-index")
			}
			arg0Val.SetSelectedIndex(arg1Val)
			return arg0
		},
	},
	"widget-select-ptr//tapped": {
		Doc:   "(*widget.Select).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"widget-select-ptr//typed-key": {
		Doc:   "(*widget.Select).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"widget-select-ptr//typed-rune": {
		Doc:   "(*widget.Select).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select-ptr//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select-ptr//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"widget-select//alignment!": {
		Doc:   "Set widget.Select Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//alignment!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Alignment, ok = v.Value.(fyne.TextAlign)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select//alignment!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-select//alignment!")
			}
			return arg0
		},
	},
	"widget-select//alignment?": {
		Doc:   "Get widget.Select Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//alignment?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//alignment?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Alignment, "fyne-text-align")
			return resObj
		},
	},
	"widget-select//hidden!": {
		Doc:   "Set widget.Select Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-select//hidden!")
			}
			return arg0
		},
	},
	"widget-select//hidden?": {
		Doc:   "Get widget.Select Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-select//on-changed!": {
		Doc:   "Set widget.Select OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select//on-changed!")
				}
				self.OnChanged = func(arg0 string) {
					var arg0Val env.Object
					arg0Val = *env.NewString(arg0)
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-select//on-changed!")
			}
			return arg0
		},
	},
	"widget-select//on-changed?": {
		Doc:   "Get widget.Select OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-select//options!": {
		Doc:   "Set widget.Select Options value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//options!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//options!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Options = make([]string, len(v.Series.S))
				for i, it := range v.Series.S {
					if v, ok := it.(env.String); ok {
						self.Options[i] = string(v.Value)
					} else {
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select//options!")
					}
				}
			case env.Native:
				var ok bool
				self.Options, ok = v.Value.([]string)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select//options!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select//options!")
				}
				self.Options = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-select//options!")
			}
			return arg0
		},
	},
	"widget-select//options?": {
		Doc:   "Get widget.Select Options value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//options?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//options?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Options, "string-arr")
			return resObj
		},
	},
	"widget-select//place-holder!": {
		Doc:   "Set widget.Select PlaceHolder value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//place-holder!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//place-holder!")
			}
			if v, ok := arg1.(env.String); ok {
				self.PlaceHolder = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-select//place-holder!")
			}
			return arg0
		},
	},
	"widget-select//place-holder?": {
		Doc:   "Get widget.Select PlaceHolder value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//place-holder?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//place-holder?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.PlaceHolder)
			return resObj
		},
	},
	"widget-select//selected!": {
		Doc:   "Set widget.Select Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//selected!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//selected!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Selected = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-select//selected!")
			}
			return arg0
		},
	},
	"widget-select//selected?": {
		Doc:   "Get widget.Select Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Select
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Select)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//selected?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-select//selected?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Selected)
			return resObj
		},
	},
	"widget-separator": {
		Doc:   "widget.NewSeparator",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewSeparator()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-separator-ptr")
			return res0Obj
		},
	},
	"widget-separator-ptr//create-renderer": {
		Doc:   "(*widget.Separator).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-separator-ptr//hidden!": {
		Doc:   "Set *widget.Separator Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-separator-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-separator-ptr//hidden?": {
		Doc:   "Get *widget.Separator Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-separator-ptr//min-size": {
		Doc:   "(*widget.Separator).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-separator-segment-ptr//inline": {
		Doc:   "(*widget.SeparatorSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-separator-segment-ptr//select": {
		Doc:   "(*widget.SeparatorSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-separator-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-separator-segment-ptr//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-separator-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-separator-segment-ptr//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-separator-segment-ptr//selected-text": {
		Doc:   "(*widget.SeparatorSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-separator-segment-ptr//textual": {
		Doc:   "(*widget.SeparatorSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-separator-segment-ptr//unselect": {
		Doc:   "(*widget.SeparatorSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"widget-separator-segment-ptr//update": {
		Doc:   "(*widget.SeparatorSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-separator-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-separator-segment-ptr//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-separator-segment-ptr//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"widget-separator-segment-ptr//visual": {
		Doc:   "(*widget.SeparatorSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.SeparatorSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.SeparatorSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator-segment-ptr//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-separator//hidden!": {
		Doc:   "Set widget.Separator Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-separator//hidden!")
			}
			return arg0
		},
	},
	"widget-separator//hidden?": {
		Doc:   "Get widget.Separator Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Separator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Separator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-separator//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-show-modal-pop-up": {
		Doc:   "widget.ShowModalPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-modal-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-modal-pop-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-modal-pop-up")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-modal-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-modal-pop-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-modal-pop-up")
			}
			widget.ShowModalPopUp(arg0Val, arg1Val)
			return nil
		},
	},
	"widget-show-pop-up": {
		Doc:   "widget.ShowPopUp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up")
			}
			widget.ShowPopUp(arg0Val, arg1Val)
			return nil
		},
	},
	"widget-show-pop-up-at-position": {
		Doc:   "widget.ShowPopUpAtPosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-at-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-at-position")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-at-position")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-at-position")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-show-pop-up-at-position")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-show-pop-up-at-position")
			}
			widget.ShowPopUpAtPosition(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"widget-show-pop-up-at-relative-position": {
		Doc:   "widget.ShowPopUpAtRelativePosition",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-show-pop-up-at-relative-position")
			}
			widget.ShowPopUpAtRelativePosition(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"widget-show-pop-up-menu-at-position": {
		Doc:   "widget.ShowPopUpMenuAtPosition",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-position")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-position")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-position")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-position")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-position")
			}
			widget.ShowPopUpMenuAtPosition(arg0Val, arg1Val, arg2Val)
			return nil
		},
	},
	"widget-show-pop-up-menu-at-relative-position": {
		Doc:   "widget.ShowPopUpMenuAtRelativePosition",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *fyne.Menu
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*fyne.Menu)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
			}
			var arg1Val fyne.Canvas
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Canvas)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
			}
			var arg3Val fyne.CanvasObject
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-show-pop-up-menu-at-relative-position")
			}
			widget.ShowPopUpMenuAtRelativePosition(arg0Val, arg1Val, arg2Val, arg3Val)
			return nil
		},
	},
	"widget-simple-renderer": {
		Doc:   "widget.NewSimpleRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.CanvasObject
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-simple-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-simple-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-simple-renderer")
			}
			res0 := widget.NewSimpleRenderer(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-slider": {
		Doc:   "widget.NewSlider",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float64
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "widget-slider")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider")
			}
			res0 := widget.NewSlider(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-slider-ptr")
			return res0Obj
		},
	},
	"widget-slider-ptr//bind": {
		Doc:   "(*widget.Slider).Bind",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//bind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//bind")
			}
			var arg1Val binding.Float
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//bind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//bind")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//bind")
			}
			arg0Val.Bind(arg1Val)
			return arg0
		},
	},
	"widget-slider-ptr//create-renderer": {
		Doc:   "(*widget.Slider).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-slider-ptr//drag-end": {
		Doc:   "(*widget.Slider).DragEnd",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//drag-end")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//drag-end")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//drag-end")
			}
			arg0Val.DragEnd()
			return arg0
		},
	},
	"widget-slider-ptr//dragged": {
		Doc:   "(*widget.Slider).Dragged",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//dragged")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//dragged")
			}
			var arg1Val *fyne.DragEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.DragEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//dragged")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//dragged")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//dragged")
			}
			arg0Val.Dragged(arg1Val)
			return arg0
		},
	},
	"widget-slider-ptr//focus-gained": {
		Doc:   "(*widget.Slider).FocusGained",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//focus-gained")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//focus-gained")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//focus-gained")
			}
			arg0Val.FocusGained()
			return arg0
		},
	},
	"widget-slider-ptr//focus-lost": {
		Doc:   "(*widget.Slider).FocusLost",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//focus-lost")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//focus-lost")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//focus-lost")
			}
			arg0Val.FocusLost()
			return arg0
		},
	},
	"widget-slider-ptr//hidden!": {
		Doc:   "Set *widget.Slider Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-slider-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-slider-ptr//hidden?": {
		Doc:   "Get *widget.Slider Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-slider-ptr//max!": {
		Doc:   "Set *widget.Slider Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//max!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//max!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//max!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider-ptr//max!")
			}
			return arg0
		},
	},
	"widget-slider-ptr//max?": {
		Doc:   "Get *widget.Slider Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//max?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//max?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//max?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"widget-slider-ptr//min!": {
		Doc:   "Set *widget.Slider Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//min!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//min!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//min!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider-ptr//min!")
			}
			return arg0
		},
	},
	"widget-slider-ptr//min-size": {
		Doc:   "(*widget.Slider).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-slider-ptr//min?": {
		Doc:   "Get *widget.Slider Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//min?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//min?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//min?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"widget-slider-ptr//mouse-in": {
		Doc:   "(*widget.Slider).MouseIn",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-in")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-in")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-in")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-in")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-in")
			}
			arg0Val.MouseIn(arg1Val)
			return arg0
		},
	},
	"widget-slider-ptr//mouse-moved": {
		Doc:   "(*widget.Slider).MouseMoved",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-moved")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-moved")
			}
			var arg1Val *desktop.MouseEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*desktop.MouseEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-moved")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-moved")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-moved")
			}
			arg0Val.MouseMoved(arg1Val)
			return arg0
		},
	},
	"widget-slider-ptr//mouse-out": {
		Doc:   "(*widget.Slider).MouseOut",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-out")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-out")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//mouse-out")
			}
			arg0Val.MouseOut()
			return arg0
		},
	},
	"widget-slider-ptr//on-change-ended!": {
		Doc:   "Set *widget.Slider OnChangeEnded value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-change-ended!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-change-ended!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-change-ended!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-slider-ptr//on-change-ended!")
				}
				self.OnChangeEnded = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-slider-ptr//on-change-ended!")
				}
				self.OnChangeEnded = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-slider-ptr//on-change-ended!")
			}
			return arg0
		},
	},
	"widget-slider-ptr//on-change-ended?": {
		Doc:   "Get *widget.Slider OnChangeEnded value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-change-ended?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-change-ended?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-change-ended?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChangeEnded, "--go-any-func--")
			return resObj
		},
	},
	"widget-slider-ptr//on-changed!": {
		Doc:   "Set *widget.Slider OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-changed!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-changed!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-slider-ptr//on-changed!")
				}
				self.OnChanged = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-slider-ptr//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-slider-ptr//on-changed!")
			}
			return arg0
		},
	},
	"widget-slider-ptr//on-changed?": {
		Doc:   "Get *widget.Slider OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-changed?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-changed?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-slider-ptr//orientation!": {
		Doc:   "Set *widget.Slider Orientation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//orientation!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//orientation!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//orientation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Orientation, ok = v.Value.(widget.Orientation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//orientation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//orientation!")
			}
			return arg0
		},
	},
	"widget-slider-ptr//orientation?": {
		Doc:   "Get *widget.Slider Orientation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//orientation?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//orientation?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//orientation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Orientation, "widget-orientation")
			return resObj
		},
	},
	"widget-slider-ptr//set-value": {
		Doc:   "(*widget.Slider).SetValue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//set-value")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//set-value")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//set-value")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider-ptr//set-value")
			}
			arg0Val.SetValue(arg1Val)
			return arg0
		},
	},
	"widget-slider-ptr//step!": {
		Doc:   "Set *widget.Slider Step value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//step!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//step!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//step!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Step = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider-ptr//step!")
			}
			return arg0
		},
	},
	"widget-slider-ptr//step?": {
		Doc:   "Get *widget.Slider Step value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//step?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//step?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//step?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Step))
			return resObj
		},
	},
	"widget-slider-ptr//tapped": {
		Doc:   "(*widget.Slider).Tapped",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//tapped")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//tapped")
			}
			var arg1Val *fyne.PointEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.PointEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//tapped")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//tapped")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//tapped")
			}
			arg0Val.Tapped(arg1Val)
			return arg0
		},
	},
	"widget-slider-ptr//typed-key": {
		Doc:   "(*widget.Slider).TypedKey",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//typed-key")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//typed-key")
			}
			var arg1Val *fyne.KeyEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*fyne.KeyEvent)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//typed-key")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//typed-key")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//typed-key")
			}
			arg0Val.TypedKey(arg1Val)
			return arg0
		},
	},
	"widget-slider-ptr//typed-rune": {
		Doc:   "(*widget.Slider).TypedRune",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//typed-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//typed-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//typed-rune")
			}
			var arg1Val rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//typed-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider-ptr//typed-rune")
			}
			arg0Val.TypedRune(arg1Val)
			return arg0
		},
	},
	"widget-slider-ptr//unbind": {
		Doc:   "(*widget.Slider).Unbind",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//unbind")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//unbind")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//unbind")
			}
			arg0Val.Unbind()
			return arg0
		},
	},
	"widget-slider-ptr//value!": {
		Doc:   "Set *widget.Slider Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//value!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//value!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//value!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider-ptr//value!")
			}
			return arg0
		},
	},
	"widget-slider-ptr//value?": {
		Doc:   "Get *widget.Slider Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//value?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//value?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider-ptr//value?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"widget-slider-with-data": {
		Doc:   "widget.NewSliderWithData",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val float64
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.DecimalType}, "widget-slider-with-data")
			}
			var arg1Val float64
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider-with-data")
			}
			var arg2Val binding.Float
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(binding.Float)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-slider-with-data")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-slider-with-data")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-slider-with-data")
			}
			res0 := widget.NewSliderWithData(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-slider-ptr")
			return res0Obj
		},
	},
	"widget-slider//hidden!": {
		Doc:   "Set widget.Slider Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-slider//hidden!")
			}
			return arg0
		},
	},
	"widget-slider//hidden?": {
		Doc:   "Get widget.Slider Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-slider//max!": {
		Doc:   "Set widget.Slider Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//max!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//max!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Max = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider//max!")
			}
			return arg0
		},
	},
	"widget-slider//max?": {
		Doc:   "Get widget.Slider Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//max?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//max?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Max))
			return resObj
		},
	},
	"widget-slider//min!": {
		Doc:   "Set widget.Slider Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//min!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//min!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Min = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider//min!")
			}
			return arg0
		},
	},
	"widget-slider//min?": {
		Doc:   "Get widget.Slider Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//min?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//min?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Min))
			return resObj
		},
	},
	"widget-slider//on-change-ended!": {
		Doc:   "Set widget.Slider OnChangeEnded value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//on-change-ended!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//on-change-ended!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-slider//on-change-ended!")
				}
				self.OnChangeEnded = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-slider//on-change-ended!")
				}
				self.OnChangeEnded = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-slider//on-change-ended!")
			}
			return arg0
		},
	},
	"widget-slider//on-change-ended?": {
		Doc:   "Get widget.Slider OnChangeEnded value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//on-change-ended?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//on-change-ended?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChangeEnded, "--go-any-func--")
			return resObj
		},
	},
	"widget-slider//on-changed!": {
		Doc:   "Set widget.Slider OnChanged value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//on-changed!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//on-changed!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-slider//on-changed!")
				}
				self.OnChanged = func(arg0 float64) {
					var arg0Val env.Object
					arg0Val = *env.NewDecimal(float64(arg0))
					evaldo.CallFunction(fn, ps, arg0Val, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-slider//on-changed!")
				}
				self.OnChanged = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-slider//on-changed!")
			}
			return arg0
		},
	},
	"widget-slider//on-changed?": {
		Doc:   "Get widget.Slider OnChanged value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//on-changed?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//on-changed?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnChanged, "--go-any-func--")
			return resObj
		},
	},
	"widget-slider//orientation!": {
		Doc:   "Set widget.Slider Orientation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//orientation!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//orientation!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Orientation, ok = v.Value.(widget.Orientation)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider//orientation!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-slider//orientation!")
			}
			return arg0
		},
	},
	"widget-slider//orientation?": {
		Doc:   "Get widget.Slider Orientation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//orientation?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//orientation?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Orientation, "widget-orientation")
			return resObj
		},
	},
	"widget-slider//step!": {
		Doc:   "Set widget.Slider Step value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//step!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//step!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Step = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider//step!")
			}
			return arg0
		},
	},
	"widget-slider//step?": {
		Doc:   "Get widget.Slider Step value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//step?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//step?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Step))
			return resObj
		},
	},
	"widget-slider//value!": {
		Doc:   "Set widget.Slider Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//value!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//value!")
			}
			if v, ok := arg1.(env.Decimal); ok {
				self.Value = float64(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.DecimalType}, "widget-slider//value!")
			}
			return arg0
		},
	},
	"widget-slider//value?": {
		Doc:   "Get widget.Slider Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Slider
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Slider)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//value?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-slider//value?")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"widget-table-cell-id-ptr//col!": {
		Doc:   "Set *widget.TableCellID Col value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//col!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//col!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//col!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Col = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-table-cell-id-ptr//col!")
			}
			return arg0
		},
	},
	"widget-table-cell-id-ptr//col?": {
		Doc:   "Get *widget.TableCellID Col value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//col?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//col?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//col?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Col))
			return resObj
		},
	},
	"widget-table-cell-id-ptr//row!": {
		Doc:   "Set *widget.TableCellID Row value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//row!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//row!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Row = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-table-cell-id-ptr//row!")
			}
			return arg0
		},
	},
	"widget-table-cell-id-ptr//row?": {
		Doc:   "Get *widget.TableCellID Row value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//row?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//row?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id-ptr//row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Row))
			return resObj
		},
	},
	"widget-table-cell-id//col!": {
		Doc:   "Set widget.TableCellID Col value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id//col!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id//col!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Col = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-table-cell-id//col!")
			}
			return arg0
		},
	},
	"widget-table-cell-id//col?": {
		Doc:   "Get widget.TableCellID Col value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id//col?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id//col?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Col))
			return resObj
		},
	},
	"widget-table-cell-id//row!": {
		Doc:   "Set widget.TableCellID Row value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id//row!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id//row!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Row = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-table-cell-id//row!")
			}
			return arg0
		},
	},
	"widget-table-cell-id//row?": {
		Doc:   "Get widget.TableCellID Row value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TableCellID
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TableCellID)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id//row?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-table-cell-id//row?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Row))
			return resObj
		},
	},
	"widget-text-grid": {
		Doc:   "widget.NewTextGrid",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewTextGrid()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-text-grid-ptr")
			return res0Obj
		},
	},
	"widget-text-grid-cell-ptr//rune!": {
		Doc:   "Set *widget.TextGridCell Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//rune!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//rune!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//rune!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//rune!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//rune!")
			}
			return arg0
		},
	},
	"widget-text-grid-cell-ptr//rune?": {
		Doc:   "Get *widget.TextGridCell Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//rune?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//rune?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//rune?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"widget-text-grid-cell-ptr//style!": {
		Doc:   "Set *widget.TextGridCell Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//style!")
				}
				self.Style = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//style!")
			}
			return arg0
		},
	},
	"widget-text-grid-cell-ptr//style?": {
		Doc:   "Get *widget.TextGridCell Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell-ptr//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "widget-text-grid-style")
			return resObj
		},
	},
	"widget-text-grid-cell//rune!": {
		Doc:   "Set widget.TextGridCell Rune value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell//rune!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell//rune!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Rune, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell//rune!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell//rune!")
			}
			return arg0
		},
	},
	"widget-text-grid-cell//rune?": {
		Doc:   "Get widget.TextGridCell Rune value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell//rune?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell//rune?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rune, "rune")
			return resObj
		},
	},
	"widget-text-grid-cell//style!": {
		Doc:   "Set widget.TextGridCell Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell//style!")
				}
				self.Style = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-cell//style!")
			}
			return arg0
		},
	},
	"widget-text-grid-cell//style?": {
		Doc:   "Get widget.TextGridCell Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridCell
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell//style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-cell//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "widget-text-grid-style")
			return resObj
		},
	},
	"widget-text-grid-from-string": {
		Doc:   "widget.NewTextGridFromString",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 0, []env.Type{env.StringType}, "widget-text-grid-from-string")
			}
			res0 := widget.NewTextGridFromString(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-text-grid-ptr")
			return res0Obj
		},
	},
	"widget-text-grid-ptr//create-renderer": {
		Doc:   "(*widget.TextGrid).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-text-grid-ptr//hidden!": {
		Doc:   "Set *widget.TextGrid Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-text-grid-ptr//hidden?": {
		Doc:   "Get *widget.TextGrid Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-text-grid-ptr//min-size": {
		Doc:   "(*widget.TextGrid).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-text-grid-ptr//resize": {
		Doc:   "(*widget.TextGrid).Resize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//resize")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//resize")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//resize")
			}
			var arg1Val fyne.Size
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Size)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-ptr//resize")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-ptr//resize")
			}
			arg0Val.Resize(arg1Val)
			return arg0
		},
	},
	"widget-text-grid-ptr//row": {
		Doc:   "(*widget.TextGrid).Row",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//row")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//row")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//row")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//row")
			}
			res0 := arg0Val.Row(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-text-grid-row")
			return res0Obj
		},
	},
	"widget-text-grid-ptr//row-text": {
		Doc:   "(*widget.TextGrid).RowText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//row-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//row-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//row-text")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//row-text")
			}
			res0 := arg0Val.RowText(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-text-grid-ptr//rows!": {
		Doc:   "Set *widget.TextGrid Rows value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//rows!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//rows!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//rows!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Rows = make([]widget.TextGridRow, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Rows[i], ok = v.Value.(widget.TextGridRow)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-ptr//rows!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-ptr//rows!")
					}
				}
			case env.Native:
				var ok bool
				self.Rows, ok = v.Value.([]widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-ptr//rows!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-ptr//rows!")
				}
				self.Rows = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-ptr//rows!")
			}
			return arg0
		},
	},
	"widget-text-grid-ptr//rows?": {
		Doc:   "Get *widget.TextGrid Rows value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//rows?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//rows?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//rows?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rows, "widget-text-grid-row-arr")
			return resObj
		},
	},
	"widget-text-grid-ptr//set-cell": {
		Doc:   "(*widget.TextGrid).SetCell",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-cell")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-cell")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-cell")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//set-cell")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "widget-text-grid-ptr//set-cell")
			}
			var arg3Val widget.TextGridCell
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-cell")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-cell")
			}
			arg0Val.SetCell(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"widget-text-grid-ptr//set-row": {
		Doc:   "(*widget.TextGrid).SetRow",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//set-row")
			}
			var arg2Val widget.TextGridRow
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row")
			}
			arg0Val.SetRow(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-text-grid-ptr//set-row-style": {
		Doc:   "(*widget.TextGrid).SetRowStyle",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row-style")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row-style")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//set-row-style")
			}
			var arg2Val widget.TextGridStyle
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row-style")
				}
				arg2Val = nil
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-row-style")
			}
			arg0Val.SetRowStyle(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-text-grid-ptr//set-rune": {
		Doc:   "(*widget.TextGrid).SetRune",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-rune")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-rune")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-rune")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//set-rune")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "widget-text-grid-ptr//set-rune")
			}
			var arg3Val rune
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(rune)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-rune")
				}
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-rune")
			}
			arg0Val.SetRune(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"widget-text-grid-ptr//set-style": {
		Doc:   "(*widget.TextGrid).SetStyle",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-style")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-style")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//set-style")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 2, []env.Type{env.IntegerType}, "widget-text-grid-ptr//set-style")
			}
			var arg3Val widget.TextGridStyle
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-style")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-style")
				}
				arg3Val = nil
			default:
				return evaldo.MakeArgError(ps, 3, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-style")
			}
			arg0Val.SetStyle(arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"widget-text-grid-ptr//set-text": {
		Doc:   "(*widget.TextGrid).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//set-text")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-text-grid-ptr//set-text")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"widget-text-grid-ptr//show-line-numbers!": {
		Doc:   "Set *widget.TextGrid ShowLineNumbers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-line-numbers!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-line-numbers!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-line-numbers!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowLineNumbers = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//show-line-numbers!")
			}
			return arg0
		},
	},
	"widget-text-grid-ptr//show-line-numbers?": {
		Doc:   "Get *widget.TextGrid ShowLineNumbers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-line-numbers?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-line-numbers?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-line-numbers?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowLineNumbers))
			return resObj
		},
	},
	"widget-text-grid-ptr//show-whitespace!": {
		Doc:   "Set *widget.TextGrid ShowWhitespace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-whitespace!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-whitespace!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-whitespace!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowWhitespace = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//show-whitespace!")
			}
			return arg0
		},
	},
	"widget-text-grid-ptr//show-whitespace?": {
		Doc:   "Get *widget.TextGrid ShowWhitespace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-whitespace?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-whitespace?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//show-whitespace?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowWhitespace))
			return resObj
		},
	},
	"widget-text-grid-ptr//tab-width!": {
		Doc:   "Set *widget.TextGrid TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//tab-width!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//tab-width!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//tab-width!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid-ptr//tab-width!")
			}
			return arg0
		},
	},
	"widget-text-grid-ptr//tab-width?": {
		Doc:   "Get *widget.TextGrid TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//tab-width?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//tab-width?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//tab-width?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"widget-text-grid-ptr//text": {
		Doc:   "(*widget.TextGrid).Text",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-ptr//text")
			}
			res0 := arg0Val.Text()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-text-grid-row-ptr//cells!": {
		Doc:   "Set *widget.TextGridRow Cells value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//cells!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//cells!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//cells!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cells = make([]widget.TextGridCell, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Cells[i], ok = v.Value.(widget.TextGridCell)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row-ptr//cells!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row-ptr//cells!")
					}
				}
			case env.Native:
				var ok bool
				self.Cells, ok = v.Value.([]widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row-ptr//cells!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row-ptr//cells!")
				}
				self.Cells = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row-ptr//cells!")
			}
			return arg0
		},
	},
	"widget-text-grid-row-ptr//cells?": {
		Doc:   "Get *widget.TextGridRow Cells value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//cells?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//cells?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//cells?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Cells, "widget-text-grid-cell-arr")
			return resObj
		},
	},
	"widget-text-grid-row-ptr//style!": {
		Doc:   "Set *widget.TextGridRow Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//style!")
				}
				self.Style = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//style!")
			}
			return arg0
		},
	},
	"widget-text-grid-row-ptr//style?": {
		Doc:   "Get *widget.TextGridRow Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row-ptr//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "widget-text-grid-style")
			return resObj
		},
	},
	"widget-text-grid-row//cells!": {
		Doc:   "Set widget.TextGridRow Cells value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row//cells!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row//cells!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Cells = make([]widget.TextGridCell, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Cells[i], ok = v.Value.(widget.TextGridCell)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row//cells!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row//cells!")
					}
				}
			case env.Native:
				var ok bool
				self.Cells, ok = v.Value.([]widget.TextGridCell)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row//cells!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row//cells!")
				}
				self.Cells = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid-row//cells!")
			}
			return arg0
		},
	},
	"widget-text-grid-row//cells?": {
		Doc:   "Get widget.TextGridRow Cells value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row//cells?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row//cells?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Cells, "widget-text-grid-cell-arr")
			return resObj
		},
	},
	"widget-text-grid-row//style!": {
		Doc:   "Set widget.TextGridRow Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-row//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-row//style!")
				}
				self.Style = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-grid-row//style!")
			}
			return arg0
		},
	},
	"widget-text-grid-row//style?": {
		Doc:   "Get widget.TextGridRow Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGridRow
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row//style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-row//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "widget-text-grid-style")
			return resObj
		},
	},
	"widget-text-grid-style//background-color": {
		Doc:   "widget.TextGridStyle.BackgroundColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.TextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-style//background-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-style//background-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-style//background-color")
			}
			res0 := arg0Val.BackgroundColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"widget-text-grid-style//text-color": {
		Doc:   "widget.TextGridStyle.TextColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.TextGridStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.TextGridStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-style//text-color")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-style//text-color")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid-style//text-color")
			}
			res0 := arg0Val.TextColor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "color-color")
			return res0Obj
		},
	},
	"widget-text-grid//hidden!": {
		Doc:   "Set widget.TextGrid Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid//hidden!")
			}
			return arg0
		},
	},
	"widget-text-grid//hidden?": {
		Doc:   "Get widget.TextGrid Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-text-grid//rows!": {
		Doc:   "Set widget.TextGrid Rows value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//rows!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//rows!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Rows = make([]widget.TextGridRow, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Rows[i], ok = v.Value.(widget.TextGridRow)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid//rows!")
						}
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid//rows!")
					}
				}
			case env.Native:
				var ok bool
				self.Rows, ok = v.Value.([]widget.TextGridRow)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid//rows!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid//rows!")
				}
				self.Rows = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-text-grid//rows!")
			}
			return arg0
		},
	},
	"widget-text-grid//rows?": {
		Doc:   "Get widget.TextGrid Rows value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//rows?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//rows?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rows, "widget-text-grid-row-arr")
			return resObj
		},
	},
	"widget-text-grid//show-line-numbers!": {
		Doc:   "Set widget.TextGrid ShowLineNumbers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//show-line-numbers!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//show-line-numbers!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowLineNumbers = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid//show-line-numbers!")
			}
			return arg0
		},
	},
	"widget-text-grid//show-line-numbers?": {
		Doc:   "Get widget.TextGrid ShowLineNumbers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//show-line-numbers?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//show-line-numbers?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowLineNumbers))
			return resObj
		},
	},
	"widget-text-grid//show-whitespace!": {
		Doc:   "Set widget.TextGrid ShowWhitespace value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//show-whitespace!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//show-whitespace!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.ShowWhitespace = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid//show-whitespace!")
			}
			return arg0
		},
	},
	"widget-text-grid//show-whitespace?": {
		Doc:   "Get widget.TextGrid ShowWhitespace value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//show-whitespace?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//show-whitespace?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ShowWhitespace))
			return resObj
		},
	},
	"widget-text-grid//tab-width!": {
		Doc:   "Set widget.TextGrid TabWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//tab-width!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//tab-width!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.TabWidth = int(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-text-grid//tab-width!")
			}
			return arg0
		},
	},
	"widget-text-grid//tab-width?": {
		Doc:   "Get widget.TextGrid TabWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextGrid
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextGrid)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//tab-width?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-grid//tab-width?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.TabWidth))
			return resObj
		},
	},
	"widget-text-segment-ptr//inline": {
		Doc:   "(*widget.TextSegment).Inline",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//inline")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//inline")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//inline")
			}
			res0 := arg0Val.Inline()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"widget-text-segment-ptr//select": {
		Doc:   "(*widget.TextSegment).Select",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//select")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//select")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//select")
			}
			var arg1Val fyne.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-segment-ptr//select")
			}
			var arg2Val fyne.Position
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fyne.Position)
				if !ok {
					return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-text-segment-ptr//select")
				}
			default:
				return evaldo.MakeArgError(ps, 2, []env.Type{env.NativeType}, "widget-text-segment-ptr//select")
			}
			arg0Val.Select(arg1Val, arg2Val)
			return arg0
		},
	},
	"widget-text-segment-ptr//selected-text": {
		Doc:   "(*widget.TextSegment).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//selected-text")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//selected-text")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//selected-text")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-text-segment-ptr//style!": {
		Doc:   "Set *widget.TextSegment Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//style!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//style!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-segment-ptr//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-segment-ptr//style!")
			}
			return arg0
		},
	},
	"widget-text-segment-ptr//style?": {
		Doc:   "Get *widget.TextSegment Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//style?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//style?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "widget-rich-text-style")
			return resObj
		},
	},
	"widget-text-segment-ptr//text!": {
		Doc:   "Set *widget.TextSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//text!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//text!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-text-segment-ptr//text!")
			}
			return arg0
		},
	},
	"widget-text-segment-ptr//text?": {
		Doc:   "Get *widget.TextSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//text?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//text?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-text-segment-ptr//textual": {
		Doc:   "(*widget.TextSegment).Textual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//textual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//textual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//textual")
			}
			res0 := arg0Val.Textual()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"widget-text-segment-ptr//unselect": {
		Doc:   "(*widget.TextSegment).Unselect",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//unselect")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//unselect")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//unselect")
			}
			arg0Val.Unselect()
			return arg0
		},
	},
	"widget-text-segment-ptr//update": {
		Doc:   "(*widget.TextSegment).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//update")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//update")
			}
			var arg1Val fyne.CanvasObject
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.CanvasObject)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-segment-ptr//update")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-segment-ptr//update")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-segment-ptr//update")
			}
			arg0Val.Update(arg1Val)
			return arg0
		},
	},
	"widget-text-segment-ptr//visual": {
		Doc:   "(*widget.TextSegment).Visual",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//visual")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//visual")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment-ptr//visual")
			}
			res0 := arg0Val.Visual()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-text-segment//style!": {
		Doc:   "Set widget.TextSegment Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment//style!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Style, ok = v.Value.(widget.RichTextStyle)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-segment//style!")
				}
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-text-segment//style!")
			}
			return arg0
		},
	},
	"widget-text-segment//style?": {
		Doc:   "Get widget.TextSegment Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment//style?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment//style?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Style, "widget-rich-text-style")
			return resObj
		},
	},
	"widget-text-segment//text!": {
		Doc:   "Set widget.TextSegment Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment//text!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment//text!")
			}
			if v, ok := arg1.(env.String); ok {
				self.Text = string(v.Value)
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.StringType}, "widget-text-segment//text!")
			}
			return arg0
		},
	},
	"widget-text-segment//text?": {
		Doc:   "Get widget.TextSegment Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.TextSegment
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.TextSegment)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment//text?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-text-segment//text?")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"widget-toolbar": {
		Doc:   "widget.NewToolbar",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val []widget.ToolbarItem
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]widget.ToolbarItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(widget.ToolbarItem)
						if !ok {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar")
						}
						arg0Val[i] = nil
					default:
						return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar")
			}
			res0 := widget.NewToolbar(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-toolbar-ptr")
			return res0Obj
		},
	},
	"widget-toolbar-action": {
		Doc:   "widget.NewToolbarAction",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val fyne.Resource
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-toolbar-action")
				}
				arg1Val = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar-action")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-toolbar-action")
			}
			res0 := widget.NewToolbarAction(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-toolbar-action-ptr")
			return res0Obj
		},
	},
	"widget-toolbar-action-ptr//icon!": {
		Doc:   "Set *widget.ToolbarAction Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//icon!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//icon!")
			}
			return arg0
		},
	},
	"widget-toolbar-action-ptr//icon?": {
		Doc:   "Get *widget.ToolbarAction Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//icon?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//icon?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
			return resObj
		},
	},
	"widget-toolbar-action-ptr//on-activated!": {
		Doc:   "Set *widget.ToolbarAction OnActivated value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//on-activated!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//on-activated!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//on-activated!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-toolbar-action-ptr//on-activated!")
				}
				self.OnActivated = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar-action-ptr//on-activated!")
				}
				self.OnActivated = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-toolbar-action-ptr//on-activated!")
			}
			return arg0
		},
	},
	"widget-toolbar-action-ptr//on-activated?": {
		Doc:   "Get *widget.ToolbarAction OnActivated value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//on-activated?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//on-activated?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//on-activated?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnActivated, "--go-any-func--")
			return resObj
		},
	},
	"widget-toolbar-action-ptr//set-icon": {
		Doc:   "(*widget.ToolbarAction).SetIcon",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//set-icon")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//set-icon")
			}
			var arg1Val fyne.Resource
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//set-icon")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//set-icon")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//set-icon")
			}
			arg0Val.SetIcon(arg1Val)
			return arg0
		},
	},
	"widget-toolbar-action-ptr//toolbar-object": {
		Doc:   "(*widget.ToolbarAction).ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//toolbar-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//toolbar-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action-ptr//toolbar-object")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-toolbar-action//icon!": {
		Doc:   "Set widget.ToolbarAction Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action//icon!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action//icon!")
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				self.Icon, ok = v.Value.(fyne.Resource)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-action//icon!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-action//icon!")
				}
				self.Icon = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-action//icon!")
			}
			return arg0
		},
	},
	"widget-toolbar-action//icon?": {
		Doc:   "Get widget.ToolbarAction Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action//icon?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action//icon?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "fyne-resource")
			return resObj
		},
	},
	"widget-toolbar-action//on-activated!": {
		Doc:   "Set widget.ToolbarAction OnActivated value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action//on-activated!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action//on-activated!")
			}
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-toolbar-action//on-activated!")
				}
				self.OnActivated = func() {
					evaldo.CallFunction(fn, ps, nil, false, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar-action//on-activated!")
				}
				self.OnActivated = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.FunctionType}, "widget-toolbar-action//on-activated!")
			}
			return arg0
		},
	},
	"widget-toolbar-action//on-activated?": {
		Doc:   "Get widget.ToolbarAction OnActivated value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.ToolbarAction
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.ToolbarAction)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action//on-activated?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-action//on-activated?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.OnActivated, "--go-any-func--")
			return resObj
		},
	},
	"widget-toolbar-item//toolbar-object": {
		Doc:   "widget.ToolbarItem.ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val widget.ToolbarItem
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-item//toolbar-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-item//toolbar-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-item//toolbar-object")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-toolbar-ptr//append": {
		Doc:   "(*widget.Toolbar).Append",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//append")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//append")
			}
			var arg1Val widget.ToolbarItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-ptr//append")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-ptr//append")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-ptr//append")
			}
			arg0Val.Append(arg1Val)
			return arg0
		},
	},
	"widget-toolbar-ptr//create-renderer": {
		Doc:   "(*widget.Toolbar).CreateRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//create-renderer")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//create-renderer")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//create-renderer")
			}
			res0 := arg0Val.CreateRenderer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-widget-renderer")
			return res0Obj
		},
	},
	"widget-toolbar-ptr//hidden!": {
		Doc:   "Set *widget.Toolbar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//hidden!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//hidden!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-toolbar-ptr//hidden!")
			}
			return arg0
		},
	},
	"widget-toolbar-ptr//hidden?": {
		Doc:   "Get *widget.Toolbar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//hidden?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//hidden?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-toolbar-ptr//items!": {
		Doc:   "Set *widget.Toolbar Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//items!")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.ToolbarItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.ToolbarItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar-ptr//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar-ptr//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar-ptr//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar-ptr//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar-ptr//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar-ptr//items!")
			}
			return arg0
		},
	},
	"widget-toolbar-ptr//items?": {
		Doc:   "Get *widget.Toolbar Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//items?")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//items?")
				}
				self = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "widget-toolbar-item-arr")
			return resObj
		},
	},
	"widget-toolbar-ptr//min-size": {
		Doc:   "(*widget.Toolbar).MinSize",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//min-size")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//min-size")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//min-size")
			}
			res0 := arg0Val.MinSize()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-size")
			return res0Obj
		},
	},
	"widget-toolbar-ptr//prepend": {
		Doc:   "(*widget.Toolbar).Prepend",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//prepend")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-ptr//prepend")
			}
			var arg1Val widget.ToolbarItem
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-ptr//prepend")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-ptr//prepend")
				}
				arg1Val = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.NativeType}, "widget-toolbar-ptr//prepend")
			}
			arg0Val.Prepend(arg1Val)
			return arg0
		},
	},
	"widget-toolbar-separator": {
		Doc:   "widget.NewToolbarSeparator",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewToolbarSeparator()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-toolbar-separator-ptr")
			return res0Obj
		},
	},
	"widget-toolbar-separator-ptr//toolbar-object": {
		Doc:   "(*widget.ToolbarSeparator).ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarSeparator
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarSeparator)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-separator-ptr//toolbar-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-separator-ptr//toolbar-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-separator-ptr//toolbar-object")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-toolbar-spacer": {
		Doc:   "widget.NewToolbarSpacer",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			res0 := widget.NewToolbarSpacer()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "widget-toolbar-spacer-ptr")
			return res0Obj
		},
	},
	"widget-toolbar-spacer-ptr//toolbar-object": {
		Doc:   "(*widget.ToolbarSpacer).ToolbarObject",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var arg0Val *widget.ToolbarSpacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.ToolbarSpacer)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-spacer-ptr//toolbar-object")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-spacer-ptr//toolbar-object")
				}
				arg0Val = nil
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar-spacer-ptr//toolbar-object")
			}
			res0 := arg0Val.ToolbarObject()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "fyne-canvas-object")
			return res0Obj
		},
	},
	"widget-toolbar//hidden!": {
		Doc:   "Set widget.Toolbar Hidden value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar//hidden!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar//hidden!")
			}
			if v, ok := arg1.(env.Integer); ok {
				self.Hidden = v.Value != 0
			} else {
				return evaldo.MakeArgError(ps, 1, []env.Type{env.IntegerType}, "widget-toolbar//hidden!")
			}
			return arg0
		},
	},
	"widget-toolbar//hidden?": {
		Doc:   "Get widget.Toolbar Hidden value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar//hidden?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar//hidden?")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Hidden))
			return resObj
		},
	},
	"widget-toolbar//items!": {
		Doc:   "Set widget.Toolbar Items value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar//items!")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar//items!")
			}
			switch v := arg1.(type) {
			case env.Block:
				self.Items = make([]widget.ToolbarItem, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						self.Items[i], ok = v.Value.(widget.ToolbarItem)
						if !ok {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar//items!")
						}
					case env.Integer:
						if v.Value != 0 {
							return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar//items!")
						}
						self.Items[i] = nil
					default:
						return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar//items!")
					}
				}
			case env.Native:
				var ok bool
				self.Items, ok = v.Value.([]widget.ToolbarItem)
				if !ok {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar//items!")
				}
			case env.Integer:
				if v.Value != 0 {
					return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar//items!")
				}
				self.Items = nil
			default:
				return evaldo.MakeArgError(ps, 1, []env.Type{env.BlockType, env.NativeType}, "widget-toolbar//items!")
			}
			return arg0
		},
	},
	"widget-toolbar//items?": {
		Doc:   "Get widget.Toolbar Items value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0 env.Object, arg1 env.Object, arg2 env.Object, arg3 env.Object, arg4 env.Object) env.Object {
			var self widget.Toolbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(widget.Toolbar)
				if !ok {
					return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar//items?")
				}
			default:
				return evaldo.MakeArgError(ps, 0, []env.Type{env.NativeType}, "widget-toolbar//items?")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Items, "widget-toolbar-item-arr")
			return resObj
		},
	},
}
